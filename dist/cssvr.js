// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '72dev' };

// browserify support

if ( typeof module === 'object' ) {

  module.exports = THREE;

}

// polyfills

if ( Math.sign === undefined ) {

  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

  Math.sign = function ( x ) {

    return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : +x;

  };

}

// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

THREE.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.MinEquation = 103;
THREE.MaxEquation = 104;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;

// depth modes

THREE.NeverDepth = 0;
THREE.AlwaysDepth = 1;
THREE.LessDepth = 2;
THREE.LessEqualDepth = 3;
THREE.EqualDepth = 4;
THREE.GreaterEqualDepth = 5;
THREE.GreaterDepth = 6;
THREE.NotEqualDepth = 7;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = 300;

THREE.CubeReflectionMapping = 301;
THREE.CubeRefractionMapping = 302;

THREE.EquirectangularReflectionMapping = 303;
THREE.EquirectangularRefractionMapping = 304;

THREE.SphericalReflectionMapping = 305;

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1025;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
THREE.RGBEFormat = THREE.RGBAFormat; //1024;

// DDS / ST3C Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;


// PVRTC compressed texture formats

THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;


// DEPRECATED

THREE.Projector = function () {

  console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

  this.projectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
    vector.project( camera );

  };

  this.unprojectVector = function ( vector, camera ) {

    console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
    vector.unproject( camera );

  };

  this.pickingRay = function ( vector, camera ) {

    console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

  };

};

THREE.CanvasRenderer = function () {

  console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

  this.domElement = document.createElement( 'canvas' );
  this.clear = function () {};
  this.render = function () {};
  this.setClearColor = function () {};
  this.setSize = function () {};

};

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

  if ( arguments.length === 3 ) {

    return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

  }

  return this.set( color )

};

THREE.Color.prototype = {

  constructor: THREE.Color,

  r: 1, g: 1, b: 1,

  set: function ( value ) {

    if ( value instanceof THREE.Color ) {

      this.copy( value );

    } else if ( typeof value === 'number' ) {

      this.setHex( value );

    } else if ( typeof value === 'string' ) {

      this.setStyle( value );

    }

    return this;

  },

  setHex: function ( hex ) {

    hex = Math.floor( hex );

    this.r = ( hex >> 16 & 255 ) / 255;
    this.g = ( hex >> 8 & 255 ) / 255;
    this.b = ( hex & 255 ) / 255;

    return this;

  },

  setRGB: function ( r, g, b ) {

    this.r = r;
    this.g = g;
    this.b = b;

    return this;

  },

  setHSL: function ( h, s, l ) {

    // h,s,l ranges are in 0.0 - 1.0

    if ( s === 0 ) {

      this.r = this.g = this.b = l;

    } else {

      var hue2rgb = function ( p, q, t ) {

        if ( t < 0 ) t += 1;
        if ( t > 1 ) t -= 1;
        if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
        if ( t < 1 / 2 ) return q;
        if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
        return p;

      };

      var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
      var q = ( 2 * l ) - p;

      this.r = hue2rgb( q, p, h + 1 / 3 );
      this.g = hue2rgb( q, p, h );
      this.b = hue2rgb( q, p, h - 1 / 3 );

    }

    return this;

  },

  setStyle: function ( style ) {

    // rgb(255,0,0)

    if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

      var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

      this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
      this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
      this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

      return this;

    }

    // rgb(100%,0%,0%)

    if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

      var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

      this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
      this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
      this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

      return this;

    }

    // #ff0000

    if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

      var color = /^\#([0-9a-f]{6})$/i.exec( style );

      this.setHex( parseInt( color[ 1 ], 16 ) );

      return this;

    }

    // #f00

    if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

      var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

      this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

      return this;

    }

    // red

    if ( /^(\w+)$/i.test( style ) ) {

      this.setHex( THREE.ColorKeywords[ style ] );

      return this;

    }


  },

  copy: function ( color ) {

    this.r = color.r;
    this.g = color.g;
    this.b = color.b;

    return this;

  },

  copyGammaToLinear: function ( color, gammaFactor ) {

    if ( gammaFactor === undefined ) gammaFactor = 2.0;

    this.r = Math.pow( color.r, gammaFactor );
    this.g = Math.pow( color.g, gammaFactor );
    this.b = Math.pow( color.b, gammaFactor );

    return this;

  },

  copyLinearToGamma: function ( color, gammaFactor ) {

    if ( gammaFactor === undefined ) gammaFactor = 2.0;

    var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

    this.r = Math.pow( color.r, safeInverse );
    this.g = Math.pow( color.g, safeInverse );
    this.b = Math.pow( color.b, safeInverse );

    return this;

  },

  convertGammaToLinear: function () {

    var r = this.r, g = this.g, b = this.b;

    this.r = r * r;
    this.g = g * g;
    this.b = b * b;

    return this;

  },

  convertLinearToGamma: function () {

    this.r = Math.sqrt( this.r );
    this.g = Math.sqrt( this.g );
    this.b = Math.sqrt( this.b );

    return this;

  },

  getHex: function () {

    return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

  },

  getHexString: function () {

    return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

  },

  getHSL: function ( optionalTarget ) {

    // h,s,l ranges are in 0.0 - 1.0

    var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

    var r = this.r, g = this.g, b = this.b;

    var max = Math.max( r, g, b );
    var min = Math.min( r, g, b );

    var hue, saturation;
    var lightness = ( min + max ) / 2.0;

    if ( min === max ) {

      hue = 0;
      saturation = 0;

    } else {

      var delta = max - min;

      saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

      switch ( max ) {

        case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
        case g: hue = ( b - r ) / delta + 2; break;
        case b: hue = ( r - g ) / delta + 4; break;

      }

      hue /= 6;

    }

    hsl.h = hue;
    hsl.s = saturation;
    hsl.l = lightness;

    return hsl;

  },

  getStyle: function () {

    return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

  },

  offsetHSL: function ( h, s, l ) {

    var hsl = this.getHSL();

    hsl.h += h; hsl.s += s; hsl.l += l;

    this.setHSL( hsl.h, hsl.s, hsl.l );

    return this;

  },

  add: function ( color ) {

    this.r += color.r;
    this.g += color.g;
    this.b += color.b;

    return this;

  },

  addColors: function ( color1, color2 ) {

    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;

    return this;

  },

  addScalar: function ( s ) {

    this.r += s;
    this.g += s;
    this.b += s;

    return this;

  },

  multiply: function ( color ) {

    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.r *= s;
    this.g *= s;
    this.b *= s;

    return this;

  },

  lerp: function ( color, alpha ) {

    this.r += ( color.r - this.r ) * alpha;
    this.g += ( color.g - this.g ) * alpha;
    this.b += ( color.b - this.b ) * alpha;

    return this;

  },

  equals: function ( c ) {

    return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

  },

  fromArray: function ( array ) {

    this.r = array[ 0 ];
    this.g = array[ 1 ];
    this.b = array[ 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.r;
    array[ offset + 1 ] = this.g;
    array[ offset + 2 ] = this.b;

    return array;
  },

  clone: function () {

    return new THREE.Color().setRGB( this.r, this.g, this.b );

  }

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

  constructor: THREE.Quaternion,

  _x: 0,_y: 0, _z: 0, _w: 0,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get w () {

    return this._w;

  },

  set w ( value ) {

    this._w = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, w ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;

    this.onChangeCallback();

    return this;

  },

  copy: function ( quaternion ) {

    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;

    this.onChangeCallback();

    return this;

  },

  setFromEuler: function ( euler, update ) {

    if ( euler instanceof THREE.Euler === false ) {

      throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
    }

    // http://www.mathworks.com/matlabcentral/fileexchange/
    //  20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
    //  content/SpinCalc.m

    var c1 = Math.cos( euler._x / 2 );
    var c2 = Math.cos( euler._y / 2 );
    var c3 = Math.cos( euler._z / 2 );
    var s1 = Math.sin( euler._x / 2 );
    var s2 = Math.sin( euler._y / 2 );
    var s3 = Math.sin( euler._z / 2 );

    if ( euler.order === 'XYZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'YXZ' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'ZXY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'ZYX' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( euler.order === 'YZX' ) {

      this._x = s1 * c2 * c3 + c1 * s2 * s3;
      this._y = c1 * s2 * c3 + s1 * c2 * s3;
      this._z = c1 * c2 * s3 - s1 * s2 * c3;
      this._w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( euler.order === 'XZY' ) {

      this._x = s1 * c2 * c3 - c1 * s2 * s3;
      this._y = c1 * s2 * c3 - s1 * c2 * s3;
      this._z = c1 * c2 * s3 + s1 * s2 * c3;
      this._w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromAxisAngle: function ( axis, angle ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

    // assumes axis is normalized

    var halfAngle = angle / 2, s = Math.sin( halfAngle );

    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos( halfAngle );

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

      trace = m11 + m22 + m33,
      s;

    if ( trace > 0 ) {

      s = 0.5 / Math.sqrt( trace + 1.0 );

      this._w = 0.25 / s;
      this._x = ( m32 - m23 ) * s;
      this._y = ( m13 - m31 ) * s;
      this._z = ( m21 - m12 ) * s;

    } else if ( m11 > m22 && m11 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

      this._w = ( m32 - m23 ) / s;
      this._x = 0.25 * s;
      this._y = ( m12 + m21 ) / s;
      this._z = ( m13 + m31 ) / s;

    } else if ( m22 > m33 ) {

      s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

      this._w = ( m13 - m31 ) / s;
      this._x = ( m12 + m21 ) / s;
      this._y = 0.25 * s;
      this._z = ( m23 + m32 ) / s;

    } else {

      s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

      this._w = ( m21 - m12 ) / s;
      this._x = ( m13 + m31 ) / s;
      this._y = ( m23 + m32 ) / s;
      this._z = 0.25 * s;

    }

    this.onChangeCallback();

    return this;

  },

  setFromUnitVectors: function () {

    // http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

    // assumes direction vectors vFrom and vTo are normalized

    var v1, r;

    var EPS = 0.000001;

    return function ( vFrom, vTo ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      r = vFrom.dot( vTo ) + 1;

      if ( r < EPS ) {

        r = 0;

        if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

          v1.set( - vFrom.y, vFrom.x, 0 );

        } else {

          v1.set( 0, - vFrom.z, vFrom.y );

        }

      } else {

        v1.crossVectors( vFrom, vTo );

      }

      this._x = v1.x;
      this._y = v1.y;
      this._z = v1.z;
      this._w = r;

      this.normalize();

      return this;

    }

  }(),

  inverse: function () {

    this.conjugate().normalize();

    return this;

  },

  conjugate: function () {

    this._x *= - 1;
    this._y *= - 1;
    this._z *= - 1;

    this.onChangeCallback();

    return this;

  },

  dot: function ( v ) {

    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

  },

  lengthSq: function () {

    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

  },

  length: function () {

    return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

  },

  normalize: function () {

    var l = this.length();

    if ( l === 0 ) {

      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;

    } else {

      l = 1 / l;

      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;

    }

    this.onChangeCallback();

    return this;

  },

  multiply: function ( q, p ) {

    if ( p !== undefined ) {

      console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
      return this.multiplyQuaternions( q, p );

    }

    return this.multiplyQuaternions( this, q );

  },

  multiplyQuaternions: function ( a, b ) {

    // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

    this.onChangeCallback();

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
    return vector.applyQuaternion( this );

  },

  slerp: function ( qb, t ) {

    if ( t === 0 ) return this;
    if ( t === 1 ) return this.copy( qb );

    var x = this._x, y = this._y, z = this._z, w = this._w;

    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

    if ( cosHalfTheta < 0 ) {

      this._w = - qb._w;
      this._x = - qb._x;
      this._y = - qb._y;
      this._z = - qb._z;

      cosHalfTheta = - cosHalfTheta;

    } else {

      this.copy( qb );

    }

    if ( cosHalfTheta >= 1.0 ) {

      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;

      return this;

    }

    var halfTheta = Math.acos( cosHalfTheta );
    var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

    if ( Math.abs( sinHalfTheta ) < 0.001 ) {

      this._w = 0.5 * ( w + this._w );
      this._x = 0.5 * ( x + this._x );
      this._y = 0.5 * ( y + this._y );
      this._z = 0.5 * ( z + this._z );

      return this;

    }

    var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
    ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

    this._w = ( w * ratioA + this._w * ratioB );
    this._x = ( x * ratioA + this._x * ratioB );
    this._y = ( y * ratioA + this._y * ratioB );
    this._z = ( z * ratioA + this._z * ratioB );

    this.onChangeCallback();

    return this;

  },

  equals: function ( quaternion ) {

    return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this._x = array[ offset ];
    this._y = array[ offset + 1 ];
    this._z = array[ offset + 2 ];
    this._w = array[ offset + 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._w;

    return array;

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {},

  clone: function () {

    return new THREE.Quaternion( this._x, this._y, this._z, this._w );

  }

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

  return qm.copy( qa ).slerp( qb, t );

};

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

  this.x = x || 0;
  this.y = y || 0;

};

THREE.Vector2.prototype = {

  constructor: THREE.Vector2,

  set: function ( x, y ) {

    this.x = x;
    this.y = y;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;

    return this;

  },

  multiply: function ( v ) {

    this.x *= v.x;
    this.y *= v.y;

    return this;

  },

  multiplyScalar: function ( s ) {

    this.x *= s;
    this.y *= s;

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    return this;
  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector2();
        max = new THREE.Vector2();

      }

      min.set( minVal, minVal );
      max.set( maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );
    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];

    return this;

  },

  clone: function () {

    return new THREE.Vector2( this.x, this.y );

  }

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;

};

THREE.Vector3.prototype = {

  constructor: THREE.Vector3,

  set: function ( x, y, z ) {

    this.x = x;
    this.y = y;
    this.z = z;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;
    this.z -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;

    return this;

  },

  multiply: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
      return this.multiplyVectors( v, w );

    }

    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;

    return this;

  },

  multiplyVectors: function ( a, b ) {

    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;

    return this;

  },

  applyEuler: function () {

    var quaternion;

    return function ( euler ) {

      if ( euler instanceof THREE.Euler === false ) {

        console.error( 'THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.' );

      }

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromEuler( euler ) );

      return this;

    };

  }(),

  applyAxisAngle: function () {

    var quaternion;

    return function ( axis, angle ) {

      if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

      this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

      return this;

    };

  }(),

  applyMatrix3: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
    this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
    this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

    return this;

  },

  applyMatrix4: function ( m ) {

    // input: THREE.Matrix4 affine matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

    return this;

  },

  applyProjection: function ( m ) {

    // input: THREE.Matrix4 projection matrix

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;
    var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

    this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
    this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
    this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

    return this;

  },

  applyQuaternion: function ( q ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;

    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;

    // calculate quat * vector

    var ix =  qw * x + qy * z - qz * y;
    var iy =  qw * y + qz * x - qx * z;
    var iz =  qw * z + qx * y - qy * x;
    var iw = - qx * x - qy * y - qz * z;

    // calculate result * inverse quat

    this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
    this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
    this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

    return this;

  },

  project: function () {

    var matrix;

    return function ( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
      return this.applyProjection( matrix );

    };

  }(),

  unproject: function () {

    var matrix;

    return function ( camera ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
      return this.applyProjection( matrix );

    };

  }(),

  transformDirection: function ( m ) {

    // input: THREE.Matrix4 affine matrix
    // vector interpreted as a direction

    var x = this.x, y = this.y, z = this.z;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

    this.normalize();

    return this;

  },

  divide: function ( v ) {

    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;

    }

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    return this;

  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector3();
        max = new THREE.Vector3();

      }

      min.set( minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength  ) {

      this.multiplyScalar( l / oldLength );
    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  cross: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
      return this.crossVectors( v, w );

    }

    var x = this.x, y = this.y, z = this.z;

    this.x = y * v.z - z * v.y;
    this.y = z * v.x - x * v.z;
    this.z = x * v.y - y * v.x;

    return this;

  },

  crossVectors: function ( a, b ) {

    var ax = a.x, ay = a.y, az = a.z;
    var bx = b.x, by = b.y, bz = b.z;

    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;

    return this;

  },

  projectOnVector: function () {

    var v1, dot;

    return function ( vector ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( vector ).normalize();

      dot = this.dot( v1 );

      return this.copy( v1 ).multiplyScalar( dot );

    };

  }(),

  projectOnPlane: function () {

    var v1;

    return function ( planeNormal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      v1.copy( this ).projectOnVector( planeNormal );

      return this.sub( v1 );

    }

  }(),

  reflect: function () {

    // reflect incident vector off plane orthogonal to normal
    // normal is assumed to have unit length

    var v1;

    return function ( normal ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

    }

  }(),

  angleTo: function ( v ) {

    var theta = this.dot( v ) / ( this.length() * v.length() );

    // clamp, to handle numerical problems

    return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

  },

  distanceTo: function ( v ) {

    return Math.sqrt( this.distanceToSquared( v ) );

  },

  distanceToSquared: function ( v ) {

    var dx = this.x - v.x;
    var dy = this.y - v.y;
    var dz = this.z - v.z;

    return dx * dx + dy * dy + dz * dz;

  },

  setEulerFromRotationMatrix: function ( m, order ) {

    console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

  },

  setEulerFromQuaternion: function ( q, order ) {

    console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

  },

  getPositionFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );

    return this.setFromMatrixPosition( m );

  },

  getScaleFromMatrix: function ( m ) {

    console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );

    return this.setFromMatrixScale( m );
  },

  getColumnFromMatrix: function ( index, matrix ) {

    console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );

    return this.setFromMatrixColumn( index, matrix );

  },

  setFromMatrixPosition: function ( m ) {

    this.x = m.elements[ 12 ];
    this.y = m.elements[ 13 ];
    this.z = m.elements[ 14 ];

    return this;

  },

  setFromMatrixScale: function ( m ) {

    var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
    var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
    var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

    this.x = sx;
    this.y = sy;
    this.z = sz;

    return this;
  },

  setFromMatrixColumn: function ( index, matrix ) {

    var offset = index * 4;

    var me = matrix.elements;

    this.x = me[ offset ];
    this.y = me[ offset + 1 ];
    this.z = me[ offset + 2 ];

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];
    this.z = attribute.array[ index + 2 ];

    return this;

  },

  clone: function () {

    return new THREE.Vector3( this.x, this.y, this.z );

  }

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

  constructor: THREE.Vector4,

  set: function ( x, y, z, w ) {

    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;

    return this;

  },

  setX: function ( x ) {

    this.x = x;

    return this;

  },

  setY: function ( y ) {

    this.y = y;

    return this;

  },

  setZ: function ( z ) {

    this.z = z;

    return this;

  },

  setW: function ( w ) {

    this.w = w;

    return this;

  },

  setComponent: function ( index, value ) {

    switch ( index ) {

      case 0: this.x = value; break;
      case 1: this.y = value; break;
      case 2: this.z = value; break;
      case 3: this.w = value; break;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  getComponent: function ( index ) {

    switch ( index ) {

      case 0: return this.x;
      case 1: return this.y;
      case 2: return this.z;
      case 3: return this.w;
      default: throw new Error( 'index is out of range: ' + index );

    }

  },

  copy: function ( v ) {

    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = ( v.w !== undefined ) ? v.w : 1;

    return this;

  },

  add: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
      return this.addVectors( v, w );

    }

    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;

    return this;

  },

  addScalar: function ( s ) {

    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;

    return this;

  },

  addVectors: function ( a, b ) {

    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;

    return this;

  },

  sub: function ( v, w ) {

    if ( w !== undefined ) {

      console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
      return this.subVectors( v, w );

    }

    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;

    return this;

  },

  subScalar: function ( s ) {

    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;

    return this;

  },

  subVectors: function ( a, b ) {

    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;

    return this;

  },

  multiplyScalar: function ( scalar ) {

    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;

    return this;

  },

  applyMatrix4: function ( m ) {

    var x = this.x;
    var y = this.y;
    var z = this.z;
    var w = this.w;

    var e = m.elements;

    this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
    this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
    this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
    this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

    return this;

  },

  divideScalar: function ( scalar ) {

    if ( scalar !== 0 ) {

      var invScalar = 1 / scalar;

      this.x *= invScalar;
      this.y *= invScalar;
      this.z *= invScalar;
      this.w *= invScalar;

    } else {

      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;

    }

    return this;

  },

  setAxisAngleFromQuaternion: function ( q ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

    // q is assumed to be normalized

    this.w = 2 * Math.acos( q.w );

    var s = Math.sqrt( 1 - q.w * q.w );

    if ( s < 0.0001 ) {

       this.x = 1;
       this.y = 0;
       this.z = 0;

    } else {

       this.x = q.x / s;
       this.y = q.y / s;
       this.z = q.z / s;

    }

    return this;

  },

  setAxisAngleFromRotationMatrix: function ( m ) {

    // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var angle, x, y, z,   // variables for result
      epsilon = 0.01,   // margin to allow for rounding errors
      epsilon2 = 0.1,   // margin to distinguish between 0 and 180 degrees

      te = m.elements,

      m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
      m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
      m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    if ( ( Math.abs( m12 - m21 ) < epsilon )
       && ( Math.abs( m13 - m31 ) < epsilon )
       && ( Math.abs( m23 - m32 ) < epsilon ) ) {

      // singularity found
      // first check for identity matrix which must have +1 for all terms
      // in leading diagonal and zero in other terms

      if ( ( Math.abs( m12 + m21 ) < epsilon2 )
         && ( Math.abs( m13 + m31 ) < epsilon2 )
         && ( Math.abs( m23 + m32 ) < epsilon2 )
         && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

        // this singularity is identity matrix so angle = 0

        this.set( 1, 0, 0, 0 );

        return this; // zero angle, arbitrary axis

      }

      // otherwise this singularity is angle = 180

      angle = Math.PI;

      var xx = ( m11 + 1 ) / 2;
      var yy = ( m22 + 1 ) / 2;
      var zz = ( m33 + 1 ) / 2;
      var xy = ( m12 + m21 ) / 4;
      var xz = ( m13 + m31 ) / 4;
      var yz = ( m23 + m32 ) / 4;

      if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

        if ( xx < epsilon ) {

          x = 0;
          y = 0.707106781;
          z = 0.707106781;

        } else {

          x = Math.sqrt( xx );
          y = xy / x;
          z = xz / x;

        }

      } else if ( yy > zz ) { // m22 is the largest diagonal term

        if ( yy < epsilon ) {

          x = 0.707106781;
          y = 0;
          z = 0.707106781;

        } else {

          y = Math.sqrt( yy );
          x = xy / y;
          z = yz / y;

        }

      } else { // m33 is the largest diagonal term so base result on this

        if ( zz < epsilon ) {

          x = 0.707106781;
          y = 0.707106781;
          z = 0;

        } else {

          z = Math.sqrt( zz );
          x = xz / z;
          y = yz / z;

        }

      }

      this.set( x, y, z, angle );

      return this; // return 180 deg rotation

    }

    // as we have reached here there are no singularities so we can handle normally

    var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
              + ( m13 - m31 ) * ( m13 - m31 )
              + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

    if ( Math.abs( s ) < 0.001 ) s = 1;

    // prevent divide by zero, should not happen if matrix is orthogonal and should be
    // caught by singularity test above, but I've left it in just in case

    this.x = ( m32 - m23 ) / s;
    this.y = ( m13 - m31 ) / s;
    this.z = ( m21 - m12 ) / s;
    this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

    return this;

  },

  min: function ( v ) {

    if ( this.x > v.x ) {

      this.x = v.x;

    }

    if ( this.y > v.y ) {

      this.y = v.y;

    }

    if ( this.z > v.z ) {

      this.z = v.z;

    }

    if ( this.w > v.w ) {

      this.w = v.w;

    }

    return this;

  },

  max: function ( v ) {

    if ( this.x < v.x ) {

      this.x = v.x;

    }

    if ( this.y < v.y ) {

      this.y = v.y;

    }

    if ( this.z < v.z ) {

      this.z = v.z;

    }

    if ( this.w < v.w ) {

      this.w = v.w;

    }

    return this;

  },

  clamp: function ( min, max ) {

    // This function assumes min < max, if this assumption isn't true it will not operate correctly

    if ( this.x < min.x ) {

      this.x = min.x;

    } else if ( this.x > max.x ) {

      this.x = max.x;

    }

    if ( this.y < min.y ) {

      this.y = min.y;

    } else if ( this.y > max.y ) {

      this.y = max.y;

    }

    if ( this.z < min.z ) {

      this.z = min.z;

    } else if ( this.z > max.z ) {

      this.z = max.z;

    }

    if ( this.w < min.w ) {

      this.w = min.w;

    } else if ( this.w > max.w ) {

      this.w = max.w;

    }

    return this;

  },

  clampScalar: ( function () {

    var min, max;

    return function ( minVal, maxVal ) {

      if ( min === undefined ) {

        min = new THREE.Vector4();
        max = new THREE.Vector4();

      }

      min.set( minVal, minVal, minVal, minVal );
      max.set( maxVal, maxVal, maxVal, maxVal );

      return this.clamp( min, max );

    };

  } )(),

  floor: function () {

    this.x = Math.floor( this.x );
    this.y = Math.floor( this.y );
    this.z = Math.floor( this.z );
    this.w = Math.floor( this.w );

    return this;

  },

  ceil: function () {

    this.x = Math.ceil( this.x );
    this.y = Math.ceil( this.y );
    this.z = Math.ceil( this.z );
    this.w = Math.ceil( this.w );

    return this;

  },

  round: function () {

    this.x = Math.round( this.x );
    this.y = Math.round( this.y );
    this.z = Math.round( this.z );
    this.w = Math.round( this.w );

    return this;

  },

  roundToZero: function () {

    this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
    this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
    this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
    this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

    return this;

  },

  negate: function () {

    this.x = - this.x;
    this.y = - this.y;
    this.z = - this.z;
    this.w = - this.w;

    return this;

  },

  dot: function ( v ) {

    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

  },

  lengthSq: function () {

    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

  },

  length: function () {

    return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

  },

  lengthManhattan: function () {

    return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

  },

  normalize: function () {

    return this.divideScalar( this.length() );

  },

  setLength: function ( l ) {

    var oldLength = this.length();

    if ( oldLength !== 0 && l !== oldLength ) {

      this.multiplyScalar( l / oldLength );

    }

    return this;

  },

  lerp: function ( v, alpha ) {

    this.x += ( v.x - this.x ) * alpha;
    this.y += ( v.y - this.y ) * alpha;
    this.z += ( v.z - this.z ) * alpha;
    this.w += ( v.w - this.w ) * alpha;

    return this;

  },

  lerpVectors: function ( v1, v2, alpha ) {

    this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

    return this;

  },

  equals: function ( v ) {

    return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

  },

  fromArray: function ( array, offset ) {

    if ( offset === undefined ) offset = 0;

    this.x = array[ offset ];
    this.y = array[ offset + 1 ];
    this.z = array[ offset + 2 ];
    this.w = array[ offset + 3 ];

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this.x;
    array[ offset + 1 ] = this.y;
    array[ offset + 2 ] = this.z;
    array[ offset + 3 ] = this.w;

    return array;

  },

  fromAttribute: function ( attribute, index, offset ) {

    if ( offset === undefined ) offset = 0;

    index = index * attribute.itemSize + offset;

    this.x = attribute.array[ index ];
    this.y = attribute.array[ index + 1 ];
    this.z = attribute.array[ index + 2 ];
    this.w = attribute.array[ index + 3 ];

    return this;

  },

  clone: function () {

    return new THREE.Vector4( this.x, this.y, this.z, this.w );

  }

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

  this._x = x || 0;
  this._y = y || 0;
  this._z = z || 0;
  this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

  constructor: THREE.Euler,

  _x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

  get x () {

    return this._x;

  },

  set x ( value ) {

    this._x = value;
    this.onChangeCallback();

  },

  get y () {

    return this._y;

  },

  set y ( value ) {

    this._y = value;
    this.onChangeCallback();

  },

  get z () {

    return this._z;

  },

  set z ( value ) {

    this._z = value;
    this.onChangeCallback();

  },

  get order () {

    return this._order;

  },

  set order ( value ) {

    this._order = value;
    this.onChangeCallback();

  },

  set: function ( x, y, z, order ) {

    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order || this._order;

    this.onChangeCallback();

    return this;

  },

  copy: function ( euler ) {

    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;

    this.onChangeCallback();

    return this;

  },

  setFromRotationMatrix: function ( m, order, update ) {

    var clamp = THREE.Math.clamp;

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    var te = m.elements;
    var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
    var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
    var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

    order = order || this._order;

    if ( order === 'XYZ' ) {

      this._y = Math.asin( clamp( m13, - 1, 1 ) );

      if ( Math.abs( m13 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m33 );
        this._z = Math.atan2( - m12, m11 );

      } else {

        this._x = Math.atan2( m32, m22 );
        this._z = 0;

      }

    } else if ( order === 'YXZ' ) {

      this._x = Math.asin( - clamp( m23, - 1, 1 ) );

      if ( Math.abs( m23 ) < 0.99999 ) {

        this._y = Math.atan2( m13, m33 );
        this._z = Math.atan2( m21, m22 );

      } else {

        this._y = Math.atan2( - m31, m11 );
        this._z = 0;

      }

    } else if ( order === 'ZXY' ) {

      this._x = Math.asin( clamp( m32, - 1, 1 ) );

      if ( Math.abs( m32 ) < 0.99999 ) {

        this._y = Math.atan2( - m31, m33 );
        this._z = Math.atan2( - m12, m22 );

      } else {

        this._y = 0;
        this._z = Math.atan2( m21, m11 );

      }

    } else if ( order === 'ZYX' ) {

      this._y = Math.asin( - clamp( m31, - 1, 1 ) );

      if ( Math.abs( m31 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m33 );
        this._z = Math.atan2( m21, m11 );

      } else {

        this._x = 0;
        this._z = Math.atan2( - m12, m22 );

      }

    } else if ( order === 'YZX' ) {

      this._z = Math.asin( clamp( m21, - 1, 1 ) );

      if ( Math.abs( m21 ) < 0.99999 ) {

        this._x = Math.atan2( - m23, m22 );
        this._y = Math.atan2( - m31, m11 );

      } else {

        this._x = 0;
        this._y = Math.atan2( m13, m33 );

      }

    } else if ( order === 'XZY' ) {

      this._z = Math.asin( - clamp( m12, - 1, 1 ) );

      if ( Math.abs( m12 ) < 0.99999 ) {

        this._x = Math.atan2( m32, m22 );
        this._y = Math.atan2( m13, m11 );

      } else {

        this._x = Math.atan2( - m23, m33 );
        this._y = 0;

      }

    } else {

      console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order )

    }

    this._order = order;

    if ( update !== false ) this.onChangeCallback();

    return this;

  },

  setFromQuaternion: function () {

    var matrix;

    return function ( q, order, update ) {

      if ( matrix === undefined ) matrix = new THREE.Matrix4();
      matrix.makeRotationFromQuaternion( q );
      this.setFromRotationMatrix( matrix, order, update );

      return this;

    };

  }(),

  setFromVector3: function ( v, order ) {

    return this.set( v.x, v.y, v.z, order || this._order );

  },

  reorder: function () {

    // WARNING: this discards revolution information -bhouston

    var q = new THREE.Quaternion();

    return function ( newOrder ) {

      q.setFromEuler( this );
      this.setFromQuaternion( q, newOrder );

    };

  }(),

  equals: function ( euler ) {

    return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

  },

  fromArray: function ( array ) {

    this._x = array[ 0 ];
    this._y = array[ 1 ];
    this._z = array[ 2 ];
    if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

    this.onChangeCallback();

    return this;

  },

  toArray: function ( array, offset ) {

    if ( array === undefined ) array = [];
    if ( offset === undefined ) offset = 0;

    array[ offset ] = this._x;
    array[ offset + 1 ] = this._y;
    array[ offset + 2 ] = this._z;
    array[ offset + 3 ] = this._order;

    return array;
  },

  toVector3: function ( optionalResult ) {

    if ( optionalResult ) {

      return optionalResult.set( this._x, this._y, this._z );

    } else {

      return new THREE.Vector3( this._x, this._y, this._z );

    }

  },

  onChange: function ( callback ) {

    this.onChangeCallback = callback;

    return this;

  },

  onChangeCallback: function () {},

  clone: function () {

    return new THREE.Euler( this._x, this._y, this._z, this._order );

  }

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

  this.start = ( start !== undefined ) ? start : new THREE.Vector3();
  this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

  constructor: THREE.Line3,

  set: function ( start, end ) {

    this.start.copy( start );
    this.end.copy( end );

    return this;

  },

  copy: function ( line ) {

    this.start.copy( line.start );
    this.end.copy( line.end );

    return this;

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

  },

  delta: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.end, this.start );

  },

  distanceSq: function () {

    return this.start.distanceToSquared( this.end );

  },

  distance: function () {

    return this.start.distanceTo( this.end );

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  closestPointToPointParameter: function () {

    var startP = new THREE.Vector3();
    var startEnd = new THREE.Vector3();

    return function ( point, clampToLine ) {

      startP.subVectors( point, this.start );
      startEnd.subVectors( this.end, this.start );

      var startEnd2 = startEnd.dot( startEnd );
      var startEnd_startP = startEnd.dot( startP );

      var t = startEnd_startP / startEnd2;

      if ( clampToLine ) {

        t = THREE.Math.clamp( t, 0, 1 );

      }

      return t;

    };

  }(),

  closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

    var t = this.closestPointToPointParameter( point, clampToLine );

    var result = optionalTarget || new THREE.Vector3();

    return this.delta( result ).multiplyScalar( t ).add( this.start );

  },

  applyMatrix4: function ( matrix ) {

    this.start.applyMatrix4( matrix );
    this.end.applyMatrix4( matrix );

    return this;

  },

  equals: function ( line ) {

    return line.start.equals( this.start ) && line.end.equals( this.end );

  },

  clone: function () {

    return new THREE.Line3().copy( this );

  }

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

  constructor: THREE.Box2,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] )

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector2();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = - Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;
  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;
  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;
  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
         ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector2();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y )
    );

  },

  isIntersectionBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector2();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector2();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  },

  clone: function () {

    return new THREE.Box2().copy( this );

  }

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

  this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
  this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

  constructor: THREE.Box3,

  set: function ( min, max ) {

    this.min.copy( min );
    this.max.copy( max );

    return this;

  },

  setFromPoints: function ( points ) {

    this.makeEmpty();

    for ( var i = 0, il = points.length; i < il; i ++ ) {

      this.expandByPoint( points[ i ] );

    }

    return this;

  },

  setFromCenterAndSize: function () {

    var v1 = new THREE.Vector3();

    return function ( center, size ) {

      var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

      this.min.copy( center ).sub( halfSize );
      this.max.copy( center ).add( halfSize );

      return this;

    };

  }(),

  setFromObject: function () {

    // Computes the world-axis-aligned bounding box of an object (including its children),
    // accounting for both the object's, and childrens', world transforms

    var v1 = new THREE.Vector3();

    return function ( object ) {

      var scope = this;

      object.updateMatrixWorld( true );

      this.makeEmpty();

      object.traverse( function ( node ) {

        var geometry = node.geometry;

        if ( geometry !== undefined ) {

          if ( geometry instanceof THREE.Geometry ) {

            var vertices = geometry.vertices;

            for ( var i = 0, il = vertices.length; i < il; i ++ ) {

              v1.copy( vertices[ i ] );

              v1.applyMatrix4( node.matrixWorld );

              scope.expandByPoint( v1 );

            }

          } else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

            var positions = geometry.attributes[ 'position' ].array;

            for ( var i = 0, il = positions.length; i < il; i += 3 ) {

              v1.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

              v1.applyMatrix4( node.matrixWorld );

              scope.expandByPoint( v1 );

            }

          }

        }

      } );

      return this;

    };

  }(),

  copy: function ( box ) {

    this.min.copy( box.min );
    this.max.copy( box.max );

    return this;

  },

  makeEmpty: function () {

    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = - Infinity;

    return this;

  },

  empty: function () {

    // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

    return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

  },

  center: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

  },

  size: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.subVectors( this.max, this.min );

  },

  expandByPoint: function ( point ) {

    this.min.min( point );
    this.max.max( point );

    return this;

  },

  expandByVector: function ( vector ) {

    this.min.sub( vector );
    this.max.add( vector );

    return this;

  },

  expandByScalar: function ( scalar ) {

    this.min.addScalar( - scalar );
    this.max.addScalar( scalar );

    return this;

  },

  containsPoint: function ( point ) {

    if ( point.x < this.min.x || point.x > this.max.x ||
         point.y < this.min.y || point.y > this.max.y ||
         point.z < this.min.z || point.z > this.max.z ) {

      return false;

    }

    return true;

  },

  containsBox: function ( box ) {

    if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
       ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
       ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

      return true;

    }

    return false;

  },

  getParameter: function ( point, optionalTarget ) {

    // This can potentially have a divide by zero if the box
    // has a size dimension of 0.

    var result = optionalTarget || new THREE.Vector3();

    return result.set(
      ( point.x - this.min.x ) / ( this.max.x - this.min.x ),
      ( point.y - this.min.y ) / ( this.max.y - this.min.y ),
      ( point.z - this.min.z ) / ( this.max.z - this.min.z )
    );

  },

  isIntersectionBox: function ( box ) {

    // using 6 splitting planes to rule out intersections.

    if ( box.max.x < this.min.x || box.min.x > this.max.x ||
         box.max.y < this.min.y || box.min.y > this.max.y ||
         box.max.z < this.min.z || box.min.z > this.max.z ) {

      return false;

    }

    return true;

  },

  clampPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( point ).clamp( this.min, this.max );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
      return clampedPoint.sub( point ).length();

    };

  }(),

  getBoundingSphere: function () {

    var v1 = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Sphere();

      result.center = this.center();
      result.radius = this.size( v1 ).length() * 0.5;

      return result;

    };

  }(),

  intersect: function ( box ) {

    this.min.max( box.min );
    this.max.min( box.max );

    return this;

  },

  union: function ( box ) {

    this.min.min( box.min );
    this.max.max( box.max );

    return this;

  },

  applyMatrix4: function () {

    var points = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];

    return function ( matrix ) {

      // NOTE: I am using a binary pattern to specify all 2^3 combinations below
      points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
      points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
      points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
      points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
      points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
      points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
      points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
      points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

      this.makeEmpty();
      this.setFromPoints( points );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.min.add( offset );
    this.max.add( offset );

    return this;

  },

  equals: function ( box ) {

    return box.min.equals( this.min ) && box.max.equals( this.max );

  },

  clone: function () {

    return new THREE.Box3().copy( this );

  }

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function () {

  this.elements = new Float32Array( [

    1, 0, 0,
    0, 1, 0,
    0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix3.prototype = {

  constructor: THREE.Matrix3,

  set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 3 ] = n12; te[ 6 ] = n13;
    te[ 1 ] = n21; te[ 4 ] = n22; te[ 7 ] = n23;
    te[ 2 ] = n31; te[ 5 ] = n32; te[ 8 ] = n33;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0,
      0, 1, 0,
      0, 0, 1

    );

    return this;

  },

  copy: function ( m ) {

    var me = m.elements;

    this.set(

      me[ 0 ], me[ 3 ], me[ 6 ],
      me[ 1 ], me[ 4 ], me[ 7 ],
      me[ 2 ], me[ 5 ], me[ 8 ]

    );

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
    return vector.applyMatrix3( this );

  },

  multiplyVector3Array: function ( a ) {

    console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    return this.applyToVector3Array( a );

  },

  applyToVector3Array: function () {

    var v1;

    return function ( array, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

        v1.fromArray( array, j );
        v1.applyMatrix3( this );
        v1.toArray( array, j );

      }

      return array;

    };

  }(),

  applyToBuffer: function () {

    var v1;

    return function applyToBuffer( buffer, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = buffer.length / buffer.itemSize;

      for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

        v1.x = buffer.getX( j );
        v1.y = buffer.getY( j );
        v1.z = buffer.getZ( j );

        v1.applyMatrix3( this );

        buffer.setXYZ( v1.x, v1.y, v1.z );

      }

      return buffer;

    };

  }(),

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
    te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
    te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

    return this;

  },

  determinant: function () {

    var te = this.elements;

    var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
      d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
      g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

  },

  getInverse: function ( matrix, throwOnInvertible ) {

    // input: THREE.Matrix4
    // ( based on http://code.google.com/p/webgl-mjs/ )

    var me = matrix.elements;
    var te = this.elements;

    te[ 0 ] =   me[ 10 ] * me[ 5 ] - me[ 6 ] * me[ 9 ];
    te[ 1 ] = - me[ 10 ] * me[ 1 ] + me[ 2 ] * me[ 9 ];
    te[ 2 ] =   me[ 6 ] * me[ 1 ] - me[ 2 ] * me[ 5 ];
    te[ 3 ] = - me[ 10 ] * me[ 4 ] + me[ 6 ] * me[ 8 ];
    te[ 4 ] =   me[ 10 ] * me[ 0 ] - me[ 2 ] * me[ 8 ];
    te[ 5 ] = - me[ 6 ] * me[ 0 ] + me[ 2 ] * me[ 4 ];
    te[ 6 ] =   me[ 9 ] * me[ 4 ] - me[ 5 ] * me[ 8 ];
    te[ 7 ] = - me[ 9 ] * me[ 0 ] + me[ 1 ] * me[ 8 ];
    te[ 8 ] =   me[ 5 ] * me[ 0 ] - me[ 1 ] * me[ 4 ];

    var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

    // no inverse

    if ( det === 0 ) {

      var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1.0 / det );

    return this;

  },

  transpose: function () {

    var tmp, m = this.elements;

    tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
    tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
    tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset     ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];

    array[ offset + 3 ] = te[ 3 ];
    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];

    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];
    array[ offset + 8 ]  = te[ 8 ];

    return array;

  },

  getNormalMatrix: function ( m ) {

    // input: THREE.Matrix4

    this.getInverse( m ).transpose();

    return this;

  },

  transposeIntoArray: function ( r ) {

    var m = this.elements;

    r[ 0 ] = m[ 0 ];
    r[ 1 ] = m[ 3 ];
    r[ 2 ] = m[ 6 ];
    r[ 3 ] = m[ 1 ];
    r[ 4 ] = m[ 4 ];
    r[ 5 ] = m[ 7 ];
    r[ 6 ] = m[ 2 ];
    r[ 7 ] = m[ 5 ];
    r[ 8 ] = m[ 8 ];

    return this;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ],
      te[ 3 ], te[ 4 ], te[ 5 ],
      te[ 6 ], te[ 7 ], te[ 8 ]
    ];

  },

  clone: function () {

    return new THREE.Matrix3().fromArray( this.elements );

  }

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

  this.elements = new Float32Array( [

    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1

  ] );

  if ( arguments.length > 0 ) {

    console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

  }

};

THREE.Matrix4.prototype = {

  constructor: THREE.Matrix4,

  set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

    var te = this.elements;

    te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
    te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
    te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
    te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

    return this;

  },

  identity: function () {

    this.set(

      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1

    );

    return this;

  },

  copy: function ( m ) {

    this.elements.set( m.elements );

    return this;

  },

  extractPosition: function ( m ) {

    console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
    return this.copyPosition( m );

  },

  copyPosition: function ( m ) {

    var te = this.elements;
    var me = m.elements;

    te[ 12 ] = me[ 12 ];
    te[ 13 ] = me[ 13 ];
    te[ 14 ] = me[ 14 ];

    return this;

  },

  extractBasis: function ( xAxis, yAxis, zAxis ) {

    var te = this.elements;

    xAxis.set( te[ 0 ], te[ 1 ], te[ 2 ] );
    yAxis.set( te[ 4 ], te[ 5 ], te[ 6 ] );
    zAxis.set( te[ 8 ], te[ 9 ], te[ 10 ] );

    return this;

  },

  makeBasis: function ( xAxis, yAxis, zAxis ) {

    this.set(
      xAxis.x, yAxis.x, zAxis.x, 0,
      xAxis.y, yAxis.y, zAxis.y, 0,
      xAxis.z, yAxis.z, zAxis.z, 0,
      0,       0,       0,       1
    );

    return this;

  },

  extractRotation: function () {

    var v1;

    return function ( m ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();

      var te = this.elements;
      var me = m.elements;

      var scaleX = 1 / v1.set( me[ 0 ], me[ 1 ], me[ 2 ] ).length();
      var scaleY = 1 / v1.set( me[ 4 ], me[ 5 ], me[ 6 ] ).length();
      var scaleZ = 1 / v1.set( me[ 8 ], me[ 9 ], me[ 10 ] ).length();

      te[ 0 ] = me[ 0 ] * scaleX;
      te[ 1 ] = me[ 1 ] * scaleX;
      te[ 2 ] = me[ 2 ] * scaleX;

      te[ 4 ] = me[ 4 ] * scaleY;
      te[ 5 ] = me[ 5 ] * scaleY;
      te[ 6 ] = me[ 6 ] * scaleY;

      te[ 8 ] = me[ 8 ] * scaleZ;
      te[ 9 ] = me[ 9 ] * scaleZ;
      te[ 10 ] = me[ 10 ] * scaleZ;

      return this;

    };

  }(),

  makeRotationFromEuler: function ( euler ) {

    if ( euler instanceof THREE.Euler === false ) {

      console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

    }

    var te = this.elements;

    var x = euler.x, y = euler.y, z = euler.z;
    var a = Math.cos( x ), b = Math.sin( x );
    var c = Math.cos( y ), d = Math.sin( y );
    var e = Math.cos( z ), f = Math.sin( z );

    if ( euler.order === 'XYZ' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = - c * f;
      te[ 8 ] = d;

      te[ 1 ] = af + be * d;
      te[ 5 ] = ae - bf * d;
      te[ 9 ] = - b * c;

      te[ 2 ] = bf - ae * d;
      te[ 6 ] = be + af * d;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YXZ' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce + df * b;
      te[ 4 ] = de * b - cf;
      te[ 8 ] = a * d;

      te[ 1 ] = a * f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b;

      te[ 2 ] = cf * b - de;
      te[ 6 ] = df + ce * b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZXY' ) {

      var ce = c * e, cf = c * f, de = d * e, df = d * f;

      te[ 0 ] = ce - df * b;
      te[ 4 ] = - a * f;
      te[ 8 ] = de + cf * b;

      te[ 1 ] = cf + de * b;
      te[ 5 ] = a * e;
      te[ 9 ] = df - ce * b;

      te[ 2 ] = - a * d;
      te[ 6 ] = b;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'ZYX' ) {

      var ae = a * e, af = a * f, be = b * e, bf = b * f;

      te[ 0 ] = c * e;
      te[ 4 ] = be * d - af;
      te[ 8 ] = ae * d + bf;

      te[ 1 ] = c * f;
      te[ 5 ] = bf * d + ae;
      te[ 9 ] = af * d - be;

      te[ 2 ] = - d;
      te[ 6 ] = b * c;
      te[ 10 ] = a * c;

    } else if ( euler.order === 'YZX' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = bd - ac * f;
      te[ 8 ] = bc * f + ad;

      te[ 1 ] = f;
      te[ 5 ] = a * e;
      te[ 9 ] = - b * e;

      te[ 2 ] = - d * e;
      te[ 6 ] = ad * f + bc;
      te[ 10 ] = ac - bd * f;

    } else if ( euler.order === 'XZY' ) {

      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

      te[ 0 ] = c * e;
      te[ 4 ] = - f;
      te[ 8 ] = d * e;

      te[ 1 ] = ac * f + bd;
      te[ 5 ] = a * e;
      te[ 9 ] = ad * f - bc;

      te[ 2 ] = bc * f - ad;
      te[ 6 ] = b * e;
      te[ 10 ] = bd * f + ac;

    }

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  setRotationFromQuaternion: function ( q ) {

    console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );

    return this.makeRotationFromQuaternion( q );

  },

  makeRotationFromQuaternion: function ( q ) {

    var te = this.elements;

    var x = q.x, y = q.y, z = q.z, w = q.w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;

    te[ 0 ] = 1 - ( yy + zz );
    te[ 4 ] = xy - wz;
    te[ 8 ] = xz + wy;

    te[ 1 ] = xy + wz;
    te[ 5 ] = 1 - ( xx + zz );
    te[ 9 ] = yz - wx;

    te[ 2 ] = xz - wy;
    te[ 6 ] = yz + wx;
    te[ 10 ] = 1 - ( xx + yy );

    // last column
    te[ 3 ] = 0;
    te[ 7 ] = 0;
    te[ 11 ] = 0;

    // bottom row
    te[ 12 ] = 0;
    te[ 13 ] = 0;
    te[ 14 ] = 0;
    te[ 15 ] = 1;

    return this;

  },

  lookAt: function () {

    var x, y, z;

    return function ( eye, target, up ) {

      if ( x === undefined ) x = new THREE.Vector3();
      if ( y === undefined ) y = new THREE.Vector3();
      if ( z === undefined ) z = new THREE.Vector3();

      var te = this.elements;

      z.subVectors( eye, target ).normalize();

      if ( z.length() === 0 ) {

        z.z = 1;

      }

      x.crossVectors( up, z ).normalize();

      if ( x.length() === 0 ) {

        z.x += 0.0001;
        x.crossVectors( up, z ).normalize();

      }

      y.crossVectors( z, x );


      te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
      te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
      te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

      return this;

    };

  }(),

  multiply: function ( m, n ) {

    if ( n !== undefined ) {

      console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
      return this.multiplyMatrices( m, n );

    }

    return this.multiplyMatrices( this, m );

  },

  multiplyMatrices: function ( a, b ) {

    var ae = a.elements;
    var be = b.elements;
    var te = this.elements;

    var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
    var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
    var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
    var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

    var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
    var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
    var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
    var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

    te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

    te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

    te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

    te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

    return this;

  },

  multiplyToArray: function ( a, b, r ) {

    var te = this.elements;

    this.multiplyMatrices( a, b );

    r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
    r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
    r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
    r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

    return this;

  },

  multiplyScalar: function ( s ) {

    var te = this.elements;

    te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
    te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
    te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
    te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

    return this;

  },

  multiplyVector3: function ( vector ) {

    console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
    return vector.applyProjection( this );

  },

  multiplyVector4: function ( vector ) {

    console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    return vector.applyMatrix4( this );

  },

  multiplyVector3Array: function ( a ) {

    console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
    return this.applyToVector3Array( a );

  },

  applyToVector3Array: function () {

    var v1;

    return function ( array, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = array.length;

      for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

        v1.fromArray( array, j );
        v1.applyMatrix4( this );
        v1.toArray( array, j );

      }

      return array;

    };

  }(),

  applyToBuffer: function () {

    var v1;

    return function applyToBuffer( buffer, offset, length ) {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      if ( offset === undefined ) offset = 0;
      if ( length === undefined ) length = buffer.length / buffer.itemSize;

      for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

        v1.x = buffer.getX( j );
        v1.y = buffer.getY( j );
        v1.z = buffer.getZ( j );

        v1.applyMatrix4( this );

        buffer.setXYZ( v1.x, v1.y, v1.z );

      }

      return buffer;

    };

  }(),

  rotateAxis: function ( v ) {

    console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

    v.transformDirection( this );

  },

  crossVector: function ( vector ) {

    console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
    return vector.applyMatrix4( this );

  },

  determinant: function () {

    var te = this.elements;

    var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
    var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
    var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
    var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

    //TODO: make this more efficient
    //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

    return (
      n41 * (
        + n14 * n23 * n32
         - n13 * n24 * n32
         - n14 * n22 * n33
         + n12 * n24 * n33
         + n13 * n22 * n34
         - n12 * n23 * n34
      ) +
      n42 * (
        + n11 * n23 * n34
         - n11 * n24 * n33
         + n14 * n21 * n33
         - n13 * n21 * n34
         + n13 * n24 * n31
         - n14 * n23 * n31
      ) +
      n43 * (
        + n11 * n24 * n32
         - n11 * n22 * n34
         - n14 * n21 * n32
         + n12 * n21 * n34
         + n14 * n22 * n31
         - n12 * n24 * n31
      ) +
      n44 * (
        - n13 * n22 * n31
         - n11 * n23 * n32
         + n11 * n22 * n33
         + n13 * n21 * n32
         - n12 * n21 * n33
         + n12 * n23 * n31
      )

    );

  },

  transpose: function () {

    var te = this.elements;
    var tmp;

    tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
    tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
    tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

    tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
    tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
    tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

    return this;

  },

  flattenToArrayOffset: function ( array, offset ) {

    var te = this.elements;

    array[ offset     ] = te[ 0 ];
    array[ offset + 1 ] = te[ 1 ];
    array[ offset + 2 ] = te[ 2 ];
    array[ offset + 3 ] = te[ 3 ];

    array[ offset + 4 ] = te[ 4 ];
    array[ offset + 5 ] = te[ 5 ];
    array[ offset + 6 ] = te[ 6 ];
    array[ offset + 7 ] = te[ 7 ];

    array[ offset + 8 ]  = te[ 8 ];
    array[ offset + 9 ]  = te[ 9 ];
    array[ offset + 10 ] = te[ 10 ];
    array[ offset + 11 ] = te[ 11 ];

    array[ offset + 12 ] = te[ 12 ];
    array[ offset + 13 ] = te[ 13 ];
    array[ offset + 14 ] = te[ 14 ];
    array[ offset + 15 ] = te[ 15 ];

    return array;

  },

  getPosition: function () {

    var v1;

    return function () {

      if ( v1 === undefined ) v1 = new THREE.Vector3();
      console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

      var te = this.elements;
      return v1.set( te[ 12 ], te[ 13 ], te[ 14 ] );

    };

  }(),

  setPosition: function ( v ) {

    var te = this.elements;

    te[ 12 ] = v.x;
    te[ 13 ] = v.y;
    te[ 14 ] = v.z;

    return this;

  },

  getInverse: function ( m, throwOnInvertible ) {

    // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
    var te = this.elements;
    var me = m.elements;

    var n11 = me[ 0 ], n12 = me[ 4 ], n13 = me[ 8 ], n14 = me[ 12 ];
    var n21 = me[ 1 ], n22 = me[ 5 ], n23 = me[ 9 ], n24 = me[ 13 ];
    var n31 = me[ 2 ], n32 = me[ 6 ], n33 = me[ 10 ], n34 = me[ 14 ];
    var n41 = me[ 3 ], n42 = me[ 7 ], n43 = me[ 11 ], n44 = me[ 15 ];

    te[ 0 ] = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;
    te[ 4 ] = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;
    te[ 8 ] = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;
    te[ 12 ] = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    te[ 1 ] = n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44;
    te[ 5 ] = n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44;
    te[ 9 ] = n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44;
    te[ 13 ] = n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34;
    te[ 2 ] = n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44;
    te[ 6 ] = n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44;
    te[ 10 ] = n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44;
    te[ 14 ] = n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34;
    te[ 3 ] = n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43;
    te[ 7 ] = n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43;
    te[ 11 ] = n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43;
    te[ 15 ] = n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33;

    var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

    if ( det === 0 ) {

      var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

      if ( throwOnInvertible || false ) {

        throw new Error( msg );

      } else {

        console.warn( msg );

      }

      this.identity();

      return this;

    }

    this.multiplyScalar( 1 / det );

    return this;

  },

  translate: function ( v ) {

    console.error( 'THREE.Matrix4: .translate() has been removed.' );

  },

  rotateX: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

  },

  rotateY: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

  },

  rotateZ: function ( angle ) {

    console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

  },

  rotateByAxis: function ( axis, angle ) {

    console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

  },

  scale: function ( v ) {

    var te = this.elements;
    var x = v.x, y = v.y, z = v.z;

    te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
    te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
    te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
    te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

    return this;

  },

  getMaxScaleOnAxis: function () {

    var te = this.elements;

    var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
    var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
    var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

    return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

  },

  makeTranslation: function ( x, y, z ) {

    this.set(

      1, 0, 0, x,
      0, 1, 0, y,
      0, 0, 1, z,
      0, 0, 0, 1

    );

    return this;

  },

  makeRotationX: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      1, 0,  0, 0,
      0, c, - s, 0,
      0, s,  c, 0,
      0, 0,  0, 1

    );

    return this;

  },

  makeRotationY: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

       c, 0, s, 0,
       0, 1, 0, 0,
      - s, 0, c, 0,
       0, 0, 0, 1

    );

    return this;

  },

  makeRotationZ: function ( theta ) {

    var c = Math.cos( theta ), s = Math.sin( theta );

    this.set(

      c, - s, 0, 0,
      s,  c, 0, 0,
      0,  0, 1, 0,
      0,  0, 0, 1

    );

    return this;

  },

  makeRotationAxis: function ( axis, angle ) {

    // Based on http://www.gamedev.net/reference/articles/article1199.asp

    var c = Math.cos( angle );
    var s = Math.sin( angle );
    var t = 1 - c;
    var x = axis.x, y = axis.y, z = axis.z;
    var tx = t * x, ty = t * y;

    this.set(

      tx * x + c, tx * y - s * z, tx * z + s * y, 0,
      tx * y + s * z, ty * y + c, ty * z - s * x, 0,
      tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
      0, 0, 0, 1

    );

     return this;

  },

  makeScale: function ( x, y, z ) {

    this.set(

      x, 0, 0, 0,
      0, y, 0, 0,
      0, 0, z, 0,
      0, 0, 0, 1

    );

    return this;

  },

  compose: function ( position, quaternion, scale ) {

    this.makeRotationFromQuaternion( quaternion );
    this.scale( scale );
    this.setPosition( position );

    return this;

  },

  decompose: function () {

    var vector, matrix;

    return function ( position, quaternion, scale ) {

      if ( vector === undefined ) vector = new THREE.Vector3();
      if ( matrix === undefined ) matrix = new THREE.Matrix4();

      var te = this.elements;

      var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
      var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
      var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

      // if determine is negative, we need to invert one scale
      var det = this.determinant();
      if ( det < 0 ) {

        sx = - sx;

      }

      position.x = te[ 12 ];
      position.y = te[ 13 ];
      position.z = te[ 14 ];

      // scale the rotation part

      matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

      var invSX = 1 / sx;
      var invSY = 1 / sy;
      var invSZ = 1 / sz;

      matrix.elements[ 0 ] *= invSX;
      matrix.elements[ 1 ] *= invSX;
      matrix.elements[ 2 ] *= invSX;

      matrix.elements[ 4 ] *= invSY;
      matrix.elements[ 5 ] *= invSY;
      matrix.elements[ 6 ] *= invSY;

      matrix.elements[ 8 ] *= invSZ;
      matrix.elements[ 9 ] *= invSZ;
      matrix.elements[ 10 ] *= invSZ;

      quaternion.setFromRotationMatrix( matrix );

      scale.x = sx;
      scale.y = sy;
      scale.z = sz;

      return this;

    };

  }(),

  makeFrustum: function ( left, right, bottom, top, near, far ) {

    var te = this.elements;
    var x = 2 * near / ( right - left );
    var y = 2 * near / ( top - bottom );

    var a = ( right + left ) / ( right - left );
    var b = ( top + bottom ) / ( top - bottom );
    var c = - ( far + near ) / ( far - near );
    var d = - 2 * far * near / ( far - near );

    te[ 0 ] = x;  te[ 4 ] = 0;  te[ 8 ] = a;  te[ 12 ] = 0;
    te[ 1 ] = 0;  te[ 5 ] = y;  te[ 9 ] = b;  te[ 13 ] = 0;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = c; te[ 14 ] = d;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = - 1; te[ 15 ] = 0;

    return this;

  },

  makePerspective: function ( fov, aspect, near, far ) {

    var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
    var ymin = - ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;

    return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

  },

  makeOrthographic: function ( left, right, top, bottom, near, far ) {

    var te = this.elements;
    var w = right - left;
    var h = top - bottom;
    var p = far - near;

    var x = ( right + left ) / w;
    var y = ( top + bottom ) / h;
    var z = ( far + near ) / p;

    te[ 0 ] = 2 / w;  te[ 4 ] = 0;  te[ 8 ] = 0;  te[ 12 ] = - x;
    te[ 1 ] = 0;  te[ 5 ] = 2 / h;  te[ 9 ] = 0;  te[ 13 ] = - y;
    te[ 2 ] = 0;  te[ 6 ] = 0;  te[ 10 ] = - 2 / p; te[ 14 ] = - z;
    te[ 3 ] = 0;  te[ 7 ] = 0;  te[ 11 ] = 0; te[ 15 ] = 1;

    return this;

  },

  fromArray: function ( array ) {

    this.elements.set( array );

    return this;

  },

  toArray: function () {

    var te = this.elements;

    return [
      te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
      te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
      te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
      te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
    ];

  },

  clone: function () {

    return new THREE.Matrix4().fromArray( this.elements );

  }

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

  this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
  this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

  constructor: THREE.Ray,

  set: function ( origin, direction ) {

    this.origin.copy( origin );
    this.direction.copy( direction );

    return this;

  },

  copy: function ( ray ) {

    this.origin.copy( ray.origin );
    this.direction.copy( ray.direction );

    return this;

  },

  at: function ( t, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

  },

  recast: function () {

    var v1 = new THREE.Vector3();

    return function ( t ) {

      this.origin.copy( this.at( t, v1 ) );

      return this;

    };

  }(),

  closestPointToPoint: function ( point, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    result.subVectors( point, this.origin );
    var directionDistance = result.dot( this.direction );

    if ( directionDistance < 0 ) {

      return result.copy( this.origin );

    }

    return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

  },

  distanceToPoint: function () {

    var v1 = new THREE.Vector3();

    return function ( point ) {

      var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

      // point behind the ray

      if ( directionDistance < 0 ) {

        return this.origin.distanceTo( point );

      }

      v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

      return v1.distanceTo( point );

    };

  }(),

  distanceSqToSegment: function () {

    var segCenter = new THREE.Vector3();
    var segDir = new THREE.Vector3();
    var diff = new THREE.Vector3();

    return function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

      // from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
      // It returns the min distance between the ray and the segment
      // defined by v0 and v1
      // It can also set two optional targets :
      // - The closest point on the ray
      // - The closest point on the segment

      segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
      segDir.copy( v1 ).sub( v0 ).normalize();
      diff.copy( this.origin ).sub( segCenter );

      var segExtent = v0.distanceTo( v1 ) * 0.5;
      var a01 = - this.direction.dot( segDir );
      var b0 = diff.dot( this.direction );
      var b1 = - diff.dot( segDir );
      var c = diff.lengthSq();
      var det = Math.abs( 1 - a01 * a01 );
      var s0, s1, sqrDist, extDet;

      if ( det > 0 ) {

        // The ray and segment are not parallel.

        s0 = a01 * b1 - b0;
        s1 = a01 * b0 - b1;
        extDet = segExtent * det;

        if ( s0 >= 0 ) {

          if ( s1 >= - extDet ) {

            if ( s1 <= extDet ) {

              // region 0
              // Minimum at interior points of ray and segment.

              var invDet = 1 / det;
              s0 *= invDet;
              s1 *= invDet;
              sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

            } else {

              // region 1

              s1 = segExtent;
              s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
              sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

            }

          } else {

            // region 5

            s1 = - segExtent;
            s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        } else {

          if ( s1 <= - extDet ) {

            // region 4

            s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
            s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          } else if ( s1 <= extDet ) {

            // region 3

            s0 = 0;
            s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = s1 * ( s1 + 2 * b1 ) + c;

          } else {

            // region 2

            s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
            s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
            sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

          }

        }

      } else {

        // Ray and segment are parallel.

        s1 = ( a01 > 0 ) ? - segExtent : segExtent;
        s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
        sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

      }

      if ( optionalPointOnRay ) {

        optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

      }

      if ( optionalPointOnSegment ) {

        optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

      }

      return sqrDist;

    };

  }(),


  isIntersectionSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) <= sphere.radius;

  },

  intersectSphere: function () {

    // from http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-sphere-intersection/

    var v1 = new THREE.Vector3();

    return function ( sphere, optionalTarget ) {

      v1.subVectors( sphere.center, this.origin );

      var tca = v1.dot( this.direction );

      var d2 = v1.dot( v1 ) - tca * tca;

      var radius2 = sphere.radius * sphere.radius;

      if ( d2 > radius2 ) return null;

      var thc = Math.sqrt( radius2 - d2 );

      // t0 = first intersect point - entrance on front of sphere
      var t0 = tca - thc;

      // t1 = second intersect point - exit point on back of sphere
      var t1 = tca + thc;

      // test to see if both t0 and t1 are behind the ray - if so, return null
      if ( t0 < 0 && t1 < 0 ) return null;

      // test to see if t0 is behind the ray:
      // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
      // in order to always return an intersect point that is in front of the ray.
      if ( t0 < 0 ) return this.at( t1, optionalTarget );

      // else t0 is in front of the ray, so return the first collision point scaled by t0
      return this.at( t0, optionalTarget );

    }

  }(),

  isIntersectionPlane: function ( plane ) {

    // check if the ray lies on the plane first

    var distToPoint = plane.distanceToPoint( this.origin );

    if ( distToPoint === 0 ) {

      return true;

    }

    var denominator = plane.normal.dot( this.direction );

    if ( denominator * distToPoint < 0 ) {

      return true;

    }

    // ray origin is behind the plane (and is pointing behind it)

    return false;

  },

  distanceToPlane: function ( plane ) {

    var denominator = plane.normal.dot( this.direction );
    if ( denominator === 0 ) {

      // line is coplanar, return origin
      if ( plane.distanceToPoint( this.origin ) === 0 ) {

        return 0;

      }

      // Null is preferable to undefined since undefined means.... it is undefined

      return null;

    }

    var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

    // Return if the ray never intersects the plane

    return t >= 0 ? t :  null;

  },

  intersectPlane: function ( plane, optionalTarget ) {

    var t = this.distanceToPlane( plane );

    if ( t === null ) {

      return null;
    }

    return this.at( t, optionalTarget );

  },

  isIntersectionBox: function () {

    var v = new THREE.Vector3();

    return function ( box ) {

      return this.intersectBox( box, v ) !== null;

    };

  }(),

  intersectBox: function ( box, optionalTarget ) {

    // http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

    var tmin,tmax,tymin,tymax,tzmin,tzmax;

    var invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z;

    var origin = this.origin;

    if ( invdirx >= 0 ) {

      tmin = ( box.min.x - origin.x ) * invdirx;
      tmax = ( box.max.x - origin.x ) * invdirx;

    } else {

      tmin = ( box.max.x - origin.x ) * invdirx;
      tmax = ( box.min.x - origin.x ) * invdirx;
    }

    if ( invdiry >= 0 ) {

      tymin = ( box.min.y - origin.y ) * invdiry;
      tymax = ( box.max.y - origin.y ) * invdiry;

    } else {

      tymin = ( box.max.y - origin.y ) * invdiry;
      tymax = ( box.min.y - origin.y ) * invdiry;
    }

    if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

    // These lines also handle the case where tmin or tmax is NaN
    // (result of 0 * Infinity). x !== x returns true if x is NaN

    if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

    if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

    if ( invdirz >= 0 ) {

      tzmin = ( box.min.z - origin.z ) * invdirz;
      tzmax = ( box.max.z - origin.z ) * invdirz;

    } else {

      tzmin = ( box.max.z - origin.z ) * invdirz;
      tzmax = ( box.min.z - origin.z ) * invdirz;
    }

    if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

    if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

    if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

    //return point closest to the ray (positive side)

    if ( tmax < 0 ) return null;

    return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

  },

  intersectTriangle: function () {

    // Compute the offset origin, edges, and normal.
    var diff = new THREE.Vector3();
    var edge1 = new THREE.Vector3();
    var edge2 = new THREE.Vector3();
    var normal = new THREE.Vector3();

    return function ( a, b, c, backfaceCulling, optionalTarget ) {

      // from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

      edge1.subVectors( b, a );
      edge2.subVectors( c, a );
      normal.crossVectors( edge1, edge2 );

      // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
      // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
      //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
      //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
      //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
      var DdN = this.direction.dot( normal );
      var sign;

      if ( DdN > 0 ) {

        if ( backfaceCulling ) return null;
        sign = 1;

      } else if ( DdN < 0 ) {

        sign = - 1;
        DdN = - DdN;

      } else {

        return null;

      }

      diff.subVectors( this.origin, a );
      var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

      // b1 < 0, no intersection
      if ( DdQxE2 < 0 ) {

        return null;

      }

      var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

      // b2 < 0, no intersection
      if ( DdE1xQ < 0 ) {

        return null;

      }

      // b1+b2 > 1, no intersection
      if ( DdQxE2 + DdE1xQ > DdN ) {

        return null;

      }

      // Line intersects triangle, check if ray does.
      var QdN = - sign * diff.dot( normal );

      // t < 0, no intersection
      if ( QdN < 0 ) {

        return null;

      }

      // Ray intersects triangle.
      return this.at( QdN / DdN, optionalTarget );

    };

  }(),

  applyMatrix4: function ( matrix4 ) {

    this.direction.add( this.origin ).applyMatrix4( matrix4 );
    this.origin.applyMatrix4( matrix4 );
    this.direction.sub( this.origin );
    this.direction.normalize();

    return this;
  },

  equals: function ( ray ) {

    return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

  },

  clone: function () {

    return new THREE.Ray().copy( this );

  }

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

  this.center = ( center !== undefined ) ? center : new THREE.Vector3();
  this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

  constructor: THREE.Sphere,

  set: function ( center, radius ) {

    this.center.copy( center );
    this.radius = radius;

    return this;
  },

  setFromPoints: function () {

    var box = new THREE.Box3();

    return function ( points, optionalCenter ) {

      var center = this.center;

      if ( optionalCenter !== undefined ) {

        center.copy( optionalCenter );

      } else {

        box.setFromPoints( points ).center( center );

      }

      var maxRadiusSq = 0;

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

      }

      this.radius = Math.sqrt( maxRadiusSq );

      return this;

    };

  }(),

  copy: function ( sphere ) {

    this.center.copy( sphere.center );
    this.radius = sphere.radius;

    return this;

  },

  empty: function () {

    return ( this.radius <= 0 );

  },

  containsPoint: function ( point ) {

    return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

  },

  distanceToPoint: function ( point ) {

    return ( point.distanceTo( this.center ) - this.radius );

  },

  intersectsSphere: function ( sphere ) {

    var radiusSum = this.radius + sphere.radius;

    return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

  },

  clampPoint: function ( point, optionalTarget ) {

    var deltaLengthSq = this.center.distanceToSquared( point );

    var result = optionalTarget || new THREE.Vector3();
    result.copy( point );

    if ( deltaLengthSq > ( this.radius * this.radius ) ) {

      result.sub( this.center ).normalize();
      result.multiplyScalar( this.radius ).add( this.center );

    }

    return result;

  },

  getBoundingBox: function ( optionalTarget ) {

    var box = optionalTarget || new THREE.Box3();

    box.set( this.center, this.center );
    box.expandByScalar( this.radius );

    return box;

  },

  applyMatrix4: function ( matrix ) {

    this.center.applyMatrix4( matrix );
    this.radius = this.radius * matrix.getMaxScaleOnAxis();

    return this;

  },

  translate: function ( offset ) {

    this.center.add( offset );

    return this;

  },

  equals: function ( sphere ) {

    return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

  },

  clone: function () {

    return new THREE.Sphere().copy( this );

  }

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

  this.planes = [

    ( p0 !== undefined ) ? p0 : new THREE.Plane(),
    ( p1 !== undefined ) ? p1 : new THREE.Plane(),
    ( p2 !== undefined ) ? p2 : new THREE.Plane(),
    ( p3 !== undefined ) ? p3 : new THREE.Plane(),
    ( p4 !== undefined ) ? p4 : new THREE.Plane(),
    ( p5 !== undefined ) ? p5 : new THREE.Plane()

  ];

};

THREE.Frustum.prototype = {

  constructor: THREE.Frustum,

  set: function ( p0, p1, p2, p3, p4, p5 ) {

    var planes = this.planes;

    planes[ 0 ].copy( p0 );
    planes[ 1 ].copy( p1 );
    planes[ 2 ].copy( p2 );
    planes[ 3 ].copy( p3 );
    planes[ 4 ].copy( p4 );
    planes[ 5 ].copy( p5 );

    return this;

  },

  copy: function ( frustum ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      planes[ i ].copy( frustum.planes[ i ] );

    }

    return this;

  },

  setFromMatrix: function ( m ) {

    var planes = this.planes;
    var me = m.elements;
    var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
    var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
    var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
    var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

    planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
    planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
    planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
    planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
    planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
    planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

    return this;

  },

  intersectsObject: function () {

    var sphere = new THREE.Sphere();

    return function ( object ) {

      var geometry = object.geometry;

      if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

      sphere.copy( geometry.boundingSphere );
      sphere.applyMatrix4( object.matrixWorld );

      return this.intersectsSphere( sphere );

    };

  }(),

  intersectsSphere: function ( sphere ) {

    var planes = this.planes;
    var center = sphere.center;
    var negRadius = - sphere.radius;

    for ( var i = 0; i < 6; i ++ ) {

      var distance = planes[ i ].distanceToPoint( center );

      if ( distance < negRadius ) {

        return false;

      }

    }

    return true;

  },

  intersectsBox: function () {

    var p1 = new THREE.Vector3(),
      p2 = new THREE.Vector3();

    return function ( box ) {

      var planes = this.planes;

      for ( var i = 0; i < 6 ; i ++ ) {

        var plane = planes[ i ];

        p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
        p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
        p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
        p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
        p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
        p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

        var d1 = plane.distanceToPoint( p1 );
        var d2 = plane.distanceToPoint( p2 );

        // if both outside plane, no intersection

        if ( d1 < 0 && d2 < 0 ) {

          return false;

        }
      }

      return true;
    };

  }(),


  containsPoint: function ( point ) {

    var planes = this.planes;

    for ( var i = 0; i < 6; i ++ ) {

      if ( planes[ i ].distanceToPoint( point ) < 0 ) {

        return false;

      }

    }

    return true;

  },

  clone: function () {

    return new THREE.Frustum().copy( this );

  }

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

  this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
  this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

  constructor: THREE.Plane,

  set: function ( normal, constant ) {

    this.normal.copy( normal );
    this.constant = constant;

    return this;

  },

  setComponents: function ( x, y, z, w ) {

    this.normal.set( x, y, z );
    this.constant = w;

    return this;

  },

  setFromNormalAndCoplanarPoint: function ( normal, point ) {

    this.normal.copy( normal );
    this.constant = - point.dot( this.normal ); // must be this.normal, not normal, as this.normal is normalized

    return this;

  },

  setFromCoplanarPoints: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();

    return function ( a, b, c ) {

      var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

      // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

      this.setFromNormalAndCoplanarPoint( normal, a );

      return this;

    };

  }(),


  copy: function ( plane ) {

    this.normal.copy( plane.normal );
    this.constant = plane.constant;

    return this;

  },

  normalize: function () {

    // Note: will lead to a divide by zero if the plane is invalid.

    var inverseNormalLength = 1.0 / this.normal.length();
    this.normal.multiplyScalar( inverseNormalLength );
    this.constant *= inverseNormalLength;

    return this;

  },

  negate: function () {

    this.constant *= - 1;
    this.normal.negate();

    return this;

  },

  distanceToPoint: function ( point ) {

    return this.normal.dot( point ) + this.constant;

  },

  distanceToSphere: function ( sphere ) {

    return this.distanceToPoint( sphere.center ) - sphere.radius;

  },

  projectPoint: function ( point, optionalTarget ) {

    return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

  },

  orthoPoint: function ( point, optionalTarget ) {

    var perpendicularMagnitude = this.distanceToPoint( point );

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

  },

  isIntersectionLine: function ( line ) {

    // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

    var startSign = this.distanceToPoint( line.start );
    var endSign = this.distanceToPoint( line.end );

    return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

  },

  intersectLine: function () {

    var v1 = new THREE.Vector3();

    return function ( line, optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      var direction = line.delta( v1 );

      var denominator = this.normal.dot( direction );

      if ( denominator === 0 ) {

        // line is coplanar, return origin
        if ( this.distanceToPoint( line.start ) === 0 ) {

          return result.copy( line.start );

        }

        // Unsure if this is the correct method to handle this case.
        return undefined;

      }

      var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

      if ( t < 0 || t > 1 ) {

        return undefined;

      }

      return result.copy( direction ).multiplyScalar( t ).add( line.start );

    };

  }(),


  coplanarPoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.copy( this.normal ).multiplyScalar( - this.constant );

  },

  applyMatrix4: function () {

    var v1 = new THREE.Vector3();
    var v2 = new THREE.Vector3();
    var m1 = new THREE.Matrix3();

    return function ( matrix, optionalNormalMatrix ) {

      // compute new normal based on theory here:
      // http://www.songho.ca/opengl/gl_normaltransform.html
      var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
      var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );

      var newCoplanarPoint = this.coplanarPoint( v2 );
      newCoplanarPoint.applyMatrix4( matrix );

      this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

      return this;

    };

  }(),

  translate: function ( offset ) {

    this.constant = this.constant - offset.dot( this.normal );

    return this;

  },

  equals: function ( plane ) {

    return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

  },

  clone: function () {

    return new THREE.Plane().copy( this );

  }

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

  generateUUID: function () {

    // http://www.broofa.com/Tools/Math.uuid.htm

    var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
    var uuid = new Array( 36 );
    var rnd = 0, r;

    return function () {

      for ( var i = 0; i < 36; i ++ ) {

        if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

          uuid[ i ] = '-';

        } else if ( i === 14 ) {

          uuid[ i ] = '4';

        } else {

          if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
          r = rnd & 0xf;
          rnd = rnd >> 4;
          uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

        }
      }

      return uuid.join( '' );

    };

  }(),

  // Clamp value to range <a, b>

  clamp: function ( x, a, b ) {

    return ( x < a ) ? a : ( ( x > b ) ? b : x );

  },

  // Clamp value to range <a, inf)

  clampBottom: function ( x, a ) {

    return x < a ? a : x;

  },

  // Linear mapping from range <a1, a2> to range <b1, b2>

  mapLinear: function ( x, a1, a2, b1, b2 ) {

    return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

  },

  // http://en.wikipedia.org/wiki/Smoothstep

  smoothstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * ( 3 - 2 * x );

  },

  smootherstep: function ( x, min, max ) {

    if ( x <= min ) return 0;
    if ( x >= max ) return 1;

    x = ( x - min ) / ( max - min );

    return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

  },

  // Random float from <0, 1> with 16 bits of randomness
  // (standard Math.random() creates repetitive patterns when applied over larger space)

  random16: function () {

    return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

  },

  // Random integer from <low, high> interval

  randInt: function ( low, high ) {

    return Math.floor( this.randFloat( low, high ) );

  },

  // Random float from <low, high> interval

  randFloat: function ( low, high ) {

    return low + Math.random() * ( high - low );

  },

  // Random float from <-range/2, range/2> interval

  randFloatSpread: function ( range ) {

    return range * ( 0.5 - Math.random() );

  },

  degToRad: function () {

    var degreeToRadiansFactor = Math.PI / 180;

    return function ( degrees ) {

      return degrees * degreeToRadiansFactor;

    };

  }(),

  radToDeg: function () {

    var radianToDegreesFactor = 180 / Math.PI;

    return function ( radians ) {

      return radians * radianToDegreesFactor;

    };

  }(),

  isPowerOfTwo: function ( value ) {

    return ( value & ( value - 1 ) ) === 0 && value !== 0;

  },

  nextPowerOfTwo: function ( value ) {

    value --;
    value |= value >> 1;
    value |= value >> 2;
    value |= value >> 4;
    value |= value >> 8;
    value |= value >> 16;
    value ++;

    return value;

  }

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

  this.points = points;

  var c = [], v3 = { x: 0, y: 0, z: 0 },
  point, intPoint, weight, w2, w3,
  pa, pb, pc, pd;

  this.initFromArray = function ( a ) {

    this.points = [];

    for ( var i = 0; i < a.length; i ++ ) {

      this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

    }

  };

  this.getPoint = function ( k ) {

    point = ( this.points.length - 1 ) * k;
    intPoint = Math.floor( point );
    weight = point - intPoint;

    c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
    c[ 1 ] = intPoint;
    c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
    c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

    pa = this.points[ c[ 0 ] ];
    pb = this.points[ c[ 1 ] ];
    pc = this.points[ c[ 2 ] ];
    pd = this.points[ c[ 3 ] ];

    w2 = weight * weight;
    w3 = weight * w2;

    v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
    v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
    v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

    return v3;

  };

  this.getControlPointsArray = function () {

    var i, p, l = this.points.length,
      coords = [];

    for ( i = 0; i < l; i ++ ) {

      p = this.points[ i ];
      coords[ i ] = [ p.x, p.y, p.z ];

    }

    return coords;

  };

  // approximate length by summing linear segments

  this.getLength = function ( nSubDivisions ) {

    var i, index, nSamples, position,
      point = 0, intPoint = 0, oldIntPoint = 0,
      oldPosition = new THREE.Vector3(),
      tmpVec = new THREE.Vector3(),
      chunkLengths = [],
      totalLength = 0;

    // first point has 0 length

    chunkLengths[ 0 ] = 0;

    if ( ! nSubDivisions ) nSubDivisions = 100;

    nSamples = this.points.length * nSubDivisions;

    oldPosition.copy( this.points[ 0 ] );

    for ( i = 1; i < nSamples; i ++ ) {

      index = i / nSamples;

      position = this.getPoint( index );
      tmpVec.copy( position );

      totalLength += tmpVec.distanceTo( oldPosition );

      oldPosition.copy( position );

      point = ( this.points.length - 1 ) * index;
      intPoint = Math.floor( point );

      if ( intPoint !== oldIntPoint ) {

        chunkLengths[ intPoint ] = totalLength;
        oldIntPoint = intPoint;

      }

    }

    // last point ends with total length

    chunkLengths[ chunkLengths.length ] = totalLength;

    return { chunks: chunkLengths, total: totalLength };

  };

  this.reparametrizeByArcLength = function ( samplingCoef ) {

    var i, j,
      index, indexCurrent, indexNext,
      realDistance,
      sampling, position,
      newpoints = [],
      tmpVec = new THREE.Vector3(),
      sl = this.getLength();

    newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

    for ( i = 1; i < this.points.length; i ++ ) {

      //tmpVec.copy( this.points[ i - 1 ] );
      //linearDistance = tmpVec.distanceTo( this.points[ i ] );

      realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

      sampling = Math.ceil( samplingCoef * realDistance / sl.total );

      indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
      indexNext = i / ( this.points.length - 1 );

      for ( j = 1; j < sampling - 1; j ++ ) {

        index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

        position = this.getPoint( index );
        newpoints.push( tmpVec.copy( position ).clone() );

      }

      newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

    }

    this.points = newpoints;

  };

  // Catmull-Rom

  function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

    var v0 = ( p2 - p0 ) * 0.5,
      v1 = ( p3 - p1 ) * 0.5;

    return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

  this.a = ( a !== undefined ) ? a : new THREE.Vector3();
  this.b = ( b !== undefined ) ? b : new THREE.Vector3();
  this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

  var v0 = new THREE.Vector3();

  return function ( a, b, c, optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    result.subVectors( c, b );
    v0.subVectors( a, b );
    result.cross( v0 );

    var resultLengthSq = result.lengthSq();
    if ( resultLengthSq > 0 ) {

      return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

    }

    return result.set( 0, 0, 0 );

  };

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

  var v0 = new THREE.Vector3();
  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function ( point, a, b, c, optionalTarget ) {

    v0.subVectors( c, a );
    v1.subVectors( b, a );
    v2.subVectors( point, a );

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var denom = ( dot00 * dot11 - dot01 * dot01 );

    var result = optionalTarget || new THREE.Vector3();

    // colinear or singular triangle
    if ( denom === 0 ) {
      // arbitrary location outside of triangle?
      // not sure if this is the best idea, maybe should be returning undefined
      return result.set( - 2, - 1, - 1 );
    }

    var invDenom = 1 / denom;
    var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
    var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

    // barycoordinates must always sum to 1
    return result.set( 1 - u - v, v, u );

  };

}();

THREE.Triangle.containsPoint = function () {

  var v1 = new THREE.Vector3();

  return function ( point, a, b, c ) {

    var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

    return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

  };

}();

THREE.Triangle.prototype = {

  constructor: THREE.Triangle,

  set: function ( a, b, c ) {

    this.a.copy( a );
    this.b.copy( b );
    this.c.copy( c );

    return this;

  },

  setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

    this.a.copy( points[ i0 ] );
    this.b.copy( points[ i1 ] );
    this.c.copy( points[ i2 ] );

    return this;

  },

  copy: function ( triangle ) {

    this.a.copy( triangle.a );
    this.b.copy( triangle.b );
    this.c.copy( triangle.c );

    return this;

  },

  area: function () {

    var v0 = new THREE.Vector3();
    var v1 = new THREE.Vector3();

    return function () {

      v0.subVectors( this.c, this.b );
      v1.subVectors( this.a, this.b );

      return v0.cross( v1 ).length() * 0.5;

    };

  }(),

  midpoint: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();
    return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

  },

  normal: function ( optionalTarget ) {

    return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

  },

  plane: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Plane();

    return result.setFromCoplanarPoints( this.a, this.b, this.c );

  },

  barycoordFromPoint: function ( point, optionalTarget ) {

    return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

  },

  containsPoint: function ( point ) {

    return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

  },

  equals: function ( triangle ) {

    return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

  },

  clone: function () {

    return new THREE.Triangle().copy( this );

  }

};

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

  this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

  this.startTime = 0;
  this.oldTime = 0;
  this.elapsedTime = 0;

  this.running = false;

};

THREE.Clock.prototype = {

  constructor: THREE.Clock,

  start: function () {

    this.startTime = self.performance !== undefined && self.performance.now !== undefined
           ? self.performance.now()
           : Date.now();

    this.oldTime = this.startTime;
    this.running = true;
  },

  stop: function () {

    this.getElapsedTime();
    this.running = false;

  },

  getElapsedTime: function () {

    this.getDelta();
    return this.elapsedTime;

  },

  getDelta: function () {

    var diff = 0;

    if ( this.autoStart && ! this.running ) {

      this.start();

    }

    if ( this.running ) {

      var newTime = self.performance !== undefined && self.performance.now !== undefined
           ? self.performance.now()
           : Date.now();

      diff = 0.001 * ( newTime - this.oldTime );
      this.oldTime = newTime;

      this.elapsedTime += diff;

    }

    return diff;

  }

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

THREE.EventDispatcher.prototype = {

  constructor: THREE.EventDispatcher,

  apply: function ( object ) {

    object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
    object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
    object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
    object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

  },

  addEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) this._listeners = {};

    var listeners = this._listeners;

    if ( listeners[ type ] === undefined ) {

      listeners[ type ] = [];

    }

    if ( listeners[ type ].indexOf( listener ) === - 1 ) {

      listeners[ type ].push( listener );

    }

  },

  hasEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return false;

    var listeners = this._listeners;

    if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

      return true;

    }

    return false;

  },

  removeEventListener: function ( type, listener ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ type ];

    if ( listenerArray !== undefined ) {

      var index = listenerArray.indexOf( listener );

      if ( index !== - 1 ) {

        listenerArray.splice( index, 1 );

      }

    }

  },

  dispatchEvent: function ( event ) {

    if ( this._listeners === undefined ) return;

    var listeners = this._listeners;
    var listenerArray = listeners[ event.type ];

    if ( listenerArray !== undefined ) {

      event.target = this;

      var array = [];
      var length = listenerArray.length;

      for ( var i = 0; i < length; i ++ ) {

        array[ i ] = listenerArray[ i ];

      }

      for ( var i = 0; i < length; i ++ ) {

        array[ i ].call( this, event );

      }

    }

  }

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

  THREE.Raycaster = function ( origin, direction, near, far ) {

    this.ray = new THREE.Ray( origin, direction );
    // direction is assumed to be normalized (for accurate distance calculations)

    this.near = near || 0;
    this.far = far || Infinity;

    this.params = {
      Sprite: {},
      Mesh: {},
      PointCloud: { threshold: 1 },
      LOD: {},
      Line: {}
    };

  };

  var descSort = function ( a, b ) {

    return a.distance - b.distance;

  };

  var intersectObject = function ( object, raycaster, intersects, recursive ) {

    object.raycast( raycaster, intersects );

    if ( recursive === true ) {

      var children = object.children;

      for ( var i = 0, l = children.length; i < l; i ++ ) {

        intersectObject( children[ i ], raycaster, intersects, true );

      }

    }

  };

  //

  THREE.Raycaster.prototype = {

    constructor: THREE.Raycaster,

    linePrecision: 1,

    set: function ( origin, direction ) {

      // direction is assumed to be normalized (for accurate distance calculations)

      this.ray.set( origin, direction );

    },

    setFromCamera: function ( coords, camera ) {

      if ( camera instanceof THREE.PerspectiveCamera ) {

        this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
        this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

      } else if ( camera instanceof THREE.OrthographicCamera ) {

        this.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );
        this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

      } else {

        console.error( 'THREE.Raycaster: Unsupported camera type.' );

      }

    },

    intersectObject: function ( object, recursive ) {

      var intersects = [];

      intersectObject( object, this, intersects, recursive );

      intersects.sort( descSort );

      return intersects;

    },

    intersectObjects: function ( objects, recursive ) {

      var intersects = [];

      if ( Array.isArray( objects ) === false ) {

        console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
        return intersects;

      }

      for ( var i = 0, l = objects.length; i < l; i ++ ) {

        intersectObject( objects[ i ], this, intersects, recursive );

      }

      intersects.sort( descSort );

      return intersects;

    }

  };

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

  Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Object3D';

  this.parent = undefined;
  this.children = [];

  this.up = THREE.Object3D.DefaultUp.clone();

  var position = new THREE.Vector3();
  var rotation = new THREE.Euler();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3( 1, 1, 1 );

  var onRotationChange = function () {
    quaternion.setFromEuler( rotation, false );
  };

  var onQuaternionChange = function () {
    rotation.setFromQuaternion( quaternion, undefined, false );
  };

  rotation.onChange( onRotationChange );
  quaternion.onChange( onQuaternionChange );

  Object.defineProperties( this, {
    position: {
      enumerable: true,
      value: position
    },
    rotation: {
      enumerable: true,
      value: rotation
    },
    quaternion: {
      enumerable: true,
      value: quaternion
    },
    scale: {
      enumerable: true,
      value: scale
    }
  } );

  this.rotationAutoUpdate = true;

  this.matrix = new THREE.Matrix4();
  this.matrixWorld = new THREE.Matrix4();

  this.matrixAutoUpdate = true;
  this.matrixWorldNeedsUpdate = false;

  this.visible = true;

  this.castShadow = false;
  this.receiveShadow = false;

  this.frustumCulled = true;
  this.renderOrder = 0;

  this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );

THREE.Object3D.prototype = {

  constructor: THREE.Object3D,

  get eulerOrder () {

    console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

    return this.rotation.order;

  },

  set eulerOrder ( value ) {

    console.warn( 'THREE.Object3D: .eulerOrder has been moved to .rotation.order.' );

    this.rotation.order = value;

  },

  get useQuaternion () {

    console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  },

  set useQuaternion ( value ) {

    console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

  },

  applyMatrix: function ( matrix ) {

    this.matrix.multiplyMatrices( matrix, this.matrix );

    this.matrix.decompose( this.position, this.quaternion, this.scale );

  },

  setRotationFromAxisAngle: function ( axis, angle ) {

    // assumes axis is normalized

    this.quaternion.setFromAxisAngle( axis, angle );

  },

  setRotationFromEuler: function ( euler ) {

    this.quaternion.setFromEuler( euler, true );

  },

  setRotationFromMatrix: function ( m ) {

    // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

    this.quaternion.setFromRotationMatrix( m );

  },

  setRotationFromQuaternion: function ( q ) {

    // assumes q is normalized

    this.quaternion.copy( q );

  },

  rotateOnAxis: function () {

    // rotate object on axis in object space
    // axis is assumed to be normalized

    var q1 = new THREE.Quaternion();

    return function ( axis, angle ) {

      q1.setFromAxisAngle( axis, angle );

      this.quaternion.multiply( q1 );

      return this;

    }

  }(),

  rotateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  rotateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( angle ) {

      return this.rotateOnAxis( v1, angle );

    };

  }(),

  translateOnAxis: function () {

    // translate object by distance along axis in object space
    // axis is assumed to be normalized

    var v1 = new THREE.Vector3();

    return function ( axis, distance ) {

      v1.copy( axis ).applyQuaternion( this.quaternion );

      this.position.add( v1.multiplyScalar( distance ) );

      return this;

    }

  }(),

  translate: function ( distance, axis ) {

    console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
    return this.translateOnAxis( axis, distance );

  },

  translateX: function () {

    var v1 = new THREE.Vector3( 1, 0, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateY: function () {

    var v1 = new THREE.Vector3( 0, 1, 0 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  translateZ: function () {

    var v1 = new THREE.Vector3( 0, 0, 1 );

    return function ( distance ) {

      return this.translateOnAxis( v1, distance );

    };

  }(),

  localToWorld: function ( vector ) {

    return vector.applyMatrix4( this.matrixWorld );

  },

  worldToLocal: function () {

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

    };

  }(),

  lookAt: function () {

    // This routine does not support objects with rotated and/or translated parent(s)

    var m1 = new THREE.Matrix4();

    return function ( vector ) {

      m1.lookAt( vector, this.position, this.up );

      this.quaternion.setFromRotationMatrix( m1 );

    };

  }(),

  add: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i ++ ) {

        this.add( arguments[ i ] );

      }

      return this;

    }

    if ( object === this ) {

      console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
      return this;

    }

    if ( object instanceof THREE.Object3D ) {

      if ( object.parent !== undefined ) {

        object.parent.remove( object );

      }

      object.parent = this;
      object.dispatchEvent( { type: 'added' } );

      this.children.push( object );

    } else {

      console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

    }

    return this;

  },

  remove: function ( object ) {

    if ( arguments.length > 1 ) {

      for ( var i = 0; i < arguments.length; i ++ ) {

        this.remove( arguments[ i ] );

      }

    }

    var index = this.children.indexOf( object );

    if ( index !== - 1 ) {

      object.parent = undefined;

      object.dispatchEvent( { type: 'removed' } );

      this.children.splice( index, 1 );

    }

  },

  getChildByName: function ( name ) {

    console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
    return this.getObjectByName( name );

  },

  getObjectById: function ( id ) {

    return this.getObjectByProperty( 'id', id );

  },

  getObjectByName: function ( name ) {

    return this.getObjectByProperty( 'name', name );

  },

  getObjectByProperty: function ( name, value ) {

    if ( this[ name ] === value ) return this;

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      var child = this.children[ i ];
      var object = child.getObjectByProperty( name, value );

      if ( object !== undefined ) {

        return object;

      }

    }

    return undefined;

  },

  getWorldPosition: function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.updateMatrixWorld( true );

    return result.setFromMatrixPosition( this.matrixWorld );

  },

  getWorldQuaternion: function () {

    var position = new THREE.Vector3();
    var scale = new THREE.Vector3();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Quaternion();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, result, scale );

      return result;

    }

  }(),

  getWorldRotation: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Euler();

      this.getWorldQuaternion( quaternion );

      return result.setFromQuaternion( quaternion, this.rotation.order, false );

    }

  }(),

  getWorldScale: function () {

    var position = new THREE.Vector3();
    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.updateMatrixWorld( true );

      this.matrixWorld.decompose( position, quaternion, result );

      return result;

    }

  }(),

  getWorldDirection: function () {

    var quaternion = new THREE.Quaternion();

    return function ( optionalTarget ) {

      var result = optionalTarget || new THREE.Vector3();

      this.getWorldQuaternion( quaternion );

      return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

    }

  }(),

  raycast: function () {},

  traverse: function ( callback ) {

    callback( this );

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].traverse( callback );

    }

  },

  traverseVisible: function ( callback ) {

    if ( this.visible === false ) return;

    callback( this );

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].traverseVisible( callback );

    }

  },

  traverseAncestors: function ( callback ) {

    if ( this.parent ) {

      callback( this.parent );

      this.parent.traverseAncestors( callback );

    }

  },

  updateMatrix: function () {

    this.matrix.compose( this.position, this.quaternion, this.scale );

    this.matrixWorldNeedsUpdate = true;

  },

  updateMatrixWorld: function ( force ) {

    if ( this.matrixAutoUpdate === true ) this.updateMatrix();

    if ( this.matrixWorldNeedsUpdate === true || force === true ) {

      if ( this.parent === undefined ) {

        this.matrixWorld.copy( this.matrix );

      } else {

        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

      }

      this.matrixWorldNeedsUpdate = false;

      force = true;

    }

    // update children

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].updateMatrixWorld( force );

    }

  },

  toJSON: function ( meta ) {

    var isRootObject = ( meta === undefined );

    var data = {};

    // meta is a hash used to collect geometries, materials.
    // not providing it implies that this is the root object
    // being serialized.
    if ( isRootObject ) {

      // initialize meta obj
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {}
      };

      data.metadata = {
        version: 4.4,
        type: 'Object',
        generator: 'Object3D.toJSON'
      };

    }

    // standard Object3D serialization

    data.uuid = this.uuid;
    data.type = this.type;

    if ( this.name !== '' ) data.name = this.name;
    if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
    if ( this.visible !== true ) data.visible = this.visible;

    data.matrix = this.matrix.toArray();

    if ( this.children.length > 0 ) {

      data.children = [];

      for ( var i = 0; i < this.children.length; i ++ ) {

        data.children.push( this.children[ i ].toJSON( meta ).object );

      }

    }

    var output = {};

    if ( isRootObject ) {

      var geometries = extractFromCache( meta.geometries );
      var materials = extractFromCache( meta.materials );
      var textures = extractFromCache( meta.textures );
      var images = extractFromCache( meta.images );

      if ( geometries.length > 0 ) output.geometries = geometries;
      if ( materials.length > 0 ) output.materials = materials;
      if ( textures.length > 0 ) output.textures = textures;
      if ( images.length > 0 ) output.images = images;

    }

    output.object = data;

    return output;

    // extract data from the cache hash
    // remove metadata on each item
    // and return as array
    function extractFromCache ( cache ) {
      var values = [];
      for ( var key in cache ) {
        var data = cache[ key ];
        delete data.metadata;
        values.push( data );
      }
      return values;
    }

  },

  clone: function ( object, recursive ) {

    if ( object === undefined ) object = new THREE.Object3D();
    if ( recursive === undefined ) recursive = true;

    object.name = this.name;

    object.up.copy( this.up );

    object.position.copy( this.position );
    object.quaternion.copy( this.quaternion );
    object.scale.copy( this.scale );

    object.rotationAutoUpdate = this.rotationAutoUpdate;

    object.matrix.copy( this.matrix );
    object.matrixWorld.copy( this.matrixWorld );

    object.matrixAutoUpdate = this.matrixAutoUpdate;
    object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

    object.visible = this.visible;

    object.castShadow = this.castShadow;
    object.receiveShadow = this.receiveShadow;

    object.frustumCulled = this.frustumCulled;
    object.renderOrder = this.renderOrder;

    object.userData = JSON.parse( JSON.stringify( this.userData ) );

    if ( recursive === true ) {

      for ( var i = 0; i < this.children.length; i ++ ) {

        var child = this.children[ i ];
        object.add( child.clone() );

      }

    }

    return object;

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color ) {

  this.a = a;
  this.b = b;
  this.c = c;

  this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
  this.vertexNormals = Array.isArray( normal ) ? normal : [];

  this.color = color instanceof THREE.Color ? color : new THREE.Color();
  this.vertexColors = Array.isArray( color ) ? color : [];

  this.vertexTangents = [];

};

THREE.Face3.prototype = {

  constructor: THREE.Face3,

  clone: function () {

    var face = new THREE.Face3( this.a, this.b, this.c );

    face.normal.copy( this.normal );
    face.color.copy( this.color );

    for ( var i = 0, il = this.vertexNormals.length; i < il; i ++ ) {

      face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();

    }

    for ( var i = 0, il = this.vertexColors.length; i < il; i ++ ) {

      face.vertexColors[ i ] = this.vertexColors[ i ].clone();

    }

    for ( var i = 0, il = this.vertexTangents.length; i < il; i ++ ) {

      face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

    }

    return face;

  }

};

// File:src/core/Face4.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

  console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
  return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize ) {

  this.array = array;
  this.itemSize = itemSize;

  this.needsUpdate = false;

};

THREE.BufferAttribute.prototype = {

  constructor: THREE.BufferAttribute,

  get length () {

    console.warn( 'THREE.BufferAttribute: .length has been renamed to .count.' );
    return this.count;

  },

  get count() {

    return this.array.length / this.itemSize;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.itemSize;
    index2 *= attribute.itemSize;

    for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

    return this;

  },

  copyArray: function ( array ) {

    this.array.set( array );

    return this;

  },

  copyColorsArray: function ( colors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = colors.length; i < l; i ++ ) {

      var color = colors[ i ];

      if ( color === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
        color = new THREE.Color();

      }

      array[ offset ++ ] = color.r;
      array[ offset ++ ] = color.g;
      array[ offset ++ ] = color.b;

    }

    return this;

  },

  copyIndicesArray: function ( indices ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = indices.length; i < l; i ++ ) {

      var index = indices[ i ];

      array[ offset ++ ] = index.a;
      array[ offset ++ ] = index.b;
      array[ offset ++ ] = index.c;

    }

    return this;

  },

  copyVector2sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
        vector = new THREE.Vector2();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;

    }

    return this;

  },

  copyVector3sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
        vector = new THREE.Vector3();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;
      array[ offset ++ ] = vector.z;

    }

    return this;

  },

  copyVector4sArray: function ( vectors ) {

    var array = this.array, offset = 0;

    for ( var i = 0, l = vectors.length; i < l; i ++ ) {

      var vector = vectors[ i ];

      if ( vector === undefined ) {

        console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
        vector = new THREE.Vector4();

      }

      array[ offset ++ ] = vector.x;
      array[ offset ++ ] = vector.y;
      array[ offset ++ ] = vector.z;
      array[ offset ++ ] = vector.w;

    }

    return this;

  },

  set: function ( value, offset ) {

    if ( offset === undefined ) offset = 0;

    this.array.set( value, offset );

    return this;

  },

  getX: function ( index ) {

    return this.array[ index * this.itemSize ];

  },

  setX: function ( index, x ) {

    this.array[ index * this.itemSize ] = x;

    return this;

  },

  getY: function ( index ) {

    return this.array[ index * this.itemSize + 1 ];

  },

  setY: function ( index, y ) {

    this.array[ index * this.itemSize + 1 ] = y;

    return this;

  },

  getZ: function ( index ) {

    return this.array[ index * this.itemSize + 2 ];

  },

  setZ: function ( index, z ) {

    this.array[ index * this.itemSize + 2 ] = z;

    return this;

  },

  getW: function ( index ) {

    return this.array[ index * this.itemSize + 3 ];

  },

  setW: function ( index, w ) {

    this.array[ index * this.itemSize + 3 ] = w;

    return this;

  },

  setXY: function ( index, x, y ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index *= this.itemSize;

    this.array[ index + 0 ] = x;
    this.array[ index + 1 ] = y;
    this.array[ index + 2 ] = z;
    this.array[ index + 3 ] = w;

    return this;

  },

  clone: function () {

    return new THREE.BufferAttribute( new this.array.constructor( this.array ), this.itemSize );

  }

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

  return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};

// File:src/core/DynamicBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

  THREE.BufferAttribute.call( this, array, itemSize );

  this.updateRange = { offset: 0, count: -1 };

};

THREE.DynamicBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.DynamicBufferAttribute.prototype.constructor = THREE.DynamicBufferAttribute;

THREE.DynamicBufferAttribute.prototype.clone = function () {

  return new THREE.DynamicBufferAttribute( new this.array.constructor( this.array ), this.itemSize );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function (array, itemSize, meshPerAttribute, dynamic) {

  THREE.DynamicBufferAttribute.call( this, array, itemSize );

  this.dynamic = dynamic || false;
  this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.DynamicBufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.clone = function () {

  return new THREE.InstancedBufferAttribute( new this.array.constructor( this.array ), this.itemSize, this.meshPerAttribute, this.dynamic );

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride, dynamic ) {

  this.array = array;
  this.stride = stride;

  this.needsUpdate = false;

  this.dynamic = dynamic || false;
  this.updateRange = { offset: 0, count: -1 };

};

THREE.InterleavedBuffer.prototype = {

  constructor: THREE.InterleavedBuffer,

  get length () {

    return this.array.length;

  },

  copyAt: function ( index1, attribute, index2 ) {

    index1 *= this.stride;
    index2 *= attribute.stride;

    for ( var i = 0, l = this.stride; i < l; i++ ) {

      this.array[ index1 + i ] = attribute.array[ index2 + i ];

    }

    return this;

  },

  set: function ( value, offset ) {

    if ( offset === undefined ) offset = 0;

    this.array.set( value, offset );

    return this;

  },

  clone: function () {

    return new THREE.InterleavedBuffer( new this.array.constructor( this.array ), this.stride, this.dynamic );

  }

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, dynamic, meshPerAttribute ) {

  THREE.InterleavedBuffer.call( this, array, stride, dynamic );

  this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.clone = function () {

  return new THREE.InstancedInterleavedBuffer( new this.array.constructor( this.array ), this.stride, this.dynamic, this.meshPerAttribute );

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

  this.data = interleavedBuffer;
  this.itemSize = itemSize;
  this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

  constructor: THREE.InterleavedBufferAttribute,

  get length() {

    console.warn( 'THREE.InterleavedBufferAttribute: .length has been renamed to .count.' );
    return this.count;

  },

  get count() {

    return this.data.array.length / this.data.stride;

  },

  setX: function ( index, x ) {

    this.data.array[ index * this.data.stride + this.offset ] = x;

    return this;

  },

  setY: function ( index, y ) {

    this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

    return this;

  },

  setZ: function ( index, z ) {

    this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

    return this;

  },

  setW: function ( index, w ) {

    this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

    return this;

  },

  getX: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset ];

  },

  getY: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 1 ];

  },

  getZ: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 2 ];

  },

  getW: function ( index ) {

    return this.data.array[ index * this.data.stride + this.offset + 3 ];

  },

  setXY: function ( index, x, y ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;

    return this;

  },

  setXYZ: function ( index, x, y, z ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;
    this.data.array[ index + 2 ] = z;

    return this;

  },

  setXYZW: function ( index, x, y, z, w ) {

    index = index * this.data.stride + this.offset;

    this.data.array[ index + 0 ] = x;
    this.data.array[ index + 1 ] = y;
    this.data.array[ index + 2 ] = z;
    this.data.array[ index + 3 ] = w;

    return this;

  }

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Geometry';

  this.vertices = [];
  this.colors = [];
  this.faces = [];
  this.faceVertexUvs = [ [] ];

  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];

  this.skinWeights = [];
  this.skinIndices = [];

  this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  this.hasTangents = false;

  // update flags

  this.verticesNeedUpdate = false;
  this.elementsNeedUpdate = false;
  this.uvsNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.tangentsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.lineDistancesNeedUpdate = false;

  this.groupsNeedUpdate = false;

};

THREE.Geometry.prototype = {

  constructor: THREE.Geometry,

  applyMatrix: function ( matrix ) {

    var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

      var vertex = this.vertices[ i ];
      vertex.applyMatrix4( matrix );

    }

    for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

      var face = this.faces[ i ];
      face.normal.applyMatrix3( normalMatrix ).normalize();

      for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

        face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

      }

    }

    if ( this.boundingBox !== null ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere !== null ) {

      this.computeBoundingSphere();

    }

    this.verticesNeedUpdate = true;
    this.normalsNeedUpdate = true;

  },

  fromBufferGeometry: function ( geometry ) {

    var scope = this;

    var attributes = geometry.attributes;

    var vertices = attributes.position.array;
    var indices = attributes.index !== undefined ? attributes.index.array : undefined;
    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;

    var tempNormals = [];
    var tempUVs = [];

    for ( var i = 0, j = 0; i < vertices.length; i += 3, j += 2 ) {

      scope.vertices.push( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

      if ( normals !== undefined ) {

        tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

      }

      if ( colors !== undefined ) {

        scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

      }

      if ( uvs !== undefined ) {

        tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

      }

    }

    var addFace = function ( a, b, c ) {

      var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
      var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

      scope.faces.push( new THREE.Face3( a, b, c, vertexNormals, vertexColors ) );

      if ( uvs !== undefined ) {

        scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

      }

    };

    if ( indices !== undefined ) {

      var drawcalls = geometry.drawcalls;

      if ( drawcalls.length > 0 ) {

        for ( var i = 0; i < drawcalls.length; i ++ ) {

          var drawcall = drawcalls[ i ];

          var start = drawcall.start;
          var count = drawcall.count;
          var index = drawcall.index;

          for ( var j = start, jl = start + count; j < jl; j += 3 ) {

            addFace( index + indices[ j ], index + indices[ j + 1 ], index + indices[ j + 2 ] );

          }

        }

      } else {

        for ( var i = 0; i < indices.length; i += 3 ) {

          addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

        }

      }

    } else {

      for ( var i = 0; i < vertices.length / 3; i += 3 ) {

        addFace( i, i + 1, i + 2 );

      }

    }

    this.computeFaceNormals();

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    return this;

  },

  center: function () {

    this.computeBoundingBox();

    var offset = this.boundingBox.center().negate();

    this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );

    return offset;

  },

  normalize: function () {

    this.computeBoundingSphere();

    var center = this.boundingSphere.center;
    var radius = this.boundingSphere.radius;

    var s = radius === 0 ? 1 : 1.0 / radius;

    var matrix = new THREE.Matrix4();
    matrix.set(
      s, 0, 0, -s * center.x,
      0, s, 0, -s * center.y,
      0, 0, s, -s * center.z,
      0, 0, 0, 1
    );

    this.applyMatrix( matrix );

    return this;
  },

  computeFaceNormals: function () {

    var cb = new THREE.Vector3(), ab = new THREE.Vector3();

    for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

      var face = this.faces[ f ];

      var vA = this.vertices[ face.a ];
      var vB = this.vertices[ face.b ];
      var vC = this.vertices[ face.c ];

      cb.subVectors( vC, vB );
      ab.subVectors( vA, vB );
      cb.cross( ab );

      cb.normalize();

      face.normal.copy( cb );

    }

  },

  computeVertexNormals: function ( areaWeighted ) {

    var v, vl, f, fl, face, vertices;

    vertices = new Array( this.vertices.length );

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ] = new THREE.Vector3();

    }

    if ( areaWeighted ) {

      // vertex normals weighted by triangle areas
      // http://www.iquilezles.org/www/articles/normals/normals.htm

      var vA, vB, vC;
      var cb = new THREE.Vector3(), ab = new THREE.Vector3();

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vA = this.vertices[ face.a ];
        vB = this.vertices[ face.b ];
        vC = this.vertices[ face.c ];

        cb.subVectors( vC, vB );
        ab.subVectors( vA, vB );
        cb.cross( ab );

        vertices[ face.a ].add( cb );
        vertices[ face.b ].add( cb );
        vertices[ face.c ].add( cb );

      }

    } else {

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        vertices[ face.a ].add( face.normal );
        vertices[ face.b ].add( face.normal );
        vertices[ face.c ].add( face.normal );

      }

    }

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      vertices[ v ].normalize();

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      var vertexNormals = face.vertexNormals;

      if ( vertexNormals.length === 3 ) {

        vertexNormals[ 0 ].copy( vertices[ face.a ] );
        vertexNormals[ 1 ].copy( vertices[ face.b ] );
        vertexNormals[ 2 ].copy( vertices[ face.c ] );

      } else {

        vertexNormals[ 0 ] = vertices[ face.a ].clone();
        vertexNormals[ 1 ] = vertices[ face.b ].clone();
        vertexNormals[ 2 ] = vertices[ face.c ].clone();

      }

    }

  },

  computeMorphNormals: function () {

    var i, il, f, fl, face;

    // save original normals
    // - create temp variables on first access
    //   otherwise just copy (for faster repeated calls)

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      if ( ! face.__originalFaceNormal ) {

        face.__originalFaceNormal = face.normal.clone();

      } else {

        face.__originalFaceNormal.copy( face.normal );

      }

      if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

      for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

        if ( ! face.__originalVertexNormals[ i ] ) {

          face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

        } else {

          face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

        }

      }

    }

    // use temp geometry to compute face and vertex normals for each morph

    var tmpGeo = new THREE.Geometry();
    tmpGeo.faces = this.faces;

    for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

      // create on first access

      if ( ! this.morphNormals[ i ] ) {

        this.morphNormals[ i ] = {};
        this.morphNormals[ i ].faceNormals = [];
        this.morphNormals[ i ].vertexNormals = [];

        var dstNormalsFace = this.morphNormals[ i ].faceNormals;
        var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

        var faceNormal, vertexNormals;

        for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

          faceNormal = new THREE.Vector3();
          vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

          dstNormalsFace.push( faceNormal );
          dstNormalsVertex.push( vertexNormals );

        }

      }

      var morphNormals = this.morphNormals[ i ];

      // set vertices to morph target

      tmpGeo.vertices = this.morphTargets[ i ].vertices;

      // compute morph normals

      tmpGeo.computeFaceNormals();
      tmpGeo.computeVertexNormals();

      // store morph normals

      var faceNormal, vertexNormals;

      for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

        face = this.faces[ f ];

        faceNormal = morphNormals.faceNormals[ f ];
        vertexNormals = morphNormals.vertexNormals[ f ];

        faceNormal.copy( face.normal );

        vertexNormals.a.copy( face.vertexNormals[ 0 ] );
        vertexNormals.b.copy( face.vertexNormals[ 1 ] );
        vertexNormals.c.copy( face.vertexNormals[ 2 ] );

      }

    }

    // restore original normals

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      face.normal = face.__originalFaceNormal;
      face.vertexNormals = face.__originalVertexNormals;

    }

  },

  computeTangents: function () {

    // based on http://www.terathon.com/code/tangent.html
    // tangents go to vertices

    var f, fl, v, vl, i, vertexIndex,
      face, uv, vA, vB, vC, uvA, uvB, uvC,
      x1, x2, y1, y2, z1, z2,
      s1, s2, t1, t2, r, t, test,
      tan1 = [], tan2 = [],
      sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
      tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
      n = new THREE.Vector3(), w;

    for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

      tan1[ v ] = new THREE.Vector3();
      tan2[ v ] = new THREE.Vector3();

    }

    function handleTriangle( context, a, b, c, ua, ub, uc ) {

      vA = context.vertices[ a ];
      vB = context.vertices[ b ];
      vC = context.vertices[ c ];

      uvA = uv[ ua ];
      uvB = uv[ ub ];
      uvC = uv[ uc ];

      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;
      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;
      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;

      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;
      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;

      r = 1.0 / ( s1 * t2 - s2 * t1 );
      sdir.set( ( t2 * x1 - t1 * x2 ) * r,
            ( t2 * y1 - t1 * y2 ) * r,
            ( t2 * z1 - t1 * z2 ) * r );
      tdir.set( ( s1 * x2 - s2 * x1 ) * r,
            ( s1 * y2 - s2 * y1 ) * r,
            ( s1 * z2 - s2 * z1 ) * r );

      tan1[ a ].add( sdir );
      tan1[ b ].add( sdir );
      tan1[ c ].add( sdir );

      tan2[ a ].add( tdir );
      tan2[ b ].add( tdir );
      tan2[ c ].add( tdir );

    }

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];
      uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

      handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

    }

    var faceIndex = [ 'a', 'b', 'c', 'd' ];

    for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

      face = this.faces[ f ];

      for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i ++ ) {

        n.copy( face.vertexNormals[ i ] );

        vertexIndex = face[ faceIndex[ i ] ];

        t = tan1[ vertexIndex ];

        // Gram-Schmidt orthogonalize

        tmp.copy( t );
        tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

        // Calculate handedness

        tmp2.crossVectors( face.vertexNormals[ i ], t );
        test = tmp2.dot( tan2[ vertexIndex ] );
        w = ( test < 0.0 ) ? - 1.0 : 1.0;

        face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

      }

    }

    this.hasTangents = true;

  },

  computeLineDistances: function () {

    var d = 0;
    var vertices = this.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      if ( i > 0 ) {

        d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

      }

      this.lineDistances[ i ] = d;

    }

  },

  computeBoundingBox: function () {

    if ( this.boundingBox === null ) {

      this.boundingBox = new THREE.Box3();

    }

    this.boundingBox.setFromPoints( this.vertices );

  },

  computeBoundingSphere: function () {

    if ( this.boundingSphere === null ) {

      this.boundingSphere = new THREE.Sphere();

    }

    this.boundingSphere.setFromPoints( this.vertices );

  },

  merge: function ( geometry, matrix ) {

    if ( geometry instanceof THREE.Geometry === false ) {

      console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
      return;

    }

    var normalMatrix,
    vertexOffset = this.vertices.length,
    vertices1 = this.vertices,
    vertices2 = geometry.vertices,
    faces1 = this.faces,
    faces2 = geometry.faces,
    uvs1 = this.faceVertexUvs[ 0 ],
    uvs2 = geometry.faceVertexUvs[ 0 ];

    if ( matrix !== undefined ) {

      normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

    }

    // vertices

    for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

      var vertex = vertices2[ i ];

      var vertexCopy = vertex.clone();

      if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

      vertices1.push( vertexCopy );

    }

    // faces

    for ( i = 0, il = faces2.length; i < il; i ++ ) {

      var face = faces2[ i ], faceCopy, normal, color,
      faceVertexNormals = face.vertexNormals,
      faceVertexColors = face.vertexColors;

      faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
      faceCopy.normal.copy( face.normal );

      if ( normalMatrix !== undefined ) {

        faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

      }

      for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

        normal = faceVertexNormals[ j ].clone();

        if ( normalMatrix !== undefined ) {

          normal.applyMatrix3( normalMatrix ).normalize();

        }

        faceCopy.vertexNormals.push( normal );

      }

      faceCopy.color.copy( face.color );

      for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

        color = faceVertexColors[ j ];
        faceCopy.vertexColors.push( color.clone() );

      }

      faces1.push( faceCopy );

    }

    // uvs

    for ( i = 0, il = uvs2.length; i < il; i ++ ) {

      var uv = uvs2[ i ], uvCopy = [];

      if ( uv === undefined ) {

        continue;

      }

      for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

        uvCopy.push( uv[ j ].clone() );

      }

      uvs1.push( uvCopy );

    }

  },

  mergeMesh: function ( mesh ) {

    if ( mesh instanceof THREE.Mesh === false ) {

      console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
      return;

    }

    mesh.matrixAutoUpdate && mesh.updateMatrix();

    this.merge( mesh.geometry, mesh.matrix );

  },

  /*
   * Checks for duplicate vertices with hashmap.
   * Duplicated vertices are removed
   * and faces' vertices are updated.
   */

  mergeVertices: function () {

    var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
    var unique = [], changes = [];

    var v, key;
    var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
    var precision = Math.pow( 10, precisionPoints );
    var i, il, face;
    var indices, j, jl;

    for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

      v = this.vertices[ i ];
      key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

      if ( verticesMap[ key ] === undefined ) {

        verticesMap[ key ] = i;
        unique.push( this.vertices[ i ] );
        changes[ i ] = unique.length - 1;

      } else {

        //console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
        changes[ i ] = changes[ verticesMap[ key ] ];

      }

    }


    // if faces are completely degenerate after merging vertices, we
    // have to remove them from the geometry.
    var faceIndicesToRemove = [];

    for ( i = 0, il = this.faces.length; i < il; i ++ ) {

      face = this.faces[ i ];

      face.a = changes[ face.a ];
      face.b = changes[ face.b ];
      face.c = changes[ face.c ];

      indices = [ face.a, face.b, face.c ];

      var dupIndex = - 1;

      // if any duplicate vertices are found in a Face3
      // we have to remove the face as nothing can be saved
      for ( var n = 0; n < 3; n ++ ) {
        if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

          dupIndex = n;
          faceIndicesToRemove.push( i );
          break;

        }
      }

    }

    for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
      var idx = faceIndicesToRemove[ i ];

      this.faces.splice( idx, 1 );

      for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

        this.faceVertexUvs[ j ].splice( idx, 1 );

      }

    }

    // Use unique set of vertices

    var diff = this.vertices.length - unique.length;
    this.vertices = unique;
    return diff;

  },

  toJSON: function () {

    var data = {
      metadata: {
        version: 4.4,
        type: 'Geometry',
        generator: 'Geometry.toJSON'
      }
    };

    // standard Geometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

      }

      return data;

    }

    var vertices = [];

    for ( var i = 0; i < this.vertices.length; i ++ ) {

      var vertex = this.vertices[ i ];
      vertices.push( vertex.x, vertex.y, vertex.z );

    }

    var faces = [];
    var normals = [];
    var normalsHash = {};
    var colors = [];
    var colorsHash = {};
    var uvs = [];
    var uvsHash = {};

    for ( var i = 0; i < this.faces.length; i ++ ) {

      var face = this.faces[ i ];

      var hasMaterial = false; // face.materialIndex !== undefined;
      var hasFaceUv = false; // deprecated
      var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
      var hasFaceNormal = face.normal.length() > 0;
      var hasFaceVertexNormal = face.vertexNormals.length > 0;
      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
      var hasFaceVertexColor = face.vertexColors.length > 0;

      var faceType = 0;

      faceType = setBit( faceType, 0, 0 );
      faceType = setBit( faceType, 1, hasMaterial );
      faceType = setBit( faceType, 2, hasFaceUv );
      faceType = setBit( faceType, 3, hasFaceVertexUv );
      faceType = setBit( faceType, 4, hasFaceNormal );
      faceType = setBit( faceType, 5, hasFaceVertexNormal );
      faceType = setBit( faceType, 6, hasFaceColor );
      faceType = setBit( faceType, 7, hasFaceVertexColor );

      faces.push( faceType );
      faces.push( face.a, face.b, face.c );

      if ( hasFaceVertexUv ) {

        var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

        faces.push(
          getUvIndex( faceVertexUvs[ 0 ] ),
          getUvIndex( faceVertexUvs[ 1 ] ),
          getUvIndex( faceVertexUvs[ 2 ] )
        );

      }

      if ( hasFaceNormal ) {

        faces.push( getNormalIndex( face.normal ) );

      }

      if ( hasFaceVertexNormal ) {

        var vertexNormals = face.vertexNormals;

        faces.push(
          getNormalIndex( vertexNormals[ 0 ] ),
          getNormalIndex( vertexNormals[ 1 ] ),
          getNormalIndex( vertexNormals[ 2 ] )
        );

      }

      if ( hasFaceColor ) {

        faces.push( getColorIndex( face.color ) );

      }

      if ( hasFaceVertexColor ) {

        var vertexColors = face.vertexColors;

        faces.push(
          getColorIndex( vertexColors[ 0 ] ),
          getColorIndex( vertexColors[ 1 ] ),
          getColorIndex( vertexColors[ 2 ] )
        );

      }

    }

    function setBit( value, position, enabled ) {

      return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position) );

    }

    function getNormalIndex( normal ) {

      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

      if ( normalsHash[ hash ] !== undefined ) {

        return normalsHash[ hash ];

      }

      normalsHash[ hash ] = normals.length / 3;
      normals.push( normal.x, normal.y, normal.z );

      return normalsHash[ hash ];

    }

    function getColorIndex( color ) {

      var hash = color.r.toString() + color.g.toString() + color.b.toString();

      if ( colorsHash[ hash ] !== undefined ) {

        return colorsHash[ hash ];

      }

      colorsHash[ hash ] = colors.length;
      colors.push( color.getHex() );

      return colorsHash[ hash ];

    }

    function getUvIndex( uv ) {

      var hash = uv.x.toString() + uv.y.toString();

      if ( uvsHash[ hash ] !== undefined ) {

        return uvsHash[ hash ];

      }

      uvsHash[ hash ] = uvs.length / 2;
      uvs.push( uv.x, uv.y );

      return uvsHash[ hash ];

    }

    data.data = {};

    data.data.vertices = vertices;
    data.data.normals = normals;
    if ( colors.length > 0 ) data.data.colors = colors;
    if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
    data.data.faces = faces;

    return data;

  },

  clone: function () {

    var geometry = new THREE.Geometry();

    var vertices = this.vertices;

    for ( var i = 0, il = vertices.length; i < il; i ++ ) {

      geometry.vertices.push( vertices[ i ].clone() );

    }

    var faces = this.faces;

    for ( var i = 0, il = faces.length; i < il; i ++ ) {

      geometry.faces.push( faces[ i ].clone() );

    }

    for ( var i = 0, il = this.faceVertexUvs.length; i < il; i ++ ) {

      var faceVertexUvs = this.faceVertexUvs[ i ];

      if ( geometry.faceVertexUvs[ i ] === undefined ) {

        geometry.faceVertexUvs[ i ] = [];

      }

      for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

        var uvs = faceVertexUvs[ j ], uvsCopy = [];

        for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

          var uv = uvs[ k ];

          uvsCopy.push( uv.clone() );

        }

        geometry.faceVertexUvs[ i ].push( uvsCopy );

      }

    }

    return geometry;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'DirectGeometry';

  this.indices = [];
  this.vertices = [];
  this.colors = [];
  this.normals = [];
  this.colors = [];
  this.uvs = [];
  this.uvs2 = [];

  this.morphTargets = [];
  this.morphColors = [];
  this.morphNormals = [];

  this.skinWeights = [];
  this.skinIndices = [];

  // this.lineDistances = [];

  this.boundingBox = null;
  this.boundingSphere = null;

  // update flags

  this.verticesNeedUpdate = false;
  this.normalsNeedUpdate = false;
  this.colorsNeedUpdate = false;
  this.uvsNeedUpdate = false;

};

THREE.DirectGeometry.prototype = {

  constructor: THREE.DirectGeometry,

  computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
  computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

  computeFaceNormals: function () {

    console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );
    return this;

  },

  computeVertexNormals: function () {

    console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );
    return this;

  },

  fromGeometry: function ( geometry, material ) {

    material = material || { 'vertexColors': THREE.NoColors };

    var faces = geometry.faces;
    var vertices = geometry.vertices;
    var faceVertexUvs = geometry.faceVertexUvs;
    var materialVertexColors = material.vertexColors;

    var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
    var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

    // morphs

    var morphTargets = geometry.morphTargets;
    var morphTargetsLength = morphTargets.length;

    for ( var i = 0; i < morphTargetsLength; i ++ ) {

      this.morphTargets[ i ] = [];

    }

    var morphNormals = geometry.morphNormals;
    var morphNormalsLength = morphNormals.length;

    for ( var i = 0; i < morphNormalsLength; i ++ ) {

      this.morphNormals[ i ] = [];

    }

    var morphColors = geometry.morphColors;
    var morphColorsLength = morphColors.length;

    for ( var i = 0; i < morphColorsLength; i ++ ) {

      this.morphColors[ i ] = [];

    }

    // skins

    var skinIndices = geometry.skinIndices;
    var skinWeights = geometry.skinWeights;

    var hasSkinIndices = skinIndices.length === vertices.length;
    var hasSkinWeights = skinWeights.length === vertices.length;

    //

    for ( var i = 0; i < faces.length; i ++ ) {

      var face = faces[ i ];

      this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

      var vertexNormals = face.vertexNormals;

      if ( vertexNormals.length === 3 ) {

        this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

      } else {

        var normal = face.normal;

        this.normals.push( normal, normal, normal );

      }

      var vertexColors = face.vertexColors;

      if ( materialVertexColors === THREE.VertexColors ) {

        this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

      } else if ( materialVertexColors === THREE.FaceColors ) {

        var color = face.color;

        this.colors.push( color, color, color );

      }

      if ( hasFaceVertexUv === true ) {

        var vertexUvs = faceVertexUvs[ 0 ][ i ];

        if ( vertexUvs !== undefined ) {

          this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

        } else {

          console.warn( 'THREE.BufferGeometry.fromGeometry(): Undefined vertexUv', i );

          this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

        }

      }

      if ( hasFaceVertexUv2 === true ) {

        var vertexUvs = faceVertexUvs[ 1 ][ i ];

        if ( vertexUvs !== undefined ) {

          this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

        } else {

          console.warn( 'THREE.BufferGeometry.fromGeometry(): Undefined vertexUv2', i );

          this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

        }

      }

      // morphs

      for ( var j = 0; j < morphTargetsLength; j ++ ) {

        var morphTarget = morphTargets[ j ].vertices;

        this.morphTargets[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

      }
      /*
      for ( var j = 0; j < morphNormalsLength; j ++ ) {

        var morphNormal = morphNormals[ j ].vertexNormals[ i ];

        this.morphNormals[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

      }

      for ( var j = 0; j < morphColorsLength; j ++ ) {

        var morphColor = morphColors[ j ].colors;

        this.morphColors[ j ].push( morphColor[ face.a ], morphColor[ face.b ], morphColor[ face.c ] );

      }
      */

      // skins

      if ( hasSkinIndices ) {

        this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

      }

      if ( hasSkinWeights ) {

        this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

      }

    }

    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
    this.uvsNeedUpdate = geometry.uvsNeedUpdate;

    return this;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.DirectGeometry.prototype );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

  Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'BufferGeometry';

  this.attributes = {};

  this.morphAttributes = [];

  this.drawcalls = [];
  this.offsets = this.drawcalls; // backwards compatibility

  this.boundingBox = null;
  this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

  constructor: THREE.BufferGeometry,

  addAttribute: function ( name, attribute ) {

    if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

      console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

      this.attributes[ name ] = { array: arguments[ 1 ], itemSize: arguments[ 2 ] };

      return;

    }

    this.attributes[ name ] = attribute;

  },

  getAttribute: function ( name ) {

    return this.attributes[ name ];

  },

  addDrawCall: function ( start, count, indexOffset ) {

    this.drawcalls.push( {

      start: start,
      count: count,
      index: indexOffset !== undefined ? indexOffset : 0

    } );

  },

  applyMatrix: function ( matrix ) {

    var position = this.attributes.position;

    if ( position !== undefined ) {

      matrix.applyToVector3Array( position.array );
      position.needsUpdate = true;

    }

    var normal = this.attributes.normal;

    if ( normal !== undefined ) {

      var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

      normalMatrix.applyToVector3Array( normal.array );
      normal.needsUpdate = true;

    }

    if ( this.boundingBox !== null ) {

      this.computeBoundingBox();

    }

    if ( this.boundingSphere !== null ) {

      this.computeBoundingSphere();

    }

  },

  copy: function ( geometry ) {

    var attributes = geometry.attributes;
    var offsets = geometry.offsets;

    for ( var name in attributes ) {

      var attribute = attributes[ name ];

      this.addAttribute( name, attribute.clone() );

    }

    for ( var i = 0, il = offsets.length; i < il; i ++ ) {

      var offset = offsets[ i ];

      this.offsets.push( {

        start: offset.start,
        index: offset.index,
        count: offset.count

      } );

    }

    return this;

  },

  center: function () {

    this.computeBoundingBox();

    var offset = this.boundingBox.center().negate();

    this.applyMatrix( new THREE.Matrix4().setPosition( offset ) );

    return offset;

  },

  setFromObject: function ( object ) {

    console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

    var geometry = object.geometry;
    var material = object.material;

    if ( object instanceof THREE.PointCloud || object instanceof THREE.Line ) {

      var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
      var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

      this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
      this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

      if ( geometry.boundingSphere !== null ) {

        this.boundingSphere = geometry.boundingSphere.clone();

      }

      if ( geometry.boundingBox !== null ) {

        this.boundingBox = geometry.boundingBox.clone();

      }

    } else if ( object instanceof THREE.Mesh ) {

      if ( geometry instanceof THREE.Geometry ) {

        this.fromGeometry( geometry );

      }

    }

    return this;

  },

  updateFromObject: function ( object ) {

    var geometry = object.geometry;

    if ( object instanceof THREE.Mesh ) {

      var direct = geometry.__directGeometry;

      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;

      geometry.verticesNeedUpdate = false;
      geometry.normalsNeedUpdate = false;
      geometry.colorsNeedUpdate = false;
      geometry.uvsNeedUpdate = false;

      geometry = direct;

    }

    if ( geometry.verticesNeedUpdate === true ) {

      var attribute = this.attributes.position;

      if ( attribute !== undefined ) {

        attribute.copyVector3sArray( geometry.vertices );
        attribute.needsUpdate = true;

      }

      geometry.verticesNeedUpdate = false;

    }

    if ( geometry.normalsNeedUpdate === true ) {

      var attribute = this.attributes.normal;

      if ( attribute !== undefined ) {

        attribute.copyVector3sArray( geometry.normals );
        attribute.needsUpdate = true;

      }

      geometry.normalsNeedUpdate = false;

    }

    if ( geometry.colorsNeedUpdate === true ) {

      var attribute = this.attributes.color;

      if ( attribute !== undefined ) {

        attribute.copyColorsArray( geometry.colors );
        attribute.needsUpdate = true;

      }

      geometry.colorsNeedUpdate = false;

    }

    return this;

  },

  fromGeometry: function ( geometry, material ) {

    geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry, material );

    return this.fromDirectGeometry( geometry.__directGeometry );

  },

  fromDirectGeometry: function ( geometry ) {

    if ( geometry.indices.length > 0 ) {

      var indices = new Uint16Array( geometry.indices.length * 3 );
      this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

    }

    if ( geometry.vertices.length > 0 ) {

      var positions = new Float32Array( geometry.vertices.length * 3 );
      this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

    }

    if ( geometry.normals.length > 0 ) {

      var normals = new Float32Array( geometry.normals.length * 3 );
      this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

    }

    if ( geometry.colors.length > 0 ) {

      var colors = new Float32Array( geometry.colors.length * 3 );
      this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

    }

    if ( geometry.uvs.length > 0 ) {

      var uvs = new Float32Array( geometry.uvs.length * 2 );
      this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

    }

    // morphs

    if ( geometry.morphTargets.length > 0 ) {

      var morphTargets = geometry.morphTargets;

      for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

        var morphTarget = morphTargets[ i ];

        var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

        this.morphAttributes.push( attribute.copyVector3sArray( morphTarget ) );

      }

      // TODO normals, colors

    }

    // skinning

    if ( geometry.skinIndices.length > 0 ) {

      var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
      this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

    }

    if ( geometry.skinWeights.length > 0 ) {

      var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
      this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

    }

    //

    if ( geometry.boundingSphere !== null ) {

      this.boundingSphere = geometry.boundingSphere.clone();

    }

    if ( geometry.boundingBox !== null ) {

      this.boundingBox = geometry.boundingBox.clone();

    }

    return this;

  },

  computeBoundingBox: function () {

    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingBox === null ) {

        this.boundingBox = new THREE.Box3();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        var bb = this.boundingBox;
        bb.makeEmpty();

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          bb.expandByPoint( vector );

        }

      }

      if ( positions === undefined || positions.length === 0 ) {

        this.boundingBox.min.set( 0, 0, 0 );
        this.boundingBox.max.set( 0, 0, 0 );

      }

      if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

        console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

      }

    };

  }(),

  computeBoundingSphere: function () {

    var box = new THREE.Box3();
    var vector = new THREE.Vector3();

    return function () {

      if ( this.boundingSphere === null ) {

        this.boundingSphere = new THREE.Sphere();

      }

      var positions = this.attributes.position.array;

      if ( positions ) {

        box.makeEmpty();

        var center = this.boundingSphere.center;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          box.expandByPoint( vector );

        }

        box.center( center );

        // hoping to find a boundingSphere with a radius smaller than the
        // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

        var maxRadiusSq = 0;

        for ( var i = 0, il = positions.length; i < il; i += 3 ) {

          vector.fromArray( positions, i );
          maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

        }

        this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

        if ( isNaN( this.boundingSphere.radius ) ) {

          console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

        }

      }

    };

  }(),

  computeFaceNormals: function () {

    // backwards compatibility

  },

  computeVertexNormals: function () {

    var attributes = this.attributes;

    if ( attributes.position ) {

      var positions = attributes.position.array;

      if ( attributes.normal === undefined ) {

        this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

      } else {

        // reset existing normals to zero

        var normals = attributes.normal.array;

        for ( var i = 0, il = normals.length; i < il; i ++ ) {

          normals[ i ] = 0;

        }

      }

      var normals = attributes.normal.array;

      var vA, vB, vC,

      pA = new THREE.Vector3(),
      pB = new THREE.Vector3(),
      pC = new THREE.Vector3(),

      cb = new THREE.Vector3(),
      ab = new THREE.Vector3();

      // indexed elements

      if ( attributes.index ) {

        var indices = attributes.index.array;

        var offsets = ( this.offsets.length > 0 ? this.offsets : [ { start: 0, count: indices.length, index: 0 } ] );

        for ( var j = 0, jl = offsets.length; j < jl; ++ j ) {

          var start = offsets[ j ].start;
          var count = offsets[ j ].count;
          var index = offsets[ j ].index;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            vA = ( index + indices[ i     ] ) * 3;
            vB = ( index + indices[ i + 1 ] ) * 3;
            vC = ( index + indices[ i + 2 ] ) * 3;

            pA.fromArray( positions, vA );
            pB.fromArray( positions, vB );
            pC.fromArray( positions, vC );

            cb.subVectors( pC, pB );
            ab.subVectors( pA, pB );
            cb.cross( ab );

            normals[ vA     ] += cb.x;
            normals[ vA + 1 ] += cb.y;
            normals[ vA + 2 ] += cb.z;

            normals[ vB     ] += cb.x;
            normals[ vB + 1 ] += cb.y;
            normals[ vB + 2 ] += cb.z;

            normals[ vC     ] += cb.x;
            normals[ vC + 1 ] += cb.y;
            normals[ vC + 2 ] += cb.z;

          }

        }

      } else {

        // non-indexed elements (unconnected triangle soup)

        for ( var i = 0, il = positions.length; i < il; i += 9 ) {

          pA.fromArray( positions, i );
          pB.fromArray( positions, i + 3 );
          pC.fromArray( positions, i + 6 );

          cb.subVectors( pC, pB );
          ab.subVectors( pA, pB );
          cb.cross( ab );

          normals[ i     ] = cb.x;
          normals[ i + 1 ] = cb.y;
          normals[ i + 2 ] = cb.z;

          normals[ i + 3 ] = cb.x;
          normals[ i + 4 ] = cb.y;
          normals[ i + 5 ] = cb.z;

          normals[ i + 6 ] = cb.x;
          normals[ i + 7 ] = cb.y;
          normals[ i + 8 ] = cb.z;

        }

      }

      this.normalizeNormals();

      attributes.normal.needsUpdate = true;

    }

  },

  computeTangents: function () {

    // based on http://www.terathon.com/code/tangent.html
    // (per vertex tangents)

    if ( this.attributes.index === undefined ||
       this.attributes.position === undefined ||
       this.attributes.normal === undefined ||
       this.attributes.uv === undefined ) {

      console.warn( 'THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()' );
      return;

    }

    var indices = this.attributes.index.array;
    var positions = this.attributes.position.array;
    var normals = this.attributes.normal.array;
    var uvs = this.attributes.uv.array;

    var nVertices = positions.length / 3;

    if ( this.attributes.tangent === undefined ) {

      this.addAttribute( 'tangent', new THREE.BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

    }

    var tangents = this.attributes.tangent.array;

    var tan1 = [], tan2 = [];

    for ( var k = 0; k < nVertices; k ++ ) {

      tan1[ k ] = new THREE.Vector3();
      tan2[ k ] = new THREE.Vector3();

    }

    var vA = new THREE.Vector3(),
      vB = new THREE.Vector3(),
      vC = new THREE.Vector3(),

      uvA = new THREE.Vector2(),
      uvB = new THREE.Vector2(),
      uvC = new THREE.Vector2(),

      x1, x2, y1, y2, z1, z2,
      s1, s2, t1, t2, r;

    var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

    function handleTriangle( a, b, c ) {

      vA.fromArray( positions, a * 3 );
      vB.fromArray( positions, b * 3 );
      vC.fromArray( positions, c * 3 );

      uvA.fromArray( uvs, a * 2 );
      uvB.fromArray( uvs, b * 2 );
      uvC.fromArray( uvs, c * 2 );

      x1 = vB.x - vA.x;
      x2 = vC.x - vA.x;

      y1 = vB.y - vA.y;
      y2 = vC.y - vA.y;

      z1 = vB.z - vA.z;
      z2 = vC.z - vA.z;

      s1 = uvB.x - uvA.x;
      s2 = uvC.x - uvA.x;

      t1 = uvB.y - uvA.y;
      t2 = uvC.y - uvA.y;

      r = 1.0 / ( s1 * t2 - s2 * t1 );

      sdir.set(
        ( t2 * x1 - t1 * x2 ) * r,
        ( t2 * y1 - t1 * y2 ) * r,
        ( t2 * z1 - t1 * z2 ) * r
      );

      tdir.set(
        ( s1 * x2 - s2 * x1 ) * r,
        ( s1 * y2 - s2 * y1 ) * r,
        ( s1 * z2 - s2 * z1 ) * r
      );

      tan1[ a ].add( sdir );
      tan1[ b ].add( sdir );
      tan1[ c ].add( sdir );

      tan2[ a ].add( tdir );
      tan2[ b ].add( tdir );
      tan2[ c ].add( tdir );

    }

    var i, il;
    var j, jl;
    var iA, iB, iC;

    if ( this.drawcalls.length === 0 ) {

      this.addDrawCall( 0, indices.length, 0 );

    }

    var drawcalls = this.drawcalls;

    for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

      var start = drawcalls[ j ].start;
      var count = drawcalls[ j ].count;
      var index = drawcalls[ j ].index;

      for ( i = start, il = start + count; i < il; i += 3 ) {

        iA = index + indices[ i ];
        iB = index + indices[ i + 1 ];
        iC = index + indices[ i + 2 ];

        handleTriangle( iA, iB, iC );

      }

    }

    var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
    var n = new THREE.Vector3(), n2 = new THREE.Vector3();
    var w, t, test;

    function handleVertex( v ) {

      n.fromArray( normals, v * 3 );
      n2.copy( n );

      t = tan1[ v ];

      // Gram-Schmidt orthogonalize

      tmp.copy( t );
      tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

      // Calculate handedness

      tmp2.crossVectors( n2, t );
      test = tmp2.dot( tan2[ v ] );
      w = ( test < 0.0 ) ? - 1.0 : 1.0;

      tangents[ v * 4     ] = tmp.x;
      tangents[ v * 4 + 1 ] = tmp.y;
      tangents[ v * 4 + 2 ] = tmp.z;
      tangents[ v * 4 + 3 ] = w;

    }

    for ( j = 0, jl = drawcalls.length; j < jl; ++ j ) {

      var start = drawcalls[ j ].start;
      var count = drawcalls[ j ].count;
      var index = drawcalls[ j ].index;

      for ( i = start, il = start + count; i < il; i += 3 ) {

        iA = index + indices[ i ];
        iB = index + indices[ i + 1 ];
        iC = index + indices[ i + 2 ];

        handleVertex( iA );
        handleVertex( iB );
        handleVertex( iC );

      }

    }

  },

  /*
  Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
  This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
  WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
  size - Defaults to 65535 or 4294967296 if extension OES_element_index_uint supported, but allows for larger or smaller chunks.
  */
  computeOffsets: function ( size ) {

    if ( size === undefined ) size = THREE.BufferGeometry.MaxIndex;

    var indices = this.attributes.index.array;
    var vertices = this.attributes.position.array;

    var facesCount = ( indices.length / 3 );

    var UintArray = ( ( vertices.length / 3 ) > 65535 && THREE.BufferGeometry.MaxIndex > 65535 ) ? Uint32Array : Uint16Array;

    /*
    console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
    console.log("Faces to process: "+(indices.length/3));
    console.log("Reordering "+verticesCount+" vertices.");
    */

    var sortedIndices = new UintArray( indices.length );

    var indexPtr = 0;
    var vertexPtr = 0;

    var offsets = [ { start:0, count:0, index:0 } ];
    var offset = offsets[ 0 ];

    var duplicatedVertices = 0;
    var newVerticeMaps = 0;
    var faceVertices = new Int32Array( 6 );
    var vertexMap = new Int32Array( vertices.length );
    var revVertexMap = new Int32Array( vertices.length );
    for ( var j = 0; j < vertices.length; j ++ ) { vertexMap[ j ] = - 1; revVertexMap[ j ] = - 1; }

    /*
      Traverse every face and reorder vertices in the proper offsets of 65k.
      We can have more than 'size' entries in the index buffer per offset, but only reference 'size' values.
    */
    for ( var findex = 0; findex < facesCount; findex ++ ) {
      newVerticeMaps = 0;

      for ( var vo = 0; vo < 3; vo ++ ) {
        var vid = indices[ findex * 3 + vo ];
        if ( vertexMap[ vid ] === - 1 ) {
          //Unmapped vertice
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = - 1;
          newVerticeMaps ++;
        } else if ( vertexMap[ vid ] < offset.index ) {
          //Reused vertices from previous block (duplicate)
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = - 1;
          duplicatedVertices ++;
        } else {
          //Reused vertice in the current block
          faceVertices[ vo * 2 ] = vid;
          faceVertices[ vo * 2 + 1 ] = vertexMap[ vid ];
        }
      }

      var faceMax = vertexPtr + newVerticeMaps;
      if ( faceMax > ( offset.index + size ) ) {
        var new_offset = { start:indexPtr, count:0, index:vertexPtr };
        offsets.push( new_offset );
        offset = new_offset;

        //Re-evaluate reused vertices in light of new offset.
        for ( var v = 0; v < 6; v += 2 ) {
          var new_vid = faceVertices[ v + 1 ];
          if ( new_vid > - 1 && new_vid < offset.index )
            faceVertices[ v + 1 ] = - 1;
        }
      }

      //Reindex the face.
      for ( var v = 0; v < 6; v += 2 ) {
        var vid = faceVertices[ v ];
        var new_vid = faceVertices[ v + 1 ];

        if ( new_vid === - 1 )
          new_vid = vertexPtr ++;

        vertexMap[ vid ] = new_vid;
        revVertexMap[ new_vid ] = vid;
        sortedIndices[ indexPtr ++ ] = new_vid - offset.index; //XXX overflows at 16bit
        offset.count ++;
      }
    }

    /* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
    this.reorderBuffers( sortedIndices, revVertexMap, vertexPtr );
    this.offsets = offsets; // TODO: Deprecate
    this.drawcalls = offsets;

    /*
    var orderTime = Date.now();
    console.log("Reorder time: "+(orderTime-s)+"ms");
    console.log("Duplicated "+duplicatedVertices+" vertices.");
    console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
    console.log("Draw offsets: "+offsets.length);
    */

    return offsets;

  },

  merge: function ( geometry, offset ) {

    if ( geometry instanceof THREE.BufferGeometry === false ) {

      console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
      return;

    }

    if ( offset === undefined ) offset = 0;

    var attributes = this.attributes;

    for ( var key in attributes ) {

      if ( geometry.attributes[ key ] === undefined ) continue;

      var attribute1 = attributes[ key ];
      var attributeArray1 = attribute1.array;

      var attribute2 = geometry.attributes[ key ];
      var attributeArray2 = attribute2.array;

      var attributeSize = attribute2.itemSize;

      for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

        attributeArray1[ j ] = attributeArray2[ i ];

      }

    }

    return this;

  },

  normalizeNormals: function () {

    var normals = this.attributes.normal.array;

    var x, y, z, n;

    for ( var i = 0, il = normals.length; i < il; i += 3 ) {

      x = normals[ i ];
      y = normals[ i + 1 ];
      z = normals[ i + 2 ];

      n = 1.0 / Math.sqrt( x * x + y * y + z * z );

      normals[ i     ] *= n;
      normals[ i + 1 ] *= n;
      normals[ i + 2 ] *= n;

    }

  },

  /*
    reoderBuffers:
    Reorder attributes based on a new indexBuffer and indexMap.
    indexBuffer - Uint16Array of the new ordered indices.
    indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
    vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
  */
  reorderBuffers: function ( indexBuffer, indexMap, vertexCount ) {

    /* Create a copy of all attributes for reordering. */
    var sortedAttributes = {};
    for ( var attr in this.attributes ) {
      if ( attr === 'index' )
        continue;
      var sourceArray = this.attributes[ attr ].array;
      sortedAttributes[ attr ] = new sourceArray.constructor( this.attributes[ attr ].itemSize * vertexCount );
    }

    /* Move attribute positions based on the new index map */
    for ( var new_vid = 0; new_vid < vertexCount; new_vid ++ ) {
      var vid = indexMap[ new_vid ];
      for ( var attr in this.attributes ) {
        if ( attr === 'index' )
          continue;
        var attrArray = this.attributes[ attr ].array;
        var attrSize = this.attributes[ attr ].itemSize;
        var sortedAttr = sortedAttributes[ attr ];
        for ( var k = 0; k < attrSize; k ++ )
          sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
      }
    }

    /* Carry the new sorted buffers locally */
    this.attributes[ 'index' ].array = indexBuffer;
    for ( var attr in this.attributes ) {
      if ( attr === 'index' )
        continue;
      this.attributes[ attr ].array = sortedAttributes[ attr ];
      this.attributes[ attr ].numItems = this.attributes[ attr ].itemSize * vertexCount;
    }
  },

  toJSON: function () {

    var data = {
      metadata: {
        version: 4.4,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON'
      }
    };

    // standard BufferGeometry serialization

    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.parameters !== undefined ) {

      var parameters = this.parameters;

      for ( var key in parameters ) {

        if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

      }

      return data;

    }

    data.data = { attributes: {} };

    var attributes = this.attributes;
    var offsets = this.offsets;
    var boundingSphere = this.boundingSphere;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];

      var array = Array.prototype.slice.call( attribute.array );

      data.data.attributes[ key ] = {
        itemSize: attribute.itemSize,
        type: attribute.array.constructor.name,
        array: array
      }

    }

    if ( offsets.length > 0 ) {

      data.data.offsets = JSON.parse( JSON.stringify( offsets ) );

    }

    if ( boundingSphere !== null ) {

      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      }

    }

    return data;

  },

  clone: function () {

    var geometry = new THREE.BufferGeometry();

    for ( var attr in this.attributes ) {

      var sourceAttr = this.attributes[ attr ];
      geometry.addAttribute( attr, sourceAttr.clone() );

    }

    for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

      var offset = this.offsets[ i ];

      geometry.offsets.push( {

        start: offset.start,
        index: offset.index,
        count: offset.count

      } );

    }

    return geometry;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

  THREE.BufferGeometry.call( this );

  this.type = 'InstancedBufferGeometry';
  this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset, instances ) {

  this.drawcalls.push( {

    start: start,
    count: count,
    index: indexOffset !== undefined ? indexOffset : 0,
    instances: instances

  } );

},

THREE.InstancedBufferGeometry.prototype.clone = function () {

  var geometry = new THREE.InstancedBufferGeometry();

  for ( var attr in this.attributes ) {

    var sourceAttr = this.attributes[attr];
    geometry.addAttribute( attr, sourceAttr.clone() );

  }

  for ( var i = 0, il = this.offsets.length; i < il; i++ ) {

    var offset = this.offsets[i];

    geometry.offsets.push( {

      start: offset.start,
      index: offset.index,
      count: offset.count,
      instances: offset.instances

    } );

  }

  return geometry;

};

THREE.EventDispatcher.prototype.apply( THREE.InstancedBufferGeometry.prototype );

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

  THREE.Object3D.call( this );

  this.type = 'Camera';

  this.matrixWorldInverse = new THREE.Matrix4();
  this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

  var quaternion = new THREE.Quaternion();

  return function ( optionalTarget ) {

    var result = optionalTarget || new THREE.Vector3();

    this.getWorldQuaternion( quaternion );

    return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

  };

}();

THREE.Camera.prototype.lookAt = function () {

  // This routine does not support cameras with rotated and/or translated parent(s)

  var m1 = new THREE.Matrix4();

  return function ( vector ) {

    m1.lookAt( this.position, vector, this.up );

    this.quaternion.setFromRotationMatrix( m1 );

  };

}();

THREE.Camera.prototype.clone = function ( camera ) {

  if ( camera === undefined ) camera = new THREE.Camera();

  THREE.Object3D.prototype.clone.call( this, camera );

  camera.matrixWorldInverse.copy( this.matrixWorldInverse );
  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;
};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *  - renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

  THREE.Object3D.call( this );

  this.type = 'CubeCamera';

  var fov = 90, aspect = 1;

  var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPX.up.set( 0, - 1, 0 );
  cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
  this.add( cameraPX );

  var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNX.up.set( 0, - 1, 0 );
  cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
  this.add( cameraNX );

  var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPY.up.set( 0, 0, 1 );
  cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
  this.add( cameraPY );

  var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNY.up.set( 0, 0, - 1 );
  cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
  this.add( cameraNY );

  var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraPZ.up.set( 0, - 1, 0 );
  cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
  this.add( cameraPZ );

  var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
  cameraNZ.up.set( 0, - 1, 0 );
  cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
  this.add( cameraNZ );

  this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

  this.updateCubeMap = function ( renderer, scene ) {

    if ( this.parent === undefined ) this.updateMatrixWorld();

    var renderTarget = this.renderTarget;
    var generateMipmaps = renderTarget.generateMipmaps;

    renderTarget.generateMipmaps = false;

    renderTarget.activeCubeFace = 0;
    renderer.render( scene, cameraPX, renderTarget );

    renderTarget.activeCubeFace = 1;
    renderer.render( scene, cameraNX, renderTarget );

    renderTarget.activeCubeFace = 2;
    renderer.render( scene, cameraPY, renderTarget );

    renderTarget.activeCubeFace = 3;
    renderer.render( scene, cameraNY, renderTarget );

    renderTarget.activeCubeFace = 4;
    renderer.render( scene, cameraPZ, renderTarget );

    renderTarget.generateMipmaps = generateMipmaps;

    renderTarget.activeCubeFace = 5;
    renderer.render( scene, cameraNZ, renderTarget );

    renderer.setRenderTarget( null );

  };

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

  THREE.Camera.call( this );

  this.type = 'OrthographicCamera';

  this.zoom = 1;

  this.left = left;
  this.right = right;
  this.top = top;
  this.bottom = bottom;

  this.near = ( near !== undefined ) ? near : 0.1;
  this.far = ( far !== undefined ) ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera;

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

  var dx = ( this.right - this.left ) / ( 2 * this.zoom );
  var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
  var cx = ( this.right + this.left ) / 2;
  var cy = ( this.top + this.bottom ) / 2;

  this.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

  var camera = new THREE.OrthographicCamera();

  THREE.Camera.prototype.clone.call( this, camera );

  camera.zoom = this.zoom;

  camera.left = this.left;
  camera.right = this.right;
  camera.top = this.top;
  camera.bottom = this.bottom;

  camera.near = this.near;
  camera.far = this.far;

  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;
};

THREE.OrthographicCamera.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.left = this.left;
  data.object.right = this.right;
  data.object.top = this.top;
  data.object.bottom = this.bottom;
  data.object.near = this.near;
  data.object.far = this.far;

  return data;

};

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

  THREE.Camera.call( this );

  this.type = 'PerspectiveCamera';

  this.zoom = 1;

  this.fov = fov !== undefined ? fov : 50;
  this.aspect = aspect !== undefined ? aspect : 1;
  this.near = near !== undefined ? near : 0.1;
  this.far = far !== undefined ? far : 2000;

  this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera;


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

  if ( frameHeight === undefined ) frameHeight = 24;

  this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
  this.updateProjectionMatrix();

};


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

  this.fullWidth = fullWidth;
  this.fullHeight = fullHeight;
  this.x = x;
  this.y = y;
  this.width = width;
  this.height = height;

  this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

  var fov = THREE.Math.radToDeg( 2 * Math.atan( Math.tan( THREE.Math.degToRad( this.fov ) * 0.5 ) / this.zoom ) );

  if ( this.fullWidth ) {

    var aspect = this.fullWidth / this.fullHeight;
    var top = Math.tan( THREE.Math.degToRad( fov * 0.5 ) ) * this.near;
    var bottom = - top;
    var left = aspect * bottom;
    var right = aspect * top;
    var width = Math.abs( right - left );
    var height = Math.abs( top - bottom );

    this.projectionMatrix.makeFrustum(
      left + this.x * width / this.fullWidth,
      left + ( this.x + this.width ) * width / this.fullWidth,
      top - ( this.y + this.height ) * height / this.fullHeight,
      top - this.y * height / this.fullHeight,
      this.near,
      this.far
    );

  } else {

    this.projectionMatrix.makePerspective( fov, this.aspect, this.near, this.far );

  }

};

THREE.PerspectiveCamera.prototype.clone = function () {

  var camera = new THREE.PerspectiveCamera();

  THREE.Camera.prototype.clone.call( this, camera );

  camera.zoom = this.zoom;

  camera.fov = this.fov;
  camera.aspect = this.aspect;
  camera.near = this.near;
  camera.far = this.far;

  camera.projectionMatrix.copy( this.projectionMatrix );

  return camera;

};

THREE.PerspectiveCamera.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.fov = this.fov;
  data.object.aspect = this.aspect;
  data.object.near = this.near;
  data.object.far = this.far;

  return data;

};

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color ) {

  THREE.Object3D.call( this );

  this.type = 'Light';

  this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
THREE.Light.prototype.constructor = THREE.Light;

THREE.Light.prototype.clone = function ( light ) {

  if ( light === undefined ) light = new THREE.Light();

  THREE.Object3D.prototype.clone.call( this, light );

  light.color.copy( this.color );

  return light;

};

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

  THREE.Light.call( this, color );

  this.type = 'AmbientLight';

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight;

THREE.AmbientLight.prototype.clone = function () {

  var light = new THREE.AmbientLight();

  THREE.Light.prototype.clone.call( this, light );

  return light;

};

THREE.AmbientLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();

  return data;

};

// File:src/lights/AreaLight.js

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity ) {

  THREE.Light.call( this, color );

  this.type = 'AreaLight';

  this.normal = new THREE.Vector3( 0, - 1, 0 );
  this.right = new THREE.Vector3( 1, 0, 0 );

  this.intensity = ( intensity !== undefined ) ? intensity : 1;

  this.width = 1.0;
  this.height = 1.0;

  this.constantAttenuation = 1.5;
  this.linearAttenuation = 0.5;
  this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );
THREE.AreaLight.prototype.constructor = THREE.AreaLight;


// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

  THREE.Light.call( this, color );

  this.type = 'DirectionalLight';

  this.position.set( 0, 1, 0 );
  this.target = new THREE.Object3D();

  this.intensity = ( intensity !== undefined ) ? intensity : 1;

  this.castShadow = false;
  this.onlyShadow = false;

  //

  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;

  this.shadowCameraLeft = - 500;
  this.shadowCameraRight = 500;
  this.shadowCameraTop = 500;
  this.shadowCameraBottom = - 500;

  this.shadowCameraVisible = false;

  this.shadowBias = 0;
  this.shadowDarkness = 0.5;

  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;

  //

  this.shadowCascade = false;

  this.shadowCascadeOffset = new THREE.Vector3( 0, 0, - 1000 );
  this.shadowCascadeCount = 2;

  this.shadowCascadeBias = [ 0, 0, 0 ];
  this.shadowCascadeWidth = [ 512, 512, 512 ];
  this.shadowCascadeHeight = [ 512, 512, 512 ];

  this.shadowCascadeNearZ = [ - 1.000, 0.990, 0.998 ];
  this.shadowCascadeFarZ = [ 0.990, 0.998, 1.000 ];

  this.shadowCascadeArray = [];

  //

  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight;

THREE.DirectionalLight.prototype.clone = function () {

  var light = new THREE.DirectionalLight();

  THREE.Light.prototype.clone.call( this, light );

  light.target = this.target.clone();

  light.intensity = this.intensity;

  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;

  //

  light.shadowCameraNear = this.shadowCameraNear;
  light.shadowCameraFar = this.shadowCameraFar;

  light.shadowCameraLeft = this.shadowCameraLeft;
  light.shadowCameraRight = this.shadowCameraRight;
  light.shadowCameraTop = this.shadowCameraTop;
  light.shadowCameraBottom = this.shadowCameraBottom;

  light.shadowCameraVisible = this.shadowCameraVisible;

  light.shadowBias = this.shadowBias;
  light.shadowDarkness = this.shadowDarkness;

  light.shadowMapWidth = this.shadowMapWidth;
  light.shadowMapHeight = this.shadowMapHeight;

  //

  light.shadowCascade = this.shadowCascade;

  light.shadowCascadeOffset.copy( this.shadowCascadeOffset );
  light.shadowCascadeCount = this.shadowCascadeCount;

  light.shadowCascadeBias = this.shadowCascadeBias.slice( 0 );
  light.shadowCascadeWidth = this.shadowCascadeWidth.slice( 0 );
  light.shadowCascadeHeight = this.shadowCascadeHeight.slice( 0 );

  light.shadowCascadeNearZ = this.shadowCascadeNearZ.slice( 0 );
  light.shadowCascadeFarZ = this.shadowCascadeFarZ.slice( 0 );

  return light;

};

THREE.DirectionalLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;

  return data;

};

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

  THREE.Light.call( this, skyColor );

  this.type = 'HemisphereLight';

  this.position.set( 0, 100, 0 );

  this.groundColor = new THREE.Color( groundColor );
  this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight;

THREE.HemisphereLight.prototype.clone = function () {

  var light = new THREE.HemisphereLight();

  THREE.Light.prototype.clone.call( this, light );

  light.groundColor.copy( this.groundColor );
  light.intensity = this.intensity;

  return light;

};

THREE.HemisphereLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.groundColor = this.groundColor.getHex();

  return data;

};

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance, decay ) {

  THREE.Light.call( this, color );

  this.type = 'PointLight';

  this.intensity = ( intensity !== undefined ) ? intensity : 1;
  this.distance = ( distance !== undefined ) ? distance : 0;
  this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
THREE.PointLight.prototype.constructor = THREE.PointLight;

THREE.PointLight.prototype.clone = function () {

  var light = new THREE.PointLight();

  THREE.Light.prototype.clone.call( this, light );

  light.intensity = this.intensity;
  light.distance = this.distance;
  light.decay = this.decay;

  return light;

};

THREE.PointLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;
  data.object.distance = this.distance;
  data.object.decay = this.decay;

  return data;

};

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent, decay ) {

  THREE.Light.call( this, color );

  this.type = 'SpotLight';

  this.position.set( 0, 1, 0 );
  this.target = new THREE.Object3D();

  this.intensity = ( intensity !== undefined ) ? intensity : 1;
  this.distance = ( distance !== undefined ) ? distance : 0;
  this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
  this.exponent = ( exponent !== undefined ) ? exponent : 10;
  this.decay = ( decay !== undefined ) ? decay : 1; // for physically correct lights, should be 2.

  this.castShadow = false;
  this.onlyShadow = false;

  //

  this.shadowCameraNear = 50;
  this.shadowCameraFar = 5000;
  this.shadowCameraFov = 50;

  this.shadowCameraVisible = false;

  this.shadowBias = 0;
  this.shadowDarkness = 0.5;

  this.shadowMapWidth = 512;
  this.shadowMapHeight = 512;

  //

  this.shadowMap = null;
  this.shadowMapSize = null;
  this.shadowCamera = null;
  this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
THREE.SpotLight.prototype.constructor = THREE.SpotLight;

THREE.SpotLight.prototype.clone = function () {

  var light = new THREE.SpotLight();

  THREE.Light.prototype.clone.call( this, light );

  light.target = this.target.clone();

  light.intensity = this.intensity;
  light.distance = this.distance;
  light.angle = this.angle;
  light.exponent = this.exponent;
  light.decay = this.decay;

  light.castShadow = this.castShadow;
  light.onlyShadow = this.onlyShadow;

  //

  light.shadowCameraNear = this.shadowCameraNear;
  light.shadowCameraFar = this.shadowCameraFar;
  light.shadowCameraFov = this.shadowCameraFov;

  light.shadowCameraVisible = this.shadowCameraVisible;

  light.shadowBias = this.shadowBias;
  light.shadowDarkness = this.shadowDarkness;

  light.shadowMapWidth = this.shadowMapWidth;
  light.shadowMapHeight = this.shadowMapHeight;

  return light;

};

THREE.SpotLight.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  data.object.color = this.color.getHex();
  data.object.intensity = this.intensity;
  data.object.distance = this.distance;
  data.object.angle = this.angle;
  data.object.exponent = this.exponent;
  data.object.decay = this.decay;

  return data;

};

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

  files: {},

  add: function ( key, file ) {

    // console.log( 'THREE.Cache', 'Adding key:', key );

    this.files[ key ] = file;

  },

  get: function ( key ) {

    // console.log( 'THREE.Cache', 'Checking key:', key );

    return this.files[ key ];

  },

  remove: function ( key ) {

    delete this.files[ key ];

  },

  clear: function () {

    this.files = {}

  }

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

  this.showStatus = showStatus;
  this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

  this.imageLoader = new THREE.ImageLoader();

  this.onLoadStart = function () {};
  this.onLoadProgress = function () {};
  this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

  constructor: THREE.Loader,

  crossOrigin: undefined,

  addStatusElement: function () {

    var e = document.createElement( 'div' );

    e.style.position = 'absolute';
    e.style.right = '0px';
    e.style.top = '0px';
    e.style.fontSize = '0.8em';
    e.style.textAlign = 'left';
    e.style.background = 'rgba(0,0,0,0.25)';
    e.style.color = '#fff';
    e.style.width = '120px';
    e.style.padding = '0.5em 0.5em 0.5em 0.5em';
    e.style.zIndex = 1000;

    e.innerHTML = 'Loading ...';

    return e;

  },

  updateProgress: function ( progress ) {

    var message = 'Loaded ';

    if ( progress.total ) {

      message += ( 100 * progress.loaded / progress.total ).toFixed( 0 ) + '%';


    } else {

      message += ( progress.loaded / 1024 ).toFixed( 2 ) + ' KB';

    }

    this.statusDomElement.innerHTML = message;

  },

  extractUrlBase: function ( url ) {

    var parts = url.split( '/' );

    if ( parts.length === 1 ) return './';

    parts.pop();

    return parts.join( '/' ) + '/';

  },

  initMaterials: function ( materials, texturePath ) {

    var array = [];

    for ( var i = 0; i < materials.length; ++ i ) {

      array[ i ] = this.createMaterial( materials[ i ], texturePath );

    }

    return array;

  },

  needsTangents: function ( materials ) {

    for ( var i = 0, il = materials.length; i < il; i ++ ) {

      var m = materials[ i ];

      if ( m instanceof THREE.ShaderMaterial ) return true;

    }

    return false;

  },

  createMaterial: function ( m, texturePath ) {

    var scope = this;

    function nearest_pow2( n ) {

      var l = Math.log( n ) / Math.LN2;
      return Math.pow( 2, Math.round(  l ) );

    }

    function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

      var fullPath = texturePath + sourceFile;

      var texture;

      var loader = THREE.Loader.Handlers.get( fullPath );

      if ( loader !== null ) {

        texture = loader.load( fullPath );

      } else {

        texture = new THREE.Texture();

        loader = scope.imageLoader;
        loader.crossOrigin = scope.crossOrigin;
        loader.load( fullPath, function ( image ) {

          if ( THREE.Math.isPowerOfTwo( image.width ) === false ||
             THREE.Math.isPowerOfTwo( image.height ) === false ) {

            var width = nearest_pow2( image.width );
            var height = nearest_pow2( image.height );

            var canvas = document.createElement( 'canvas' );
            canvas.width = width;
            canvas.height = height;

            var context = canvas.getContext( '2d' );
            context.drawImage( image, 0, 0, width, height );

            texture.image = canvas;

          } else {

            texture.image = image;

          }

          texture.needsUpdate = true;

        } );

      }

      texture.sourceFile = sourceFile;

      if ( repeat ) {

        texture.repeat.set( repeat[ 0 ], repeat[ 1 ] );

        if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
        if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

      }

      if ( offset ) {

        texture.offset.set( offset[ 0 ], offset[ 1 ] );

      }

      if ( wrap ) {

        var wrapMap = {
          'repeat': THREE.RepeatWrapping,
          'mirror': THREE.MirroredRepeatWrapping
        };

        if ( wrapMap[ wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ wrap[ 0 ] ];
        if ( wrapMap[ wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ wrap[ 1 ] ];

      }

      if ( anisotropy ) {

        texture.anisotropy = anisotropy;

      }

      where[ name ] = texture;

    }

    function rgb2hex( rgb ) {

      return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

    }

    // defaults

    var mtype = 'MeshLambertMaterial';
    var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

    // parameters from model file

    if ( m.shading ) {

      var shading = m.shading.toLowerCase();

      if ( shading === 'phong' ) mtype = 'MeshPhongMaterial';
      else if ( shading === 'basic' ) mtype = 'MeshBasicMaterial';

    }

    if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

      mpars.blending = THREE[ m.blending ];

    }

    if ( m.transparent !== undefined ) {

      mpars.transparent = m.transparent;

    }

    if ( m.opacity !== undefined && m.opacity < 1.0 ) {

      mpars.transparent = true;

    }

    if ( m.depthTest !== undefined ) {

      mpars.depthTest = m.depthTest;

    }

    if ( m.depthWrite !== undefined ) {

      mpars.depthWrite = m.depthWrite;

    }

    if ( m.visible !== undefined ) {

      mpars.visible = m.visible;

    }

    if ( m.flipSided !== undefined ) {

      mpars.side = THREE.BackSide;

    }

    if ( m.doubleSided !== undefined ) {

      mpars.side = THREE.DoubleSide;

    }

    if ( m.wireframe !== undefined ) {

      mpars.wireframe = m.wireframe;

    }

    if ( m.vertexColors !== undefined ) {

      if ( m.vertexColors === 'face' ) {

        mpars.vertexColors = THREE.FaceColors;

      } else if ( m.vertexColors ) {

        mpars.vertexColors = THREE.VertexColors;

      }

    }

    // colors

    if ( m.colorDiffuse ) {

      mpars.color = rgb2hex( m.colorDiffuse );

    } else if ( m.DbgColor ) {

      mpars.color = m.DbgColor;

    }

    if ( m.colorSpecular ) {

      mpars.specular = rgb2hex( m.colorSpecular );

    }

    if ( m.colorEmissive ) {

      mpars.emissive = rgb2hex( m.colorEmissive );

    }

    // modifiers

    if ( m.transparency !== undefined ) {

      console.warn( 'THREE.Loader: transparency has been renamed to opacity' );
      m.opacity = m.transparency;

    }

    if ( m.opacity !== undefined ) {

      mpars.opacity = m.opacity;

    }

    if ( m.specularCoef ) {

      mpars.shininess = m.specularCoef;

    }

    // textures

    if ( m.mapDiffuse && texturePath ) {

      create_texture( mpars, 'map', m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

    }

    if ( m.mapLight && texturePath ) {

      create_texture( mpars, 'lightMap', m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

    }

    if ( m.mapAO && texturePath ) {

      create_texture( mpars, 'aoMap', m.mapAO, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );

    }

    if ( m.mapBump && texturePath ) {

      create_texture( mpars, 'bumpMap', m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

    }

    if ( m.mapNormal && texturePath ) {

      create_texture( mpars, 'normalMap', m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

    }

    if ( m.mapSpecular && texturePath ) {

      create_texture( mpars, 'specularMap', m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

    }

    if ( m.mapAlpha && texturePath ) {

      create_texture( mpars, 'alphaMap', m.mapAlpha, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );

    }

    //

    if ( m.mapBumpScale ) {

      mpars.bumpScale = m.mapBumpScale;

    }

    if ( m.mapNormalFactor ) {

      mpars.normalScale = new THREE.Vector2( m.mapNormalFactor, m.mapNormalFactor );

    }

    var material = new THREE[ mtype ]( mpars );

    if ( m.DbgName !== undefined ) material.name = m.DbgName;

    return material;

  }

};

THREE.Loader.Handlers = {

  handlers: [],

  add: function ( regex, loader ) {

    this.handlers.push( regex, loader );

  },

  get: function ( file ) {

    for ( var i = 0, l = this.handlers.length; i < l; i += 2 ) {

      var regex = this.handlers[ i ];
      var loader  = this.handlers[ i + 1 ];

      if ( regex.test( file ) ) {

        return loader;

      }

    }

    return null;

  }

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

  constructor: THREE.XHRLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var cached = THREE.Cache.get( url );

    if ( cached !== undefined ) {

      if ( onLoad ) onLoad( cached );
      return cached;

    }

    var request = new XMLHttpRequest();
    request.open( 'GET', url, true );

    request.addEventListener( 'load', function ( event ) {

      THREE.Cache.add( url, this.response );

      if ( onLoad ) onLoad( this.response );

      scope.manager.itemEnd( url );

    }, false );

    if ( onProgress !== undefined ) {

      request.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    if ( onError !== undefined ) {

      request.addEventListener( 'error', function ( event ) {

        onError( event );

      }, false );

    }

    if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;
    if ( this.responseType !== undefined ) request.responseType = this.responseType;

    request.send( null );

    scope.manager.itemStart( url );

    return request;

  },

  setResponseType: function ( value ) {

    this.responseType = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

  constructor: THREE.ImageLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var cached = THREE.Cache.get( url );

    if ( cached !== undefined ) {

      if ( onLoad ) onLoad( cached );
      return cached;

    }

    var image = document.createElement( 'img' );

    image.addEventListener( 'load', function ( event ) {

      THREE.Cache.add( url, this );

      if ( onLoad ) onLoad( this );

      scope.manager.itemEnd( url );

    }, false );

    if ( onProgress !== undefined ) {

      image.addEventListener( 'progress', function ( event ) {

        onProgress( event );

      }, false );

    }

    if ( onError !== undefined ) {

      image.addEventListener( 'error', function ( event ) {

        onError( event );

      }, false );

    }

    if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

    scope.manager.itemStart( url );

    image.src = url;

    return image;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

  THREE.Loader.call( this, showStatus );

  this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );
THREE.JSONLoader.prototype.constructor = THREE.JSONLoader;

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

  // todo: unify load API to for easier SceneLoader use

  texturePath = texturePath && ( typeof texturePath === 'string' ) ? texturePath : this.extractUrlBase( url );

  this.onLoadStart();
  this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

  var xhr = new XMLHttpRequest();

  var length = 0;

  xhr.onreadystatechange = function () {

    if ( xhr.readyState === xhr.DONE ) {

      if ( xhr.status === 200 || xhr.status === 0 ) {

        if ( xhr.responseText ) {

          var json = JSON.parse( xhr.responseText );
          var metadata = json.metadata;

          if ( metadata !== undefined ) {

            if ( metadata.type === 'object' ) {

              console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
              return;

            }

            if ( metadata.type === 'scene' ) {

              console.error( 'THREE.JSONLoader: ' + url + ' seems to be a Scene. Use THREE.SceneLoader instead.' );
              return;

            }

          }

          var result = context.parse( json, texturePath );
          callback( result.geometry, result.materials );

        } else {

          console.error( 'THREE.JSONLoader: ' + url + ' seems to be unreachable or the file is empty.' );

        }

        // in context of more complex asset initialization
        // do not block on single failed file
        // maybe should go even one more level up

        context.onLoadComplete();

      } else {

        console.error( 'THREE.JSONLoader: Couldn\'t load ' + url + ' (' + xhr.status + ')' );

      }

    } else if ( xhr.readyState === xhr.LOADING ) {

      if ( callbackProgress ) {

        if ( length === 0 ) {

          length = xhr.getResponseHeader( 'Content-Length' );

        }

        callbackProgress( { total: length, loaded: xhr.responseText.length } );

      }

    } else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

      if ( callbackProgress !== undefined ) {

        length = xhr.getResponseHeader( 'Content-Length' );

      }

    }

  };

  xhr.open( 'GET', url, true );
  xhr.withCredentials = this.withCredentials;
  xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

  var geometry = new THREE.Geometry(),
  scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

  parseModel( scale );

  parseSkin();
  parseMorphing( scale );

  geometry.computeFaceNormals();
  geometry.computeBoundingSphere();

  function parseModel( scale ) {

    function isBitSet( value, position ) {

      return value & ( 1 << position );

    }

    var i, j, fi,

    offset, zLength,

    colorIndex, normalIndex, uvIndex,

    type,
    isQuad,
    hasMaterial,
    hasFaceVertexUv,
    hasFaceNormal, hasFaceVertexNormal,
    hasFaceColor, hasFaceVertexColor,

    vertex, face, faceA, faceB, hex, normal,

    uvLayer, uv, u, v,

    faces = json.faces,
    vertices = json.vertices,
    normals = json.normals,
    colors = json.colors,

    nUvLayers = 0;

    if ( json.uvs !== undefined ) {

      // disregard empty arrays

      for ( i = 0; i < json.uvs.length; i ++ ) {

        if ( json.uvs[ i ].length ) nUvLayers ++;

      }

      for ( i = 0; i < nUvLayers; i ++ ) {

        geometry.faceVertexUvs[ i ] = [];

      }

    }

    offset = 0;
    zLength = vertices.length;

    while ( offset < zLength ) {

      vertex = new THREE.Vector3();

      vertex.x = vertices[ offset ++ ] * scale;
      vertex.y = vertices[ offset ++ ] * scale;
      vertex.z = vertices[ offset ++ ] * scale;

      geometry.vertices.push( vertex );

    }

    offset = 0;
    zLength = faces.length;

    while ( offset < zLength ) {

      type = faces[ offset ++ ];


      isQuad              = isBitSet( type, 0 );
      hasMaterial         = isBitSet( type, 1 );
      hasFaceVertexUv     = isBitSet( type, 3 );
      hasFaceNormal       = isBitSet( type, 4 );
      hasFaceVertexNormal = isBitSet( type, 5 );
      hasFaceColor       = isBitSet( type, 6 );
      hasFaceVertexColor  = isBitSet( type, 7 );

      // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

      if ( isQuad ) {

        faceA = new THREE.Face3();
        faceA.a = faces[ offset ];
        faceA.b = faces[ offset + 1 ];
        faceA.c = faces[ offset + 3 ];

        faceB = new THREE.Face3();
        faceB.a = faces[ offset + 1 ];
        faceB.b = faces[ offset + 2 ];
        faceB.c = faces[ offset + 3 ];

        offset += 4;

        if ( hasMaterial ) {

          offset ++;

        }

        // to get face <=> uv index correspondence

        fi = geometry.faces.length;

        if ( hasFaceVertexUv ) {

          for ( i = 0; i < nUvLayers; i ++ ) {

            uvLayer = json.uvs[ i ];

            geometry.faceVertexUvs[ i ][ fi ] = [];
            geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

            for ( j = 0; j < 4; j ++ ) {

              uvIndex = faces[ offset ++ ];

              u = uvLayer[ uvIndex * 2 ];
              v = uvLayer[ uvIndex * 2 + 1 ];

              uv = new THREE.Vector2( u, v );

              if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
              if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

            }

          }

        }

        if ( hasFaceNormal ) {

          normalIndex = faces[ offset ++ ] * 3;

          faceA.normal.set(
            normals[ normalIndex ++ ],
            normals[ normalIndex ++ ],
            normals[ normalIndex ]
          );

          faceB.normal.copy( faceA.normal );

        }

        if ( hasFaceVertexNormal ) {

          for ( i = 0; i < 4; i ++ ) {

            normalIndex = faces[ offset ++ ] * 3;

            normal = new THREE.Vector3(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );


            if ( i !== 2 ) faceA.vertexNormals.push( normal );
            if ( i !== 0 ) faceB.vertexNormals.push( normal );

          }

        }


        if ( hasFaceColor ) {

          colorIndex = faces[ offset ++ ];
          hex = colors[ colorIndex ];

          faceA.color.setHex( hex );
          faceB.color.setHex( hex );

        }


        if ( hasFaceVertexColor ) {

          for ( i = 0; i < 4; i ++ ) {

            colorIndex = faces[ offset ++ ];
            hex = colors[ colorIndex ];

            if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
            if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

          }

        }

        geometry.faces.push( faceA );
        geometry.faces.push( faceB );

      } else {

        face = new THREE.Face3();
        face.a = faces[ offset ++ ];
        face.b = faces[ offset ++ ];
        face.c = faces[ offset ++ ];

        if ( hasMaterial ) {

          offset ++;

        }

        // to get face <=> uv index correspondence

        fi = geometry.faces.length;

        if ( hasFaceVertexUv ) {

          for ( i = 0; i < nUvLayers; i ++ ) {

            uvLayer = json.uvs[ i ];

            geometry.faceVertexUvs[ i ][ fi ] = [];

            for ( j = 0; j < 3; j ++ ) {

              uvIndex = faces[ offset ++ ];

              u = uvLayer[ uvIndex * 2 ];
              v = uvLayer[ uvIndex * 2 + 1 ];

              uv = new THREE.Vector2( u, v );

              geometry.faceVertexUvs[ i ][ fi ].push( uv );

            }

          }

        }

        if ( hasFaceNormal ) {

          normalIndex = faces[ offset ++ ] * 3;

          face.normal.set(
            normals[ normalIndex ++ ],
            normals[ normalIndex ++ ],
            normals[ normalIndex ]
          );

        }

        if ( hasFaceVertexNormal ) {

          for ( i = 0; i < 3; i ++ ) {

            normalIndex = faces[ offset ++ ] * 3;

            normal = new THREE.Vector3(
              normals[ normalIndex ++ ],
              normals[ normalIndex ++ ],
              normals[ normalIndex ]
            );

            face.vertexNormals.push( normal );

          }

        }


        if ( hasFaceColor ) {

          colorIndex = faces[ offset ++ ];
          face.color.setHex( colors[ colorIndex ] );

        }


        if ( hasFaceVertexColor ) {

          for ( i = 0; i < 3; i ++ ) {

            colorIndex = faces[ offset ++ ];
            face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

          }

        }

        geometry.faces.push( face );

      }

    }

  }

  function parseSkin() {
    var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

    if ( json.skinWeights ) {

      for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

        var x =                               json.skinWeights[ i     ];
        var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
        var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
        var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

        geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

      }

    }

    if ( json.skinIndices ) {

      for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

        var a =                               json.skinIndices[ i     ];
        var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
        var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
        var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

        geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

      }

    }

    geometry.bones = json.bones;

    if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

      console.warn( 'THREE.JSONLoader: When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
          geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

    }


    // could change this to json.animations[0] or remove completely

    geometry.animation = json.animation;
    geometry.animations = json.animations;

  }

  function parseMorphing( scale ) {

    if ( json.morphTargets !== undefined ) {

      var i, l, v, vl, dstVertices, srcVertices;

      for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

        geometry.morphTargets[ i ] = {};
        geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
        geometry.morphTargets[ i ].vertices = [];

        dstVertices = geometry.morphTargets[ i ].vertices;
        srcVertices = json.morphTargets [ i ].vertices;

        for ( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

          var vertex = new THREE.Vector3();
          vertex.x = srcVertices[ v ] * scale;
          vertex.y = srcVertices[ v + 1 ] * scale;
          vertex.z = srcVertices[ v + 2 ] * scale;

          dstVertices.push( vertex );

        }

      }

    }

    if ( json.morphColors !== undefined ) {

      var i, l, c, cl, dstColors, srcColors, color;

      for ( i = 0, l = json.morphColors.length; i < l; i ++ ) {

        geometry.morphColors[ i ] = {};
        geometry.morphColors[ i ].name = json.morphColors[ i ].name;
        geometry.morphColors[ i ].colors = [];

        dstColors = geometry.morphColors[ i ].colors;
        srcColors = json.morphColors [ i ].colors;

        for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

          color = new THREE.Color( 0xffaa00 );
          color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
          dstColors.push( color );

        }

      }

    }

  }

  if ( json.materials === undefined || json.materials.length === 0 ) {

    return { geometry: geometry };

  } else {

    var materials = this.initMaterials( json.materials, texturePath );

    if ( this.needsTangents( materials ) ) {

      geometry.computeTangents();

    }

    return { geometry: geometry, materials: materials };

  }

};

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

  var scope = this;

  var loaded = 0, total = 0;

  this.onLoad = onLoad;
  this.onProgress = onProgress;
  this.onError = onError;

  this.itemStart = function ( url ) {

    total ++;

  };

  this.itemEnd = function ( url ) {

    loaded ++;

    if ( scope.onProgress !== undefined ) {

      scope.onProgress( url, loaded, total );

    }

    if ( loaded === total && scope.onLoad !== undefined ) {

      scope.onLoad();

    }

  };

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

  constructor: THREE.BufferGeometryLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var geometry = new THREE.BufferGeometry();

    var attributes = json.data.attributes;

    for ( var key in attributes ) {

      var attribute = attributes[ key ];
      var typedArray = new self[ attribute.type ]( attribute.array );

      geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize ) );

    }

    var offsets = json.data.offsets;

    if ( offsets !== undefined ) {

      geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

    }

    var boundingSphere = json.data.boundingSphere;

    if ( boundingSphere !== undefined ) {

      var center = new THREE.Vector3();

      if ( boundingSphere.center !== undefined ) {

        center.fromArray( boundingSphere.center );

      }

      geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

    }

    return geometry;

  }

};

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

  constructor: THREE.MaterialLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      onLoad( scope.parse( JSON.parse( text ) ) );

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json ) {

    var material = new THREE[ json.type ];

    if ( json.color !== undefined ) material.color.setHex( json.color );
    if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
    if ( json.specular !== undefined ) material.specular.setHex( json.specular );
    if ( json.shininess !== undefined ) material.shininess = json.shininess;
    if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
    if ( json.attributes !== undefined ) material.attributes = json.attributes;
    if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
    if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
    if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
    if ( json.shading !== undefined ) material.shading = json.shading;
    if ( json.blending !== undefined ) material.blending = json.blending;
    if ( json.side !== undefined ) material.side = json.side;
    if ( json.opacity !== undefined ) material.opacity = json.opacity;
    if ( json.transparent !== undefined ) material.transparent = json.transparent;
    if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
    if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;

    // for PointCloudMaterial
    if ( json.size !== undefined ) material.size = json.size;
    if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

    if ( json.materials !== undefined ) {

      for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

        material.materials.push( this.parse( json.materials[ i ] ) );

      }

    }

    return material;

  }

};

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
  this.texturePath = '';

};

THREE.ObjectLoader.prototype = {

  constructor: THREE.ObjectLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    if ( this.texturePath === '' ) {

      this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

    }

    var scope = this;

    var loader = new THREE.XHRLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( text ) {

      scope.parse( JSON.parse( text ), onLoad );

    }, onProgress, onError );

  },

  setTexturePath: function ( value ) {

    this.texturePath = value;

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  },

  parse: function ( json, onLoad ) {

    var geometries = this.parseGeometries( json.geometries );

    var images = this.parseImages( json.images, function () {

      if ( onLoad !== undefined ) onLoad( object );

    } );

    var textures  = this.parseTextures( json.textures, images );
    var materials = this.parseMaterials( json.materials, textures );
    var object = this.parseObject( json.object, geometries, materials );

    if ( json.images === undefined || json.images.length === 0 ) {

      if ( onLoad !== undefined ) onLoad( object );

    }

    return object;

  },

  parseGeometries: function ( json ) {

    var geometries = {};

    if ( json !== undefined ) {

      var geometryLoader = new THREE.JSONLoader();
      var bufferGeometryLoader = new THREE.BufferGeometryLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var geometry;
        var data = json[ i ];

        switch ( data.type ) {

          case 'PlaneGeometry':
          case 'PlaneBufferGeometry':

            geometry = new THREE[ data.type ](
              data.width,
              data.height,
              data.widthSegments,
              data.heightSegments
            );

            break;

          case 'BoxGeometry':
          case 'CubeGeometry': // backwards compatible

            geometry = new THREE.BoxGeometry(
              data.width,
              data.height,
              data.depth,
              data.widthSegments,
              data.heightSegments,
              data.depthSegments
            );

            break;

          case 'CircleGeometry':

            geometry = new THREE.CircleGeometry(
              data.radius,
              data.segments
            );

            break;

          case 'CylinderGeometry':

            geometry = new THREE.CylinderGeometry(
              data.radiusTop,
              data.radiusBottom,
              data.height,
              data.radialSegments,
              data.heightSegments,
              data.openEnded
            );

            break;

          case 'SphereGeometry':

            geometry = new THREE.SphereGeometry(
              data.radius,
              data.widthSegments,
              data.heightSegments,
              data.phiStart,
              data.phiLength,
              data.thetaStart,
              data.thetaLength
            );

            break;

          case 'IcosahedronGeometry':

            geometry = new THREE.IcosahedronGeometry(
              data.radius,
              data.detail
            );

            break;

          case 'TorusGeometry':

            geometry = new THREE.TorusGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.arc
            );

            break;

          case 'TorusKnotGeometry':

            geometry = new THREE.TorusKnotGeometry(
              data.radius,
              data.tube,
              data.radialSegments,
              data.tubularSegments,
              data.p,
              data.q,
              data.heightScale
            );

            break;

          case 'BufferGeometry':

            geometry = bufferGeometryLoader.parse( data );

            break;

          case 'Geometry':

            geometry = geometryLoader.parse( data.data ).geometry;

            break;

          case 'TextGeometry':

            geometry = new THREE.TextGeometry(
              data.text,
              data.data
            );

            break;

        }

        geometry.uuid = data.uuid;

        if ( data.name !== undefined ) geometry.name = data.name;

        geometries[ data.uuid ] = geometry;

      }

    }

    return geometries;

  },

  parseMaterials: function ( json, textures ) {

    var materials = {};

    if ( json !== undefined ) {

      var getTexture = function ( name ) {

        if ( textures[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined texture', name );

        }

        return textures[ name ];

      };

      var loader = new THREE.MaterialLoader();

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var data = json[ i ];
        var material = loader.parse( data );

        material.uuid = data.uuid;

        if ( data.depthTest !== undefined ) material.depthTest = data.depthTest;
        if ( data.depthWrite !== undefined ) material.depthWrite = data.depthWrite;

        if ( data.name !== undefined ) material.name = data.name;

        if ( data.map !== undefined ) material.map = getTexture( data.map );

        if ( data.alphaMap !== undefined ) {

          material.alphaMap = getTexture( data.alphaMap );
          material.transparent = true;

        }

        if ( data.bumpMap !== undefined ) material.bumpMap = getTexture( data.bumpMap );
        if ( data.bumpScale !== undefined ) material.bumpScale = data.bumpScale;

        if ( data.normalMap !== undefined ) material.normalMap = getTexture( data.normalMap );
        if ( data.normalScale ) material.normalScale = new THREE.Vector2( data.normalScale, data.normalScale );

        if ( data.specularMap !== undefined ) material.specularMap = getTexture( data.specularMap );

        if ( data.envMap !== undefined ) {

          material.envMap = getTexture( data.envMap );
          material.combine = THREE.MultiplyOperation;

        }

        if ( data.reflectivity ) material.reflectivity = data.reflectivity;

        if ( data.lightMap !== undefined ) material.lightMap = getTexture( data.lightMap );
        if ( data.lightMapIntensity !== undefined ) material.lightMapIntensity = data.lightMapIntensity;

        if ( data.aoMap !== undefined ) material.aoMap = getTexture( data.aoMap );
        if ( data.aoMapIntensity !== undefined ) material.aoMapIntensity = data.aoMapIntensity;

        materials[ data.uuid ] = material;

      }

    }

    return materials;

  },

  parseImages: function ( json, onLoad ) {

    var scope = this;
    var images = {};

    if ( json !== undefined && json.length > 0 ) {

      var manager = new THREE.LoadingManager( onLoad );

      var loader = new THREE.ImageLoader( manager );
      loader.setCrossOrigin( this.crossOrigin );

      var loadImage = function ( url ) {

        scope.manager.itemStart( url );

        return loader.load( url, function () {

          scope.manager.itemEnd( url );

        } );

      };

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var image = json[ i ];
        images[ image.uuid ] = loadImage( image.url );

      }

    }

    return images;

  },

  parseTextures: function ( json, images ) {

    function parseConstant( value ) {

      if ( typeof( value ) === 'number' ) return value;

      console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

      return THREE[ value ];

    }

    var textures = {};

    if ( json !== undefined ) {

      for ( var i = 0, l = json.length; i < l; i ++ ) {

        var data = json[ i ];

        if ( data.image === undefined ) {

          console.warn( 'THREE.ObjectLoader: No "image" speficied for', data.uuid );

        }

        if ( images[ data.image ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

        }

        var texture = new THREE.Texture( images[ data.image ] );
        texture.needsUpdate = true;

        texture.uuid = data.uuid;

        if ( data.name !== undefined ) texture.name = data.name;
        if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
        if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
        if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
        if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
        if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
        if ( Array.isArray( data.wrap ) ) {

          texture.wrapS = parseConstant( data.wrap[ 0 ] );
          texture.wrapT = parseConstant( data.wrap[ 1 ] );

        }

        textures[ data.uuid ] = texture;

      }

    }

    return textures;

  },

  parseObject: function () {

    var matrix = new THREE.Matrix4();

    return function ( data, geometries, materials ) {

      var object;

      var getGeometry = function ( name ) {

        if ( geometries[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

        }

        return geometries[ name ];

      };

      var getMaterial = function ( name ) {

        if ( materials[ name ] === undefined ) {

          console.warn( 'THREE.ObjectLoader: Undefined material', name );

        }

        return materials[ name ];

      };

      switch ( data.type ) {

        case 'Scene':

          object = new THREE.Scene();

          break;

        case 'PerspectiveCamera':

          object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

          break;

        case 'OrthographicCamera':

          object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

          break;

        case 'AmbientLight':

          object = new THREE.AmbientLight( data.color );

          break;

        case 'DirectionalLight':

          object = new THREE.DirectionalLight( data.color, data.intensity );

          break;

        case 'PointLight':

          object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

          break;

        case 'SpotLight':

          object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent, data.decay );

          break;

        case 'HemisphereLight':

          object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

          break;

        case 'Mesh':

          object = new THREE.Mesh( getGeometry( data.geometry ), getMaterial( data.material ) );

          break;

        case 'Line':

          object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

          break;

        case 'PointCloud':

          object = new THREE.PointCloud( getGeometry( data.geometry ), getMaterial( data.material ) );

          break;

        case 'Sprite':

          object = new THREE.Sprite( getMaterial( data.material ) );

          break;

        case 'Group':

          object = new THREE.Group();

          break;

        default:

          object = new THREE.Object3D();

      }

      object.uuid = data.uuid;

      if ( data.name !== undefined ) object.name = data.name;
      if ( data.matrix !== undefined ) {

        matrix.fromArray( data.matrix );
        matrix.decompose( object.position, object.quaternion, object.scale );

      } else {

        if ( data.position !== undefined ) object.position.fromArray( data.position );
        if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
        if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

      }

      if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
      if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

      if ( data.visible !== undefined ) object.visible = data.visible;
      if ( data.userData !== undefined ) object.userData = data.userData;

      if ( data.children !== undefined ) {

        for ( var child in data.children ) {

          object.add( this.parseObject( data.children[ child ], geometries, materials ) );

        }

      }

      return object;

    }

  }()

};

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

  this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

  constructor: THREE.TextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var loader = new THREE.ImageLoader( scope.manager );
    loader.setCrossOrigin( this.crossOrigin );
    loader.load( url, function ( image ) {

      var texture = new THREE.Texture( image );
      texture.needsUpdate = true;

      if ( onLoad !== undefined ) {

        onLoad( texture );

      }

    }, onProgress, onError );

  },

  setCrossOrigin: function ( value ) {

    this.crossOrigin = value;

  }

};

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function () {

  // override in sub classes
  this._parser = null;

};

THREE.BinaryTextureLoader.prototype = {

  constructor: THREE.BinaryTextureLoader,

  load: function ( url, onLoad, onProgress, onError ) {

    var scope = this;

    var texture = new THREE.DataTexture( );

    var loader = new THREE.XHRLoader();
    loader.setResponseType( 'arraybuffer' );

    loader.load( url, function ( buffer ) {

      var texData = scope._parser( buffer );

      if ( !texData ) return;

      if ( undefined !== texData.image ) {

        texture.image = texData.image;

      } else if ( undefined !== texData.data ) {

        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;

      }

      texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
      texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

      texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
      texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

      texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

      if ( undefined !== texData.format ) {

        texture.format = texData.format;

      }
      if ( undefined !== texData.type ) {

        texture.type = texData.type;

      }

      if ( undefined !== texData.mipmaps ) {

        texture.mipmaps = texData.mipmaps;

      }

      if ( 1 === texData.mipmapCount ) {

        texture.minFilter = THREE.LinearFilter;

      }

      texture.needsUpdate = true;

      if ( onLoad ) onLoad( texture, texData );

    }, onProgress, onError );


    return texture;

  }

};

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function () {

  // override in sub classes
  this._parser = null;

};


THREE.CompressedTextureLoader.prototype = {

  constructor: THREE.CompressedTextureLoader,

  load: function ( url, onLoad, onError ) {

    var scope = this;

    var images = [];

    var texture = new THREE.CompressedTexture();
    texture.image = images;

    var loader = new THREE.XHRLoader();
    loader.setResponseType( 'arraybuffer' );

    if ( Array.isArray( url ) ) {

      var loaded = 0;

      var loadTexture = function ( i ) {

        loader.load( url[ i ], function ( buffer ) {

          var texDatas = scope._parser( buffer, true );

          images[ i ] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };

          loaded += 1;

          if ( loaded === 6 ) {

            if (texDatas.mipmapCount === 1)
              texture.minFilter = THREE.LinearFilter;

            texture.format = texDatas.format;
            texture.needsUpdate = true;

            if ( onLoad ) onLoad( texture );

          }

        } );

      };

      for ( var i = 0, il = url.length; i < il; ++ i ) {

        loadTexture( i );

      }

    } else {

      // compressed cubemap texture stored in a single DDS file

      loader.load( url, function ( buffer ) {

        var texDatas = scope._parser( buffer, true );

        if ( texDatas.isCubemap ) {

          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

          for ( var f = 0; f < faces; f ++ ) {

            images[ f ] = { mipmaps : [] };

            for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

              images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
              images[ f ].format = texDatas.format;
              images[ f ].width = texDatas.width;
              images[ f ].height = texDatas.height;

            }

          }

        } else {

          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;

        }

        if ( texDatas.mipmapCount === 1 ) {

          texture.minFilter = THREE.LinearFilter;

        }

        texture.format = texDatas.format;
        texture.needsUpdate = true;

        if ( onLoad ) onLoad( texture );

      } );

    }

    return texture;

  }

};

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

  Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.type = 'Material';

  this.side = THREE.FrontSide;

  this.opacity = 1;
  this.transparent = false;

  this.blending = THREE.NormalBlending;

  this.blendSrc = THREE.SrcAlphaFactor;
  this.blendDst = THREE.OneMinusSrcAlphaFactor;
  this.blendEquation = THREE.AddEquation;
  this.blendSrcAlpha = null;
  this.blendDstAlpha = null;
  this.blendEquationAlpha = null;

  this.depthFunc = THREE.LessEqualDepth;
  this.depthTest = true;
  this.depthWrite = true;

  this.colorWrite = true;

  this.polygonOffset = false;
  this.polygonOffsetFactor = 0;
  this.polygonOffsetUnits = 0;

  this.alphaTest = 0;

  this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

  this.visible = true;

  this._needsUpdate = true;

};

THREE.Material.prototype = {

  constructor: THREE.Material,

  get needsUpdate () {

    return this._needsUpdate;

  },

  set needsUpdate ( value ) {

    if ( value === true ) this.update();

    this._needsUpdate = value;

  },

  setValues: function ( values ) {

    if ( values === undefined ) return;

    for ( var key in values ) {

      var newValue = values[ key ];

      if ( newValue === undefined ) {

        console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
        continue;

      }

      if ( key in this ) {

        var currentValue = this[ key ];

        if ( currentValue instanceof THREE.Color ) {

          currentValue.set( newValue );

        } else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

          currentValue.copy( newValue );

        } else if ( key === 'overdraw' ) {

          // ensure overdraw is backwards-compatable with legacy boolean type
          this[ key ] = Number( newValue );

        } else {

          this[ key ] = newValue;

        }

      }

    }

  },

  toJSON: function ( meta ) {

    var data = {
      metadata: {
        version: 4.4,
        type: 'Material',
        generator: 'Material.toJSON'
      }
    };

    // standard Material serialization
    data.uuid = this.uuid;
    data.type = this.type;
    if ( this.name !== '' ) data.name = this.name;

    if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();
    if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
    if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
    if ( this.shininess !== undefined ) data.shininess = this.shininess;

    if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
    if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
    if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
    if ( this.bumpMap instanceof THREE.Texture ) {
      data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
      data.bumpScale = this.bumpScale;
    }
    if ( this.normalMap instanceof THREE.Texture ) {
      data.normalMap = this.normalMap.toJSON( meta ).uuid;
      data.normalScale = this.normalScale; // Removed for now, causes issue in editor ui.js
    }
    if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
    if ( this.envMap instanceof THREE.Texture ) {
      data.envMap = this.envMap.toJSON( meta ).uuid;
      data.reflectivity = this.reflectivity; // Scale behind envMap
    }

    if ( this.size !== undefined ) data.size = this.size;
    if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

    if ( this.vertexColors !== undefined && this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;
    if ( this.shading !== undefined && this.shading !== THREE.SmoothShading ) data.shading = this.shading;
    if ( this.blending !== undefined && this.blending !== THREE.NormalBlending ) data.blending = this.blending;
    if ( this.side !== undefined && this.side !== THREE.FrontSide ) data.side = this.side;

    if ( this.opacity < 1 ) data.opacity = this.opacity;
    if ( this.transparent === true ) data.transparent = this.transparent;
    if ( this.wireframe === true ) data.wireframe = this.wireframe;

    return data;

  },

  clone: function ( material ) {

    if ( material === undefined ) material = new THREE.Material();

    material.name = this.name;

    material.side = this.side;

    material.opacity = this.opacity;
    material.transparent = this.transparent;

    material.blending = this.blending;

    material.blendSrc = this.blendSrc;
    material.blendDst = this.blendDst;
    material.blendEquation = this.blendEquation;
    material.blendSrcAlpha = this.blendSrcAlpha;
    material.blendDstAlpha = this.blendDstAlpha;
    material.blendEquationAlpha = this.blendEquationAlpha;

    material.depthFunc = this.depthFunc;
    material.depthTest = this.depthTest;
    material.depthWrite = this.depthWrite;

    material.polygonOffset = this.polygonOffset;
    material.polygonOffsetFactor = this.polygonOffsetFactor;
    material.polygonOffsetUnits = this.polygonOffsetUnits;

    material.alphaTest = this.alphaTest;

    material.overdraw = this.overdraw;

    material.visible = this.visible;

    return material;

  },

  update: function () {

    this.dispatchEvent( { type: 'update' } );

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineBasicMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;
  this.linecap = 'round';
  this.linejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.clone = function () {

  var material = new THREE.LineBasicMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.linewidth = this.linewidth;
  material.linecap = this.linecap;
  material.linejoin = this.linejoin;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'LineDashedMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.linewidth = 1;

  this.scale = 1;
  this.dashSize = 3;
  this.gapSize = 1;

  this.vertexColors = false;

  this.fog = true;

  this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.clone = function () {

  var material = new THREE.LineDashedMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.linewidth = this.linewidth;

  material.scale = this.scale;
  material.dashSize = this.dashSize;
  material.gapSize = this.gapSize;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshBasicMaterial';

  this.color = new THREE.Color( 0xffffff ); // emissive

  this.map = null;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.clone = function () {

  var material = new THREE.MeshBasicMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.map = this.map;

  material.aoMap = this.aoMap;
  material.aoMapIntensity = this.aoMapIntensity;

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;

  return material;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshLambertMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.emissive = new THREE.Color( 0x000000 );

  this.map = null;

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.clone = function () {

  var material = new THREE.MeshLambertMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.emissive.copy( this.emissive );

  material.map = this.map;

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshPhongMaterial';

  this.color = new THREE.Color( 0xffffff ); // diffuse
  this.emissive = new THREE.Color( 0x000000 );
  this.specular = new THREE.Color( 0x111111 );
  this.shininess = 30;

  this.metal = false;

  this.map = null;

  this.lightMap = null;
  this.lightMapIntensity = 1.0;

  this.aoMap = null;
  this.aoMapIntensity = 1.0;

  this.bumpMap = null;
  this.bumpScale = 1;

  this.normalMap = null;
  this.normalScale = new THREE.Vector2( 1, 1 );

  this.specularMap = null;

  this.alphaMap = null;

  this.envMap = null;
  this.combine = THREE.MultiplyOperation;
  this.reflectivity = 1;
  this.refractionRatio = 0.98;

  this.fog = true;

  this.shading = THREE.SmoothShading;

  this.wireframe = false;
  this.wireframeLinewidth = 1;
  this.wireframeLinecap = 'round';
  this.wireframeLinejoin = 'round';

  this.vertexColors = THREE.NoColors;

  this.skinning = false;
  this.morphTargets = false;
  this.morphNormals = false;

  this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.clone = function () {

  var material = new THREE.MeshPhongMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.emissive.copy( this.emissive );
  material.specular.copy( this.specular );
  material.shininess = this.shininess;

  material.metal = this.metal;

  material.map = this.map;

  material.lightMap = this.lightMap;
  material.lightMapIntensity = this.lightMapIntensity;

  material.aoMap = this.aoMap;
  material.aoMapIntensity = this.aoMapIntensity;

  material.bumpMap = this.bumpMap;
  material.bumpScale = this.bumpScale;

  material.normalMap = this.normalMap;
  material.normalScale.copy( this.normalScale );

  material.specularMap = this.specularMap;

  material.alphaMap = this.alphaMap;

  material.envMap = this.envMap;
  material.combine = this.combine;
  material.reflectivity = this.reflectivity;
  material.refractionRatio = this.refractionRatio;

  material.fog = this.fog;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;
  material.wireframeLinecap = this.wireframeLinecap;
  material.wireframeLinejoin = this.wireframeLinejoin;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;
  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'MeshDepthMaterial';

  this.morphTargets = false;
  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.clone = function () {

  var material = new THREE.MeshDepthMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  return material;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

  THREE.Material.call( this, parameters );

  this.type = 'MeshNormalMaterial';

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.morphTargets = false;

  this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.clone = function () {

  var material = new THREE.MeshNormalMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  return material;

};

// File:src/materials/MeshFaceMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

  console.error( 'THREE.MeshFaceMaterial has been removed.' );

  var material = Array.isArray( materials ) ? materials[ 0 ] : new THREE.MeshBasicMaterial();
  material.materials = []; // temporal workaround

  return material;

};

// File:src/materials/PointCloudMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.PointCloudMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'PointCloudMaterial';

  this.color = new THREE.Color( 0xffffff );

  this.map = null;

  this.size = 1;
  this.sizeAttenuation = true;

  this.vertexColors = THREE.NoColors;

  this.fog = true;

  this.setValues( parameters );

};

THREE.PointCloudMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointCloudMaterial.prototype.constructor = THREE.PointCloudMaterial;

THREE.PointCloudMaterial.prototype.clone = function () {

  var material = new THREE.PointCloudMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );

  material.map = this.map;

  material.size = this.size;
  material.sizeAttenuation = this.sizeAttenuation;

  material.vertexColors = this.vertexColors;

  material.fog = this.fog;

  return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = function ( parameters ) {

  console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointCloudMaterial.' );
  return new THREE.PointCloudMaterial( parameters );

};

THREE.ParticleSystemMaterial = function ( parameters ) {

  console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointCloudMaterial.' );
  return new THREE.PointCloudMaterial( parameters );

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'ShaderMaterial';

  this.defines = {};
  this.uniforms = {};
  this.attributes = [];

  this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
  this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

  this.shading = THREE.SmoothShading;

  this.linewidth = 1;

  this.wireframe = false;
  this.wireframeLinewidth = 1;

  this.fog = false; // set to use scene fog

  this.lights = false; // set to use scene lights

  this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

  this.skinning = false; // set to use skinning attribute streams

  this.morphTargets = false; // set to use morph targets
  this.morphNormals = false; // set to use morph normals

  this.derivatives = false; // set to use derivatives

  // When rendered geometry doesn't include these attributes but the material does,
  // use these default values in WebGL. This avoids errors when buffer data is missing.
  this.defaultAttributeValues = {
    'color': [ 1, 1, 1 ],
    'uv': [ 0, 0 ],
    'uv2': [ 0, 0 ]
  };

  this.index0AttributeName = undefined;

  if ( parameters !== undefined ) {

    if ( parameters.attributes !== undefined && Array.isArray( parameters.attributes ) === false ) {

      console.warn( 'THREE.ShaderMaterial: attributes should now be an array of attribute names.' );
      parameters.attributes = Object.keys( parameters.attributes );

    }

    this.setValues( parameters );

  }

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.clone = function ( material ) {

  if ( material === undefined ) material = new THREE.ShaderMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.fragmentShader = this.fragmentShader;
  material.vertexShader = this.vertexShader;

  material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

  material.attributes = this.attributes;
  material.defines = this.defines;

  material.shading = this.shading;

  material.wireframe = this.wireframe;
  material.wireframeLinewidth = this.wireframeLinewidth;

  material.fog = this.fog;

  material.lights = this.lights;

  material.vertexColors = this.vertexColors;

  material.skinning = this.skinning;

  material.morphTargets = this.morphTargets;
  material.morphNormals = this.morphNormals;

  return material;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

  var data = THREE.Material.prototype.toJSON.call( this, meta );

  data.uniforms = this.uniforms;
  data.attributes = this.attributes;
  data.vertexShader = this.vertexShader;
  data.fragmentShader = this.fragmentShader;

  return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

  THREE.ShaderMaterial.call( this, parameters );

  this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;

THREE.RawShaderMaterial.prototype.clone = function () {

  var material = new THREE.RawShaderMaterial();

  THREE.ShaderMaterial.prototype.clone.call( this, material );

  return material;

};

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  uvOffset: new THREE.Vector2(),
 *  uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

  THREE.Material.call( this );

  this.type = 'SpriteMaterial';

  this.color = new THREE.Color( 0xffffff );
  this.map = null;

  this.rotation = 0;

  this.fog = false;

  // set parameters

  this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.clone = function () {

  var material = new THREE.SpriteMaterial();

  THREE.Material.prototype.clone.call( this, material );

  material.color.copy( this.color );
  material.map = this.map;

  material.rotation = this.rotation;

  material.fog = this.fog;

  return material;

};

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

  this.uuid = THREE.Math.generateUUID();

  this.name = '';
  this.sourceFile = '';

  this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
  this.mipmaps = [];

  this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

  this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

  this.format = format !== undefined ? format : THREE.RGBAFormat;
  this.type = type !== undefined ? type : THREE.UnsignedByteType;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.generateMipmaps = true;
  this.premultiplyAlpha = false;
  this.flipY = true;
  this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

  this._needsUpdate = false;
  this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

  constructor: THREE.Texture,

  get needsUpdate () {

    return this._needsUpdate;

  },

  set needsUpdate ( value ) {

    if ( value === true ) this.update();

    this._needsUpdate = value;

  },

  clone: function ( texture ) {

    if ( texture === undefined ) texture = new THREE.Texture();

    texture.image = this.image;
    texture.mipmaps = this.mipmaps.slice( 0 );

    texture.mapping = this.mapping;

    texture.wrapS = this.wrapS;
    texture.wrapT = this.wrapT;

    texture.magFilter = this.magFilter;
    texture.minFilter = this.minFilter;

    texture.anisotropy = this.anisotropy;

    texture.format = this.format;
    texture.type = this.type;

    texture.offset.copy( this.offset );
    texture.repeat.copy( this.repeat );

    texture.generateMipmaps = this.generateMipmaps;
    texture.premultiplyAlpha = this.premultiplyAlpha;
    texture.flipY = this.flipY;
    texture.unpackAlignment = this.unpackAlignment;

    return texture;

  },

  toJSON: function ( meta ) {

    if ( meta.textures[ this.uuid ] !== undefined ) {

      return meta.textures[ this.uuid ];

    }

    var output = {
      metadata: {
        version: 4.4,
        type: 'Texture',
        generator: 'Texture.toJSON'
      },

      uuid: this.uuid,
      name: this.name,

      mapping: this.mapping,

      repeat: [ this.repeat.x, this.repeat.y ],
      offset: [ this.offset.x, this.offset.y ],
      wrap: [ this.wrapS, this.wrapT ],

      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy
    };

    if ( this.image !== undefined ) {

      // TODO: Move to THREE.Image

      var image = this.image;

      if ( image.uuid === undefined ) {

        image.uuid = THREE.Math.generateUUID(); // UGH

      }

      if ( meta.images[ this.image.uuid ] === undefined ) {

        var canvas = document.createElement( 'canvas' );
        canvas.width = image.width;
        canvas.height = image.height;

        var context = canvas.getContext( '2d' );
        context.drawImage( image, 0, 0, image.width, image.height );

        var src;

        if ( image.width > 2048 || image.height > 2048 ) {

          src = canvas.toDataURL( 'image/jpeg', 0.6 );

        } else {

          src = canvas.toDataURL( 'image/png' );

        }

        meta.images[ this.image.uuid ] = { uuid: this.image.uuid, url: src };

      }

      output.image = image.uuid;

    }

    meta.textures[ this.uuid ] = output;

    return output;

  },

  update: function () {

    this.dispatchEvent( { type: 'update' } );

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

  THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.images = images;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

THREE.CubeTexture.clone = function ( texture ) {

  if ( texture === undefined ) texture = new THREE.CubeTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  texture.images = this.images;

  return texture;

};

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { width: width, height: height };
  this.mipmaps = mipmaps;

  // no flipping for cube textures
  // (also flipping doesn't work for compressed textures )

  this.flipY = false;

  // can't generate mipmaps for compressed textures
  // mips must be embedded in DDS files

  this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

THREE.CompressedTexture.prototype.clone = function () {

  var texture = new THREE.CompressedTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  return texture;

};

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

THREE.DataTexture.prototype.clone = function () {

  var texture = new THREE.DataTexture();

  THREE.Texture.prototype.clone.call( this, texture );

  return texture;

};

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

  THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

  this.generateMipmaps = false;

  var scope = this;

  var update = function () {

    requestAnimationFrame( update );

    if ( video.readyState === video.HAVE_ENOUGH_DATA ) {

      scope.needsUpdate = true;

    }

  };

  update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

  THREE.Object3D.call( this );

  this.type = 'Group';

};

THREE.Group.prototype = Object.create( THREE.Object3D.prototype );
THREE.Group.prototype.constructor = THREE.Group;

// File:src/objects/PointCloud.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.PointCloud = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'PointCloud';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.PointCloudMaterial( { color: Math.random() * 0xffffff } );

};

THREE.PointCloud.prototype = Object.create( THREE.Object3D.prototype );
THREE.PointCloud.prototype.constructor = THREE.PointCloud;

THREE.PointCloud.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();

  return function ( raycaster, intersects ) {

    var object = this;
    var geometry = object.geometry;
    var threshold = raycaster.params.PointCloud.threshold;

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    if ( geometry.boundingBox !== null ) {

      if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

        return;

      }

    }

    var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
    var position = new THREE.Vector3();

    var testPoint = function ( point, index ) {

      var rayPointDistance = ray.distanceToPoint( point );

      if ( rayPointDistance < localThreshold ) {

        var intersectPoint = ray.closestPointToPoint( point );
        intersectPoint.applyMatrix4( object.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectPoint );

        if ( distance < raycaster.near || distance > raycaster.far ) return;

        intersects.push( {

          distance: distance,
          distanceToRay: rayPointDistance,
          point: intersectPoint.clone(),
          index: index,
          face: null,
          object: object

        } );

      }

    };

    if ( geometry instanceof THREE.BufferGeometry ) {

      var attributes = geometry.attributes;
      var positions = attributes.position.array;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          var offset = {
            start: 0,
            count: indices.length,
            index: 0
          };

          offsets = [ offset ];

        }

        for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

          var start = offsets[ oi ].start;
          var count = offsets[ oi ].count;
          var index = offsets[ oi ].index;

          for ( var i = start, il = start + count; i < il; i ++ ) {

            var a = index + indices[ i ];

            position.fromArray( positions, a * 3 );

            testPoint( position, a );

          }

        }

      } else {

        var pointCount = positions.length / 3;

        for ( var i = 0; i < pointCount; i ++ ) {

          position.set(
            positions[ 3 * i ],
            positions[ 3 * i + 1 ],
            positions[ 3 * i + 2 ]
          );

          testPoint( position, i );

        }

      }

    } else {

      var vertices = this.geometry.vertices;

      for ( var i = 0; i < vertices.length; i ++ ) {

        testPoint( vertices[ i ], i );

      }

    }

  };

}() );

THREE.PointCloud.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.PointCloud( this.geometry, this.material );

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

THREE.PointCloud.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();
  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {
    meta.materials[ this.material.uuid ] = this.material.toJSON();
  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// Backwards compatibility

THREE.ParticleSystem = function ( geometry, material ) {

  console.warn( 'THREE.ParticleSystem has been renamed to THREE.PointCloud.' );
  return new THREE.PointCloud( geometry, material );

};

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

  if ( mode === 1 ) {

    console.error( 'THREE.Line: THREE.LinePieces mode has been removed. Use THREE.LineSegments instead.' );

  }

  THREE.Object3D.call( this );

  this.type = 'Line';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );
THREE.Line.prototype.constructor = THREE.Line;

THREE.Line.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  return function ( raycaster, intersects ) {

    var precision = raycaster.linePrecision;
    var precisionSq = precision * precision;

    var geometry = this.geometry;

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    // Checking boundingSphere distance to ray

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( this.matrixWorld );

    if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

      return;

    }

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    var vStart = new THREE.Vector3();
    var vEnd = new THREE.Vector3();
    var interSegment = new THREE.Vector3();
    var interRay = new THREE.Vector3();
    var step = this instanceof THREE.LineSegments ? 2 : 1;

    if ( geometry instanceof THREE.BufferGeometry ) {

      var attributes = geometry.attributes;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var positions = attributes.position.array;
        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          offsets = [ { start: 0, count: indices.length, index: 0 } ];

        }

        for ( var oi = 0; oi < offsets.length; oi ++) {

          var start = offsets[ oi ].start;
          var count = offsets[ oi ].count;
          var index = offsets[ oi ].index;

          for ( var i = start; i < start + count - 1; i += step ) {

            var a = index + indices[ i ];
            var b = index + indices[ i + 1 ];

            vStart.fromArray( positions, a * 3 );
            vEnd.fromArray( positions, b * 3 );

            var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

            if ( distSq > precisionSq ) continue;

            var distance = ray.origin.distanceTo( interRay );

            if ( distance < raycaster.near || distance > raycaster.far ) continue;

            intersects.push( {

              distance: distance,
              // What do we want? intersection point on the ray or on the segment??
              // point: raycaster.ray.at( distance ),
              point: interSegment.clone().applyMatrix4( this.matrixWorld ),
              index: i,
              offsetIndex: oi,
              face: null,
              faceIndex: null,
              object: this

            } );

          }

        }

      } else {

        var positions = attributes.position.array;

        for ( var i = 0; i < positions.length / 3 - 1; i += step ) {

          vStart.fromArray( positions, 3 * i );
          vEnd.fromArray( positions, 3 * i + 3 );

          var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

          if ( distSq > precisionSq ) continue;

          var distance = ray.origin.distanceTo( interRay );

          if ( distance < raycaster.near || distance > raycaster.far ) continue;

          intersects.push( {

            distance: distance,
            // What do we want? intersection point on the ray or on the segment??
            // point: raycaster.ray.at( distance ),
            point: interSegment.clone().applyMatrix4( this.matrixWorld ),
            index: i,
            face: null,
            faceIndex: null,
            object: this

          } );

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var vertices = geometry.vertices;
      var nbVertices = vertices.length;

      for ( var i = 0; i < nbVertices - 1; i += step ) {

        var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

        if ( distSq > precisionSq ) continue;

        var distance = ray.origin.distanceTo( interRay );

        if ( distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4( this.matrixWorld ),
          index: i,
          face: null,
          faceIndex: null,
          object: this

        } );

      }

    }

  };

}() );

THREE.Line.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE[ this.type ]( this.geometry, this.material );

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

THREE.Line.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON();
  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {
    meta.materials[ this.material.uuid ] = this.material.toJSON();
  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// DEPRECATED

THREE.LineStrip = 0;
THREE.LinePieces = 1;

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

  THREE.Line.call( this, geometry, material );

  this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.create( THREE.Line.prototype );
THREE.LineSegments.prototype.constructor = THREE.LineSegments;

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

  THREE.Object3D.call( this );

  this.type = 'Mesh';

  this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
  this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

  this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );
THREE.Mesh.prototype.constructor = THREE.Mesh;

THREE.Mesh.prototype.updateMorphTargets = function () {

  if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

    this.morphTargetBase = - 1;
    this.morphTargetForcedOrder = [];
    this.morphTargetInfluences = [];
    this.morphTargetDictionary = {};

    for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

      this.morphTargetInfluences.push( 0 );
      this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

    }

  }

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

  if ( this.morphTargetDictionary[ name ] !== undefined ) {

    return this.morphTargetDictionary[ name ];

  }

  console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

  return 0;

};


THREE.Mesh.prototype.raycast = ( function () {

  var inverseMatrix = new THREE.Matrix4();
  var ray = new THREE.Ray();
  var sphere = new THREE.Sphere();

  var vA = new THREE.Vector3();
  var vB = new THREE.Vector3();
  var vC = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    var geometry = this.geometry;

    // Checking boundingSphere distance to ray

    if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

    sphere.copy( geometry.boundingSphere );
    sphere.applyMatrix4( this.matrixWorld );

    if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

      return;

    }

    // Check boundingBox before continuing

    inverseMatrix.getInverse( this.matrixWorld );
    ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

    if ( geometry.boundingBox !== null ) {

      if ( ray.isIntersectionBox( geometry.boundingBox ) === false ) {

        return;

      }

    }

    if ( geometry instanceof THREE.BufferGeometry ) {

      var material = this.material;

      if ( material === undefined ) return;

      var attributes = geometry.attributes;

      var a, b, c;

      if ( attributes.index !== undefined ) {

        var indices = attributes.index.array;
        var positions = attributes.position.array;
        var offsets = geometry.offsets;

        if ( offsets.length === 0 ) {

          offsets = [ { start: 0, count: indices.length, index: 0 } ];

        }

        for ( var oi = 0, ol = offsets.length; oi < ol; ++ oi ) {

          var start = offsets[ oi ].start;
          var count = offsets[ oi ].count;
          var index = offsets[ oi ].index;

          for ( var i = start, il = start + count; i < il; i += 3 ) {

            a = index + indices[ i ];
            b = index + indices[ i + 1 ];
            c = index + indices[ i + 2 ];

            vA.fromArray( positions, a * 3 );
            vB.fromArray( positions, b * 3 );
            vC.fromArray( positions, c * 3 );

            if ( material.side === THREE.BackSide ) {

              var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

            } else {

              var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

            }

            if ( intersectionPoint === null ) continue;

            intersectionPoint.applyMatrix4( this.matrixWorld );

            var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

            if ( distance < raycaster.near || distance > raycaster.far ) continue;

            intersects.push( {

              distance: distance,
              point: intersectionPoint,
              face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
              faceIndex: null,
              object: this

            } );

          }

        }

      } else {

        var positions = attributes.position.array;

        for ( var i = 0, j = 0, il = positions.length; i < il; i += 3, j += 9 ) {

          a = i;
          b = i + 1;
          c = i + 2;

          vA.fromArray( positions, j );
          vB.fromArray( positions, j + 3 );
          vC.fromArray( positions, j + 6 );

          if ( material.side === THREE.BackSide ) {

            var intersectionPoint = ray.intersectTriangle( vC, vB, vA, true );

          } else {

            var intersectionPoint = ray.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

          }

          if ( intersectionPoint === null ) continue;

          intersectionPoint.applyMatrix4( this.matrixWorld );

          var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

          if ( distance < raycaster.near || distance > raycaster.far ) continue;

          intersects.push( {

            distance: distance,
            point: intersectionPoint,
            face: new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) ),
            faceIndex: null,
            object: this

          } );

        }

      }

    } else if ( geometry instanceof THREE.Geometry ) {

      var isFaceMaterial = this.material instanceof THREE.MeshFaceMaterial;
      var objectMaterials = isFaceMaterial === true ? this.material.materials : null;

      var a, b, c;

      var vertices = geometry.vertices;

      for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

        var face = geometry.faces[ f ];

        var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : this.material;

        if ( material === undefined ) continue;

        a = vertices[ face.a ];
        b = vertices[ face.b ];
        c = vertices[ face.c ];

        if ( material.morphTargets === true ) {

          var morphTargets = geometry.morphTargets;
          var morphInfluences = this.morphTargetInfluences;

          vA.set( 0, 0, 0 );
          vB.set( 0, 0, 0 );
          vC.set( 0, 0, 0 );

          for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

            var influence = morphInfluences[ t ];

            if ( influence === 0 ) continue;

            var targets = morphTargets[ t ].vertices;

            vA.x += ( targets[ face.a ].x - a.x ) * influence;
            vA.y += ( targets[ face.a ].y - a.y ) * influence;
            vA.z += ( targets[ face.a ].z - a.z ) * influence;

            vB.x += ( targets[ face.b ].x - b.x ) * influence;
            vB.y += ( targets[ face.b ].y - b.y ) * influence;
            vB.z += ( targets[ face.b ].z - b.z ) * influence;

            vC.x += ( targets[ face.c ].x - c.x ) * influence;
            vC.y += ( targets[ face.c ].y - c.y ) * influence;
            vC.z += ( targets[ face.c ].z - c.z ) * influence;

          }

          vA.add( a );
          vB.add( b );
          vC.add( c );

          a = vA;
          b = vB;
          c = vC;

        }

        if ( material.side === THREE.BackSide ) {

          var intersectionPoint = ray.intersectTriangle( c, b, a, true );

        } else {

          var intersectionPoint = ray.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

        }

        if ( intersectionPoint === null ) continue;

        intersectionPoint.applyMatrix4( this.matrixWorld );

        var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

        if ( distance < raycaster.near || distance > raycaster.far ) continue;

        intersects.push( {

          distance: distance,
          point: intersectionPoint,
          face: face,
          faceIndex: f,
          object: this

        } );

      }

    }

  };

}() );

THREE.Mesh.prototype.clone = function ( object, recursive ) {

  if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

  THREE.Object3D.prototype.clone.call( this, object, recursive );

  return object;

};

THREE.Mesh.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta geometries cache
  if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
    meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
  }

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {
    meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
  }

  data.object.geometry = this.geometry.uuid;
  data.object.material = this.material.uuid;

  return data;

};

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

  THREE.Object3D.call( this );

  this.type = 'Bone';

  this.skin = skin;

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );
THREE.Bone.prototype.constructor = THREE.Bone;

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

  this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

  this.identityMatrix = new THREE.Matrix4();

  // copy the bone array

  bones = bones || [];

  this.bones = bones.slice( 0 );

  // create a bone texture or an array of floats

  if ( this.useVertexTexture ) {

    // layout (1 matrix = 4 pixels)
    //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
    //  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
    //       16x16 pixel texture max   64 bones (16 * 16 / 4)
    //       32x32 pixel texture max  256 bones (32 * 32 / 4)
    //       64x64 pixel texture max 1024 bones (64 * 64 / 4)

    var size;

    if ( this.bones.length > 256 )
      size = 64;
    else if ( this.bones.length > 64 )
      size = 32;
    else if ( this.bones.length > 16 )
      size = 16;
    else
      size = 8;

    this.boneTextureWidth = size;
    this.boneTextureHeight = size;

    this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
    this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
    this.boneTexture.minFilter = THREE.NearestFilter;
    this.boneTexture.magFilter = THREE.NearestFilter;
    this.boneTexture.generateMipmaps = false;
    this.boneTexture.flipY = false;

  } else {

    this.boneMatrices = new Float32Array( 16 * this.bones.length );

  }

  // use the supplied bone inverses or calculate the inverses

  if ( boneInverses === undefined ) {

    this.calculateInverses();

  } else {

    if ( this.bones.length === boneInverses.length ) {

      this.boneInverses = boneInverses.slice( 0 );

    } else {

      console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

      this.boneInverses = [];

      for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

        this.boneInverses.push( new THREE.Matrix4() );

      }

    }

  }

};

THREE.Skeleton.prototype.calculateInverses = function () {

  this.boneInverses = [];

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    var inverse = new THREE.Matrix4();

    if ( this.bones[ b ] ) {

      inverse.getInverse( this.bones[ b ].matrixWorld );

    }

    this.boneInverses.push( inverse );

  }

};

THREE.Skeleton.prototype.pose = function () {

  var bone;

  // recover the bind-time world matrices

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      bone.matrixWorld.getInverse( this.boneInverses[ b ] );

    }

  }

  // compute the local matrices, positions, rotations and scales

  for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

    bone = this.bones[ b ];

    if ( bone ) {

      if ( bone.parent ) {

        bone.matrix.getInverse( bone.parent.matrixWorld );
        bone.matrix.multiply( bone.matrixWorld );

      } else {

        bone.matrix.copy( bone.matrixWorld );

      }

      bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

    }

  }

};

THREE.Skeleton.prototype.update = ( function () {

  var offsetMatrix = new THREE.Matrix4();

  return function () {

    // flatten bone matrices to array

    for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

      // compute the offset between the current and the original transform

      var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

      offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
      offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

    }

    if ( this.useVertexTexture ) {

      this.boneTexture.needsUpdate = true;

    }

  };

} )();


// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'SkinnedMesh';

  this.bindMode = "attached";
  this.bindMatrix = new THREE.Matrix4();
  this.bindMatrixInverse = new THREE.Matrix4();

  // init bones

  // TODO: remove bone creation as there is no reason (other than
  // convenience) for THREE.SkinnedMesh to do this.

  var bones = [];

  if ( this.geometry && this.geometry.bones !== undefined ) {

    var bone, gbone, p, q, s;

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

      gbone = this.geometry.bones[ b ];

      p = gbone.pos;
      q = gbone.rotq;
      s = gbone.scl;

      bone = new THREE.Bone( this );
      bones.push( bone );

      bone.name = gbone.name;
      bone.position.set( p[ 0 ], p[ 1 ], p[ 2 ] );
      bone.quaternion.set( q[ 0 ], q[ 1 ], q[ 2 ], q[ 3 ] );

      if ( s !== undefined ) {

        bone.scale.set( s[ 0 ], s[ 1 ], s[ 2 ] );

      } else {

        bone.scale.set( 1, 1, 1 );

      }

    }

    for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

      gbone = this.geometry.bones[ b ];

      if ( gbone.parent !== - 1 ) {

        bones[ gbone.parent ].add( bones[ b ] );

      } else {

        this.add( bones[ b ] );

      }

    }

  }

  this.normalizeSkinWeights();

  this.updateMatrixWorld( true );
  this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ) );

};


THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh;

THREE.SkinnedMesh.prototype.bind = function( skeleton, bindMatrix ) {

  this.skeleton = skeleton;

  if ( bindMatrix === undefined ) {

    this.updateMatrixWorld( true );

    bindMatrix = this.matrixWorld;

  }

  this.bindMatrix.copy( bindMatrix );
  this.bindMatrixInverse.getInverse( bindMatrix );

};

THREE.SkinnedMesh.prototype.pose = function () {

  this.skeleton.pose();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

  if ( this.geometry instanceof THREE.Geometry ) {

    for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

      var sw = this.geometry.skinWeights[ i ];

      var scale = 1.0 / sw.lengthManhattan();

      if ( scale !== Infinity ) {

        sw.multiplyScalar( scale );

      } else {

        sw.set( 1 ); // this will be normalized by the shader anyway

      }

    }

  } else {

    // skinning weights assumed to be normalized for THREE.BufferGeometry

  }

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function( force ) {

  THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

  if ( this.bindMode === "attached" ) {

    this.bindMatrixInverse.getInverse( this.matrixWorld );

  } else if ( this.bindMode === "detached" ) {

    this.bindMatrixInverse.getInverse( this.bindMatrix );

  } else {

    console.warn( 'THREE.SkinnedMesh unreckognized bindMode: ' + this.bindMode );

  }

};

THREE.SkinnedMesh.prototype.clone = function( object ) {

  if ( object === undefined ) {

    object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

  }

  THREE.Mesh.prototype.clone.call( this, object );

  return object;

};


// File:src/objects/MorphAnimMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.type = 'MorphAnimMesh';

  // API

  this.duration = 1000; // milliseconds
  this.mirroredLoop = false;
  this.time = 0;

  // internals

  this.lastKeyframe = 0;
  this.currentKeyframe = 0;

  this.direction = 1;
  this.directionBackwards = false;

  this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphAnimMesh.prototype.constructor = THREE.MorphAnimMesh;

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

  this.startKeyframe = start;
  this.endKeyframe = end;

  this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

  this.direction = 1;
  this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

  this.direction = - 1;
  this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

  var geometry = this.geometry;

  if ( ! geometry.animations ) geometry.animations = {};

  var firstAnimation, animations = geometry.animations;

  var pattern = /([a-z]+)_?(\d+)/;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var parts = morph.name.match( pattern );

    if ( parts && parts.length > 1 ) {

      var label = parts[ 1 ];

      if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: - Infinity };

      var animation = animations[ label ];

      if ( i < animation.start ) animation.start = i;
      if ( i > animation.end ) animation.end = i;

      if ( ! firstAnimation ) firstAnimation = label;

    }

  }

  geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

  if ( ! this.geometry.animations ) this.geometry.animations = {};

  this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

  var animation = this.geometry.animations[ label ];

  if ( animation ) {

    this.setFrameRange( animation.start, animation.end );
    this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
    this.time = 0;

  } else {

    console.warn( 'THREE.MorphAnimMesh: animation[' + label + '] undefined in .playAnimation()' );

  }

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

  var frameTime = this.duration / this.length;

  this.time += this.direction * delta;

  if ( this.mirroredLoop ) {

    if ( this.time > this.duration || this.time < 0 ) {

      this.direction *= - 1;

      if ( this.time > this.duration ) {

        this.time = this.duration;
        this.directionBackwards = true;

      }

      if ( this.time < 0 ) {

        this.time = 0;
        this.directionBackwards = false;

      }

    }

  } else {

    this.time = this.time % this.duration;

    if ( this.time < 0 ) this.time += this.duration;

  }

  var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

  if ( keyframe !== this.currentKeyframe ) {

    this.morphTargetInfluences[ this.lastKeyframe ] = 0;
    this.morphTargetInfluences[ this.currentKeyframe ] = 1;

    this.morphTargetInfluences[ keyframe ] = 0;

    this.lastKeyframe = this.currentKeyframe;
    this.currentKeyframe = keyframe;

  }

  var mix = ( this.time % frameTime ) / frameTime;

  if ( this.directionBackwards ) {

    mix = 1 - mix;

  }

  this.morphTargetInfluences[ this.currentKeyframe ] = mix;
  this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.interpolateTargets = function ( a, b, t ) {

  var influences = this.morphTargetInfluences;

  for ( var i = 0, l = influences.length; i < l; i ++ ) {

    influences[ i ] = 0;

  }

  if ( a > -1 ) influences[ a ] = 1 - t;
  if ( b > -1 ) influences[ b ] = t;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

  object.duration = this.duration;
  object.mirroredLoop = this.mirroredLoop;
  object.time = this.time;

  object.lastKeyframe = this.lastKeyframe;
  object.currentKeyframe = this.currentKeyframe;

  object.direction = this.direction;
  object.directionBackwards = this.directionBackwards;

  THREE.Mesh.prototype.clone.call( this, object );

  return object;

};

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

  THREE.Object3D.call( this );

  this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );
THREE.LOD.prototype.constructor = THREE.LOD;

THREE.LOD.prototype.addLevel = function ( object, distance ) {

  if ( distance === undefined ) distance = 0;

  distance = Math.abs( distance );

  for ( var l = 0; l < this.objects.length; l ++ ) {

    if ( distance < this.objects[ l ].distance ) {

      break;

    }

  }

  this.objects.splice( l, 0, { distance: distance, object: object } );
  this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

  for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

    if ( distance < this.objects[ i ].distance ) {

      break;

    }

  }

  return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distance = raycaster.ray.origin.distanceTo( matrixPosition );

    this.getObjectForDistance( distance ).raycast( raycaster, intersects );

  };

}() );

THREE.LOD.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();

  return function ( camera ) {

    if ( this.objects.length > 1 ) {

      v1.setFromMatrixPosition( camera.matrixWorld );
      v2.setFromMatrixPosition( this.matrixWorld );

      var distance = v1.distanceTo( v2 );

      this.objects[ 0 ].object.visible = true;

      for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

        if ( distance >= this.objects[ i ].distance ) {

          this.objects[ i - 1 ].object.visible = false;
          this.objects[ i     ].object.visible = true;

        } else {

          break;

        }

      }

      for ( ; i < l; i ++ ) {

        this.objects[ i ].object.visible = false;

      }

    }

  };

}();

THREE.LOD.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.LOD();

  THREE.Object3D.prototype.clone.call( this, object );

  for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
    var x = this.objects[ i ].object.clone();
    x.visible = i === 0;
    object.addLevel( x, this.objects[ i ].distance );
  }

  return object;

};

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

  var indices = new Uint16Array( [ 0, 1, 2,  0, 2, 3 ] );
  var vertices = new Float32Array( [ - 0.5, - 0.5, 0,   0.5, - 0.5, 0,   0.5, 0.5, 0,   - 0.5, 0.5, 0 ] );
  var uvs = new Float32Array( [ 0, 0,   1, 0,   1, 1,   0, 1 ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  return function ( material ) {

    THREE.Object3D.call( this );

    this.type = 'Sprite';

    this.geometry = geometry;
    this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

  };

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );
THREE.Sprite.prototype.constructor = THREE.Sprite;

THREE.Sprite.prototype.raycast = ( function () {

  var matrixPosition = new THREE.Vector3();

  return function ( raycaster, intersects ) {

    matrixPosition.setFromMatrixPosition( this.matrixWorld );

    var distance = raycaster.ray.distanceToPoint( matrixPosition );

    if ( distance > this.scale.x ) {

      return;

    }

    intersects.push( {

      distance: distance,
      point: this.position,
      face: null,
      object: this

    } );

  };

}() );

THREE.Sprite.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.Sprite( this.material );

  THREE.Object3D.prototype.clone.call( this, object );

  return object;

};

THREE.Sprite.prototype.toJSON = function ( meta ) {

  var data = THREE.Object3D.prototype.toJSON.call( this, meta );

  // only serialize if not in meta materials cache
  if ( meta.materials[ this.material.uuid ] === undefined ) {
    meta.materials[ this.material.uuid ] = this.material.toJSON();
  }

  data.object.material = this.material.uuid;

  return data;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

  THREE.Object3D.call( this );

  this.lensFlares = [];

  this.positionScreen = new THREE.Vector3();
  this.customUpdateCallback = undefined;

  if ( texture !== undefined ) {

    this.add( texture, size, distance, blending, color );

  }

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );
THREE.LensFlare.prototype.constructor = THREE.LensFlare;


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

  if ( size === undefined ) size = - 1;
  if ( distance === undefined ) distance = 0;
  if ( opacity === undefined ) opacity = 1;
  if ( color === undefined ) color = new THREE.Color( 0xffffff );
  if ( blending === undefined ) blending = THREE.NormalBlending;

  distance = Math.min( distance, Math.max( 0, distance ) );

  this.lensFlares.push( {
    texture: texture,       // THREE.Texture
    size: size,         // size in pixels (-1 = use texture.width)
    distance: distance,     // distance (0-1) from light source (0=at light source)
    x: 0, y: 0, z: 0,     // screen position (-1 => 1) z = 0 is ontop z = 1 is back
    scale: 1,           // scale
    rotation: 1,        // rotation
    opacity: opacity,     // opacity
    color: color,       // color
    blending: blending      // blending
  } );

};

/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

  var f, fl = this.lensFlares.length;
  var flare;
  var vecX = - this.positionScreen.x * 2;
  var vecY = - this.positionScreen.y * 2;

  for ( f = 0; f < fl; f ++ ) {

    flare = this.lensFlares[ f ];

    flare.x = this.positionScreen.x + vecX * flare.distance;
    flare.y = this.positionScreen.y + vecY * flare.distance;

    flare.wantedRotation = flare.x * Math.PI * 0.25;
    flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

  }

};


// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

  THREE.Object3D.call( this );

  this.type = 'Scene';

  this.fog = null;
  this.overrideMaterial = null;

  this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.clone = function ( object ) {

  if ( object === undefined ) object = new THREE.Scene();

  THREE.Object3D.prototype.clone.call( this, object );

  if ( this.fog !== null ) object.fog = this.fog.clone();
  if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

  object.autoUpdate = this.autoUpdate;
  object.matrixAutoUpdate = this.matrixAutoUpdate;

  return object;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

  this.name = '';

  this.color = new THREE.Color( color );

  this.near = ( near !== undefined ) ? near : 1;
  this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

  return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

  this.name = '';

  this.color = new THREE.Color( color );
  this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

  return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment'] = "#ifdef USE_ALPHAMAP\n\n  diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment'] = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment'] = "#ifdef ALPHATEST\n\n  if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment'] = "#ifdef USE_AOMAP\n\n  totalAmbientLight *= ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment'] = "#ifdef USE_AOMAP\n\n uniform sampler2D aoMap;\n  uniform float aoMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment'] = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n  uniform float bumpScale;\n\n  // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n    vec2 dSTdx = dFdx( vUv );\n   vec2 dSTdy = dFdy( vUv );\n\n   float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n    float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n    float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n    return vec2( dBx, dBy );\n\n  }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n    vec3 vSigmaX = dFdx( surf_pos );\n    vec3 vSigmaY = dFdy( surf_pos );\n    vec3 vN = surf_norm;    // normalized\n\n   vec3 R1 = cross( vSigmaY, vN );\n   vec3 R2 = cross( vN, vSigmaX );\n\n   float fDet = dot( vSigmaX, R1 );\n\n    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n    return normalize( abs( fDet ) * surf_norm - vGrad );\n\n  }\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment'] = "#ifdef USE_COLOR\n\n  diffuseColor.rgb *= vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment'] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex'] = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex'] = "#ifdef USE_COLOR\n\n  vColor.xyz = inputToLinear( color.xyz );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common'] = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nvec3 transformDirection( in vec3 normal, in mat4 matrix ) {\n\n  return normalize( ( matrix * vec4( normal, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\n  return normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n  float distance = dot( planeNormal, point - pointOnPlane );\n\n  return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n  return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\n\n if ( decayExponent > 0.0 ) {\n\n    return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n }\n\n return 1.0;\n\n}\n\nvec3 F_Schlick( in vec3 specularColor, in float dotLH ) {\n\n return ( 1.0 - specularColor ) * pow( 1.0 - dotLH, 5.0 ) + specularColor;\n\n}\n\nfloat G_BlinnPhong_Implicit( /* in float dotNL, in float dotNV */ ) {\n\n // geometry term is (n⋅l)(n⋅v) / 4(n⋅l)(n⋅v)\n\n  return 0.25;\n\n}\n\nfloat D_BlinnPhong( in float shininess, in float dotNH ) {\n\n // factor of 1/PI in distribution term omitted\n\n  return ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_BlinnPhong( in vec3 specularColor, in float shininess, in vec3 normal, in vec3 lightDir, in vec3 viewDir ) {\n\n  vec3 halfDir = normalize( lightDir + viewDir );\n\n //float dotNL = saturate( dot( normal, lightDir ) );\n  //float dotNV = saturate( dot( normal, viewDir ) );\n float dotNH = saturate( dot( normal, halfDir ) );\n float dotLH = saturate( dot( lightDir, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n  float D = D_BlinnPhong( shininess, dotNH );\n\n return F * G * D;\n\n}\n\nvec3 inputToLinear( in vec3 a ) {\n\n #ifdef GAMMA_INPUT\n\n    return pow( a, vec3( float( GAMMA_FACTOR ) ) );\n\n #else\n\n   return a;\n\n #endif\n\n}\n\nvec3 linearToOutput( in vec3 a ) {\n\n #ifdef GAMMA_OUTPUT\n\n   return pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\n #else\n\n   return a;\n\n #endif\n\n}\n";

// File:src/renderers/shaders/ShaderChunk/default_vertex.glsl

THREE.ShaderChunk[ 'default_vertex'] = "#ifdef USE_SKINNING\n\n vec4 mvPosition = modelViewMatrix * skinned;\n\n#elif defined( USE_MORPHTARGETS )\n\n vec4 mvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#else\n\n  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex'] = "#ifdef USE_SKINNING\n\n vec3 objectNormal = skinnedNormal.xyz;\n\n#elif defined( USE_MORPHNORMALS )\n\n vec3 objectNormal = morphedNormal;\n\n#else\n\n vec3 objectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n  objectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment'] = "#ifdef USE_ENVMAP\n\n  #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n    vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n   // Transforming Normal Vectors with the Inverse Transformation\n    vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n   #ifdef ENVMAP_MODE_REFLECTION\n\n     vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n   #else\n\n     vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n    #endif\n\n  #else\n\n   vec3 reflectVec = vReflect;\n\n #endif\n\n  #ifdef DOUBLE_SIDED\n   float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n #else\n   float flipNormal = 1.0;\n #endif\n\n  #ifdef ENVMAP_TYPE_CUBE\n   vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n #elif defined( ENVMAP_TYPE_EQUIREC )\n    vec2 sampleUV;\n    sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n   sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n   vec4 envColor = texture2D( envMap, sampleUV );\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n   vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n    vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n  #endif\n\n  envColor.xyz = inputToLinear( envColor.xyz );\n\n #ifdef ENVMAP_BLENDING_MULTIPLY\n\n   outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n  #elif defined( ENVMAP_BLENDING_MIX )\n\n    outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n  #elif defined( ENVMAP_BLENDING_ADD )\n\n    outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment'] = "#ifdef USE_ENVMAP\n\n uniform float reflectivity;\n #ifdef ENVMAP_TYPE_CUBE\n   uniform samplerCube envMap;\n #else\n   uniform sampler2D envMap;\n #endif\n  uniform float flipEnvMap;\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n    uniform float refractionRatio;\n\n  #else\n\n   varying vec3 vReflect;\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n varying vec3 vReflect;\n\n  uniform float refractionRatio;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex'] = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG )\n\n  vec3 worldNormal = transformDirection( objectNormal, modelMatrix );\n\n vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vReflect = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment'] = "#ifdef USE_FOG\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    float depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n #else\n\n   float depth = gl_FragCoord.z / gl_FragCoord.w;\n\n  #endif\n\n  #ifdef FOG_EXP2\n\n   float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\n  #else\n\n   float fogFactor = smoothstep( fogNear, fogFar, depth );\n\n #endif\n  \n  outgoingLight = mix( outgoingLight, fogColor, fogFactor );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment'] = "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n\n  #ifdef FOG_EXP2\n\n   uniform float fogDensity;\n\n #else\n\n   uniform float fogNear;\n    uniform float fogFar;\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment'] = "#ifdef USE_LIGHTMAP\n\n  totalAmbientLight += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment'] = "#ifdef USE_LIGHTMAP\n\n uniform sampler2D lightMap;\n uniform float lightMapIntensity;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_pars_vertex'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex'] = "vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n  vLightBack = vec3( 0.0 );\n\n#endif\n\nvec3 normal = normalize( transformedNormal );\n\n#if MAX_POINT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n   vec3 lightColor = pointLightColor[ i ];\n\n   vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n   vec3 lVector = lPosition.xyz - mvPosition.xyz;\n    vec3 lightDir = normalize( lVector );\n\n   // attenuation\n\n    float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n   // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n   #ifdef DOUBLE_SIDED\n\n     vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n    #endif\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n    vec3 lightColor = spotLightColor[ i ];\n\n    vec3 lightPosition = spotLightPosition[ i ];\n    vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz - mvPosition.xyz;\n    vec3 lightDir = normalize( lVector );\n\n   float spotEffect = dot( spotLightDirection[ i ], normalize( lightPosition - worldPosition.xyz ) );\n\n    if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n      spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n     // attenuation\n\n      float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n     attenuation *= spotEffect;\n\n      // diffuse\n\n      float dotProduct = dot( normal, lightDir );\n\n     vLightFront += lightColor * attenuation * saturate( dotProduct );\n\n     #ifdef DOUBLE_SIDED\n\n       vLightBack += lightColor * attenuation * saturate( - dotProduct );\n\n      #endif\n\n    }\n\n }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n for ( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n   vec3 lightColor = directionalLightColor[ i ];\n\n   vec3 lightDir = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n   // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   vLightFront += lightColor * saturate( dotProduct );\n\n   #ifdef DOUBLE_SIDED\n\n     vLightBack += lightColor * saturate( - dotProduct );\n\n    #endif\n\n  }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n    vec3 lightDir = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n    // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n   vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n   #ifdef DOUBLE_SIDED\n\n     float hemiDiffuseWeightBack = - 0.5 * dotProduct + 0.5;\n\n     vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n    #endif\n\n  }\n\n#endif\n\nvLightFront += ambientLightColor;\n\n#ifdef DOUBLE_SIDED\n\n vLightBack += ambientLightColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment'] = "#ifndef FLAT_SHADED\n\n  vec3 normal = normalize( vNormal );\n\n #ifdef DOUBLE_SIDED\n\n   normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n #endif\n\n#else\n\n vec3 fdx = dFdx( vViewPosition );\n vec3 fdy = dFdy( vViewPosition );\n vec3 normal = normalize( cross( fdx, fdy ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n normal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\nvec3 viewDir = normalize( vViewPosition );\n\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n\n#if MAX_POINT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n   vec3 lightColor = pointLightColor[ i ];\n\n   vec3 lightPosition = pointLightPosition[ i ];\n   vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n   vec3 lightDir = normalize( lVector );\n\n   // attenuation\n\n    float attenuation = calcLightAttenuation( length( lVector ), pointLightDistance[ i ], pointLightDecay[ i ] );\n\n   // diffuse\n\n    float cosineTerm = saturate( dot( normal, lightDir ) );\n\n   totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n   // specular\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n\n  }\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n  for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n    vec3 lightColor = spotLightColor[ i ];\n\n    vec3 lightPosition = spotLightPosition[ i ];\n    vec4 lPosition = viewMatrix * vec4( lightPosition, 1.0 );\n   vec3 lVector = lPosition.xyz + vViewPosition.xyz;\n   vec3 lightDir = normalize( lVector );\n\n   float spotEffect = dot( spotLightDirection[ i ], normalize( lightPosition - vWorldPosition ) );\n\n   if ( spotEffect > spotLightAngleCos[ i ] ) {\n\n      spotEffect = saturate( pow( saturate( spotEffect ), spotLightExponent[ i ] ) );\n\n     // attenuation\n\n      float attenuation = calcLightAttenuation( length( lVector ), spotLightDistance[ i ], spotLightDecay[ i ] );\n\n     attenuation *= spotEffect;\n\n      // diffuse\n\n      float cosineTerm = saturate( dot( normal, lightDir ) );\n\n     totalDiffuseLight += lightColor * attenuation * cosineTerm;\n\n     // specular\n\n     vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n      totalSpecularLight += brdf * specularStrength * lightColor * attenuation * cosineTerm;\n\n    }\n\n }\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n    vec3 lightColor = directionalLightColor[ i ];\n\n   vec3 lightDir = transformDirection( directionalLightDirection[ i ], viewMatrix );\n\n   // diffuse\n\n    float cosineTerm = saturate( dot( normal, lightDir ) );\n\n   totalDiffuseLight += lightColor * cosineTerm;\n\n   // specular\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * cosineTerm;\n\n  }\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n   vec3 lightDir = transformDirection( hemisphereLightDirection[ i ], viewMatrix );\n\n    // diffuse\n\n    float dotProduct = dot( normal, lightDir );\n\n   float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n   vec3 lightColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n    totalDiffuseLight += lightColor;\n\n    // specular (sky term only)\n\n   vec3 brdf = BRDF_BlinnPhong( specular, shininess, normal, lightDir, viewDir );\n\n    totalSpecularLight += brdf * specularStrength * lightColor * max( dotProduct, 0.0 );\n\n  }\n\n#endif\n\n#ifdef METAL\n\n outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight + emissive;\n\n#else\n\n  outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight + emissive;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment'] = "uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n  uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n  uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n  uniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n uniform float pointLightDecay[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n  uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n uniform float spotLightDecay[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n  varying vec3 vWorldPosition;\n\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n  varying vec3 vNormal;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_pars_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n  varying vec3 vWorldPosition;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_vertex.glsl

THREE.ShaderChunk[ 'lights_phong_vertex'] = "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n vWorldPosition = worldPosition.xyz;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/linear_to_gamma_fragment.glsl

THREE.ShaderChunk[ 'linear_to_gamma_fragment'] = "\n  outgoingLight = linearToOutput( outgoingLight );\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment'] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n  gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment'] = "#ifdef USE_LOGDEPTHBUF\n\n uniform float logDepthBufFC;\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    #extension GL_EXT_frag_depth : enable\n   varying float vFragDepth;\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n    varying float vFragDepth;\n\n #endif\n\n  uniform float logDepthBufFC;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex'] = "#ifdef USE_LOGDEPTHBUF\n\n  gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n  #ifdef USE_LOGDEPTHBUF_EXT\n\n    vFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n    gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n  #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment'] = "#ifdef USE_MAP\n\n  vec4 texelColor = texture2D( map, vUv );\n\n  texelColor.xyz = inputToLinear( texelColor.xyz );\n\n diffuseColor *= texelColor;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment'] = "#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment'] = "#ifdef USE_MAP\n\n diffuseColor *= texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment'] = "#ifdef USE_MAP\n\n  uniform vec4 offsetRepeat;\n  uniform sampler2D map;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex'] = "#ifdef USE_MORPHNORMALS\n\n vec3 morphedNormal = vec3( 0.0 );\n\n morphedNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n  morphedNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n  morphedNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n  morphedNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n  morphedNormal += normal;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex'] = "#ifdef USE_MORPHTARGETS\n\n  #ifndef USE_MORPHNORMALS\n\n  uniform float morphTargetInfluences[ 8 ];\n\n #else\n\n uniform float morphTargetInfluences[ 4 ];\n\n #endif\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex'] = "#ifdef USE_MORPHTARGETS\n\n vec3 morphed = vec3( 0.0 );\n morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n  morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n  morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n  morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n  #ifndef USE_MORPHNORMALS\n\n  morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n  morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n  morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n  morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n  #endif\n\n  morphed += position;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment'] = "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n  uniform vec2 normalScale;\n\n // Per-Pixel Tangent Space Normal Mapping\n // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n    vec3 q0 = dFdx( eye_pos.xyz );\n    vec3 q1 = dFdy( eye_pos.xyz );\n    vec2 st0 = dFdx( vUv.st );\n    vec2 st1 = dFdy( vUv.st );\n\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n   vec3 N = normalize( surf_norm );\n\n    vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n    mapN.xy = normalScale * mapN.xy;\n    mat3 tsn = mat3( S, T, N );\n   return normalize( tsn * mapN );\n\n }\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_fragment'] = "#ifdef USE_SHADOWMAP\n\n  #ifdef SHADOWMAP_DEBUG\n\n    vec3 frustumColors[3];\n    frustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n   frustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n   frustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n #endif\n\n  #ifdef SHADOWMAP_CASCADE\n\n    int inFrustumCount = 0;\n\n #endif\n\n  float fDepth;\n vec3 shadowColor = vec3( 1.0 );\n\n for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n   vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n       // if ( something && something ) breaks ATI OpenGL shader compiler\n        // if ( all( something, something ) ) using this instead\n\n    bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n    bool inFrustum = all( inFrustumVec );\n\n       // don't shadow pixels outside of light frustum\n       // use just first frustum (for cascades)\n        // don't shadow pixels behind far plane of light frustum\n\n    #ifdef SHADOWMAP_CASCADE\n\n      inFrustumCount += int( inFrustum );\n     bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n   #else\n\n     bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n    #endif\n\n    bool frustumTest = all( frustumTestVec );\n\n   if ( frustumTest ) {\n\n      shadowCoord.z += shadowBias[ i ];\n\n     #if defined( SHADOWMAP_TYPE_PCF )\n\n           // Percentage-close filtering\n           // (9 pixel kernel)\n           // http://fabiensanglard.net/shadowmappingPCF/\n\n        float shadow = 0.0;\n\n   /*\n            // nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n            // must enroll loop manually\n\n        for ( float y = -1.25; y <= 1.25; y += 1.25 )\n         for ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n           vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n                // doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n               //vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n           float fDepth = unpackDepth( rgbaDepth );\n\n            if ( fDepth < shadowCoord.z )\n             shadow += 1.0;\n\n        }\n\n       shadow /= 9.0;\n\n    */\n\n        const float shadowDelta = 1.0 / 9.0;\n\n        float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n        float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n        float dx0 = -1.25 * xPixelOffset;\n       float dy0 = -1.25 * yPixelOffset;\n       float dx1 = 1.25 * xPixelOffset;\n        float dy1 = 1.25 * yPixelOffset;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n        if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n       if ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n        shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n     #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n            // Percentage-close filtering\n           // (9 pixel kernel)\n           // http://fabiensanglard.net/shadowmappingPCF/\n\n        float shadow = 0.0;\n\n       float xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n        float yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n        float dx0 = -1.0 * xPixelOffset;\n        float dy0 = -1.0 * yPixelOffset;\n        float dx1 = 1.0 * xPixelOffset;\n       float dy1 = 1.0 * yPixelOffset;\n\n       mat3 shadowKernel;\n        mat3 depthKernel;\n\n       depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n        depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n        depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n        depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n        depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n       depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n        depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n        depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n        depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n        vec3 shadowZ = vec3( shadowCoord.z );\n       shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n       shadowKernel[0] *= vec3(0.25);\n\n        shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n       shadowKernel[1] *= vec3(0.25);\n\n        shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n       shadowKernel[2] *= vec3(0.25);\n\n        vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n       shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n       shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n       vec4 shadowValues;\n        shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n        shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n        shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n        shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n        shadow = dot( shadowValues, vec4( 1.0 ) );\n\n        shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n     #else\n\n       vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n       float fDepth = unpackDepth( rgbaDepth );\n\n        if ( fDepth < shadowCoord.z )\n\n   // spot with multiple shadows is darker\n\n         shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n    // spot with multiple shadows has the same color as single shadow spot\n\n    //          shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n      #endif\n\n    }\n\n\n   #ifdef SHADOWMAP_DEBUG\n\n      #ifdef SHADOWMAP_CASCADE\n\n        if ( inFrustum && inFrustumCount == 1 ) outgoingLight *= frustumColors[ i ];\n\n      #else\n\n       if ( inFrustum ) outgoingLight *= frustumColors[ i ];\n\n     #endif\n\n    #endif\n\n  }\n\n // NOTE: I am unsure if this is correct in linear space.  -bhouston, Dec 29, 2014\n shadowColor = inputToLinear( shadowColor );\n\n outgoingLight = outgoingLight * shadowColor;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment'] = "#ifdef USE_SHADOWMAP\n\n uniform sampler2D shadowMap[ MAX_SHADOWS ];\n uniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n  uniform float shadowDarkness[ MAX_SHADOWS ];\n  uniform float shadowBias[ MAX_SHADOWS ];\n\n  varying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n float unpackDepth( const in vec4 rgba_depth ) {\n\n   const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n    float depth = dot( rgba_depth, bit_shift );\n   return depth;\n\n }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex'] = "#ifdef USE_SHADOWMAP\n\n varying vec4 vShadowCoord[ MAX_SHADOWS ];\n uniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex'] = "#ifdef USE_SHADOWMAP\n\n  for( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n   vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n  }\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex'] = "#ifdef USE_SKINNING\n\n  mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex'] = "#ifdef USE_SKINNING\n\n uniform mat4 bindMatrix;\n  uniform mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n   uniform sampler2D boneTexture;\n    uniform int boneTextureWidth;\n   uniform int boneTextureHeight;\n\n    mat4 getBoneMatrix( const in float i ) {\n\n      float j = i * 4.0;\n      float x = mod( j, float( boneTextureWidth ) );\n      float y = floor( j / float( boneTextureWidth ) );\n\n     float dx = 1.0 / float( boneTextureWidth );\n     float dy = 1.0 / float( boneTextureHeight );\n\n      y = dy * ( y + 0.5 );\n\n     vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n      vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n      vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n      vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n      mat4 bone = mat4( v1, v2, v3, v4 );\n\n     return bone;\n\n    }\n\n #else\n\n   uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n\n   mat4 getBoneMatrix( const in float i ) {\n\n      mat4 bone = boneGlobalMatrices[ int(i) ];\n     return bone;\n\n    }\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex'] = "#ifdef USE_SKINNING\n\n  #ifdef USE_MORPHTARGETS\n\n vec4 skinVertex = bindMatrix * vec4( morphed, 1.0 );\n\n  #else\n\n vec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\n #endif\n\n  vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n  skinned += boneMatY * skinVertex * skinWeight.y;\n  skinned += boneMatZ * skinVertex * skinWeight.z;\n  skinned += boneMatW * skinVertex * skinWeight.w;\n  skinned  = bindMatrixInverse * skinned;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex'] = "#ifdef USE_SKINNING\n\n  mat4 skinMatrix = mat4( 0.0 );\n  skinMatrix += skinWeight.x * boneMatX;\n  skinMatrix += skinWeight.y * boneMatY;\n  skinMatrix += skinWeight.z * boneMatZ;\n  skinMatrix += skinWeight.w * boneMatW;\n  skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n  #ifdef USE_MORPHNORMALS\n\n vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n\n #else\n\n vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n\n  #endif\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment'] = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n\n#else\n\n  specularStrength = 1.0;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment'] = "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n  varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n  attribute vec2 uv2;\n varying vec2 vUv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex'] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n vUv2 = uv2;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n varying vec2 vUv;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n varying vec2 vUv;\n uniform vec4 offsetRepeat;\n\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex'] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n  vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex'] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n #ifdef USE_SKINNING\n\n   vec4 worldPosition = modelMatrix * skinned;\n\n #elif defined( USE_MORPHTARGETS )\n\n   vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n  #else\n\n   vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n #endif\n\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

  merge: function ( uniforms ) {

    var merged = {};

    for ( var u = 0; u < uniforms.length; u ++ ) {

      var tmp = this.clone( uniforms[ u ] );

      for ( var p in tmp ) {

        merged[ p ] = tmp[ p ];

      }

    }

    return merged;

  },

  clone: function ( uniforms_src ) {

    var uniforms_dst = {};

    for ( var u in uniforms_src ) {

      uniforms_dst[ u ] = {};

      for ( var p in uniforms_src[ u ] ) {

        var parameter_src = uniforms_src[ u ][ p ];

        if ( parameter_src instanceof THREE.Color ||
           parameter_src instanceof THREE.Vector2 ||
           parameter_src instanceof THREE.Vector3 ||
           parameter_src instanceof THREE.Vector4 ||
           parameter_src instanceof THREE.Matrix3 ||
           parameter_src instanceof THREE.Matrix4 ||
           parameter_src instanceof THREE.Texture ) {

          uniforms_dst[ u ][ p ] = parameter_src.clone();

        } else if ( Array.isArray( parameter_src ) ) {

          uniforms_dst[ u ][ p ] = parameter_src.slice();

        } else {

          uniforms_dst[ u ][ p ] = parameter_src;

        }

      }

    }

    return uniforms_dst;

  }

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

  common: {

    "diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },

    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

    "specularMap" : { type: "t", value: null },
    "alphaMap" : { type: "t", value: null },

    "envMap" : { type: "t", value: null },
    "flipEnvMap" : { type: "f", value: - 1 },
    "reflectivity" : { type: "f", value: 1.0 },
    "refractionRatio" : { type: "f", value: 0.98 }

  },

  aomap: {

    "aoMap" : { type: "t", value: null },
    "aoMapIntensity" : { type: "f", value: 1 },

  },

  lightmap: {

    "lightMap" : { type: "t", value: null },
    "lightMapIntensity" : { type: "f", value: 1 },

  },

  bump: {

    "bumpMap" : { type: "t", value: null },
    "bumpScale" : { type: "f", value: 1 }

  },

  normalmap: {

    "normalMap" : { type: "t", value: null },
    "normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
  },

  fog : {

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  lights: {

    "ambientLightColor" : { type: "fv", value: [] },

    "directionalLightDirection" : { type: "fv", value: [] },
    "directionalLightColor" : { type: "fv", value: [] },

    "hemisphereLightDirection" : { type: "fv", value: [] },
    "hemisphereLightSkyColor" : { type: "fv", value: [] },
    "hemisphereLightGroundColor" : { type: "fv", value: [] },

    "pointLightColor" : { type: "fv", value: [] },
    "pointLightPosition" : { type: "fv", value: [] },
    "pointLightDistance" : { type: "fv1", value: [] },
    "pointLightDecay" : { type: "fv1", value: [] },

    "spotLightColor" : { type: "fv", value: [] },
    "spotLightPosition" : { type: "fv", value: [] },
    "spotLightDirection" : { type: "fv", value: [] },
    "spotLightDistance" : { type: "fv1", value: [] },
    "spotLightAngleCos" : { type: "fv1", value: [] },
    "spotLightExponent" : { type: "fv1", value: [] },
    "spotLightDecay" : { type: "fv1", value: [] }

  },

  particle: {

    "psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
    "opacity" : { type: "f", value: 1.0 },
    "size" : { type: "f", value: 1.0 },
    "scale" : { type: "f", value: 1.0 },
    "map" : { type: "t", value: null },
    "offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

    "fogDensity" : { type: "f", value: 0.00025 },
    "fogNear" : { type: "f", value: 1 },
    "fogFar" : { type: "f", value: 2000 },
    "fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

  },

  shadowmap: {

    "shadowMap": { type: "tv", value: [] },
    "shadowMapSize": { type: "v2v", value: [] },

    "shadowBias" : { type: "fv1", value: [] },
    "shadowDarkness": { type: "fv1", value: [] },

    "shadowMatrix" : { type: "m4v", value: [] }

  }

};

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

  'basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],

      " #ifdef USE_ENVMAP",

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      " #endif",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );",
      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " vec3 totalAmbientLight = vec3( 1.0 );", // hardwired

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "aomap_fragment" ],

      " outgoingLight = diffuseColor.rgb * totalAmbientLight;", // simple shader

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],    // TODO: Shadows on an otherwise unlit surface doesn't make sense.

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'lambert': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) }
      }

    ] ),

    vertexShader: [

      "#define LAMBERT",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_lambert_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform float opacity;",

      "varying vec3 vLightFront;",

      "#ifdef DOUBLE_SIDED",

      " varying vec3 vLightBack;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],

      " #ifdef DOUBLE_SIDED",

          //"float isFront = float( gl_FrontFacing );",
          //"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

      "   if ( gl_FrontFacing )",
      "     outgoingLight += diffuseColor.rgb * vLightFront + emissive;",
      "   else",
      "     outgoingLight += diffuseColor.rgb * vLightBack + emissive;",

      " #else",

      "   outgoingLight += diffuseColor.rgb * vLightFront + emissive;",

      " #endif",

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'phong': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "aomap" ],
      THREE.UniformsLib[ "lightmap" ],
      THREE.UniformsLib[ "bump" ],
      THREE.UniformsLib[ "normalmap" ],
      THREE.UniformsLib[ "fog" ],
      THREE.UniformsLib[ "lights" ],
      THREE.UniformsLib[ "shadowmap" ],

      {
        "emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
        "specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
        "shininess": { type: "f", value: 30 }
      }

    ] ),

    vertexShader: [

      "#define PHONG",

      "varying vec3 vViewPosition;",

      "#ifndef FLAT_SHADED",

      " varying vec3 vNormal;",

      "#endif",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "uv_pars_vertex" ],
      THREE.ShaderChunk[ "uv2_pars_vertex" ],
      THREE.ShaderChunk[ "envmap_pars_vertex" ],
      THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "uv_vertex" ],
        THREE.ShaderChunk[ "uv2_vertex" ],
        THREE.ShaderChunk[ "color_vertex" ],

        THREE.ShaderChunk[ "morphnormal_vertex" ],
        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "skinnormal_vertex" ],
        THREE.ShaderChunk[ "defaultnormal_vertex" ],

      "#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

      " vNormal = normalize( transformedNormal );",

      "#endif",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      " vViewPosition = -mvPosition.xyz;",

        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "envmap_vertex" ],
        THREE.ShaderChunk[ "lights_phong_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "#define PHONG",

      "uniform vec3 diffuse;",
      "uniform vec3 emissive;",
      "uniform vec3 specular;",
      "uniform float shininess;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "uv_pars_fragment" ],
      THREE.ShaderChunk[ "uv2_pars_fragment" ],
      THREE.ShaderChunk[ "map_pars_fragment" ],
      THREE.ShaderChunk[ "alphamap_pars_fragment" ],
      THREE.ShaderChunk[ "aomap_pars_fragment" ],
      THREE.ShaderChunk[ "lightmap_pars_fragment" ],
      THREE.ShaderChunk[ "envmap_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
      THREE.ShaderChunk[ "normalmap_pars_fragment" ],
      THREE.ShaderChunk[ "specularmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( diffuse, opacity );",
      " vec3 totalAmbientLight = ambientLightColor;",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphamap_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],
        THREE.ShaderChunk[ "specularmap_fragment" ],
        THREE.ShaderChunk[ "lightmap_fragment" ],
        THREE.ShaderChunk[ "aomap_fragment" ],

        THREE.ShaderChunk[ "lights_phong_fragment" ],

        THREE.ShaderChunk[ "envmap_fragment" ],
        THREE.ShaderChunk[ "shadowmap_fragment" ],

        THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'particle_basic': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "particle" ],
      THREE.UniformsLib[ "shadowmap" ]

    ] ),

    vertexShader: [

      "uniform float size;",
      "uniform float scale;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

      " #ifdef USE_SIZEATTENUATION",
      "   gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
      " #else",
      "   gl_PointSize = size;",
      " #endif",

      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],
        THREE.ShaderChunk[ "worldpos_vertex" ],
        THREE.ShaderChunk[ "shadowmap_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 psColor;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "map_particle_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( psColor, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "map_particle_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],
        THREE.ShaderChunk[ "alphatest_fragment" ],

      " outgoingLight = diffuseColor.rgb;", // simple shader

        THREE.ShaderChunk[ "shadowmap_fragment" ],
        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'dashed': {

    uniforms: THREE.UniformsUtils.merge( [

      THREE.UniformsLib[ "common" ],
      THREE.UniformsLib[ "fog" ],

      {
        "scale"    : { type: "f", value: 1 },
        "dashSize" : { type: "f", value: 1 },
        "totalSize": { type: "f", value: 2 }
      }

    ] ),

    vertexShader: [

      "uniform float scale;",
      "attribute float lineDistance;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "color_vertex" ],

      " vLineDistance = scale * lineDistance;",

      " vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
      " gl_Position = projectionMatrix * mvPosition;",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform vec3 diffuse;",
      "uniform float opacity;",

      "uniform float dashSize;",
      "uniform float totalSize;",

      "varying float vLineDistance;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "color_pars_fragment" ],
      THREE.ShaderChunk[ "fog_pars_fragment" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " if ( mod( vLineDistance, totalSize ) > dashSize ) {",

      "   discard;",

      " }",

      " vec3 outgoingLight = vec3( 0.0 );", // outgoing light does not have an alpha, the surface does
      " vec4 diffuseColor = vec4( diffuse, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],
        THREE.ShaderChunk[ "color_fragment" ],

      " outgoingLight = diffuseColor.rgb;", // simple shader

        THREE.ShaderChunk[ "fog_fragment" ],

      " gl_FragColor = vec4( outgoingLight, diffuseColor.a );", // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'depth': {

    uniforms: {

      "mNear": { type: "f", value: 1.0 },
      "mFar" : { type: "f", value: 2000.0 },
      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform float mNear;",
      "uniform float mFar;",
      "uniform float opacity;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   float depth = gl_FragDepthEXT / gl_FragCoord.w;",

      " #else",

      "   float depth = gl_FragCoord.z / gl_FragCoord.w;",

      " #endif",

      " float color = 1.0 - smoothstep( mNear, mFar, depth );",
      " gl_FragColor = vec4( vec3( color ), opacity );",   // TODO, this should be pre-multiplied to allow for bright highlights on very transparent objects

      "}"

    ].join("\n")

  },

  'normal': {

    uniforms: {

      "opacity" : { type: "f", value: 1.0 }

    },

    vertexShader: [

      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vNormal = normalize( normalMatrix * normal );",

        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform float opacity;",
      "varying vec3 vNormal;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join("\n")

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'cube': {

    uniforms: { "tCube": { type: "t", value: null },
          "tFlip": { type: "f", value: - 1 } },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vWorldPosition = transformDirection( position, modelMatrix );",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform samplerCube tCube;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

      " gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join("\n")

  },

  /* -------------------------------------------------------------------------
  //  Cube map shader
   ------------------------------------------------------------------------- */

  'equirect': {

    uniforms: { "tEquirect": { type: "t", value: null },
          "tFlip": { type: "f", value: - 1 } },

    vertexShader: [

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

      " vWorldPosition = transformDirection( position, modelMatrix );",

      " gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      "uniform sampler2D tEquirect;",
      "uniform float tFlip;",

      "varying vec3 vWorldPosition;",

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "void main() {",

        // "  gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",
        "vec3 direction = normalize( vWorldPosition );",
        "vec2 sampleUV;",
        "sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );",
        "sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;",
        "gl_FragColor = texture2D( tEquirect, sampleUV );",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      "}"

    ].join("\n")

  },

  /* Depth encoding into RGBA texture
   *
   * based on SpiderGL shadow map example
   * http://spidergl.org/example.php?id=6
   *
   * originally from
   * http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
   *
   * see also
   * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
   */

  'depthRGBA': {

    uniforms: {},

    vertexShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
      THREE.ShaderChunk[ "skinning_pars_vertex" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ],

      "void main() {",

        THREE.ShaderChunk[ "skinbase_vertex" ],
        THREE.ShaderChunk[ "morphtarget_vertex" ],
        THREE.ShaderChunk[ "skinning_vertex" ],
        THREE.ShaderChunk[ "default_vertex" ],
        THREE.ShaderChunk[ "logdepthbuf_vertex" ],

      "}"

    ].join("\n"),

    fragmentShader: [

      THREE.ShaderChunk[ "common" ],
      THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ],

      "vec4 pack_depth( const in float depth ) {",

      " const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
      " const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
      " vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );", // "  vec4 res = fract( depth * bit_shift );",
      " res -= res.xxyz * bit_mask;",
      " return res;",

      "}",

      "void main() {",

        THREE.ShaderChunk[ "logdepthbuf_fragment" ],

      " #ifdef USE_LOGDEPTHBUF_EXT",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );",

      " #else",

      "   gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

      " #endif",

        //"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
        //"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
        //"gl_FragData[ 0 ] = pack_depth( z );",
        //"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

      "}"

    ].join("\n")

  }

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

  console.log( 'THREE.WebGLRenderer', THREE.REVISION );

  parameters = parameters || {};

  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
  _context = parameters.context !== undefined ? parameters.context : null,

  _width = _canvas.width,
  _height = _canvas.height,

  pixelRatio = 1,

  _precision = parameters.precision !== undefined ? parameters.precision : 'highp',

  _alpha = parameters.alpha !== undefined ? parameters.alpha : false,
  _depth = parameters.depth !== undefined ? parameters.depth : true,
  _stencil = parameters.stencil !== undefined ? parameters.stencil : true,
  _antialias = parameters.antialias !== undefined ? parameters.antialias : false,
  _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
  _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
  _logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,

  _clearColor = new THREE.Color( 0x000000 ),
  _clearAlpha = 0;

  var lights = [];

  var opaqueObjects = [];
  var transparentObjects = [];

  var sprites = [];
  var lensFlares = [];

  // public properties

  this.domElement = _canvas;
  this.context = null;

  // clearing

  this.autoClear = true;
  this.autoClearColor = true;
  this.autoClearDepth = true;
  this.autoClearStencil = true;

  // scene graph

  this.sortObjects = true;

  // physically based shading

  this.gammaFactor = 2.0; // for backwards compatibility
  this.gammaInput = false;
  this.gammaOutput = false;

  // morphs

  this.maxMorphTargets = 8;
  this.maxMorphNormals = 4;

  // flags

  this.autoScaleCubemaps = true;

  // info

  this.info = {

    memory: {

      programs: 0,
      geometries: 0,
      textures: 0

    },

    render: {

      calls: 0,
      vertices: 0,
      faces: 0,
      points: 0

    }

  };

  // internal properties

  var _this = this,

  _programs = [],

  // internal state cache

  _currentProgram = null,
  _currentFramebuffer = null,
  _currentMaterialId = - 1,
  _currentGeometryProgram = '',
  _currentCamera = null,

  _usedTextureUnits = 0,

  _viewportX = 0,
  _viewportY = 0,
  _viewportWidth = _canvas.width,
  _viewportHeight = _canvas.height,
  _currentWidth = 0,
  _currentHeight = 0,

  // frustum

  _frustum = new THREE.Frustum(),

   // camera matrices cache

  _projScreenMatrix = new THREE.Matrix4(),

  _vector3 = new THREE.Vector3(),

  // light arrays cache

  _direction = new THREE.Vector3(),

  _lightsNeedUpdate = true,

  _lights = {

    ambient: [ 0, 0, 0 ],
    directional: { length: 0, colors:[], positions: [] },
    point: { length: 0, colors: [], positions: [], distances: [], decays: [] },
    spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [], decays: [] },
    hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

  };

  // initialize

  var _gl;

  try {

    var attributes = {
      alpha: _alpha,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer
    };

    _gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

    if ( _gl === null ) {

      if ( _canvas.getContext( 'webgl') !== null ) {

        throw 'Error creating WebGL context with your selected attributes.';

      } else {

        throw 'Error creating WebGL context.';

      }

    }

    _canvas.addEventListener( 'webglcontextlost', function ( event ) {

      event.preventDefault();

      resetGLState();
      setDefaultGLState();

      objects.objects = {};

    }, false);

  } catch ( error ) {

    console.error( 'THREE.WebGLRenderer: ' + error );

  }

  var state = new THREE.WebGLState( _gl, paramThreeToGL );

  if ( _gl.getShaderPrecisionFormat === undefined ) {

    _gl.getShaderPrecisionFormat = function () {

      return {
        'rangeMin': 1,
        'rangeMax': 1,
        'precision': 1
      };

    }

  }

  var extensions = new THREE.WebGLExtensions( _gl );
  var objects = new THREE.WebGLObjects( _gl, this.info );

  extensions.get( 'OES_texture_float' );
  extensions.get( 'OES_texture_float_linear' );
  extensions.get( 'OES_texture_half_float' );
  extensions.get( 'OES_texture_half_float_linear' );
  extensions.get( 'OES_standard_derivatives' );
  extensions.get( 'ANGLE_instanced_arrays' );

  if ( extensions.get( 'OES_element_index_uint' ) ) {

    THREE.BufferGeometry.MaxIndex = 4294967296;

  }

  if ( _logarithmicDepthBuffer ) {

    extensions.get( 'EXT_frag_depth' );

  }

  //

  var glClearColor = function ( r, g, b, a ) {

    if ( _premultipliedAlpha === true ) {

      r *= a; g *= a; b *= a;

    }

    _gl.clearColor( r, g, b, a );

  };

  var setDefaultGLState = function () {

    _gl.clearColor( 0, 0, 0, 1 );
    _gl.clearDepth( 1 );
    _gl.clearStencil( 0 );

    _gl.enable( _gl.DEPTH_TEST );
    _gl.depthFunc( _gl.LEQUAL );

    _gl.frontFace( _gl.CCW );
    _gl.cullFace( _gl.BACK );
    _gl.enable( _gl.CULL_FACE );

    _gl.enable( _gl.BLEND );
    _gl.blendEquation( _gl.FUNC_ADD );
    _gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

    _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  var resetGLState = function () {

    _currentProgram = null;
    _currentCamera = null;

    _currentGeometryProgram = '';
    _currentMaterialId = - 1;

    _lightsNeedUpdate = true;

    state.reset();

  };

  setDefaultGLState();

  this.context = _gl;
  this.extensions = extensions;
  this.state = state;

  // shadow map

  var shadowMap = new THREE.WebGLShadowMap( this, lights, objects );

  this.shadowMap = shadowMap;

  // GPU capabilities

  var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
  var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
  var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
  var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

  var _supportsVertexTextures = _maxVertexTextures > 0;
  var _supportsBoneTextures = _supportsVertexTextures && extensions.get( 'OES_texture_float' );
  var _supportsInstancedArrays = extensions.get( 'ANGLE_instanced_arrays' );

  //

  var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
  var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );

  var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
  var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );

  var getCompressedTextureFormats = ( function () {

    var array;

    return function () {

      if ( array !== undefined ) {

        return array;

      }

      array = [];

      if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) || extensions.get( 'WEBGL_compressed_texture_s3tc' ) ) {

        var formats = _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS );

        for ( var i = 0; i < formats.length; i ++ ) {

          array.push( formats[ i ] );

        }

      }

      return array;

    };

  } )();

  // clamp precision to maximum available

  var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
  var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

  if ( _precision === 'highp' && ! highpAvailable ) {

    if ( mediumpAvailable ) {

      _precision = 'mediump';
      console.warn( 'THREE.WebGLRenderer: highp not supported, using mediump.' );

    } else {

      _precision = 'lowp';
      console.warn( 'THREE.WebGLRenderer: highp and mediump not supported, using lowp.' );

    }

  }

  if ( _precision === 'mediump' && ! mediumpAvailable ) {

    _precision = 'lowp';
    console.warn( 'THREE.WebGLRenderer: mediump not supported, using lowp.' );

  }

  // Plugins

  var spritePlugin = new THREE.SpritePlugin( this, sprites );
  var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

  // API

  this.getContext = function () {

    return _gl;

  };

  this.forceContextLoss = function () {

    extensions.get( 'WEBGL_lose_context' ).loseContext();

  };

  this.supportsVertexTextures = function () {

    return _supportsVertexTextures;

  };

  this.supportsInstancedArrays = function () {

    return _supportsInstancedArrays;

  };

  this.supportsFloatTextures = function () {

    return extensions.get( 'OES_texture_float' );

  };

  this.supportsHalfFloatTextures = function () {

    return extensions.get( 'OES_texture_half_float' );

  };

  this.supportsStandardDerivatives = function () {

    return extensions.get( 'OES_standard_derivatives' );

  };

  this.supportsCompressedTextureS3TC = function () {

    return extensions.get( 'WEBGL_compressed_texture_s3tc' );

  };

  this.supportsCompressedTexturePVRTC = function () {

    return extensions.get( 'WEBGL_compressed_texture_pvrtc' );

  };

  this.supportsBlendMinMax = function () {

    return extensions.get( 'EXT_blend_minmax' );

  };

  this.getMaxAnisotropy = ( function () {

    var value;

    return function () {

      if ( value !== undefined ) return value;

      var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

      if ( extension !== null ) {

        value = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

      } else {

        value = 0;

      }

      return value;

    }

  } )();

  this.getPrecision = function () {

    return _precision;

  };

  this.getPixelRatio = function () {

    return pixelRatio;

  };

  this.setPixelRatio = function ( value ) {

    if ( value !== undefined ) pixelRatio = value;

  };

  this.getSize = function () {

    return {
      width: _width,
      height: _height
    };

  };

  this.setSize = function ( width, height, updateStyle ) {

    _width = width;
    _height = height;

    _canvas.width = width * pixelRatio;
    _canvas.height = height * pixelRatio;

    if ( updateStyle !== false ) {

      _canvas.style.width = width + 'px';
      _canvas.style.height = height + 'px';

    }

    this.setViewport( 0, 0, width, height );

  };

  this.setViewport = function ( x, y, width, height ) {

    _viewportX = x * pixelRatio;
    _viewportY = y * pixelRatio;

    _viewportWidth = width * pixelRatio;
    _viewportHeight = height * pixelRatio;

    _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

  };

  this.setScissor = function ( x, y, width, height ) {

    _gl.scissor(
      x * pixelRatio,
      y * pixelRatio,
      width * pixelRatio,
      height * pixelRatio
    );

  };

  this.enableScissorTest = function ( enable ) {

    enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

  };

  // Clearing

  this.getClearColor = function () {

    return _clearColor;

  };

  this.setClearColor = function ( color, alpha ) {

    _clearColor.set( color );

    _clearAlpha = alpha !== undefined ? alpha : 1;

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.getClearAlpha = function () {

    return _clearAlpha;

  };

  this.setClearAlpha = function ( alpha ) {

    _clearAlpha = alpha;

    glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

  };

  this.clear = function ( color, depth, stencil ) {

    var bits = 0;

    if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
    if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
    if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

    _gl.clear( bits );

  };

  this.clearColor = function () {

    _gl.clear( _gl.COLOR_BUFFER_BIT );

  };

  this.clearDepth = function () {

    _gl.clear( _gl.DEPTH_BUFFER_BIT );

  };

  this.clearStencil = function () {

    _gl.clear( _gl.STENCIL_BUFFER_BIT );

  };

  this.clearTarget = function ( renderTarget, color, depth, stencil ) {

    this.setRenderTarget( renderTarget );
    this.clear( color, depth, stencil );

  };

  // Reset

  this.resetGLState = resetGLState;

  // Events

  var onTextureDispose = function ( event ) {

    var texture = event.target;

    texture.removeEventListener( 'dispose', onTextureDispose );

    deallocateTexture( texture );

    _this.info.memory.textures --;


  };

  var onRenderTargetDispose = function ( event ) {

    var renderTarget = event.target;

    renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

    deallocateRenderTarget( renderTarget );

    _this.info.memory.textures --;

  };

  var onMaterialDispose = function ( event ) {

    var material = event.target;

    material.removeEventListener( 'dispose', onMaterialDispose );

    deallocateMaterial( material );

  };

  // Buffer deallocation

  var deallocateTexture = function ( texture ) {

    if ( texture.image && texture.image.__webglTextureCube ) {

      // cube texture

      _gl.deleteTexture( texture.image.__webglTextureCube );

      delete texture.image.__webglTextureCube;

    } else {

      // 2D texture

      if ( texture.__webglInit === undefined ) return;

      _gl.deleteTexture( texture.__webglTexture );

      delete texture.__webglTexture;
      delete texture.__webglInit;

    }

  };

  var deallocateRenderTarget = function ( renderTarget ) {

    if ( ! renderTarget || renderTarget.__webglTexture === undefined ) return;

    _gl.deleteTexture( renderTarget.__webglTexture );

    delete renderTarget.__webglTexture;

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      for ( var i = 0; i < 6; i ++ ) {

        _gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
        _gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

      }

    } else {

      _gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
      _gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

    }

    delete renderTarget.__webglFramebuffer;
    delete renderTarget.__webglRenderbuffer;

  };

  var deallocateMaterial = function ( material ) {

    var program = material.program.program;

    if ( program === undefined ) return;

    material.program = undefined;

    // only deallocate GL program if this was the last use of shared program
    // assumed there is only single copy of any program in the _programs list
    // (that's how it's constructed)

    var i, il, programInfo;
    var deleteProgram = false;

    for ( i = 0, il = _programs.length; i < il; i ++ ) {

      programInfo = _programs[ i ];

      if ( programInfo.program === program ) {

        programInfo.usedTimes --;

        if ( programInfo.usedTimes === 0 ) {

          deleteProgram = true;

        }

        break;

      }

    }

    if ( deleteProgram === true ) {

      // avoid using array.splice, this is costlier than creating new array from scratch

      var newPrograms = [];

      for ( i = 0, il = _programs.length; i < il; i ++ ) {

        programInfo = _programs[ i ];

        if ( programInfo.program !== program ) {

          newPrograms.push( programInfo );

        }

      }

      _programs = newPrograms;

      _gl.deleteProgram( program );

      _this.info.memory.programs --;

    }

  };

  // Buffer rendering

  this.renderBufferImmediate = function ( object, program, material ) {

    state.initAttributes();

    if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
    if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
    if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
    if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

    var attributes = program.getAttributes();

    if ( object.hasPositions ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.position );
      _gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasNormals ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

      if ( material instanceof THREE.MeshPhongMaterial === false && material.shading === THREE.FlatShading ) {

        var nx, ny, nz,
          nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
          normalArray,
          i, il = object.count * 3;

        for ( i = 0; i < il; i += 9 ) {

          normalArray = object.normalArray;

          nax = normalArray[ i ];
          nay = normalArray[ i + 1 ];
          naz = normalArray[ i + 2 ];

          nbx = normalArray[ i + 3 ];
          nby = normalArray[ i + 4 ];
          nbz = normalArray[ i + 5 ];

          ncx = normalArray[ i + 6 ];
          ncy = normalArray[ i + 7 ];
          ncz = normalArray[ i + 8 ];

          nx = ( nax + nbx + ncx ) / 3;
          ny = ( nay + nby + ncy ) / 3;
          nz = ( naz + nbz + ncz ) / 3;

          normalArray[ i     ] = nx;
          normalArray[ i + 1 ] = ny;
          normalArray[ i + 2 ] = nz;

          normalArray[ i + 3 ] = nx;
          normalArray[ i + 4 ] = ny;
          normalArray[ i + 5 ] = nz;

          normalArray[ i + 6 ] = nx;
          normalArray[ i + 7 ] = ny;
          normalArray[ i + 8 ] = nz;

        }

      }

      _gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.normal );

      _gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasUvs && material.map ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.uv );

      _gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

    }

    if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

      _gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
      _gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

      state.enableAttribute( attributes.color );

      _gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

    }

    state.disableUnusedAttributes();

    _gl.drawArrays( _gl.TRIANGLES, 0, object.count );

    object.count = 0;

  };

  function setupVertexAttributes( material, program, geometry, startIndex ) {

    var extension;

    if ( geometry instanceof THREE.InstancedBufferGeometry ) {

      extension = extensions.get( 'ANGLE_instanced_arrays' );

      if ( extension === null ) {

        console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
        return;

      }

    }

    var geometryAttributes = geometry.attributes;

    var programAttributes = program.getAttributes();

    var materialDefaultAttributeValues = material.defaultAttributeValues;

    for ( var name in programAttributes ) {

      var programAttribute = programAttributes[ name ];

      if ( programAttribute >= 0 ) {

        var geometryAttribute = geometryAttributes[ name ];

        if ( geometryAttribute !== undefined ) {

          var size = geometryAttribute.itemSize;
          state.enableAttribute( programAttribute );

          if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

            var data = geometryAttribute.data;
            var stride = data.stride;
            var offset = geometryAttribute.offset;

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.data.buffer );
            _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

            if ( data instanceof THREE.InstancedInterleavedBuffer ) {

              if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

              }

              extension.vertexAttribDivisorANGLE( programAttribute, data.meshPerAttribute );

              if ( geometry.maxInstancedCount === undefined ) {

                geometry.maxInstancedCount = data.meshPerAttribute * ( data.array.length / data.stride );

              }

            }

          } else {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometryAttribute.buffer );
            _gl.vertexAttribPointer( programAttribute, size, _gl.FLOAT, false, 0, startIndex * size * 4 ); // 4 bytes per Float32

            if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

              if ( extension === null ) {

                console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferAttribute but hardware does not support extension ANGLE_instanced_arrays.' );
                return;

              }

              extension.vertexAttribDivisorANGLE( programAttribute, geometryAttribute.meshPerAttribute );

              if ( geometry.maxInstancedCount === undefined ) {

                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * ( geometryAttribute.array.length / geometryAttribute.itemSize );

              }

            }

          }

        } else if ( materialDefaultAttributeValues !== undefined ) {

          var value = materialDefaultAttributeValues[ name ];
          if ( value !== undefined ) {

            switch ( value.length ) {

              case 2:
                _gl.vertexAttrib2fv( programAttribute, value );
                break;

              case 3:
                _gl.vertexAttrib3fv( programAttribute, value );
                break;

              case 4:
                _gl.vertexAttrib4fv( programAttribute, value );
                break;

              default:
                _gl.vertexAttrib1fv( programAttribute, value );

            }

          }

        }

      }

    }

    state.disableUnusedAttributes();

  }

  this.renderBufferDirect = function ( camera, lights, fog, material, object ) {

    if ( material.visible === false ) return;

    var geometry = objects.geometries.get( object );
    var program = setProgram( camera, lights, fog, material, object );

    var updateBuffers = false,
      wireframeBit = material.wireframe ? 1 : 0,
      geometryProgram = geometry.id + '_' + program.id + '_' + wireframeBit;

    if ( geometryProgram !== _currentGeometryProgram ) {

      _currentGeometryProgram = geometryProgram;
      updateBuffers = true;

    }

    if ( updateBuffers ) {

      state.initAttributes();

    }

    if ( object instanceof THREE.Mesh ) {

      renderMesh( material, geometry, object, program, updateBuffers );

    } else if ( object instanceof THREE.Line ) {

      renderLine( material, geometry, object, program, updateBuffers );

    } else if ( object instanceof THREE.PointCloud ) {

      renderPointCloud( material, geometry, object, program, updateBuffers );

    }

  };

  function renderMesh( material, geometry, object, program, updateBuffers ) {

    var mode = material.wireframe === true ? _gl.LINES : _gl.TRIANGLES;

    var index = geometry.attributes.index;

    if ( index ) {

      // indexed triangles

      var type, size;

      if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

        type = _gl.UNSIGNED_INT;
        size = 4;

      } else {

        type = _gl.UNSIGNED_SHORT;
        size = 2;

      }

      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );
          _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

        }

        if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

          var extension = extensions.get( 'ANGLE_instanced_arrays' );

          if ( extension === null ) {

            console.error( 'THREE.WebGLRenderer.renderMesh: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

          }

          extension.drawElementsInstancedANGLE( mode, index.array.length, type, 0, geometry.maxInstancedCount ); // Draw the instanced meshes

        } else {

          _gl.drawElements( mode, index.array.length, type, 0 );

        }
        _this.info.render.calls ++;
        _this.info.render.vertices += index.array.length; // not really true, here vertices can be shared
        _this.info.render.faces += index.array.length / 3;

      } else {

        // if there is more than 1 chunk
        // must set attribute pointers to use new offsets for each chunk
        // even if geometry and materials didn't change

        updateBuffers = true;

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          var startIndex = offsets[ i ].index;

          if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry, startIndex );
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

          }

          // render indexed triangles

          if ( geometry instanceof THREE.InstancedBufferGeometry && offsets[i].instances > 0 ) {

            var extension = extensions.get( 'ANGLE_instanced_arrays' );

            if ( extension === null ) {

              console.error( 'THREE.WebGLRenderer.renderMesh: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
              return;

            }

            extension.drawElementsInstancedANGLE( mode, offsets[i].count, type, offsets[i].start * size, offsets[i].count, type, offsets[i].instances ); // Draw the instanced meshes

          } else {

            _gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

          }

          _this.info.render.calls ++;
          _this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
          _this.info.render.faces += offsets[ i ].count / 3;

        }

      }

    } else {

      // non-indexed triangles

      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );

        }

        var position = geometry.attributes.position;

        // render non-indexed triangles

        if ( geometry instanceof THREE.InstancedBufferGeometry && geometry.maxInstancedCount > 0 ) {

          var extension = extensions.get( 'ANGLE_instanced_arrays' );

          if ( extension === null ) {

            console.error( 'THREE.WebGLRenderer.renderMesh: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
            return;

          }

          if ( position instanceof THREE.InterleavedBufferAttribute ) {

            extension.drawArraysInstancedANGLE( mode, 0, position.data.array.length / position.data.stride, geometry.maxInstancedCount ); // Draw the instanced meshes

          } else {

            extension.drawArraysInstancedANGLE( mode, 0, position.array.length / position.itemSize, geometry.maxInstancedCount ); // Draw the instanced meshes

          }

        } else {

          if ( position instanceof THREE.InterleavedBufferAttribute ) {

            _gl.drawArrays( mode, 0, position.data.array.length / position.data.stride );

          } else {

            _gl.drawArrays( mode, 0, position.array.length / position.itemSize );

          }

        }

        _this.info.render.calls++;
        _this.info.render.vertices += position.array.length / position.itemSize;
        _this.info.render.faces += position.array.length / ( 3 * position.itemSize );

      } else {

        // if there is more than 1 chunk
        // must set attribute pointers to use new offsets for each chunk
        // even if geometry and materials didn't change

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );

        }

        for ( var i = 0, il = offsets.length; i < il; i++ ) {

          // render non-indexed triangles

          if ( geometry instanceof THREE.InstancedBufferGeometry ) {

            console.error( 'THREE.WebGLRenderer.renderMesh: cannot use drawCalls with THREE.InstancedBufferGeometry.' );
            return;

          } else {

            _gl.drawArrays( mode, offsets[ i ].start, offsets[ i ].count );

          }

          _this.info.render.calls++;
          _this.info.render.vertices += offsets[ i ].count;
          _this.info.render.faces += ( offsets[ i ].count  ) / 3;

        }
      }
    }

  }

  function renderLine( material, geometry, object, program, updateBuffers ) {

    var mode = object instanceof THREE.LineSegments ? _gl.LINES : _gl.LINE_STRIP;

    // In case user is not using Line*Material by mistake
    var lineWidth = material.linewidth !== undefined ? material.linewidth : 1;

    state.setLineWidth( lineWidth * pixelRatio );

    var index = geometry.attributes.index;

    if ( index ) {

      // indexed lines

      var type, size;

      if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

        type = _gl.UNSIGNED_INT;
        size = 4;

      } else {

        type = _gl.UNSIGNED_SHORT;
        size = 2;

      }

      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );
          _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

        }

        _gl.drawElements( mode, index.array.length, type, 0 ); // 2 bytes per Uint16Array

        _this.info.render.calls ++;
        _this.info.render.vertices += index.array.length; // not really true, here vertices can be shared

      } else {

        // if there is more than 1 chunk
        // must set attribute pointers to use new offsets for each chunk
        // even if geometry and materials didn't change

        if ( offsets.length > 1 ) updateBuffers = true;

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          var startIndex = offsets[ i ].index;

          if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry, startIndex );
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

          }

          // render indexed lines

          _gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size ); // 2 bytes per Uint16Array

          _this.info.render.calls ++;
          _this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

        }

      }

    } else {

      // non-indexed lines

      if ( updateBuffers ) {

        setupVertexAttributes( material, program, geometry, 0 );

      }

      var position = geometry.attributes.position;
      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        _gl.drawArrays( mode, 0, position.array.length / 3 );

        _this.info.render.calls ++;
        _this.info.render.vertices += position.array.length / 3;

      } else {

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          _gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

          _this.info.render.calls ++;
          _this.info.render.vertices += offsets[ i ].count;

        }

      }

    }

  }

  function renderPointCloud( material, geometry, object, program, updateBuffers ) {

    var mode = _gl.POINTS;

    var index = geometry.attributes.index;

    if ( index ) {

      // indexed points

      var type, size;

      if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

        type = _gl.UNSIGNED_INT;
        size = 4;

      } else {

        type = _gl.UNSIGNED_SHORT;
        size = 2;

      }

      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        if ( updateBuffers ) {

          setupVertexAttributes( material, program, geometry, 0 );
          _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

        }

        _gl.drawElements( mode, index.array.length, type, 0);

        _this.info.render.calls ++;
        _this.info.render.points += index.array.length;

      } else {

        // if there is more than 1 chunk
        // must set attribute pointers to use new offsets for each chunk
        // even if geometry and materials didn't change

        if ( offsets.length > 1 ) updateBuffers = true;

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          var startIndex = offsets[ i ].index;

          if ( updateBuffers ) {

            setupVertexAttributes( material, program, geometry, startIndex );
            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

          }

          // render indexed points

          _gl.drawElements( mode, offsets[ i ].count, type, offsets[ i ].start * size );

          _this.info.render.calls ++;
          _this.info.render.points += offsets[ i ].count;

        }

      }

    } else {

      // non-indexed points

      if ( updateBuffers ) {

        setupVertexAttributes( material, program, geometry, 0 );

      }

      var position = geometry.attributes.position;
      var offsets = geometry.offsets;

      if ( offsets.length === 0 ) {

        _gl.drawArrays( mode, 0, position.array.length / 3 );

        _this.info.render.calls ++;
        _this.info.render.points += position.array.length / 3;

      } else {

        for ( var i = 0, il = offsets.length; i < il; i ++ ) {

          _gl.drawArrays( mode, offsets[ i ].index, offsets[ i ].count );

          _this.info.render.calls ++;
          _this.info.render.points += offsets[ i ].count;

        }

      }

    }

  }

  // Sorting

  function painterSortStable ( a, b ) {

    if ( a.object.renderOrder !== b.object.renderOrder ) {

      return a.object.renderOrder - b.object.renderOrder;

    } else if ( a.object.material.id !== b.object.material.id ) {

      return a.object.material.id - b.object.material.id;

    } else if ( a.z !== b.z ) {

      return a.z - b.z;

    } else {

      return a.id - b.id;

    }

  }

  function reversePainterSortStable ( a, b ) {

    if ( a.object.renderOrder !== b.object.renderOrder ) {

      return a.object.renderOrder - b.object.renderOrder;

    } if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return a.id - b.id;

    }

  }

  // Rendering

  this.render = function ( scene, camera, renderTarget, forceClear ) {

    if ( camera instanceof THREE.Camera === false ) {

      console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
      return;

    }

    var fog = scene.fog;

    // reset caching for this frame

    _currentGeometryProgram = '';
    _currentMaterialId = - 1;
    _currentCamera = null;
    _lightsNeedUpdate = true;

    // update scene graph

    if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

    // update camera matrices and frustum

    if ( camera.parent === undefined ) camera.updateMatrixWorld();

    camera.matrixWorldInverse.getInverse( camera.matrixWorld );

    _projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
    _frustum.setFromMatrix( _projScreenMatrix );

    lights.length = 0;
    opaqueObjects.length = 0;
    transparentObjects.length = 0;

    sprites.length = 0;
    lensFlares.length = 0;

    projectObject( scene );

    if ( _this.sortObjects === true ) {

      opaqueObjects.sort( painterSortStable );
      transparentObjects.sort( reversePainterSortStable );

    }

    objects.update( opaqueObjects );
    objects.update( transparentObjects );

    //

    shadowMap.render( scene, camera );

    //

    _this.info.render.calls = 0;
    _this.info.render.vertices = 0;
    _this.info.render.faces = 0;
    _this.info.render.points = 0;

    this.setRenderTarget( renderTarget );

    if ( this.autoClear || forceClear ) {

      this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

    }

    // set matrices for immediate objects

    for ( var i = 0, il = objects.objectsImmediate.length; i < il; i ++ ) {

      var webglObject = objects.objectsImmediate[ i ];
      var object = webglObject.object;

      if ( object.visible === true ) {

        setupMatrices( object, camera );

        var material = object.material;

        if ( material.transparent ) {

          webglObject.transparent = material;
          webglObject.opaque = null;

        } else {

          webglObject.opaque = material;
          webglObject.transparent = null;

        }

      }

    }

    if ( scene.overrideMaterial ) {

      var overrideMaterial = scene.overrideMaterial;

      setMaterial( overrideMaterial );

      renderObjects( opaqueObjects, camera, lights, fog, overrideMaterial );
      renderObjects( transparentObjects, camera, lights, fog, overrideMaterial );
      renderObjectsImmediate( objects.objectsImmediate, '', camera, lights, fog, overrideMaterial );

    } else {

      // opaque pass (front-to-back order)

      state.setBlending( THREE.NoBlending );

      renderObjects( opaqueObjects, camera, lights, fog, null );
      renderObjectsImmediate( objects.objectsImmediate, 'opaque', camera, lights, fog, null );

      // transparent pass (back-to-front order)

      renderObjects( transparentObjects, camera, lights, fog, null );
      renderObjectsImmediate( objects.objectsImmediate, 'transparent', camera, lights, fog, null );

    }

    // custom render plugins (post pass)

    spritePlugin.render( scene, camera );
    lensFlarePlugin.render( scene, camera, _currentWidth, _currentHeight );

    // Generate mipmap if we're using any kind of mipmap filtering

    if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

      updateRenderTargetMipmap( renderTarget );

    }

    // Ensure depth buffer writing is enabled so it can be cleared on next render

    state.setDepthTest( true );
    state.setDepthWrite( true );
    state.setColorWrite( true );

    // _gl.finish();

  };

  function projectObject( object ) {

    if ( object.visible === true ) {

      if ( object instanceof THREE.Scene || object instanceof THREE.Group ) {

        // skip

      } else {

        // update Skeleton objects
        if ( object instanceof THREE.SkinnedMesh ) {

          object.skeleton.update();

        }

        objects.init( object );

        if ( object instanceof THREE.Light ) {

          lights.push( object );

        } else if ( object instanceof THREE.Sprite ) {

          sprites.push( object );

        } else if ( object instanceof THREE.LensFlare ) {

          lensFlares.push( object );

        } else {

          var webglObject = objects.objects[ object.id ];

          if ( webglObject && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

            var material = object.material;

            if ( material.transparent ) {

              transparentObjects.push( webglObject );

            } else {

              opaqueObjects.push( webglObject );

            }

            if ( _this.sortObjects === true ) {

              _vector3.setFromMatrixPosition( object.matrixWorld );
              _vector3.applyProjection( _projScreenMatrix );

              webglObject.z = _vector3.z;

            }

          }

        }

      }

      for ( var i = 0, l = object.children.length; i < l; i ++ ) {

        projectObject( object.children[ i ] );

      }

    }

  }

  function renderObjects( renderList, camera, lights, fog, overrideMaterial ) {

    var material;

    for ( var i = 0, l = renderList.length; i < l; i ++ ) {

      var webglObject = renderList[ i ];

      var object = webglObject.object;

      setupMatrices( object, camera );

      if ( overrideMaterial ) {

        material = overrideMaterial;

      } else {

        material = object.material;

        if ( ! material ) continue;

        setMaterial( material );

      }

      _this.setMaterialFaces( material );
      _this.renderBufferDirect( camera, lights, fog, material, object );

    }

  }

  function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, overrideMaterial ) {

    var material;

    for ( var i = 0, l = renderList.length; i < l; i ++ ) {

      var webglObject = renderList[ i ];
      var object = webglObject.object;

      if ( object.visible === true ) {

        if ( overrideMaterial ) {

          material = overrideMaterial;

        } else {

          material = webglObject[ materialType ];

          if ( ! material ) continue;

          setMaterial( material );

        }

        _this.renderImmediateObject( camera, lights, fog, material, object );

      }

    }

  }

  this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

    var program = setProgram( camera, lights, fog, material, object );

    _currentGeometryProgram = '';

    _this.setMaterialFaces( material );

    if ( object.immediateRenderCallback ) {

      object.immediateRenderCallback( program, _gl, _frustum );

    } else {

      object.render( function ( object ) { _this.renderBufferImmediate( object, program, material ); } );

    }

  };

  // Materials

  var shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointCloudMaterial: 'particle_basic'
  };

  function initMaterial( material, lights, fog, object ) {

    var shaderID = shaderIDs[ material.type ];

    // heuristics to create shader parameters according to lights in the scene
    // (not to blow over maxLights budget)

    var maxLightCount = allocateLights( lights );
    var maxShadows = allocateShadows( lights );
    var maxBones = allocateBones( object );

    var parameters = {

      precision: _precision,
      supportsVertexTextures: _supportsVertexTextures,

      map: !! material.map,
      envMap: !! material.envMap,
      envMapMode: material.envMap && material.envMap.mapping,
      lightMap: !! material.lightMap,
      aoMap: !! material.aoMap,
      bumpMap: !! material.bumpMap,
      normalMap: !! material.normalMap,
      specularMap: !! material.specularMap,
      alphaMap: !! material.alphaMap,

      combine: material.combine,

      vertexColors: material.vertexColors,

      fog: fog,
      useFog: material.fog,
      fogExp: fog instanceof THREE.FogExp2,

      flatShading: material.shading === THREE.FlatShading,

      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer: _logarithmicDepthBuffer,

      skinning: material.skinning,
      maxBones: maxBones,
      useVertexTexture: _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture,

      morphTargets: material.morphTargets,
      morphNormals: material.morphNormals,
      maxMorphTargets: _this.maxMorphTargets,
      maxMorphNormals: _this.maxMorphNormals,

      maxDirLights: maxLightCount.directional,
      maxPointLights: maxLightCount.point,
      maxSpotLights: maxLightCount.spot,
      maxHemiLights: maxLightCount.hemi,

      maxShadows: maxShadows,
      shadowMapEnabled: shadowMap.enabled && object.receiveShadow && maxShadows > 0,
      shadowMapType: shadowMap.type,
      shadowMapDebug: shadowMap.debug,
      shadowMapCascade: shadowMap.cascade,

      alphaTest: material.alphaTest,
      metal: material.metal,
      doubleSided: material.side === THREE.DoubleSide,
      flipSided: material.side === THREE.BackSide

    };

    // Generate code

    var chunks = [];

    if ( shaderID ) {

      chunks.push( shaderID );

    } else {

      chunks.push( material.fragmentShader );
      chunks.push( material.vertexShader );

    }

    if ( material.defines !== undefined ) {

      for ( var name in material.defines ) {

        chunks.push( name );
        chunks.push( material.defines[ name ] );

      }

    }

    for ( var name in parameters ) {

      chunks.push( name );
      chunks.push( parameters[ name ] );

    }

    var code = chunks.join();

    if ( !material.program ) {

      // new material
      material.addEventListener( 'dispose', onMaterialDispose );

    } else if ( material.program.code !== code ) {

      // changed glsl or parameters
      deallocateMaterial( material );

    } else if ( shaderID !== undefined ) {

      // same glsl
      return;

    } else if ( material.__webglShader.uniforms === material.uniforms ) {

      // same uniforms (container object)
      return;

    }

    if ( shaderID ) {

      var shader = THREE.ShaderLib[ shaderID ];

      material.__webglShader = {
        uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      }

    } else {

      material.__webglShader = {
        uniforms: material.uniforms,
        vertexShader: material.vertexShader,
        fragmentShader: material.fragmentShader
      }

    }

    var program;

    // Check if code has been already compiled

    for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

      var programInfo = _programs[ p ];

      if ( programInfo.code === code ) {

        program = programInfo;
        program.usedTimes ++;

        break;

      }

    }

    if ( program === undefined ) {

      program = new THREE.WebGLProgram( _this, code, material, parameters );
      _programs.push( program );

      _this.info.memory.programs = _programs.length;

    }

    material.program = program;

    var attributes = program.getAttributes();

    if ( material.morphTargets ) {

      material.numSupportedMorphTargets = 0;

      for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

        if ( attributes[ 'morphTarget' + i ] >= 0 ) {

          material.numSupportedMorphTargets ++;

        }

      }

    }

    if ( material.morphNormals ) {

      material.numSupportedMorphNormals = 0;

      for ( i = 0; i < _this.maxMorphNormals; i ++ ) {

        if ( attributes[ 'morphNormal' + i ] >= 0 ) {

          material.numSupportedMorphNormals ++;

        }

      }

    }

    material.uniformsList = [];

    var uniformLocations = material.program.getUniforms();
    for ( var u in material.__webglShader.uniforms ) {

      var location = uniformLocations[ u ];

      if ( location ) {
        material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
      }

    }

  }

  function setMaterial( material ) {

    if ( material.transparent === true ) {

      state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha );

    } else {

      state.setBlending( THREE.NoBlending );

    }

    state.setDepthFunc( material.depthFunc );
    state.setDepthTest( material.depthTest );
    state.setDepthWrite( material.depthWrite );
    state.setColorWrite( material.colorWrite );
    state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

  }

  function setProgram( camera, lights, fog, material, object ) {

    _usedTextureUnits = 0;

    if ( material.needsUpdate ) {

      initMaterial( material, lights, fog, object );
      material.needsUpdate = false;

    }

    var refreshProgram = false;
    var refreshMaterial = false;
    var refreshLights = false;

    var program = material.program,
      p_uniforms = program.getUniforms(),
      m_uniforms = material.__webglShader.uniforms;

    if ( program.id !== _currentProgram ) {

      _gl.useProgram( program.program );
      _currentProgram = program.id;

      refreshProgram = true;
      refreshMaterial = true;
      refreshLights = true;

    }

    if ( material.id !== _currentMaterialId ) {

      if ( _currentMaterialId === -1 ) refreshLights = true;
      _currentMaterialId = material.id;

      refreshMaterial = true;

    }

    if ( refreshProgram || camera !== _currentCamera ) {

      _gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

      if ( _logarithmicDepthBuffer ) {

        _gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

      }


      if ( camera !== _currentCamera ) _currentCamera = camera;

      // load material specific uniforms
      // (shader material also gets them for the sake of genericity)

      if ( material instanceof THREE.ShaderMaterial ||
         material instanceof THREE.MeshPhongMaterial ||
         material.envMap ) {

        if ( p_uniforms.cameraPosition !== null ) {

          _vector3.setFromMatrixPosition( camera.matrixWorld );
          _gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

        }

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.ShaderMaterial ||
         material.skinning ) {

        if ( p_uniforms.viewMatrix !== null ) {

          _gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

        }

      }

    }

    // skinning uniforms must be set even if material didn't change
    // auto-setting of texture unit for bone texture must go before other textures
    // not sure why, but otherwise weird things happen

    if ( material.skinning ) {

      if ( object.bindMatrix && p_uniforms.bindMatrix !== null ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrix, false, object.bindMatrix.elements );

      }

      if ( object.bindMatrixInverse && p_uniforms.bindMatrixInverse !== null ) {

        _gl.uniformMatrix4fv( p_uniforms.bindMatrixInverse, false, object.bindMatrixInverse.elements );

      }

      if ( _supportsBoneTextures && object.skeleton && object.skeleton.useVertexTexture ) {

        if ( p_uniforms.boneTexture !== null ) {

          var textureUnit = getTextureUnit();

          _gl.uniform1i( p_uniforms.boneTexture, textureUnit );
          _this.setTexture( object.skeleton.boneTexture, textureUnit );

        }

        if ( p_uniforms.boneTextureWidth !== null ) {

          _gl.uniform1i( p_uniforms.boneTextureWidth, object.skeleton.boneTextureWidth );

        }

        if ( p_uniforms.boneTextureHeight !== null ) {

          _gl.uniform1i( p_uniforms.boneTextureHeight, object.skeleton.boneTextureHeight );

        }

      } else if ( object.skeleton && object.skeleton.boneMatrices ) {

        if ( p_uniforms.boneGlobalMatrices !== null ) {

          _gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.skeleton.boneMatrices );

        }

      }

    }

    if ( refreshMaterial ) {

      // refresh uniforms common to several materials

      if ( fog && material.fog ) {

        refreshUniformsFog( m_uniforms, fog );

      }

      if ( material instanceof THREE.MeshPhongMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material.lights ) {

        if ( _lightsNeedUpdate ) {

          refreshLights = true;
          setupLights( lights );
          _lightsNeedUpdate = false;
        }

        if ( refreshLights ) {
          refreshUniformsLights( m_uniforms, _lights );
          markUniformsLightsNeedsUpdate( m_uniforms, true );
        } else {
          markUniformsLightsNeedsUpdate( m_uniforms, false );
        }

      }

      if ( material instanceof THREE.MeshBasicMaterial ||
         material instanceof THREE.MeshLambertMaterial ||
         material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsCommon( m_uniforms, material );

      }

      // refresh single material specific uniforms

      if ( material instanceof THREE.LineBasicMaterial ) {

        refreshUniformsLine( m_uniforms, material );

      } else if ( material instanceof THREE.LineDashedMaterial ) {

        refreshUniformsLine( m_uniforms, material );
        refreshUniformsDash( m_uniforms, material );

      } else if ( material instanceof THREE.PointCloudMaterial ) {

        refreshUniformsParticle( m_uniforms, material );

      } else if ( material instanceof THREE.MeshPhongMaterial ) {

        refreshUniformsPhong( m_uniforms, material );

      } else if ( material instanceof THREE.MeshLambertMaterial ) {

        refreshUniformsLambert( m_uniforms, material );

      } else if ( material instanceof THREE.MeshBasicMaterial ) {

        refreshUniformsBasic( m_uniforms, material );

      } else if ( material instanceof THREE.MeshDepthMaterial ) {

        m_uniforms.mNear.value = camera.near;
        m_uniforms.mFar.value = camera.far;
        m_uniforms.opacity.value = material.opacity;

      } else if ( material instanceof THREE.MeshNormalMaterial ) {

        m_uniforms.opacity.value = material.opacity;

      }

      if ( object.receiveShadow && ! material._shadowPass ) {

        refreshUniformsShadow( m_uniforms, lights );

      }

      // load common uniforms

      loadUniformsGeneric( material.uniformsList );

    }

    loadUniformsMatrices( p_uniforms, object );

    if ( p_uniforms.modelMatrix !== null ) {

      _gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

    }

    return program;

  }

  // Uniforms (refresh uniforms objects)

  function refreshUniformsCommon ( uniforms, material ) {

    uniforms.opacity.value = material.opacity;

    uniforms.diffuse.value = material.color;

    uniforms.map.value = material.map;
    uniforms.specularMap.value = material.specularMap;
    uniforms.alphaMap.value = material.alphaMap;

    if ( material.bumpMap ) {

      uniforms.bumpMap.value = material.bumpMap;
      uniforms.bumpScale.value = material.bumpScale;

    }

    if ( material.normalMap ) {

      uniforms.normalMap.value = material.normalMap;
      uniforms.normalScale.value.copy( material.normalScale );

    }

    // uv repeat and offset setting priorities
    // 1. color map
    // 2. specular map
    // 3. normal map
    // 4. bump map
    // 5. alpha map

    var uvScaleMap;

    if ( material.map ) {

      uvScaleMap = material.map;

    } else if ( material.specularMap ) {

      uvScaleMap = material.specularMap;

    } else if ( material.normalMap ) {

      uvScaleMap = material.normalMap;

    } else if ( material.bumpMap ) {

      uvScaleMap = material.bumpMap;

    } else if ( material.alphaMap ) {

      uvScaleMap = material.alphaMap;

    }

    if ( uvScaleMap !== undefined ) {

      var offset = uvScaleMap.offset;
      var repeat = uvScaleMap.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

    uniforms.envMap.value = material.envMap;
    uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : - 1;

    uniforms.reflectivity.value = material.reflectivity;
    uniforms.refractionRatio.value = material.refractionRatio;

  }

  function refreshUniformsLine ( uniforms, material ) {

    uniforms.diffuse.value = material.color;
    uniforms.opacity.value = material.opacity;

  }

  function refreshUniformsDash ( uniforms, material ) {

    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;

  }

  function refreshUniformsParticle ( uniforms, material ) {

    uniforms.psColor.value = material.color;
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size;
    uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

    uniforms.map.value = material.map;

    if ( material.map !== null ) {

      var offset = material.map.offset;
      var repeat = material.map.repeat;

      uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

    }

  }

  function refreshUniformsFog ( uniforms, fog ) {

    uniforms.fogColor.value = fog.color;

    if ( fog instanceof THREE.Fog ) {

      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;

    } else if ( fog instanceof THREE.FogExp2 ) {

      uniforms.fogDensity.value = fog.density;

    }

  }

  function refreshUniformsPhong ( uniforms, material ) {

    uniforms.shininess.value = material.shininess;

    uniforms.emissive.value = material.emissive;
    uniforms.specular.value = material.specular;

    uniforms.lightMap.value = material.lightMap;
    uniforms.lightMapIntensity.value = material.lightMapIntensity;

    uniforms.aoMap.value = material.aoMap;
    uniforms.aoMapIntensity.value = material.aoMapIntensity;

  }

  function refreshUniformsLambert ( uniforms, material ) {

    uniforms.emissive.value = material.emissive;

  }

  function refreshUniformsBasic ( uniforms, material ) {

    uniforms.aoMap.value = material.aoMap;
    uniforms.aoMapIntensity.value = material.aoMapIntensity;

  }

  function refreshUniformsLights ( uniforms, lights ) {

    uniforms.ambientLightColor.value = lights.ambient;

    uniforms.directionalLightColor.value = lights.directional.colors;
    uniforms.directionalLightDirection.value = lights.directional.positions;

    uniforms.pointLightColor.value = lights.point.colors;
    uniforms.pointLightPosition.value = lights.point.positions;
    uniforms.pointLightDistance.value = lights.point.distances;
    uniforms.pointLightDecay.value = lights.point.decays;

    uniforms.spotLightColor.value = lights.spot.colors;
    uniforms.spotLightPosition.value = lights.spot.positions;
    uniforms.spotLightDistance.value = lights.spot.distances;
    uniforms.spotLightDirection.value = lights.spot.directions;
    uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
    uniforms.spotLightExponent.value = lights.spot.exponents;
    uniforms.spotLightDecay.value = lights.spot.decays;

    uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
    uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
    uniforms.hemisphereLightDirection.value = lights.hemi.positions;

  }

  // If uniforms are marked as clean, they don't need to be loaded to the GPU.

  function markUniformsLightsNeedsUpdate ( uniforms, value ) {

    uniforms.ambientLightColor.needsUpdate = value;

    uniforms.directionalLightColor.needsUpdate = value;
    uniforms.directionalLightDirection.needsUpdate = value;

    uniforms.pointLightColor.needsUpdate = value;
    uniforms.pointLightPosition.needsUpdate = value;
    uniforms.pointLightDistance.needsUpdate = value;
    uniforms.pointLightDecay.needsUpdate = value;

    uniforms.spotLightColor.needsUpdate = value;
    uniforms.spotLightPosition.needsUpdate = value;
    uniforms.spotLightDistance.needsUpdate = value;
    uniforms.spotLightDirection.needsUpdate = value;
    uniforms.spotLightAngleCos.needsUpdate = value;
    uniforms.spotLightExponent.needsUpdate = value;
    uniforms.spotLightDecay.needsUpdate = value;

    uniforms.hemisphereLightSkyColor.needsUpdate = value;
    uniforms.hemisphereLightGroundColor.needsUpdate = value;
    uniforms.hemisphereLightDirection.needsUpdate = value;

  }

  function refreshUniformsShadow ( uniforms, lights ) {

    if ( uniforms.shadowMatrix ) {

      var j = 0;

      for ( var i = 0, il = lights.length; i < il; i ++ ) {

        var light = lights[ i ];

        if ( ! light.castShadow ) continue;

        if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

          uniforms.shadowMap.value[ j ] = light.shadowMap;
          uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

          uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

          uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
          uniforms.shadowBias.value[ j ] = light.shadowBias;

          j ++;

        }

      }

    }

  }

  // Uniforms (load to GPU)

  function loadUniformsMatrices ( uniforms, object ) {

    _gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

    if ( uniforms.normalMatrix ) {

      _gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

    }

  }

  function getTextureUnit() {

    var textureUnit = _usedTextureUnits;

    if ( textureUnit >= _maxTextures ) {

      console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + _maxTextures );

    }

    _usedTextureUnits += 1;

    return textureUnit;

  }

  function loadUniformsGeneric ( uniforms ) {

    var texture, textureUnit, offset;

    for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

      var uniform = uniforms[ j ][ 0 ];

      // needsUpdate property is not added to all uniforms.
      if ( uniform.needsUpdate === false ) continue;

      var type = uniform.type;
      var value = uniform.value;
      var location = uniforms[ j ][ 1 ];

      switch ( type ) {

        case '1i':
          _gl.uniform1i( location, value );
          break;

        case '1f':
          _gl.uniform1f( location, value );
          break;

        case '2f':
          _gl.uniform2f( location, value[ 0 ], value[ 1 ] );
          break;

        case '3f':
          _gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
          break;

        case '4f':
          _gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
          break;

        case '1iv':
          _gl.uniform1iv( location, value );
          break;

        case '3iv':
          _gl.uniform3iv( location, value );
          break;

        case '1fv':
          _gl.uniform1fv( location, value );
          break;

        case '2fv':
          _gl.uniform2fv( location, value );
          break;

        case '3fv':
          _gl.uniform3fv( location, value );
          break;

        case '4fv':
          _gl.uniform4fv( location, value );
          break;

        case 'Matrix3fv':
          _gl.uniformMatrix3fv( location, false, value );
          break;

        case 'Matrix4fv':
          _gl.uniformMatrix4fv( location, false, value );
          break;

        //

        case 'i':

          // single integer
          _gl.uniform1i( location, value );

          break;

        case 'f':

          // single float
          _gl.uniform1f( location, value );

          break;

        case 'v2':

          // single THREE.Vector2
          _gl.uniform2f( location, value.x, value.y );

          break;

        case 'v3':

          // single THREE.Vector3
          _gl.uniform3f( location, value.x, value.y, value.z );

          break;

        case 'v4':

          // single THREE.Vector4
          _gl.uniform4f( location, value.x, value.y, value.z, value.w );

          break;

        case 'c':

          // single THREE.Color
          _gl.uniform3f( location, value.r, value.g, value.b );

          break;

        case 'iv1':

          // flat array of integers (JS or typed array)
          _gl.uniform1iv( location, value );

          break;

        case 'iv':

          // flat array of integers with 3 x N size (JS or typed array)
          _gl.uniform3iv( location, value );

          break;

        case 'fv1':

          // flat array of floats (JS or typed array)
          _gl.uniform1fv( location, value );

          break;

        case 'fv':

          // flat array of floats with 3 x N size (JS or typed array)
          _gl.uniform3fv( location, value );

          break;

        case 'v2v':

          // array of THREE.Vector2

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 2 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 2;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;

          }

          _gl.uniform2fv( location, uniform._array );

          break;

        case 'v3v':

          // array of THREE.Vector3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 3 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 3;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;
            uniform._array[ offset + 2 ] = value[ i ].z;

          }

          _gl.uniform3fv( location, uniform._array );

          break;

        case 'v4v':

          // array of THREE.Vector4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 4 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            offset = i * 4;

            uniform._array[ offset + 0 ] = value[ i ].x;
            uniform._array[ offset + 1 ] = value[ i ].y;
            uniform._array[ offset + 2 ] = value[ i ].z;
            uniform._array[ offset + 3 ] = value[ i ].w;

          }

          _gl.uniform4fv( location, uniform._array );

          break;

        case 'm3':

          // single THREE.Matrix3
          _gl.uniformMatrix3fv( location, false, value.elements );

          break;

        case 'm3v':

          // array of THREE.Matrix3

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 9 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

          }

          _gl.uniformMatrix3fv( location, false, uniform._array );

          break;

        case 'm4':

          // single THREE.Matrix4
          _gl.uniformMatrix4fv( location, false, value.elements );

          break;

        case 'm4v':

          // array of THREE.Matrix4

          if ( uniform._array === undefined ) {

            uniform._array = new Float32Array( 16 * value.length );

          }

          for ( var i = 0, il = value.length; i < il; i ++ ) {

            value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

          }

          _gl.uniformMatrix4fv( location, false, uniform._array );

          break;

        case 't':

          // single THREE.Texture (2d or cube)

          texture = value;
          textureUnit = getTextureUnit();

          _gl.uniform1i( location, textureUnit );

          if ( ! texture ) continue;

          if ( texture instanceof THREE.CubeTexture ||
             ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

            setCubeTexture( texture, textureUnit );

          } else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

            setCubeTextureDynamic( texture, textureUnit );

          } else {

            _this.setTexture( texture, textureUnit );

          }

          break;

        case 'tv':

          // array of THREE.Texture (2d)

          if ( uniform._array === undefined ) {

            uniform._array = [];

          }

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            uniform._array[ i ] = getTextureUnit();

          }

          _gl.uniform1iv( location, uniform._array );

          for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

            texture = uniform.value[ i ];
            textureUnit = uniform._array[ i ];

            if ( ! texture ) continue;

            _this.setTexture( texture, textureUnit );

          }

          break;

        default:

          console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

      }

    }

  }

  function setupMatrices ( object, camera ) {

    object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
    object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

  }

  function setColorLinear( array, offset, color, intensity ) {

    array[ offset + 0 ] = color.r * intensity;
    array[ offset + 1 ] = color.g * intensity;
    array[ offset + 2 ] = color.b * intensity;

  }

  function setupLights ( lights ) {

    var l, ll, light,
    r = 0, g = 0, b = 0,
    color, skyColor, groundColor,
    intensity,
    distance,

    zlights = _lights,

    dirColors = zlights.directional.colors,
    dirPositions = zlights.directional.positions,

    pointColors = zlights.point.colors,
    pointPositions = zlights.point.positions,
    pointDistances = zlights.point.distances,
    pointDecays = zlights.point.decays,

    spotColors = zlights.spot.colors,
    spotPositions = zlights.spot.positions,
    spotDistances = zlights.spot.distances,
    spotDirections = zlights.spot.directions,
    spotAnglesCos = zlights.spot.anglesCos,
    spotExponents = zlights.spot.exponents,
    spotDecays = zlights.spot.decays,

    hemiSkyColors = zlights.hemi.skyColors,
    hemiGroundColors = zlights.hemi.groundColors,
    hemiPositions = zlights.hemi.positions,

    dirLength = 0,
    pointLength = 0,
    spotLength = 0,
    hemiLength = 0,

    dirCount = 0,
    pointCount = 0,
    spotCount = 0,
    hemiCount = 0,

    dirOffset = 0,
    pointOffset = 0,
    spotOffset = 0,
    hemiOffset = 0;

    for ( l = 0, ll = lights.length; l < ll; l ++ ) {

      light = lights[ l ];

      if ( light.onlyShadow ) continue;

      color = light.color;
      intensity = light.intensity;
      distance = light.distance;

      if ( light instanceof THREE.AmbientLight ) {

        if ( ! light.visible ) continue;

        r += color.r;
        g += color.g;
        b += color.b;

      } else if ( light instanceof THREE.DirectionalLight ) {

        dirCount += 1;

        if ( ! light.visible ) continue;

        _direction.setFromMatrixPosition( light.matrixWorld );
        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        _direction.sub( _vector3 );
        _direction.normalize();

        dirOffset = dirLength * 3;

        dirPositions[ dirOffset + 0 ] = _direction.x;
        dirPositions[ dirOffset + 1 ] = _direction.y;
        dirPositions[ dirOffset + 2 ] = _direction.z;

        setColorLinear( dirColors, dirOffset, color, intensity );

        dirLength += 1;

      } else if ( light instanceof THREE.PointLight ) {

        pointCount += 1;

        if ( ! light.visible ) continue;

        pointOffset = pointLength * 3;

        setColorLinear( pointColors, pointOffset, color, intensity );

        _vector3.setFromMatrixPosition( light.matrixWorld );

        pointPositions[ pointOffset + 0 ] = _vector3.x;
        pointPositions[ pointOffset + 1 ] = _vector3.y;
        pointPositions[ pointOffset + 2 ] = _vector3.z;

        // distance is 0 if decay is 0, because there is no attenuation at all.
        pointDistances[ pointLength ] = distance;
        pointDecays[ pointLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

        pointLength += 1;

      } else if ( light instanceof THREE.SpotLight ) {

        spotCount += 1;

        if ( ! light.visible ) continue;

        spotOffset = spotLength * 3;

        setColorLinear( spotColors, spotOffset, color, intensity );

        _direction.setFromMatrixPosition( light.matrixWorld );

        spotPositions[ spotOffset + 0 ] = _direction.x;
        spotPositions[ spotOffset + 1 ] = _direction.y;
        spotPositions[ spotOffset + 2 ] = _direction.z;

        spotDistances[ spotLength ] = distance;

        _vector3.setFromMatrixPosition( light.target.matrixWorld );
        _direction.sub( _vector3 );
        _direction.normalize();

        spotDirections[ spotOffset + 0 ] = _direction.x;
        spotDirections[ spotOffset + 1 ] = _direction.y;
        spotDirections[ spotOffset + 2 ] = _direction.z;

        spotAnglesCos[ spotLength ] = Math.cos( light.angle );
        spotExponents[ spotLength ] = light.exponent;
        spotDecays[ spotLength ] = ( light.distance === 0 ) ? 0.0 : light.decay;

        spotLength += 1;

      } else if ( light instanceof THREE.HemisphereLight ) {

        hemiCount += 1;

        if ( ! light.visible ) continue;

        _direction.setFromMatrixPosition( light.matrixWorld );
        _direction.normalize();

        hemiOffset = hemiLength * 3;

        hemiPositions[ hemiOffset + 0 ] = _direction.x;
        hemiPositions[ hemiOffset + 1 ] = _direction.y;
        hemiPositions[ hemiOffset + 2 ] = _direction.z;

        skyColor = light.color;
        groundColor = light.groundColor;

        setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
        setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

        hemiLength += 1;

      }

    }

    // null eventual remains from removed lights
    // (this is to avoid if in shader)

    for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
    for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
    for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
    for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
    for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

    zlights.directional.length = dirLength;
    zlights.point.length = pointLength;
    zlights.spot.length = spotLength;
    zlights.hemi.length = hemiLength;

    zlights.ambient[ 0 ] = r;
    zlights.ambient[ 1 ] = g;
    zlights.ambient[ 2 ] = b;

  }

  // GL state setting

  this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

    if ( cullFace === THREE.CullFaceNone ) {

      _gl.disable( _gl.CULL_FACE );

    } else {

      if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

        _gl.frontFace( _gl.CW );

      } else {

        _gl.frontFace( _gl.CCW );

      }

      if ( cullFace === THREE.CullFaceBack ) {

        _gl.cullFace( _gl.BACK );

      } else if ( cullFace === THREE.CullFaceFront ) {

        _gl.cullFace( _gl.FRONT );

      } else {

        _gl.cullFace( _gl.FRONT_AND_BACK );

      }

      _gl.enable( _gl.CULL_FACE );

    }

  };

  this.setMaterialFaces = function ( material ) {

    state.setDoubleSided( material.side === THREE.DoubleSide );
    state.setFlipSided( material.side === THREE.BackSide );

  };

  // Textures

  function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

    var extension;

    if ( isImagePowerOfTwo ) {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

    } else {

      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
      _gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

      if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

        console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping. ( ' + texture.sourceFile + ' )' );

      }

      _gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
      _gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

      if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

        console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter. ( ' + texture.sourceFile + ' )' );

      }

    }

    extension = extensions.get( 'EXT_texture_filter_anisotropic' );

    if ( extension && texture.type !== THREE.FloatType && texture.type !== THREE.HalfFloatType ) {

      if ( texture.anisotropy > 1 || texture.__currentAnisotropy ) {

        _gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );
        texture.__currentAnisotropy = texture.anisotropy;

      }

    }

  }

  this.uploadTexture = function ( texture, slot ) {

    if ( texture.__webglInit === undefined ) {

      texture.__webglInit = true;

      texture.addEventListener( 'dispose', onTextureDispose );

      texture.__webglTexture = _gl.createTexture();

      _this.info.memory.textures ++;

    }

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

    _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
    _gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
    _gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

    texture.image = clampToMaxSize( texture.image, _maxTextureSize );

    var image = texture.image,
    isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
    glFormat = paramThreeToGL( texture.format ),
    glType = paramThreeToGL( texture.type );

    setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

    var mipmap, mipmaps = texture.mipmaps;

    if ( texture instanceof THREE.DataTexture ) {

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

        texture.generateMipmaps = false;

      } else {

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

      }

    } else if ( texture instanceof THREE.CompressedTexture ) {

      for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

        mipmap = mipmaps[ i ];

        if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

          if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

            state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

          } else {

            console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

          }

        } else {

          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

        }

      }

    } else { // regular Texture (image, video, canvas)

      // use manually created mipmaps if available
      // if there are no manual mipmaps
      // set 0 level mipmap and then use GL to generate other mipmap levels

      if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

        for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

          mipmap = mipmaps[ i ];
          state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

        }

        texture.generateMipmaps = false;

      } else {

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

      }

    }

    if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

    texture.needsUpdate = false;

    if ( texture.onUpdate ) texture.onUpdate( texture );

  };

  this.setTexture = function ( texture, slot ) {

    if ( texture.needsUpdate === true ) {

      var image = texture.image;

      if ( image === undefined ) {

        console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
        return;

      }

      if ( image.complete === false ) {

        console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
        return;

      }

      _this.uploadTexture( texture, slot );
      return;

    }

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

  };

  function clampToMaxSize ( image, maxSize ) {

    if ( image.width > maxSize || image.height > maxSize ) {

      // Warning: Scaling through the canvas will only work with images that use
      // premultiplied alpha.

      var scale = maxSize / Math.max( image.width, image.height );

      var canvas = document.createElement( 'canvas' );
      canvas.width = Math.floor( image.width * scale );
      canvas.height = Math.floor( image.height * scale );

      var context = canvas.getContext( '2d' );
      context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

      console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

      return canvas;

    }

    return image;

  }

  function setCubeTexture ( texture, slot ) {

    if ( texture.image.length === 6 ) {

      if ( texture.needsUpdate ) {

        if ( ! texture.image.__webglTextureCube ) {

          texture.addEventListener( 'dispose', onTextureDispose );

          texture.image.__webglTextureCube = _gl.createTexture();

          _this.info.memory.textures ++;

        }

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

        _gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

        var isCompressed = texture instanceof THREE.CompressedTexture;
        var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

        var cubeImage = [];

        for ( var i = 0; i < 6; i ++ ) {

          if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {

            cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

          } else {

            cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

          }

        }

        var image = cubeImage[ 0 ],
        isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
        glFormat = paramThreeToGL( texture.format ),
        glType = paramThreeToGL( texture.type );

        setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          if ( ! isCompressed ) {

            if ( isDataTexture ) {

              state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

            } else {

              state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

            }

          } else {

            var mipmap, mipmaps = cubeImage[ i ].mipmaps;

            for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

              mipmap = mipmaps[ j ];

              if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

                if ( getCompressedTextureFormats().indexOf( glFormat ) > -1 ) {

                  state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

                } else {

                  console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()" );

                }

              } else {

                state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

              }

            }

          }

        }

        if ( texture.generateMipmaps && isImagePowerOfTwo ) {

          _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

        }

        texture.needsUpdate = false;

        if ( texture.onUpdate ) texture.onUpdate( texture );

      } else {

        state.activeTexture( _gl.TEXTURE0 + slot );
        state.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

      }

    }

  }

  function setCubeTextureDynamic ( texture, slot ) {

    state.activeTexture( _gl.TEXTURE0 + slot );
    state.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

  }

  // Render targets

  function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

    _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
    _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

  }

  function setupRenderBuffer ( renderbuffer, renderTarget ) {

    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

    if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    /* For some reason this is not working. Defaulting to RGBA4.
    } else if ( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
    */
    } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
      _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

    } else {

      _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

    }

  }

  this.setRenderTarget = function ( renderTarget ) {

    var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

    if ( renderTarget && renderTarget.__webglFramebuffer === undefined ) {

      if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
      if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

      renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

      renderTarget.__webglTexture = _gl.createTexture();

      _this.info.memory.textures ++;

      // Setup texture, create render and frame buffers

      var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
        glFormat = paramThreeToGL( renderTarget.format ),
        glType = paramThreeToGL( renderTarget.type );

      if ( isCube ) {

        renderTarget.__webglFramebuffer = [];
        renderTarget.__webglRenderbuffer = [];

        state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );

        setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

        for ( var i = 0; i < 6; i ++ ) {

          renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
          renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

          state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

          setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
          setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

        }

        if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

      } else {

        renderTarget.__webglFramebuffer = _gl.createFramebuffer();

        if ( renderTarget.shareDepthFrom ) {

          renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

        } else {

          renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

        }

        state.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
        setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

        state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

        setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

        if ( renderTarget.shareDepthFrom ) {

          if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

          } else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

            _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

          }

        } else {

          setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

        }

        if ( renderTarget.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

      }

      // Release everything

      if ( isCube ) {

        state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

      } else {

        state.bindTexture( _gl.TEXTURE_2D, null );

      }

      _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
      _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

    }

    var framebuffer, width, height, vx, vy;

    if ( renderTarget ) {

      if ( isCube ) {

        framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

      } else {

        framebuffer = renderTarget.__webglFramebuffer;

      }

      width = renderTarget.width;
      height = renderTarget.height;

      vx = 0;
      vy = 0;

    } else {

      framebuffer = null;

      width = _viewportWidth;
      height = _viewportHeight;

      vx = _viewportX;
      vy = _viewportY;

    }

    if ( framebuffer !== _currentFramebuffer ) {

      _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
      _gl.viewport( vx, vy, width, height );

      _currentFramebuffer = framebuffer;

    }

    _currentWidth = width;
    _currentHeight = height;

  };

  this.readRenderTargetPixels = function( renderTarget, x, y, width, height, buffer ) {

    if ( ! ( renderTarget instanceof THREE.WebGLRenderTarget ) ) {

      console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
      return;

    }

    if ( renderTarget.__webglFramebuffer ) {

      if ( renderTarget.format !== THREE.RGBAFormat ) {

        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA format. readPixels can read only RGBA format.' );
        return;

      }

      var restore = false;

      if ( renderTarget.__webglFramebuffer !== _currentFramebuffer ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTarget.__webglFramebuffer );

        restore = true;

      }

      if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

        _gl.readPixels( x, y, width, height, _gl.RGBA, _gl.UNSIGNED_BYTE, buffer );

      } else {

        console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

      }

      if ( restore ) {

        _gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

      }

    }

  };

  function updateRenderTargetMipmap ( renderTarget ) {

    if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

      state.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
      _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
      state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

    } else {

      state.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
      _gl.generateMipmap( _gl.TEXTURE_2D );
      state.bindTexture( _gl.TEXTURE_2D, null );

    }

  }

  // Fallback filters for non-power-of-2 textures

  function filterFallback ( f ) {

    if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

      return _gl.NEAREST;

    }

    return _gl.LINEAR;

  }

  // Map three.js constants to WebGL constants

  function paramThreeToGL ( p ) {

    var extension;

    if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
    if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
    if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

    if ( p === THREE.NearestFilter ) return _gl.NEAREST;
    if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
    if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

    if ( p === THREE.LinearFilter ) return _gl.LINEAR;
    if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
    if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

    if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
    if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
    if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
    if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

    if ( p === THREE.ByteType ) return _gl.BYTE;
    if ( p === THREE.ShortType ) return _gl.SHORT;
    if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
    if ( p === THREE.IntType ) return _gl.INT;
    if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
    if ( p === THREE.FloatType ) return _gl.FLOAT;

    extension = extensions.get( 'OES_texture_half_float' );

    if ( extension !== null ) {

      if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

    }

    if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
    if ( p === THREE.RGBFormat ) return _gl.RGB;
    if ( p === THREE.RGBAFormat ) return _gl.RGBA;
    if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
    if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

    if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
    if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
    if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

    if ( p === THREE.ZeroFactor ) return _gl.ZERO;
    if ( p === THREE.OneFactor ) return _gl.ONE;
    if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
    if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
    if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
    if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
    if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
    if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

    if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
    if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
    if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

    extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

    }

    extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

    if ( extension !== null ) {

      if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

    }

    extension = extensions.get( 'EXT_blend_minmax' );

    if ( extension !== null ) {

      if ( p === THREE.MinEquation ) return extension.MIN_EXT;
      if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

    }

    return 0;

  }

  // Allocations

  function allocateBones ( object ) {

    if ( _supportsBoneTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

      return 1024;

    } else {

      // default for when object is not specified
      // ( for example when prebuilding shader to be used with multiple objects )
      //
      //  - leave some extra space for other uniforms
      //  - limit here is ANGLE's 254 max uniform vectors
      //    (up to 54 should be safe)

      var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
      var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

      var maxBones = nVertexMatrices;

      if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

        maxBones = Math.min( object.skeleton.bones.length, maxBones );

        if ( maxBones < object.skeleton.bones.length ) {

          console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

        }

      }

      return maxBones;

    }

  }

  function allocateLights( lights ) {

    var dirLights = 0;
    var pointLights = 0;
    var spotLights = 0;
    var hemiLights = 0;

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];

      if ( light.onlyShadow || light.visible === false ) continue;

      if ( light instanceof THREE.DirectionalLight ) dirLights ++;
      if ( light instanceof THREE.PointLight ) pointLights ++;
      if ( light instanceof THREE.SpotLight ) spotLights ++;
      if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

    }

    return { 'directional': dirLights, 'point': pointLights, 'spot': spotLights, 'hemi': hemiLights };

  }

  function allocateShadows( lights ) {

    var maxShadows = 0;

    for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

      var light = lights[ l ];

      if ( ! light.castShadow ) continue;

      if ( light instanceof THREE.SpotLight ) maxShadows ++;
      if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

    }

    return maxShadows;

  }

  // DEPRECATED

  this.initMaterial = function () {

    console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

  };

  this.addPrePlugin = function () {

    console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

  };

  this.addPostPlugin = function () {

    console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

  };

  this.updateShadowMap = function () {

    console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

  };

  Object.defineProperties( this, {
    shadowMapEnabled: {
      get: function () {
        return shadowMap.enabled;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
        shadowMap.enabled = value;
      }
    },
    shadowMapType: {
      get: function () {
        return shadowMap.type;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
        shadowMap.type = value;
      }
    },
    shadowMapCullFace: {
      get: function () {
        return shadowMap.cullFace;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
        shadowMap.cullFace = value;
      }
    },
    shadowMapDebug: {
      get: function () {
        return shadowMap.debug;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapDebug is now .shadowMap.debug.' );
        shadowMap.debug = value;
      }
    },
    shadowMapCascade: {
      get: function () {
        return shadowMap.cascade;
      },
      set: function ( value ) {
        console.warn( 'THREE.WebGLRenderer: .shadowMapCascade is now .shadowMap.cascade.' );
        shadowMap.cascade = value;
      }
    }
  } );

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

  this.width = width;
  this.height = height;

  options = options || {};

  this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
  this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

  this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
  this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

  this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

  this.offset = new THREE.Vector2( 0, 0 );
  this.repeat = new THREE.Vector2( 1, 1 );

  this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
  this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

  this.generateMipmaps = true;

  this.shareDepthFrom = options.shareDepthFrom !== undefined ? options.shareDepthFrom : null;

};

THREE.WebGLRenderTarget.prototype = {

  constructor: THREE.WebGLRenderTarget,

  setSize: function ( width, height ) {

    if ( this.width !== width || this.height !== height ) {

      this.width = width;
      this.height = height;

      this.dispose();

    }
  },

  clone: function () {

    var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

    tmp.wrapS = this.wrapS;
    tmp.wrapT = this.wrapT;

    tmp.magFilter = this.magFilter;
    tmp.minFilter = this.minFilter;

    tmp.anisotropy = this.anisotropy;

    tmp.offset.copy( this.offset );
    tmp.repeat.copy( this.repeat );

    tmp.format = this.format;
    tmp.type = this.type;

    tmp.depthBuffer = this.depthBuffer;
    tmp.stencilBuffer = this.stencilBuffer;

    tmp.generateMipmaps = this.generateMipmaps;

    tmp.shareDepthFrom = this.shareDepthFrom;

    return tmp;

  },

  dispose: function () {

    this.dispatchEvent( { type: 'dispose' } );

  }

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

  THREE.WebGLRenderTarget.call( this, width, height, options );

  this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

  var extensions = {};

  this.get = function ( name ) {

    if ( extensions[ name ] !== undefined ) {

      return extensions[ name ];

    }

    var extension;

    switch ( name ) {

      case 'EXT_texture_filter_anisotropic':
        extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
        break;

      case 'WEBGL_compressed_texture_s3tc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
        break;

      case 'WEBGL_compressed_texture_pvrtc':
        extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
        break;

      default:
        extension = gl.getExtension( name );

    }

    if ( extension === null ) {

      console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

    }

    extensions[ name ] = extension;

    return extension;

  };

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLGeometries = function ( gl, info ) {

  var geometries = {};

  this.get = function ( object ) {

    var geometry = object.geometry;

    if ( geometries[ geometry.id ] !== undefined ) {

      return geometries[ geometry.id ];

    }

    geometry.addEventListener( 'dispose', onGeometryDispose );

    if ( geometry instanceof THREE.BufferGeometry ) {

      geometries[ geometry.id ] = geometry;

    } else {

      geometries[ geometry.id ] = new THREE.BufferGeometry().setFromObject( object );

    }

    info.memory.geometries ++;

    return geometries[ geometry.id ];

  };

  function onGeometryDispose( event ) {

    var geometry = event.target;

    geometry.removeEventListener( 'dispose', onGeometryDispose );

    geometry = geometries[ geometry.id ];

    for ( var name in geometry.attributes ) {

      var attribute = geometry.attributes[ name ];

      if ( attribute.buffer !== undefined ) {

        gl.deleteBuffer( attribute.buffer );

        delete attribute.buffer;

      }

    }

    info.memory.geometries --;

  }

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLObjects = function ( gl, info ) {

  var objects = {};
  var objectsImmediate = [];

  var morphInfluences = new Float32Array( 8 );

  var geometries = new THREE.WebGLGeometries( gl, info );

  //

  function onObjectRemoved( event ) {

    var object = event.target;

    object.traverse( function ( child ) {

      child.removeEventListener( 'remove', onObjectRemoved );
      removeObject( child );

    } );

  }

  function removeObject( object ) {

    if ( object instanceof THREE.Mesh ||
       object instanceof THREE.PointCloud ||
       object instanceof THREE.Line ) {

      delete objects[ object.id ];

    } else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

      removeInstances( objectsImmediate, object );

    }

    delete object.__webglInit;
    delete object._modelViewMatrix;
    delete object._normalMatrix;

    delete object.__webglActive;

  }

  function removeInstances( objlist, object ) {

    for ( var o = objlist.length - 1; o >= 0; o -- ) {

      if ( objlist[ o ].object === object ) {

        objlist.splice( o, 1 );

      }

    }

  }

  //

  this.objects = objects;
  this.objectsImmediate = objectsImmediate;

  this.geometries = geometries;

  this.init = function ( object ) {

    if ( object.__webglInit === undefined ) {

      object.__webglInit = true;
      object._modelViewMatrix = new THREE.Matrix4();
      object._normalMatrix = new THREE.Matrix3();

      object.addEventListener( 'removed', onObjectRemoved );

    }

    if ( object.__webglActive === undefined ) {

      object.__webglActive = true;

      if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.PointCloud ) {

        objects[ object.id ] = {
          id: object.id,
          object: object,
          z: 0
        };

      } else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

        objectsImmediate.push( {
          id: null,
          object: object,
          opaque: null,
          transparent: null,
          z: 0
        } );

      }

    }

  };

  function numericalSort ( a, b ) {

    return b[ 0 ] - a[ 0 ];

  }

  function updateObject( object ) {

    var geometry = geometries.get( object );

    if ( object.geometry.dynamic === true ) {

      geometry.updateFromObject( object );

    }

    // morph targets

    if ( object.morphTargetInfluences !== undefined ) {

      var activeInfluences = [];
      var morphTargetInfluences = object.morphTargetInfluences;

      for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

        var influence = morphTargetInfluences[ i ];
        activeInfluences.push( [ influence, i ] );

      }

      activeInfluences.sort( numericalSort );

      if ( activeInfluences.length > 8 ) {

        activeInfluences.length = 8;

      }

      for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

        morphInfluences[ i ] = activeInfluences[ i ][ 0 ];

        var attribute = geometry.morphAttributes[ activeInfluences[ i ][ 1 ] ];
        geometry.addAttribute( 'morphTarget' + i, attribute );

      }

      var material = object.material;

      if ( material.program !== undefined ) {

        if ( material.program.uniforms.morphTargetInfluences !== null ) {

          gl.uniform1fv( material.program.uniforms.morphTargetInfluences, morphInfluences );

        }

      } else {

        console.warn( 'TOFIX: material.program is undefined' );

      }

    }

    //

    var attributes = geometry.attributes;

    for ( var name in attributes ) {

      var attribute = attributes[ name ];

      var bufferType = ( name === 'index' ) ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;

      var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

      if ( data.buffer === undefined ) {

        data.buffer = gl.createBuffer();
        gl.bindBuffer( bufferType, data.buffer );

        var usage = gl.STATIC_DRAW;

        if ( data instanceof THREE.DynamicBufferAttribute
             || ( data instanceof THREE.InstancedBufferAttribute && data.dynamic === true )
             || ( data instanceof THREE.InterleavedBuffer && data.dynamic === true ) ) {

          usage = gl.DYNAMIC_DRAW;

        }

        gl.bufferData( bufferType, data.array, usage );

        data.needsUpdate = false;

      } else if ( data.needsUpdate === true ) {

        gl.bindBuffer( bufferType, data.buffer );

        if ( data.updateRange === undefined || data.updateRange.count === -1 ) { // Not using update ranges

          gl.bufferSubData( bufferType, 0, data.array );

        } else if ( data.updateRange.count === 0 ) {

          console.error( 'THREE.WebGLRenderer.updateObject: using updateRange for THREE.DynamicBufferAttribute and marked as needsUpdate but count is 0, ensure you are using set methods or updating manually.' );

        } else {

          gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
                   data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

          data.updateRange.count = 0; // reset range

        }

        data.needsUpdate = false;

      }

    }

  };

  this.update = function ( renderList ) {

    for ( var i = 0, ul = renderList.length; i < ul; i++ ) {

      var object = renderList[i].object;

      if ( object.material.visible !== false ) {

        updateObject( object );

      }

    }

  };

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

  var programIdCount = 0;

  function generateDefines( defines ) {

    var chunks = [];

    for ( var name in defines ) {

      var value = defines[ name ];

      if ( value === false ) continue;

      chunks.push( '#define ' + name + ' ' + value );

    }

    return chunks.join( '\n' );

  }

  function fetchUniformLocations( gl, program, identifiers ) {


    var uniforms = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveUniform( program , i );
      var name = info.name;
      var location = gl.getUniformLocation( program, name );

      //console.log("THREE.WebGLProgram: ACTIVE UNIFORM:", name);

      var suffixPos = name.lastIndexOf( '[0]' );
      if ( suffixPos !== -1 && suffixPos === name.length - 3 ) {

        uniforms[ name.substr( 0, suffixPos ) ] = location;

      }

      uniforms[ name ] = location;

    }

    return uniforms;

  }

  function fetchAttributeLocations( gl, program, identifiers ) {

    var attributes = {};

    var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

    for ( var i = 0; i < n; i ++ ) {

      var info = gl.getActiveAttrib( program , i );
      var name = info.name;

      //console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name);

      attributes[ name ] = gl.getAttribLocation( program, name );

    }

    return attributes;

  }

  function filterEmptyLine( string ) {

    return string !== '';

  }

  return function ( renderer, code, material, parameters ) {

    var gl = renderer.context;

    var defines = material.defines;
    var uniforms = material.__webglShader.uniforms;
    var attributes = material.attributes;

    var vertexShader = material.__webglShader.vertexShader;
    var fragmentShader = material.__webglShader.fragmentShader;

    var index0AttributeName = material.index0AttributeName;

    /*
    if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

      // programs with morphTargets displace position out of attribute 0

      index0AttributeName = 'position';

    }
    */

    var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

    if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

    } else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

      shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

    }

    var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
    var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
    var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

    if ( parameters.envMap ) {

      switch ( material.envMap.mapping ) {

        case THREE.CubeReflectionMapping:
        case THREE.CubeRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
          break;

        case THREE.EquirectangularReflectionMapping:
        case THREE.EquirectangularRefractionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
          break;

        case THREE.SphericalReflectionMapping:
          envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
          break;

      }

      switch ( material.envMap.mapping ) {

        case THREE.CubeRefractionMapping:
        case THREE.EquirectangularRefractionMapping:
          envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
          break;

      }

      switch ( material.combine ) {

        case THREE.MultiplyOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
          break;

        case THREE.MixOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
          break;

        case THREE.AddOperation:
          envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
          break;

      }

    }

    var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

    // console.log( 'building new program ' );

    //

    var customDefines = generateDefines( defines );

    //

    var program = gl.createProgram();

    var prefixVertex, prefixFragment;

    if ( material instanceof THREE.RawShaderMaterial ) {

      prefixVertex = '';
      prefixFragment = '';

    } else {

      prefixVertex = [

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        customDefines,

        parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

        renderer.gammaInput ? '#define GAMMA_INPUT' : '',
        renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

        '#define MAX_SHADOWS ' + parameters.maxShadows,

        '#define MAX_BONES ' + parameters.maxBones,

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED': '',

        parameters.skinning ? '#define USE_SKINNING' : '',
        parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

        parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
        parameters.morphNormals ? '#define USE_MORPHNORMALS' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

        parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',


        'uniform mat4 modelMatrix;',
        'uniform mat4 modelViewMatrix;',
        'uniform mat4 projectionMatrix;',
        'uniform mat4 viewMatrix;',
        'uniform mat3 normalMatrix;',
        'uniform vec3 cameraPosition;',

        'attribute vec3 position;',
        'attribute vec3 normal;',
        'attribute vec2 uv;',

        '#ifdef USE_COLOR',

        ' attribute vec3 color;',

        '#endif',

        '#ifdef USE_MORPHTARGETS',

        ' attribute vec3 morphTarget0;',
        ' attribute vec3 morphTarget1;',
        ' attribute vec3 morphTarget2;',
        ' attribute vec3 morphTarget3;',

        ' #ifdef USE_MORPHNORMALS',

        '   attribute vec3 morphNormal0;',
        '   attribute vec3 morphNormal1;',
        '   attribute vec3 morphNormal2;',
        '   attribute vec3 morphNormal3;',

        ' #else',

        '   attribute vec3 morphTarget4;',
        '   attribute vec3 morphTarget5;',
        '   attribute vec3 morphTarget6;',
        '   attribute vec3 morphTarget7;',

        ' #endif',

        '#endif',

        '#ifdef USE_SKINNING',

        ' attribute vec4 skinIndex;',
        ' attribute vec4 skinWeight;',

        '#endif',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

      prefixFragment = [

        ( parameters.bumpMap || parameters.normalMap || parameters.flatShading || material.derivatives ) ? '#extension GL_OES_standard_derivatives : enable' : '',

        'precision ' + parameters.precision + ' float;',
        'precision ' + parameters.precision + ' int;',

        customDefines,

        '#define MAX_DIR_LIGHTS ' + parameters.maxDirLights,
        '#define MAX_POINT_LIGHTS ' + parameters.maxPointLights,
        '#define MAX_SPOT_LIGHTS ' + parameters.maxSpotLights,
        '#define MAX_HEMI_LIGHTS ' + parameters.maxHemiLights,

        '#define MAX_SHADOWS ' + parameters.maxShadows,

        parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

        renderer.gammaInput ? '#define GAMMA_INPUT' : '',
        renderer.gammaOutput ? '#define GAMMA_OUTPUT' : '',
        '#define GAMMA_FACTOR ' + gammaFactorDefine,

        ( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
        ( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

        parameters.map ? '#define USE_MAP' : '',
        parameters.envMap ? '#define USE_ENVMAP' : '',
        parameters.envMap ? '#define ' + envMapTypeDefine : '',
        parameters.envMap ? '#define ' + envMapModeDefine : '',
        parameters.envMap ? '#define ' + envMapBlendingDefine : '',
        parameters.lightMap ? '#define USE_LIGHTMAP' : '',
        parameters.aoMap ? '#define USE_AOMAP' : '',
        parameters.bumpMap ? '#define USE_BUMPMAP' : '',
        parameters.normalMap ? '#define USE_NORMALMAP' : '',
        parameters.specularMap ? '#define USE_SPECULARMAP' : '',
        parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
        parameters.vertexColors ? '#define USE_COLOR' : '',

        parameters.flatShading ? '#define FLAT_SHADED': '',

        parameters.metal ? '#define METAL' : '',
        parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
        parameters.flipSided ? '#define FLIP_SIDED' : '',

        parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
        parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
        parameters.shadowMapDebug ? '#define SHADOWMAP_DEBUG' : '',
        parameters.shadowMapCascade ? '#define SHADOWMAP_CASCADE' : '',

        parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
        parameters.logarithmicDepthBuffer && renderer.extensions.get('EXT_frag_depth') ? '#define USE_LOGDEPTHBUF_EXT' : '',

        'uniform mat4 viewMatrix;',
        'uniform vec3 cameraPosition;',

        '\n'

      ].filter( filterEmptyLine ).join( '\n' );

    }

    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;

    var glVertexShader = new THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
    var glFragmentShader = new THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

    gl.attachShader( program, glVertexShader );
    gl.attachShader( program, glFragmentShader );

    if ( index0AttributeName !== undefined ) {

      // Force a particular attribute to index 0.
      // because potentially expensive emulation is done by browser if attribute 0 is disabled.
      // And, color, for example is often automatically bound to index 0 so disabling it

      gl.bindAttribLocation( program, 0, index0AttributeName );

    }

    gl.linkProgram( program );

    var programLogInfo = gl.getProgramInfoLog( program );
    var vertexErrorLogInfo = gl.getShaderInfoLog( glVertexShader );
    var fragmentErrorLogInfo = gl.getShaderInfoLog( glFragmentShader );

    if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

      console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLogInfo, vertexErrorLogInfo, fragmentErrorLogInfo );

    }

    if ( programLogInfo !== '' ) {

      console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLogInfo );

    }

    // clean up

    gl.deleteShader( glVertexShader );
    gl.deleteShader( glFragmentShader );

    // set up caching for uniform locations

    var getUniforms = function() { return this._cachedUniforms; };

    this.getUniforms = function() {

      // fetch, cache, and next time just use a dumb accessor
      var uniforms = fetchUniformLocations( gl, program );
      this._cachedUniforms = uniforms;
      this.getUniforms = getUniforms;
      return uniforms;

    };

    // set up caching for attribute locations

    var getAttributes = function() { return this._cachedAttributes; };

    this.getAttributes = function() {

      var attributes = fetchAttributeLocations( gl, program );
      this._cachedAttributes = attributes;
      this.getAttributes = getAttributes;
      return attributes;

    };

    // DEPRECATED

    Object.defineProperties( this, {

      uniforms: {
        get: function() {

          console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
          return this.getUniforms();

        }
      },

      attributes: {
        get: function() {

          console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
          return this.getAttributes();

        }
      }

    });


    //

    this.id = programIdCount ++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;

    return this;

  };

} )();

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

  var addLineNumbers = function ( string ) {

    var lines = string.split( '\n' );

    for ( var i = 0; i < lines.length; i ++ ) {

      lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

    }

    return lines.join( '\n' );

  };

  return function ( gl, type, string ) {

    var shader = gl.createShader( type );

    gl.shaderSource( shader, string );
    gl.compileShader( shader );

    if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

      console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

    }

    if ( gl.getShaderInfoLog( shader ) !== '' ) {

      console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

    }

    // --enable-privileged-webgl-extension
    // console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

    return shader;

  };

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

  var _gl = _renderer.context,
  _frustum = new THREE.Frustum(),
  _projScreenMatrix = new THREE.Matrix4(),

  _min = new THREE.Vector3(),
  _max = new THREE.Vector3(),

  _webglObjects = _objects.objects,
  _webglObjectsImmediate = _objects.objectsImmediate,

  _matrixPosition = new THREE.Vector3(),

  _renderList = [];

  // init

  var depthShader = THREE.ShaderLib[ "depthRGBA" ];
  var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

  var _depthMaterial = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader
   } );

  var _depthMaterialMorph = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    morphTargets: true
  } );

  var _depthMaterialSkin = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    skinning: true
  } );

  var _depthMaterialMorphSkin = new THREE.ShaderMaterial( {
    uniforms: depthUniforms,
    vertexShader: depthShader.vertexShader,
    fragmentShader: depthShader.fragmentShader,
    morphTargets: true,
    skinning: true
  } );

  _depthMaterial._shadowPass = true;
  _depthMaterialMorph._shadowPass = true;
  _depthMaterialSkin._shadowPass = true;
  _depthMaterialMorphSkin._shadowPass = true;

  //

  var scope = this;

  this.enabled = false;
  this.type = THREE.PCFShadowMap;
  this.cullFace = THREE.CullFaceFront;
  this.debug = false;
  this.cascade = false;

  this.render = function ( scene, camera ) {

    if ( scope.enabled === false ) return;

    var i, il, j, jl, n,

    shadowMap, shadowMatrix, shadowCamera,
    webglObject, object, material, light,

    lights = [],
    k = 0,

    fog = null;

    // set GL state for depth map

    _gl.clearColor( 1, 1, 1, 1 );
    _gl.disable( _gl.BLEND );

    _gl.enable( _gl.CULL_FACE );
    _gl.frontFace( _gl.CCW );

    if ( scope.cullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.FRONT );

    } else {

      _gl.cullFace( _gl.BACK );

    }

    _renderer.state.setDepthTest( true );

    // preprocess lights
    //  - skip lights that are not casting shadows
    //  - create virtual lights for cascaded shadow maps

    for ( i = 0, il = _lights.length; i < il; i ++ ) {

      light = _lights[ i ];

      if ( ! light.castShadow ) continue;

      if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

        for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

          var virtualLight;

          if ( ! light.shadowCascadeArray[ n ] ) {

            virtualLight = createVirtualLight( light, n );
            virtualLight.originalCamera = camera;

            var gyro = new THREE.Gyroscope();
            gyro.position.copy( light.shadowCascadeOffset );

            gyro.add( virtualLight );
            gyro.add( virtualLight.target );

            camera.add( gyro );

            light.shadowCascadeArray[ n ] = virtualLight;

            //console.log( "Created virtualLight", virtualLight );

          } else {

            virtualLight = light.shadowCascadeArray[ n ];

          }

          updateVirtualLight( light, n );

          lights[ k ] = virtualLight;
          k ++;

        }

      } else {

        lights[ k ] = light;
        k ++;

      }

    }

    // render depth map

    for ( i = 0, il = lights.length; i < il; i ++ ) {

      light = lights[ i ];

      if ( ! light.shadowMap ) {

        var shadowFilter = THREE.LinearFilter;

        if ( scope.type === THREE.PCFSoftShadowMap ) {

          shadowFilter = THREE.NearestFilter;

        }

        var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

        light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
        light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

        light.shadowMatrix = new THREE.Matrix4();

      }

      if ( ! light.shadowCamera ) {

        if ( light instanceof THREE.SpotLight ) {

          light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

        } else if ( light instanceof THREE.DirectionalLight ) {

          light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

        } else {

          console.error( "THREE.ShadowMapPlugin: Unsupported light type for shadow", light );
          continue;

        }

        scene.add( light.shadowCamera );

        if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

      }

      if ( light.shadowCameraVisible && ! light.cameraHelper ) {

        light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
        scene.add( light.cameraHelper );

      }

      if ( light.isVirtual && virtualLight.originalCamera == camera ) {

        updateShadowCamera( camera, light );

      }

      shadowMap = light.shadowMap;
      shadowMatrix = light.shadowMatrix;
      shadowCamera = light.shadowCamera;

      //

      shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
      _matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
      shadowCamera.lookAt( _matrixPosition );
      shadowCamera.updateMatrixWorld();

      shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

      //

      if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
      if ( light.shadowCameraVisible ) light.cameraHelper.update();

      // compute shadow matrix

      shadowMatrix.set(
        0.5, 0.0, 0.0, 0.5,
        0.0, 0.5, 0.0, 0.5,
        0.0, 0.0, 0.5, 0.5,
        0.0, 0.0, 0.0, 1.0
      );

      shadowMatrix.multiply( shadowCamera.projectionMatrix );
      shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

      // update camera matrices and frustum

      _projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
      _frustum.setFromMatrix( _projScreenMatrix );

      // render shadow map

      _renderer.setRenderTarget( shadowMap );
      _renderer.clear();

      // set object matrices & frustum culling

      _renderList.length = 0;

      projectObject( scene, shadowCamera );


      // render regular objects

      var objectMaterial, useMorphing, useSkinning;

      for ( j = 0, jl = _renderList.length; j < jl; j ++ ) {

        webglObject = _renderList[ j ];

        object = webglObject.object;

        // culling is overriden globally for all objects
        // while rendering depth map

        // need to deal with MeshFaceMaterial somehow
        // in that case just use the first of material.materials for now
        // (proper solution would require to break objects by materials
        //  similarly to regular rendering and then set corresponding
        //  depth materials per each chunk instead of just once per object)

        objectMaterial = getObjectMaterial( object );

        useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
        useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

        if ( object.customDepthMaterial ) {

          material = object.customDepthMaterial;

        } else if ( useSkinning ) {

          material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

        } else if ( useMorphing ) {

          material = _depthMaterialMorph;

        } else {

          material = _depthMaterial;

        }

        _renderer.setMaterialFaces( objectMaterial );
        _renderer.renderBufferDirect( shadowCamera, _lights, fog, material, object );

      }

      // set matrices and render immediate objects

      for ( j = 0, jl = _webglObjectsImmediate.length; j < jl; j ++ ) {

        webglObject = _webglObjectsImmediate[ j ];
        object = webglObject.object;

        if ( object.visible && object.castShadow ) {

          object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

          _renderer.renderImmediateObject( shadowCamera, _lights, fog, _depthMaterial, object );

        }

      }

    }

    // restore GL state

    var clearColor = _renderer.getClearColor(),
    clearAlpha = _renderer.getClearAlpha();

    _gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
    _gl.enable( _gl.BLEND );

    if ( scope.cullFace === THREE.CullFaceFront ) {

      _gl.cullFace( _gl.BACK );

    }

    _renderer.resetGLState();

  };

  function projectObject( object, shadowCamera ) {

    if ( object.visible === true ) {

      var webglObject = _objects.objects[ object.id ];

      if ( webglObject && object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

        object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
        _renderList.push( webglObject );

      }

      for ( var i = 0, l = object.children.length; i < l; i ++ ) {

        projectObject( object.children[ i ], shadowCamera );

      }

    }

  }

  function createVirtualLight( light, cascade ) {

    var virtualLight = new THREE.DirectionalLight();

    virtualLight.isVirtual = true;

    virtualLight.onlyShadow = true;
    virtualLight.castShadow = true;

    virtualLight.shadowCameraNear = light.shadowCameraNear;
    virtualLight.shadowCameraFar = light.shadowCameraFar;

    virtualLight.shadowCameraLeft = light.shadowCameraLeft;
    virtualLight.shadowCameraRight = light.shadowCameraRight;
    virtualLight.shadowCameraBottom = light.shadowCameraBottom;
    virtualLight.shadowCameraTop = light.shadowCameraTop;

    virtualLight.shadowCameraVisible = light.shadowCameraVisible;

    virtualLight.shadowDarkness = light.shadowDarkness;

    virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
    virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
    virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

    virtualLight.pointsWorld = [];
    virtualLight.pointsFrustum = [];

    var pointsWorld = virtualLight.pointsWorld,
      pointsFrustum = virtualLight.pointsFrustum;

    for ( var i = 0; i < 8; i ++ ) {

      pointsWorld[ i ] = new THREE.Vector3();
      pointsFrustum[ i ] = new THREE.Vector3();

    }

    var nearZ = light.shadowCascadeNearZ[ cascade ];
    var farZ = light.shadowCascadeFarZ[ cascade ];

    pointsFrustum[ 0 ].set( - 1, - 1, nearZ );
    pointsFrustum[ 1 ].set(  1, - 1, nearZ );
    pointsFrustum[ 2 ].set( - 1,  1, nearZ );
    pointsFrustum[ 3 ].set(  1,  1, nearZ );

    pointsFrustum[ 4 ].set( - 1, - 1, farZ );
    pointsFrustum[ 5 ].set(  1, - 1, farZ );
    pointsFrustum[ 6 ].set( - 1,  1, farZ );
    pointsFrustum[ 7 ].set(  1,  1, farZ );

    return virtualLight;

  }

  // Synchronize virtual light with the original light

  function updateVirtualLight( light, cascade ) {

    var virtualLight = light.shadowCascadeArray[ cascade ];

    virtualLight.position.copy( light.position );
    virtualLight.target.position.copy( light.target.position );
    virtualLight.lookAt( virtualLight.target );

    virtualLight.shadowCameraVisible = light.shadowCameraVisible;
    virtualLight.shadowDarkness = light.shadowDarkness;

    virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

    var nearZ = light.shadowCascadeNearZ[ cascade ];
    var farZ = light.shadowCascadeFarZ[ cascade ];

    var pointsFrustum = virtualLight.pointsFrustum;

    pointsFrustum[ 0 ].z = nearZ;
    pointsFrustum[ 1 ].z = nearZ;
    pointsFrustum[ 2 ].z = nearZ;
    pointsFrustum[ 3 ].z = nearZ;

    pointsFrustum[ 4 ].z = farZ;
    pointsFrustum[ 5 ].z = farZ;
    pointsFrustum[ 6 ].z = farZ;
    pointsFrustum[ 7 ].z = farZ;

  }

  // Fit shadow camera's ortho frustum to camera frustum

  function updateShadowCamera( camera, light ) {

    var shadowCamera = light.shadowCamera,
      pointsFrustum = light.pointsFrustum,
      pointsWorld = light.pointsWorld;

    _min.set( Infinity, Infinity, Infinity );
    _max.set( - Infinity, - Infinity, - Infinity );

    for ( var i = 0; i < 8; i ++ ) {

      var p = pointsWorld[ i ];

      p.copy( pointsFrustum[ i ] );
      p.unproject( camera );

      p.applyMatrix4( shadowCamera.matrixWorldInverse );

      if ( p.x < _min.x ) _min.x = p.x;
      if ( p.x > _max.x ) _max.x = p.x;

      if ( p.y < _min.y ) _min.y = p.y;
      if ( p.y > _max.y ) _max.y = p.y;

      if ( p.z < _min.z ) _min.z = p.z;
      if ( p.z > _max.z ) _max.z = p.z;

    }

    shadowCamera.left = _min.x;
    shadowCamera.right = _max.x;
    shadowCamera.top = _max.y;
    shadowCamera.bottom = _min.y;

    // can't really fit near/far
    //shadowCamera.near = _min.z;
    //shadowCamera.far = _max.z;

    shadowCamera.updateProjectionMatrix();

  }

  // For the moment just ignore objects that have multiple materials with different animation methods
  // Only the first material will be taken into account for deciding which depth material to use for shadow maps

  function getObjectMaterial( object ) {

    return object.material instanceof THREE.MeshFaceMaterial
      ? object.material.materials[ 0 ]
      : object.material;

  }

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLState = function ( gl, paramThreeToGL ) {

  var _this = this;

  var newAttributes = new Uint8Array( 16 );
  var enabledAttributes = new Uint8Array( 16 );

  var currentBlending = null;
  var currentBlendEquation = null;
  var currentBlendSrc = null;
  var currentBlendDst = null;
  var currentBlendEquationAlpha = null;
  var currentBlendSrcAlpha = null;
  var currentBlendDstAlpha = null;

  var currentDepthFunc = null;
  var currentDepthTest = null;
  var currentDepthWrite = null;

  var currentColorWrite = null;

  var currentDoubleSided = null;
  var currentFlipSided = null;

  var currentLineWidth = null;

  var currentPolygonOffset = null;
  var currentPolygonOffsetFactor = null;
  var currentPolygonOffsetUnits = null;

  var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

  var currentTextureSlot = undefined;
  var currentBoundTextures = {};

  this.initAttributes = function () {

    for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

      newAttributes[ i ] = 0;

    }

  };

  this.enableAttribute = function ( attribute ) {

    newAttributes[ attribute ] = 1;

    if ( enabledAttributes[ attribute ] === 0 ) {

      gl.enableVertexAttribArray( attribute );
      enabledAttributes[ attribute ] = 1;

    }

  };

  this.disableUnusedAttributes = function () {

    for ( var i = 0, l = enabledAttributes.length; i < l; i ++ ) {

      if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

        gl.disableVertexAttribArray( i );
        enabledAttributes[ i ] = 0;

      }

    }

  };

  this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha ) {

    if ( blending !== currentBlending ) {

      if ( blending === THREE.NoBlending ) {

        gl.disable( gl.BLEND );

      } else if ( blending === THREE.AdditiveBlending ) {

        gl.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

      } else if ( blending === THREE.SubtractiveBlending ) {

        // TODO: Find blendFuncSeparate() combination
        gl.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

      } else if ( blending === THREE.MultiplyBlending ) {

        // TODO: Find blendFuncSeparate() combination
        gl.enable( gl.BLEND );
        gl.blendEquation( gl.FUNC_ADD );
        gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

      } else if ( blending === THREE.CustomBlending ) {

        gl.enable( gl.BLEND );

      } else {

        gl.enable( gl.BLEND );
        gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
        gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

      }

      currentBlending = blending;

    }

    if ( blending === THREE.CustomBlending ) {

      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;

      if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

        gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;

      }

      if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

        gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;

      }

    } else {

      currentBlendEquation = null;
      currentBlendSrc = null;
      currentBlendDst = null;
      currentBlendEquationAlpha = null;
      currentBlendSrcAlpha = null;
      currentBlendDstAlpha = null;

    }

  };

  this.setDepthFunc = function ( depthFunc ) {

      if ( currentDepthFunc !== depthFunc ) {

          if ( depthFunc ) {

              switch ( depthFunc ) {

                  case THREE.NeverDepth:

                      gl.depthFunc( gl.NEVER );
                      break;

                  case THREE.AlwaysDepth:

                      gl.depthFunc( gl.ALWAYS );
                      break;

                  case THREE.LessDepth:

                      gl.depthFunc( gl.LESS );
                      break;

                  case THREE.LessEqualDepth:

                      gl.depthFunc( gl.LEQUAL );
                      break;

                  case THREE.EqualDepth:

                      gl.depthFunc( gl.EQUAL );
                      break;

                  case THREE.GreaterEqualDepth:

                      gl.depthFunc( gl.GEQUAL );
                      break;

                  case THREE.GreaterDepth:

                      gl.depthFunc( gl.GREATER );
                      break;

                  case THREE.NotEqualDepth:

                      gl.depthFunc( gl.NOTEQUAL );
                      break;

                  default:

                        gl.depthFunc( gl.LEQUAL );
              }

          } else {

              gl.depthFunc( gl.LEQUAL );

          }

          currentDepthFunc = depthFunc;

      }

  };

  this.setDepthTest = function ( depthTest ) {

    if ( currentDepthTest !== depthTest ) {

      if ( depthTest ) {

        gl.enable( gl.DEPTH_TEST );

      } else {

        gl.disable( gl.DEPTH_TEST );

      }

      currentDepthTest = depthTest;

    }

  };

  this.setDepthWrite = function ( depthWrite ) {

    if ( currentDepthWrite !== depthWrite ) {

      gl.depthMask( depthWrite );
      currentDepthWrite = depthWrite;

    }

  };

  this.setColorWrite = function ( colorWrite ) {

    if ( currentColorWrite !== colorWrite ) {

      gl.colorMask( colorWrite, colorWrite, colorWrite, colorWrite );
      currentColorWrite = colorWrite;

    }

  };

  this.setDoubleSided = function ( doubleSided ) {

    if ( currentDoubleSided !== doubleSided ) {

      if ( doubleSided ) {

        gl.disable( gl.CULL_FACE );

      } else {

        gl.enable( gl.CULL_FACE );

      }

      currentDoubleSided = doubleSided;

    }

  };

  this.setFlipSided = function ( flipSided ) {

    if ( currentFlipSided !== flipSided ) {

      if ( flipSided ) {

        gl.frontFace( gl.CW );

      } else {

        gl.frontFace( gl.CCW );

      }

      currentFlipSided = flipSided;

    }

  };

  this.setLineWidth = function ( width ) {

    if ( width !== currentLineWidth ) {

      gl.lineWidth( width );

      currentLineWidth = width;

    }

  };

  this.setPolygonOffset = function ( polygonoffset, factor, units ) {

    if ( currentPolygonOffset !== polygonoffset ) {

      if ( polygonoffset ) {

        gl.enable( gl.POLYGON_OFFSET_FILL );

      } else {

        gl.disable( gl.POLYGON_OFFSET_FILL );

      }

      currentPolygonOffset = polygonoffset;

    }

    if ( polygonoffset && ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) ) {

      gl.polygonOffset( factor, units );

      currentPolygonOffsetFactor = factor;
      currentPolygonOffsetUnits = units;

    }

  };

  // texture

  this.activeTexture = function ( webglSlot ) {

    if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

    if ( currentTextureSlot !== webglSlot ) {

      gl.activeTexture( webglSlot );
      currentTextureSlot = webglSlot;

    }

  }

  this.bindTexture = function ( webglType, webglTexture ) {

    if ( currentTextureSlot === undefined ) {

      _this.activeTexture();

    }

    var boundTexture = currentBoundTextures[currentTextureSlot];

    if ( boundTexture === undefined ) {

      boundTexture = { type: undefined, texture: undefined };
      currentBoundTextures[currentTextureSlot] = boundTexture;

    }

    if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

      gl.bindTexture( webglType, webglTexture );

      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;

    }

  };

  this.compressedTexImage2D = function () {

    try {

      gl.compressedTexImage2D.apply( gl, arguments );

    } catch ( error ) {

      console.error( error );

    }

  };

  this.texImage2D = function () {

    try {

      gl.texImage2D.apply( gl, arguments );

    } catch ( error ) {

      console.error( error );

    }

  };

  //

  this.reset = function () {

    for ( var i = 0; i < enabledAttributes.length; i ++ ) {

      if ( enabledAttributes[ i ] === 1 ) {

        gl.disableVertexAttribArray( i );
        enabledAttributes[ i ] = 0;

      }

    }

    currentBlending = null;
    currentDepthTest = null;
    currentDepthWrite = null;
    currentColorWrite = null;
    currentDoubleSided = null;
    currentFlipSided = null;

  };

};

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

  var gl = renderer.context;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;
  var hasVertexTexture;

  var tempTexture, occlusionTexture;

  var init = function () {

    var vertices = new Float32Array( [
      -1, -1,  0, 0,
       1, -1,  1, 0,
       1,  1,  1, 1,
      -1,  1,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    // buffers

    vertexBuffer     = gl.createBuffer();
    elementBuffer    = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    // textures

    tempTexture      = gl.createTexture();
    occlusionTexture = gl.createTexture();

    renderer.state.bindTexture( gl.TEXTURE_2D, tempTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    renderer.state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

    hasVertexTexture = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) > 0;

    var shader;

    if ( hasVertexTexture ) {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "uniform sampler2D occlusionMap;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if( renderType == 2 ) {",

              "vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

              "vVisibility =        visibility.r / 9.0;",
              "vVisibility *= 1.0 - visibility.g / 9.0;",
              "vVisibility *=       visibility.b / 9.0;",
              "vVisibility *= 1.0 - visibility.a / 9.0;",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",
          "varying float vVisibility;",

          "void main() {",

            // pink square

            "if( renderType == 0 ) {",

              "gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

            // restore

            "} else if( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * vVisibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    } else {

      shader = {

        vertexShader: [

          "uniform lowp int renderType;",

          "uniform vec3 screenPosition;",
          "uniform vec2 scale;",
          "uniform float rotation;",

          "attribute vec2 position;",
          "attribute vec2 uv;",

          "varying vec2 vUV;",

          "void main() {",

            "vUV = uv;",

            "vec2 pos = position;",

            "if( renderType == 2 ) {",

              "pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
              "pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

            "}",

            "gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

          "}"

        ].join( "\n" ),

        fragmentShader: [

          "precision mediump float;",

          "uniform lowp int renderType;",

          "uniform sampler2D map;",
          "uniform sampler2D occlusionMap;",
          "uniform float opacity;",
          "uniform vec3 color;",

          "varying vec2 vUV;",

          "void main() {",

            // pink square

            "if( renderType == 0 ) {",

              "gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

            // restore

            "} else if( renderType == 1 ) {",

              "gl_FragColor = texture2D( map, vUV );",

            // flare

            "} else {",

              "float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
              "visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
              "visibility = ( 1.0 - visibility / 4.0 );",

              "vec4 texture = texture2D( map, vUV );",
              "texture.a *= opacity * visibility;",
              "gl_FragColor = texture;",
              "gl_FragColor.rgb *= color;",

            "}",

          "}"

        ].join( "\n" )

      };

    }

    program = createProgram( shader );

    attributes = {
      vertex: gl.getAttribLocation ( program, "position" ),
      uv:     gl.getAttribLocation ( program, "uv" )
    };

    uniforms = {
      renderType:     gl.getUniformLocation( program, "renderType" ),
      map:            gl.getUniformLocation( program, "map" ),
      occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
      opacity:        gl.getUniformLocation( program, "opacity" ),
      color:          gl.getUniformLocation( program, "color" ),
      scale:          gl.getUniformLocation( program, "scale" ),
      rotation:       gl.getUniformLocation( program, "rotation" ),
      screenPosition: gl.getUniformLocation( program, "screenPosition" )
    };

  };

  /*
   * Render lens flares
   * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
   *         reads these back and calculates occlusion.
   */

  this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

    if ( flares.length === 0 ) return;

    var tempPosition = new THREE.Vector3();

    var invAspect = viewportHeight / viewportWidth,
      halfViewportWidth = viewportWidth * 0.5,
      halfViewportHeight = viewportHeight * 0.5;

    var size = 16 / viewportHeight,
      scale = new THREE.Vector2( size * invAspect, size );

    var screenPosition = new THREE.Vector3( 1, 1, 0 ),
      screenPositionPixels = new THREE.Vector2( 1, 1 );

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    renderer.state.initAttributes();
    renderer.state.enableAttribute( attributes.vertex );
    renderer.state.enableAttribute( attributes.uv );
    renderer.state.disableUnusedAttributes();

    // loop through all lens flares to update their occlusion and positions
    // setup gl and common used attribs/unforms

    gl.uniform1i( uniforms.occlusionMap, 0 );
    gl.uniform1i( uniforms.map, 1 );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    gl.disable( gl.CULL_FACE );
    gl.depthMask( false );

    for ( var i = 0, l = flares.length; i < l; i ++ ) {

      size = 16 / viewportHeight;
      scale.set( size * invAspect, size );

      // calc object screen position

      var flare = flares[ i ];

      tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

      tempPosition.applyMatrix4( camera.matrixWorldInverse );
      tempPosition.applyProjection( camera.projectionMatrix );

      // setup arrays for gl programs

      screenPosition.copy( tempPosition );

      screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
      screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

      // screen cull

      if ( hasVertexTexture || (
        screenPositionPixels.x > 0 &&
        screenPositionPixels.x < viewportWidth &&
        screenPositionPixels.y > 0 &&
        screenPositionPixels.y < viewportHeight ) ) {

        // save current RGB to temp texture

        renderer.state.activeTexture( gl.TEXTURE1 );
        renderer.state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


        // render pink quad

        gl.uniform1i( uniforms.renderType, 0 );
        gl.uniform2f( uniforms.scale, scale.x, scale.y );
        gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

        gl.disable( gl.BLEND );
        gl.enable( gl.DEPTH_TEST );

        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // copy result to occlusionMap

        renderer.state.activeTexture( gl.TEXTURE0 );
        renderer.state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
        gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


        // restore graphics

        gl.uniform1i( uniforms.renderType, 1 );
        gl.disable( gl.DEPTH_TEST );

        renderer.state.activeTexture( gl.TEXTURE1 );
        renderer.state.bindTexture( gl.TEXTURE_2D, tempTexture );
        gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


        // update object positions

        flare.positionScreen.copy( screenPosition );

        if ( flare.customUpdateCallback ) {

          flare.customUpdateCallback( flare );

        } else {

          flare.updateLensFlares();

        }

        // render flares

        gl.uniform1i( uniforms.renderType, 2 );
        gl.enable( gl.BLEND );

        for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

          var sprite = flare.lensFlares[ j ];

          if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

            screenPosition.x = sprite.x;
            screenPosition.y = sprite.y;
            screenPosition.z = sprite.z;

            size = sprite.size * sprite.scale / viewportHeight;

            scale.x = size * invAspect;
            scale.y = size;

            gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
            gl.uniform2f( uniforms.scale, scale.x, scale.y );
            gl.uniform1f( uniforms.rotation, sprite.rotation );

            gl.uniform1f( uniforms.opacity, sprite.opacity );
            gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

            renderer.state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
            renderer.setTexture( sprite.texture, 1 );

            gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

          }

        }

      }

    }

    // restore gl

    gl.enable( gl.CULL_FACE );
    gl.enable( gl.DEPTH_TEST );
    gl.depthMask( true );

    renderer.resetGLState();

  };

  function createProgram ( shader ) {

    var program = gl.createProgram();

    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
    var vertexShader = gl.createShader( gl.VERTEX_SHADER );

    var prefix = "precision " + renderer.getPrecision() + " float;\n";

    gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
    gl.shaderSource( vertexShader, prefix + shader.vertexShader );

    gl.compileShader( fragmentShader );
    gl.compileShader( vertexShader );

    gl.attachShader( program, fragmentShader );
    gl.attachShader( program, vertexShader );

    gl.linkProgram( program );

    return program;

  }

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

  var gl = renderer.context;

  var vertexBuffer, elementBuffer;
  var program, attributes, uniforms;

  var texture;

  // decompose matrixWorld

  var spritePosition = new THREE.Vector3();
  var spriteRotation = new THREE.Quaternion();
  var spriteScale = new THREE.Vector3();

  var init = function () {

    var vertices = new Float32Array( [
      - 0.5, - 0.5,  0, 0,
        0.5, - 0.5,  1, 0,
        0.5,   0.5,  1, 1,
      - 0.5,   0.5,  0, 1
    ] );

    var faces = new Uint16Array( [
      0, 1, 2,
      0, 2, 3
    ] );

    vertexBuffer  = gl.createBuffer();
    elementBuffer = gl.createBuffer();

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

    program = createProgram();

    attributes = {
      position:     gl.getAttribLocation ( program, 'position' ),
      uv:         gl.getAttribLocation ( program, 'uv' )
    };

    uniforms = {
      uvOffset:     gl.getUniformLocation( program, 'uvOffset' ),
      uvScale:      gl.getUniformLocation( program, 'uvScale' ),

      rotation:     gl.getUniformLocation( program, 'rotation' ),
      scale:        gl.getUniformLocation( program, 'scale' ),

      color:        gl.getUniformLocation( program, 'color' ),
      map:        gl.getUniformLocation( program, 'map' ),
      opacity:      gl.getUniformLocation( program, 'opacity' ),

      modelViewMatrix:  gl.getUniformLocation( program, 'modelViewMatrix' ),
      projectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),

      fogType:      gl.getUniformLocation( program, 'fogType' ),
      fogDensity:     gl.getUniformLocation( program, 'fogDensity' ),
      fogNear:      gl.getUniformLocation( program, 'fogNear' ),
      fogFar:       gl.getUniformLocation( program, 'fogFar' ),
      fogColor:     gl.getUniformLocation( program, 'fogColor' ),

      alphaTest:      gl.getUniformLocation( program, 'alphaTest' )
    };

    var canvas = document.createElement( 'canvas' );
    canvas.width = 8;
    canvas.height = 8;

    var context = canvas.getContext( '2d' );
    context.fillStyle = 'white';
    context.fillRect( 0, 0, 8, 8 );

    texture = new THREE.Texture( canvas );
    texture.needsUpdate = true;

  };

  this.render = function ( scene, camera ) {

    if ( sprites.length === 0 ) return;

    // setup gl

    if ( program === undefined ) {

      init();

    }

    gl.useProgram( program );

    renderer.state.initAttributes();
    renderer.state.enableAttribute( attributes.position );
    renderer.state.enableAttribute( attributes.uv );
    renderer.state.disableUnusedAttributes();

    gl.disable( gl.CULL_FACE );
    gl.enable( gl.BLEND );

    gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
    gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
    gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

    gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

    renderer.state.activeTexture( gl.TEXTURE0 );
    gl.uniform1i( uniforms.map, 0 );

    var oldFogType = 0;
    var sceneFogType = 0;
    var fog = scene.fog;

    if ( fog ) {

      gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

      if ( fog instanceof THREE.Fog ) {

        gl.uniform1f( uniforms.fogNear, fog.near );
        gl.uniform1f( uniforms.fogFar, fog.far );

        gl.uniform1i( uniforms.fogType, 1 );
        oldFogType = 1;
        sceneFogType = 1;

      } else if ( fog instanceof THREE.FogExp2 ) {

        gl.uniform1f( uniforms.fogDensity, fog.density );

        gl.uniform1i( uniforms.fogType, 2 );
        oldFogType = 2;
        sceneFogType = 2;

      }

    } else {

      gl.uniform1i( uniforms.fogType, 0 );
      oldFogType = 0;
      sceneFogType = 0;

    }


    // update positions and sort

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];

      sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
      sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

    }

    sprites.sort( painterSortStable );

    // render all sprites

    var scale = [];

    for ( var i = 0, l = sprites.length; i < l; i ++ ) {

      var sprite = sprites[ i ];
      var material = sprite.material;

      gl.uniform1f( uniforms.alphaTest, material.alphaTest );
      gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

      sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

      scale[ 0 ] = spriteScale.x;
      scale[ 1 ] = spriteScale.y;

      var fogType = 0;

      if ( scene.fog && material.fog ) {

        fogType = sceneFogType;

      }

      if ( oldFogType !== fogType ) {

        gl.uniform1i( uniforms.fogType, fogType );
        oldFogType = fogType;

      }

      if ( material.map !== null ) {

        gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
        gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

      } else {

        gl.uniform2f( uniforms.uvOffset, 0, 0 );
        gl.uniform2f( uniforms.uvScale, 1, 1 );

      }

      gl.uniform1f( uniforms.opacity, material.opacity );
      gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

      gl.uniform1f( uniforms.rotation, material.rotation );
      gl.uniform2fv( uniforms.scale, scale );

      renderer.state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
      renderer.state.setDepthTest( material.depthTest );
      renderer.state.setDepthWrite( material.depthWrite );

      if ( material.map && material.map.image && material.map.image.width ) {

        renderer.setTexture( material.map, 0 );

      } else {

        renderer.setTexture( texture, 0 );

      }

      gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

    }

    // restore gl

    gl.enable( gl.CULL_FACE );

    renderer.resetGLState();

  };

  function createProgram () {

    var program = gl.createProgram();

    var vertexShader = gl.createShader( gl.VERTEX_SHADER );
    var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

    gl.shaderSource( vertexShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform float rotation;',
      'uniform vec2 scale;',
      'uniform vec2 uvOffset;',
      'uniform vec2 uvScale;',

      'attribute vec2 position;',
      'attribute vec2 uv;',

      'varying vec2 vUV;',

      'void main() {',

        'vUV = uvOffset + uv * uvScale;',

        'vec2 alignedPosition = position * scale;',

        'vec2 rotatedPosition;',
        'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
        'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

        'vec4 finalPosition;',

        'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
        'finalPosition.xy += rotatedPosition;',
        'finalPosition = projectionMatrix * finalPosition;',

        'gl_Position = finalPosition;',

      '}'

    ].join( '\n' ) );

    gl.shaderSource( fragmentShader, [

      'precision ' + renderer.getPrecision() + ' float;',

      'uniform vec3 color;',
      'uniform sampler2D map;',
      'uniform float opacity;',

      'uniform int fogType;',
      'uniform vec3 fogColor;',
      'uniform float fogDensity;',
      'uniform float fogNear;',
      'uniform float fogFar;',
      'uniform float alphaTest;',

      'varying vec2 vUV;',

      'void main() {',

        'vec4 texture = texture2D( map, vUV );',

        'if ( texture.a < alphaTest ) discard;',

        'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

        'if ( fogType > 0 ) {',

          'float depth = gl_FragCoord.z / gl_FragCoord.w;',
          'float fogFactor = 0.0;',

          'if ( fogType == 1 ) {',

            'fogFactor = smoothstep( fogNear, fogFar, depth );',

          '} else {',

            'const float LOG2 = 1.442695;',
            'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
            'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

          '}',

          'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

        '}',

      '}'

    ].join( '\n' ) );

    gl.compileShader( vertexShader );
    gl.compileShader( fragmentShader );

    gl.attachShader( program, vertexShader );
    gl.attachShader( program, fragmentShader );

    gl.linkProgram( program );

    return program;

  }

  function painterSortStable ( a, b ) {

    if ( a.z !== b.z ) {

      return b.z - a.z;

    } else {

      return b.id - a.id;

    }

  }

};

// File:src/extras/GeometryUtils.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GeometryUtils = {

  merge: function ( geometry1, geometry2, materialIndexOffset ) {

    console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

    var matrix;

    if ( geometry2 instanceof THREE.Mesh ) {

      geometry2.matrixAutoUpdate && geometry2.updateMatrix();

      matrix = geometry2.matrix;
      geometry2 = geometry2.geometry;

    }

    geometry1.merge( geometry2, matrix, materialIndexOffset );

  },

  center: function ( geometry ) {

    console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
    return geometry.center();

  }

};

// File:src/extras/ImageUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Daosheng Mu / https://github.com/DaoshengMu/
 */

THREE.ImageUtils = {

  crossOrigin: undefined,

  loadTexture: function ( url, mapping, onLoad, onError ) {

    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;

    var texture = new THREE.Texture( undefined, mapping );

    loader.load( url, function ( image ) {

      texture.image = image;
      texture.needsUpdate = true;

      if ( onLoad ) onLoad( texture );

    }, undefined, function ( event ) {

      if ( onError ) onError( event );

    } );

    texture.sourceFile = url;

    return texture;

  },

  loadTextureCube: function ( array, mapping, onLoad, onError ) {

    var images = [];

    var loader = new THREE.ImageLoader();
    loader.crossOrigin = this.crossOrigin;

    var texture = new THREE.CubeTexture( images, mapping );

    // no flipping needed for cube textures

    texture.flipY = false;

    var loaded = 0;

    var loadTexture = function ( i ) {

      loader.load( array[ i ], function ( image ) {

        texture.images[ i ] = image;

        loaded += 1;

        if ( loaded === 6 ) {

          texture.needsUpdate = true;

          if ( onLoad ) onLoad( texture );

        }

      }, undefined, onError );

    };

    for ( var i = 0, il = array.length; i < il; ++ i ) {

      loadTexture( i );

    }

    return texture;

  },

  loadCompressedTexture: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' )

  },

  loadCompressedTextureCube: function () {

    console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' )

  },

  getNormalMap: function ( image, depth ) {

    // Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

    var cross = function ( a, b ) {

      return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

    };

    var subtract = function ( a, b ) {

      return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

    };

    var normalize = function ( a ) {

      var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
      return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

    };

    depth = depth | 1;

    var width = image.width;
    var height = image.height;

    var canvas = document.createElement( 'canvas' );
    canvas.width = width;
    canvas.height = height;

    var context = canvas.getContext( '2d' );
    context.drawImage( image, 0, 0 );

    var data = context.getImageData( 0, 0, width, height ).data;
    var imageData = context.createImageData( width, height );
    var output = imageData.data;

    for ( var x = 0; x < width; x ++ ) {

      for ( var y = 0; y < height; y ++ ) {

        var ly = y - 1 < 0 ? 0 : y - 1;
        var uy = y + 1 > height - 1 ? height - 1 : y + 1;
        var lx = x - 1 < 0 ? 0 : x - 1;
        var ux = x + 1 > width - 1 ? width - 1 : x + 1;

        var points = [];
        var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
        points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
        points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
        points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
        points.push( [ 1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
        points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
        points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

        var normals = [];
        var num_points = points.length;

        for ( var i = 0; i < num_points; i ++ ) {

          var v1 = points[ i ];
          var v2 = points[ ( i + 1 ) % num_points ];
          v1 = subtract( v1, origin );
          v2 = subtract( v2, origin );
          normals.push( normalize( cross( v1, v2 ) ) );

        }

        var normal = [ 0, 0, 0 ];

        for ( var i = 0; i < normals.length; i ++ ) {

          normal[ 0 ] += normals[ i ][ 0 ];
          normal[ 1 ] += normals[ i ][ 1 ];
          normal[ 2 ] += normals[ i ][ 2 ];

        }

        normal[ 0 ] /= normals.length;
        normal[ 1 ] /= normals.length;
        normal[ 2 ] /= normals.length;

        var idx = ( y * width + x ) * 4;

        output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
        output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
        output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
        output[ idx + 3 ] = 255;

      }

    }

    context.putImageData( imageData, 0, 0 );

    return canvas;

  },

  generateDataTexture: function ( width, height, color ) {

    var size = width * height;
    var data = new Uint8Array( 3 * size );

    var r = Math.floor( color.r * 255 );
    var g = Math.floor( color.g * 255 );
    var b = Math.floor( color.b * 255 );

    for ( var i = 0; i < size; i ++ ) {

      data[ i * 3 ]      = r;
      data[ i * 3 + 1 ] = g;
      data[ i * 3 + 2 ] = b;

    }

    var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
    texture.needsUpdate = true;

    return texture;

  }

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

  createMultiMaterialObject: function ( geometry, materials ) {

    var group = new THREE.Object3D();

    for ( var i = 0, l = materials.length; i < l; i ++ ) {

      group.add( new THREE.Mesh( geometry, materials[ i ] ) );

    }

    return group;

  },

  detach: function ( child, parent, scene ) {

    child.applyMatrix( parent.matrixWorld );
    parent.remove( child );
    scene.add( child );

  },

  attach: function ( child, scene, parent ) {

    var matrixWorldInverse = new THREE.Matrix4();
    matrixWorldInverse.getInverse( parent.matrixWorld );
    child.applyMatrix( matrixWorldInverse );

    scene.remove( child );
    parent.add( child );

  }

};

// File:src/extras/FontUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 *  Triangulation ported from AS3
 *    Simple Polygon Triangulation
 *    http://actionsnippet.com/?p=1462
 *
 *  A Method to triangulate shapes with holes
 *    http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

  faces: {},

  // Just for now. face[weight][style]

  face: 'helvetiker',
  weight: 'normal',
  style: 'normal',
  size: 150,
  divisions: 10,

  getFace: function () {

    try {

      return this.faces[ this.face ][ this.weight ][ this.style ];

    } catch (e) {

      throw "The font " + this.face + " with " + this.weight + " weight and " + this.style + " style is missing."

    }

  },

  loadFace: function ( data ) {

    var family = data.familyName.toLowerCase();

    var ThreeFont = this;

    ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

    ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
    ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

    ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

    return data;

  },

  drawText: function ( text ) {

    // RenderText

    var i,
      face = this.getFace(),
      scale = this.size / face.resolution,
      offset = 0,
      chars = String( text ).split( '' ),
      length = chars.length;

    var fontPaths = [];

    for ( i = 0; i < length; i ++ ) {

      var path = new THREE.Path();

      var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
      offset += ret.offset;

      fontPaths.push( ret.path );

    }

    // get the width

    var width = offset / 2;
    //
    // for ( p = 0; p < allPts.length; p++ ) {
    //
    //  allPts[ p ].x -= width;
    //
    // }

    //var extract = this.extractPoints( allPts, characterPts );
    //extract.contour = allPts;

    //extract.paths = fontPaths;
    //extract.offset = width;

    return { paths: fontPaths, offset: width };

  },




  extractGlyphPoints: function ( c, face, scale, offset, path ) {

    var pts = [];

    var i, i2, divisions,
      outline, action, length,
      scaleX, scaleY,
      x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
      laste,
      glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

    if ( ! glyph ) return;

    if ( glyph.o ) {

      outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
      length = outline.length;

      scaleX = scale;
      scaleY = scale;

      for ( i = 0; i < length; ) {

        action = outline[ i ++ ];

        //console.log( action );

        switch ( action ) {

        case 'm':

          // Move To

          x = outline[ i ++ ] * scaleX + offset;
          y = outline[ i ++ ] * scaleY;

          path.moveTo( x, y );
          break;

        case 'l':

          // Line To

          x = outline[ i ++ ] * scaleX + offset;
          y = outline[ i ++ ] * scaleY;
          path.lineTo( x, y );
          break;

        case 'q':

          // QuadraticCurveTo

          cpx  = outline[ i ++ ] * scaleX + offset;
          cpy  = outline[ i ++ ] * scaleY;
          cpx1 = outline[ i ++ ] * scaleX + offset;
          cpy1 = outline[ i ++ ] * scaleY;

          path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

          laste = pts[ pts.length - 1 ];

          if ( laste ) {

            cpx0 = laste.x;
            cpy0 = laste.y;

            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

              var t = i2 / divisions;
              THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
              THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
            }

          }

          break;

        case 'b':

          // Cubic Bezier Curve

          cpx  = outline[ i ++ ] *  scaleX + offset;
          cpy  = outline[ i ++ ] *  scaleY;
          cpx1 = outline[ i ++ ] *  scaleX + offset;
          cpy1 = outline[ i ++ ] *  scaleY;
          cpx2 = outline[ i ++ ] *  scaleX + offset;
          cpy2 = outline[ i ++ ] *  scaleY;

          path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

          laste = pts[ pts.length - 1 ];

          if ( laste ) {

            cpx0 = laste.x;
            cpy0 = laste.y;

            for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

              var t = i2 / divisions;
              THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
              THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

            }

          }

          break;

        }

      }
    }



    return { offset: glyph.ha * scale, path:path };
  }

};


THREE.FontUtils.generateShapes = function ( text, parameters ) {

  // Parameters

  parameters = parameters || {};

  var size = parameters.size !== undefined ? parameters.size : 100;
  var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments : 4;

  var font = parameters.font !== undefined ? parameters.font : 'helvetiker';
  var weight = parameters.weight !== undefined ? parameters.weight : 'normal';
  var style = parameters.style !== undefined ? parameters.style : 'normal';

  THREE.FontUtils.size = size;
  THREE.FontUtils.divisions = curveSegments;

  THREE.FontUtils.face = font;
  THREE.FontUtils.weight = weight;
  THREE.FontUtils.style = style;

  // Get a Font data json object

  var data = THREE.FontUtils.drawText( text );

  var paths = data.paths;
  var shapes = [];

  for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

    Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

  }

  return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function ( namespace ) {

  var EPSILON = 0.0000000001;

  // takes in an contour array and returns

  var process = function ( contour, indices ) {

    var n = contour.length;

    if ( n < 3 ) return null;

    var result = [],
      verts = [],
      vertIndices = [];

    /* we want a counter-clockwise polygon in verts */

    var u, v, w;

    if ( area( contour ) > 0.0 ) {

      for ( v = 0; v < n; v ++ ) verts[ v ] = v;

    } else {

      for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

    }

    var nv = n;

    /*  remove nv - 2 vertices, creating 1 triangle every time */

    var count = 2 * nv;   /* error detection */

    for ( v = nv - 1; nv > 2; ) {

      /* if we loop, it is probably a non-simple polygon */

      if ( ( count -- ) <= 0 ) {

        //** Triangulate: ERROR - probable bad polygon!

        //throw ( "Warning, unable to triangulate polygon!" );
        //return null;
        // Sometimes warning is fine, especially polygons are triangulated in reverse.
        console.warn( 'THREE.FontUtils: Warning, unable to triangulate polygon! in Triangulate.process()' );

        if ( indices ) return vertIndices;
        return result;

      }

      /* three consecutive vertices in current polygon, <u,v,w> */

      u = v;    if ( nv <= u ) u = 0;     /* previous */
      v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
      w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

      if ( snip( contour, u, v, w, nv, verts ) ) {

        var a, b, c, s, t;

        /* true names of the vertices */

        a = verts[ u ];
        b = verts[ v ];
        c = verts[ w ];

        /* output Triangle */

        result.push( [ contour[ a ],
          contour[ b ],
          contour[ c ] ] );


        vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

        /* remove v from the remaining polygon */

        for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

          verts[ s ] = verts[ t ];

        }

        nv --;

        /* reset error detection counter */

        count = 2 * nv;

      }

    }

    if ( indices ) return vertIndices;
    return result;

  };

  // calculate area of the contour polygon

  var area = function ( contour ) {

    var n = contour.length;
    var a = 0.0;

    for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

      a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

    }

    return a * 0.5;

  };

  var snip = function ( contour, u, v, w, n, verts ) {

    var p;
    var ax, ay, bx, by;
    var cx, cy, px, py;

    ax = contour[ verts[ u ] ].x;
    ay = contour[ verts[ u ] ].y;

    bx = contour[ verts[ v ] ].x;
    by = contour[ verts[ v ] ].y;

    cx = contour[ verts[ w ] ].x;
    cy = contour[ verts[ w ] ].y;

    if ( EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

    var aX, aY, bX, bY, cX, cY;
    var apx, apy, bpx, bpy, cpx, cpy;
    var cCROSSap, bCROSScp, aCROSSbp;

    aX = cx - bx;  aY = cy - by;
    bX = ax - cx;  bY = ay - cy;
    cX = bx - ax;  cY = by - ay;

    for ( p = 0; p < n; p ++ ) {

      px = contour[ verts[ p ] ].x;
      py = contour[ verts[ p ] ].y;

      if ( ( ( px === ax ) && ( py === ay ) ) ||
         ( ( px === bx ) && ( py === by ) ) ||
         ( ( px === cx ) && ( py === cy ) ) ) continue;

      apx = px - ax;  apy = py - ay;
      bpx = px - bx;  bpy = py - by;
      cpx = px - cx;  cpy = py - cy;

      // see if p is inside triangle abc

      aCROSSbp = aX * bpy - aY * bpx;
      cCROSSap = cX * apy - cY * apx;
      bCROSScp = bX * cpy - bY * cpx;

      if ( ( aCROSSbp >= - EPSILON ) && ( bCROSScp >= - EPSILON ) && ( cCROSSap >= - EPSILON ) ) return false;

    }

    return true;

  };


  namespace.Triangulate = process;
  namespace.Triangulate.area = area;

  return namespace;

} )( THREE.FontUtils );

// To use the typeface.js face files, hook up the API

THREE.typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
if ( typeof self !== 'undefined' ) self._typeface_js = THREE.typeface_js;

// File:src/extras/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Audio = function ( listener ) {

  THREE.Object3D.call( this );

  this.type = 'Audio';

  this.context = listener.context;
  this.source = this.context.createBufferSource();
  this.source.onended = this.onEnded.bind(this);

  this.gain = this.context.createGain();
  this.gain.connect( this.context.destination );

  this.panner = this.context.createPanner();
  this.panner.connect( this.gain );

  this.autoplay = false;

  this.startTime = 0;
  this.isPlaying = false;

};

THREE.Audio.prototype = Object.create( THREE.Object3D.prototype );
THREE.Audio.prototype.constructor = THREE.Audio;

THREE.Audio.prototype.load = function ( file ) {

  var scope = this;

  var request = new XMLHttpRequest();
  request.open( 'GET', file, true );
  request.responseType = 'arraybuffer';
  request.onload = function ( e ) {

    scope.context.decodeAudioData( this.response, function ( buffer ) {

      scope.source.buffer = buffer;

      if( scope.autoplay ) scope.play();

    } );

  };
  request.send();

  return this;

};

THREE.Audio.prototype.play = function () {

  if ( this.isPlaying === true ) {

    console.warn( 'THREE.Audio: Audio is already playing.' );
    return;

  }

  var source = this.context.createBufferSource();

  source.buffer = this.source.buffer;
  source.loop = this.source.loop;
  source.onended = this.source.onended;
  source.connect( this.panner );
  source.start( 0, this.startTime );

  this.isPlaying = true;

  this.source = source;

};

THREE.Audio.prototype.pause = function () {

  this.source.stop();
  this.startTime = this.context.currentTime;

};

THREE.Audio.prototype.stop = function () {

  this.source.stop();
  this.startTime = 0;

};

THREE.Audio.prototype.onEnded = function() {

  this.isPlaying = false;

};

THREE.Audio.prototype.setLoop = function ( value ) {

  this.source.loop = value;

};

THREE.Audio.prototype.setRefDistance = function ( value ) {

  this.panner.refDistance = value;

};

THREE.Audio.prototype.setRolloffFactor = function ( value ) {

  this.panner.rolloffFactor = value;

};

THREE.Audio.prototype.setVolume = function ( value ) {

  this.gain.gain.value = value;

};

THREE.Audio.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();

  return function ( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    position.setFromMatrixPosition( this.matrixWorld );

    this.panner.setPosition( position.x, position.y, position.z );

  };

} )();

// File:src/extras/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

  THREE.Object3D.call( this );

  this.type = 'AudioListener';

  this.context = new ( window.AudioContext || window.webkitAudioContext )();

};

THREE.AudioListener.prototype = Object.create( THREE.Object3D.prototype );
THREE.AudioListener.prototype.constructor = THREE.AudioListener;

THREE.AudioListener.prototype.updateMatrixWorld = ( function () {

  var position = new THREE.Vector3();
  var quaternion = new THREE.Quaternion();
  var scale = new THREE.Vector3();

  var orientation = new THREE.Vector3();

  return function ( force ) {

    THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

    var listener = this.context.listener;
    var up = this.up;

    this.matrixWorld.decompose( position, quaternion, scale );

    orientation.set( 0, 0, -1 ).applyQuaternion( quaternion );

    listener.setPosition( position.x, position.y, position.z );
    listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

  };

} )();

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *  Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//  - t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

  console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
  return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

  var t = this.getUtoTmapping( u );
  return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 5;

  var d, pts = [];

  for ( d = 0; d <= divisions; d ++ ) {

    pts.push( this.getPoint( d / divisions ) );

  }

  return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

  if ( ! divisions ) divisions = 5;

  var d, pts = [];

  for ( d = 0; d <= divisions; d ++ ) {

    pts.push( this.getPointAt( d / divisions ) );

  }

  return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

  var lengths = this.getLengths();
  return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

  if ( ! divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions) : 200;

  if ( this.cacheArcLengths
    && ( this.cacheArcLengths.length === divisions + 1 )
    && ! this.needsUpdate) {

    //console.log( "cached", this.cacheArcLengths );
    return this.cacheArcLengths;

  }

  this.needsUpdate = false;

  var cache = [];
  var current, last = this.getPoint( 0 );
  var p, sum = 0;

  cache.push( 0 );

  for ( p = 1; p <= divisions; p ++ ) {

    current = this.getPoint ( p / divisions );
    sum += current.distanceTo( last );
    cache.push( sum );
    last = current;

  }

  this.cacheArcLengths = cache;

  return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
  this.needsUpdate = true;
  this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

  var arcLengths = this.getLengths();

  var i = 0, il = arcLengths.length;

  var targetArcLength; // The targeted u distance value to get

  if ( distance ) {

    targetArcLength = distance;

  } else {

    targetArcLength = u * arcLengths[ il - 1 ];

  }

  //var time = Date.now();

  // binary search for the index with largest value smaller than target u distance

  var low = 0, high = il - 1, comparison;

  while ( low <= high ) {

    i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

    comparison = arcLengths[ i ] - targetArcLength;

    if ( comparison < 0 ) {

      low = i + 1;

    } else if ( comparison > 0 ) {

      high = i - 1;

    } else {

      high = i;
      break;

      // DONE

    }

  }

  i = high;

  //console.log('b' , i, low, high, Date.now()- time);

  if ( arcLengths[ i ] === targetArcLength ) {

    var t = i / ( il - 1 );
    return t;

  }

  // we could get finer grain at lengths, or use simple interpolatation between two points

  var lengthBefore = arcLengths[ i ];
  var lengthAfter = arcLengths[ i + 1 ];

  var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

  var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

  var t = ( i + segmentFraction ) / ( il - 1 );

  return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

  var delta = 0.0001;
  var t1 = t - delta;
  var t2 = t + delta;

  // Capping in case of danger

  if ( t1 < 0 ) t1 = 0;
  if ( t2 > 1 ) t2 = 1;

  var pt1 = this.getPoint( t1 );
  var pt2 = this.getPoint( t2 );

  var vec = pt2.clone().sub(pt1);
  return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

  var t = this.getUtoTmapping( u );
  return this.getTangent( t );

};





/**************************************************************
 *  Utils
 **************************************************************/

THREE.Curve.Utils = {

  tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

    return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

  },

  // Puay Bing, thanks for helping with this derivative!

  tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

    return - 3 * p0 * (1 - t) * (1 - t)  +
      3 * p1 * (1 - t) * (1 - t) - 6 * t * p1 * (1 - t) +
      6 * t *  p2 * (1 - t) - 3 * t * t * p2 +
      3 * t * t * p3;

  },

  tangentSpline: function ( t, p0, p1, p2, p3 ) {

    // To check if my formulas are correct

    var h00 = 6 * t * t - 6 * t;  // derived from 2t^3 − 3t^2 + 1
    var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
    var h01 = - 6 * t * t + 6 * t;  // − 2t3 + 3t2
    var h11 = 3 * t * t - 2 * t;  // t3 − t2

    return h00 + h10 + h01 + h11;

  },

  // Catmull-Rom

  interpolate: function( p0, p1, p2, p3, t ) {

    var v0 = ( p2 - p0 ) * 0.5;
    var v1 = ( p3 - p1 ) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

  }

};


// TODO: Transformation for Curves?

/**************************************************************
 *  3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

  constructor.prototype = Object.create( THREE.Curve.prototype );
  constructor.prototype.constructor = constructor;
  constructor.prototype.getPoint = getPointFunc;

  return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *  Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

  this.curves = [];
  this.bends = [];

  this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );
THREE.CurvePath.prototype.constructor = THREE.CurvePath;

THREE.CurvePath.prototype.add = function ( curve ) {

  this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
  // TODO
  // If the ending of curve is not connected to the starting
  // or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
  // TODO Test
  // and verify for vector3 (needs to implement equals)
  // Add a line curve if start and end of lines are not connected
  var startPoint = this.curves[0].getPoint(0);
  var endPoint = this.curves[this.curves.length - 1].getPoint(1);

  if (! startPoint.equals(endPoint)) {
    this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
  }

};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

  var d = t * this.getLength();
  var curveLengths = this.getCurveLengths();
  var i = 0, diff, curve;

  // To think about boundaries points.

  while ( i < curveLengths.length ) {

    if ( curveLengths[ i ] >= d ) {

      diff = curveLengths[ i ] - d;
      curve = this.curves[ i ];

      var u = 1 - diff / curve.getLength();

      return curve.getPointAt( u );

    }

    i ++;

  }

  return null;

  // loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

  var lens = this.getCurveLengths();
  return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

  // We use cache values if curves and cache array are same length

  if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

    return this.cacheLengths;

  }

  // Get length of subsurve
  // Push sums into cached array

  var lengths = [], sums = 0;
  var i, il = this.curves.length;

  for ( i = 0; i < il; i ++ ) {

    sums += this.curves[ i ].getLength();
    lengths.push( sums );

  }

  this.cacheLengths = lengths;

  return lengths;

};



// Returns min and max coordinates

THREE.CurvePath.prototype.getBoundingBox = function () {

  var points = this.getPoints();

  var maxX, maxY, maxZ;
  var minX, minY, minZ;

  maxX = maxY = Number.NEGATIVE_INFINITY;
  minX = minY = Number.POSITIVE_INFINITY;

  var p, i, il, sum;

  var v3 = points[0] instanceof THREE.Vector3;

  sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

  for ( i = 0, il = points.length; i < il; i ++ ) {

    p = points[ i ];

    if ( p.x > maxX ) maxX = p.x;
    else if ( p.x < minX ) minX = p.x;

    if ( p.y > maxY ) maxY = p.y;
    else if ( p.y < minY ) minY = p.y;

    if ( v3 ) {

      if ( p.z > maxZ ) maxZ = p.z;
      else if ( p.z < minZ ) minZ = p.z;

    }

    sum.add( p );

  }

  var ret = {

    minX: minX,
    minY: minY,
    maxX: maxX,
    maxY: maxY

  };

  if ( v3 ) {

    ret.maxZ = maxZ;
    ret.minZ = minZ;

  }

  return ret;

};

/**************************************************************
 *  Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or Points objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

  var pts = this.getPoints( divisions, true );
  return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

  var pts = this.getSpacedPoints( divisions, true );
  return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < points.length; i ++ ) {

    geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

  }

  return geometry;

};


/**************************************************************
 *  Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

  this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

  var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
  var i, il;

  if ( ! bends ) {

    bends = this.bends;

  }

  for ( i = 0, il = bends.length; i < il; i ++ ) {

    oldPts = this.getWrapPoints( oldPts, bends[ i ] );

  }

  return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

  var oldPts = this.getSpacedPoints( segments );

  var i, il;

  if ( ! bends ) {

    bends = this.bends;

  }

  for ( i = 0, il = bends.length; i < il; i ++ ) {

    oldPts = this.getWrapPoints( oldPts, bends[ i ] );

  }

  return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

  var bounds = this.getBoundingBox();

  var i, il, p, oldX, oldY, xNorm;

  for ( i = 0, il = oldPts.length; i < il; i ++ ) {

    p = oldPts[ i ];

    oldX = p.x;
    oldY = p.y;

    xNorm = oldX / bounds.maxX;

    // If using actual distance, for length > path, requires line extrusions
    //xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

    xNorm = path.getUtoTmapping( xNorm, oldX );

    // check for out of bounds?

    var pathPt = path.getPoint( xNorm );
    var normal = path.getTangent( xNorm );
    normal.set( - normal.y, normal.x ).multiplyScalar( oldY );

    p.x = pathPt.x + normal.x;
    p.y = pathPt.y + normal.y;

  }

  return oldPts;

};

// File:src/extras/core/Gyroscope.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

  THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );
THREE.Gyroscope.prototype.constructor = THREE.Gyroscope;

THREE.Gyroscope.prototype.updateMatrixWorld = ( function () {

  var translationObject = new THREE.Vector3();
  var quaternionObject = new THREE.Quaternion();
  var scaleObject = new THREE.Vector3();

  var translationWorld = new THREE.Vector3();
  var quaternionWorld = new THREE.Quaternion();
  var scaleWorld = new THREE.Vector3();

  return function ( force ) {

    this.matrixAutoUpdate && this.updateMatrix();

    // update matrixWorld

    if ( this.matrixWorldNeedsUpdate || force ) {

      if ( this.parent ) {

        this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

        this.matrixWorld.decompose( translationWorld, quaternionWorld, scaleWorld );
        this.matrix.decompose( translationObject, quaternionObject, scaleObject );

        this.matrixWorld.compose( translationWorld, quaternionObject, scaleWorld );


      } else {

        this.matrixWorld.copy( this.matrix );

      }


      this.matrixWorldNeedsUpdate = false;

      force = true;

    }

    // update children

    for ( var i = 0, l = this.children.length; i < l; i ++ ) {

      this.children[ i ].updateMatrixWorld( force );

    }

  };

}() );

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

  THREE.CurvePath.call(this);

  this.actions = [];

  if ( points ) {

    this.fromPoints( points );

  }

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );
THREE.Path.prototype.constructor = THREE.Path;

THREE.PathActions = {

  MOVE_TO: 'moveTo',
  LINE_TO: 'lineTo',
  QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
  BEZIER_CURVE_TO: 'bezierCurveTo',     // Bezier cubic curve
  CSPLINE_THRU: 'splineThru',       // Catmull-rom spline
  ARC: 'arc',               // Circle
  ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

  this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

  for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

    this.lineTo( vectors[ v ].x, vectors[ v ].y );

  }

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

  var args = Array.prototype.slice.call( arguments );
  this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
                        new THREE.Vector2( aCPx, aCPy ),
                        new THREE.Vector2( aX, aY ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
                         aCP2x, aCP2y,
                         aX, aY ) {

  var args = Array.prototype.slice.call( arguments );

  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
                      new THREE.Vector2( aCP1x, aCP1y ),
                      new THREE.Vector2( aCP2x, aCP2y ),
                      new THREE.Vector2( aX, aY ) );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

  var args = Array.prototype.slice.call( arguments );
  var lastargs = this.actions[ this.actions.length - 1 ].args;

  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];
//---
  var npts = [ new THREE.Vector2( x0, y0 ) ];
  Array.prototype.push.apply( npts, pts );

  var curve = new THREE.SplineCurve( npts );
  this.curves.push( curve );

  this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var lastargs = this.actions[ this.actions.length - 1].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absarc(aX + x0, aY + y0, aRadius,
    aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
                    aStartAngle, aEndAngle, aClockwise ) {
  this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var lastargs = this.actions[ this.actions.length - 1].args;
  var x0 = lastargs[ lastargs.length - 2 ];
  var y0 = lastargs[ lastargs.length - 1 ];

  this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
    aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
                    aStartAngle, aEndAngle, aClockwise ) {

  var args = Array.prototype.slice.call( arguments );
  var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
                  aStartAngle, aEndAngle, aClockwise );
  this.curves.push( curve );

  var lastPoint = curve.getPoint(1);
  args.push(lastPoint.x);
  args.push(lastPoint.y);

  this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

  if ( ! divisions ) divisions = 40;

  var points = [];

  for ( var i = 0; i < divisions; i ++ ) {

    points.push( this.getPoint( i / divisions ) );

    //if( !this.getPoint( i / divisions ) ) throw "DIE";

  }

  // if ( closedPath ) {
  //
  //  points.push( points[ 0 ] );
  //
  // }

  return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

  if (this.useSpacedPoints) {
    console.log('tata');
    return this.getSpacedPoints( divisions, closedPath );
  }

  divisions = divisions || 12;

  var points = [];

  var i, il, item, action, args;
  var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
    laste, j,
    t, tx, ty;

  for ( i = 0, il = this.actions.length; i < il; i ++ ) {

    item = this.actions[ i ];

    action = item.action;
    args = item.args;

    switch ( action ) {

    case THREE.PathActions.MOVE_TO:

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case THREE.PathActions.LINE_TO:

      points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

      break;

    case THREE.PathActions.QUADRATIC_CURVE_TO:

      cpx  = args[ 2 ];
      cpy  = args[ 3 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }

      for ( j = 1; j <= divisions; j ++ ) {

        t = j / divisions;

        tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
        ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case THREE.PathActions.BEZIER_CURVE_TO:

      cpx  = args[ 4 ];
      cpy  = args[ 5 ];

      cpx1 = args[ 0 ];
      cpy1 = args[ 1 ];

      cpx2 = args[ 2 ];
      cpy2 = args[ 3 ];

      if ( points.length > 0 ) {

        laste = points[ points.length - 1 ];

        cpx0 = laste.x;
        cpy0 = laste.y;

      } else {

        laste = this.actions[ i - 1 ].args;

        cpx0 = laste[ laste.length - 2 ];
        cpy0 = laste[ laste.length - 1 ];

      }


      for ( j = 1; j <= divisions; j ++ ) {

        t = j / divisions;

        tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
        ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

        points.push( new THREE.Vector2( tx, ty ) );

      }

      break;

    case THREE.PathActions.CSPLINE_THRU:

      laste = this.actions[ i - 1 ].args;

      var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
      var spts = [ last ];

      var n = divisions * args[ 0 ].length;

      spts = spts.concat( args[ 0 ] );

      var spline = new THREE.SplineCurve( spts );

      for ( j = 1; j <= n; j ++ ) {

        points.push( spline.getPointAt( j / n ) ) ;

      }

      break;

    case THREE.PathActions.ARC:

      var aX = args[ 0 ], aY = args[ 1 ],
        aRadius = args[ 2 ],
        aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
        aClockwise = !! args[ 5 ];

      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      for ( j = 1; j <= tdivisions; j ++ ) {

        t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + aRadius * Math.cos( angle );
        ty = aY + aRadius * Math.sin( angle );

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    case THREE.PathActions.ELLIPSE:

      var aX = args[ 0 ], aY = args[ 1 ],
        xRadius = args[ 2 ],
        yRadius = args[ 3 ],
        aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
        aClockwise = !! args[ 6 ];


      var deltaAngle = aEndAngle - aStartAngle;
      var angle;
      var tdivisions = divisions * 2;

      for ( j = 1; j <= tdivisions; j ++ ) {

        t = j / tdivisions;

        if ( ! aClockwise ) {

          t = 1 - t;

        }

        angle = aStartAngle + t * deltaAngle;

        tx = aX + xRadius * Math.cos( angle );
        ty = aY + yRadius * Math.sin( angle );

        //console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

        points.push( new THREE.Vector2( tx, ty ) );

      }

      //console.log(points);

      break;

    } // end switch

  }



  // Normalize to remove the closing point by default.
  var lastPoint = points[ points.length - 1];
  var EPSILON = 0.0000000001;
  if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
       Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
    points.splice( points.length - 1, 1);
  if ( closedPath ) {

    points.push( points[ 0 ] );

  }

  return points;

};

//
// Breaks path into shapes
//
//  Assumptions (if parameter isCCW==true the opposite holds):
//  - solid shapes are defined clockwise (CW)
//  - holes are defined counterclockwise (CCW)
//
//  If parameter noHoles==true:
//  - all subPaths are regarded as solid shapes
//  - definition order CW/CCW has no relevance
//

THREE.Path.prototype.toShapes = function( isCCW, noHoles ) {

  function extractSubpaths( inActions ) {

    var i, il, item, action, args;

    var subPaths = [], lastPath = new THREE.Path();

    for ( i = 0, il = inActions.length; i < il; i ++ ) {

      item = inActions[ i ];

      args = item.args;
      action = item.action;

      if ( action === THREE.PathActions.MOVE_TO ) {

        if ( lastPath.actions.length !== 0 ) {

          subPaths.push( lastPath );
          lastPath = new THREE.Path();

        }

      }

      lastPath[ action ].apply( lastPath, args );

    }

    if ( lastPath.actions.length !== 0 ) {

      subPaths.push( lastPath );

    }

    // console.log(subPaths);

    return  subPaths;
  }

  function toShapesNoHoles( inSubpaths ) {

    var shapes = [];

    for ( var i = 0, il = inSubpaths.length; i < il; i ++ ) {

      var tmpPath = inSubpaths[ i ];

      var tmpShape = new THREE.Shape();
      tmpShape.actions = tmpPath.actions;
      tmpShape.curves = tmpPath.curves;

      shapes.push( tmpShape );
    }

    //console.log("shape", shapes);

    return shapes;
  }

  function isPointInsidePolygon( inPt, inPolygon ) {
    var EPSILON = 0.0000000001;

    var polyLen = inPolygon.length;

    // inPt on polygon contour => immediate success    or
    // toggling of inside/outside at every single! intersection point of an edge
    //  with the horizontal line through inPt, left of inPt
    //  not counting lowerY endpoints of edges and whole edges on that line
    var inside = false;
    for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
      var edgeLowPt  = inPolygon[ p ];
      var edgeHighPt = inPolygon[ q ];

      var edgeDx = edgeHighPt.x - edgeLowPt.x;
      var edgeDy = edgeHighPt.y - edgeLowPt.y;

      if ( Math.abs(edgeDy) > EPSILON ) {     // not parallel
        if ( edgeDy < 0 ) {
          edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
          edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
        }
        if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) )    continue;

        if ( inPt.y === edgeLowPt.y ) {
          if ( inPt.x === edgeLowPt.x )   return  true;   // inPt is on contour ?
          // continue;        // no intersection or edgeLowPt => doesn't count !!!
        } else {
          var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
          if ( perpEdge === 0 )       return  true;   // inPt is on contour ?
          if ( perpEdge < 0 )         continue;
          inside = ! inside;    // true intersection left of inPt
        }
      } else {    // parallel or colinear
        if ( inPt.y !== edgeLowPt.y )     continue;     // parallel
        // egde lies on the same horizontal line as inPt
        if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
           ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )    return  true; // inPt: Point on contour !
        // continue;
      }
    }

    return  inside;
  }


  var subPaths = extractSubpaths( this.actions );
  if ( subPaths.length === 0 ) return [];

  if ( noHoles === true ) return  toShapesNoHoles( subPaths );


  var solid, tmpPath, tmpShape, shapes = [];

  if ( subPaths.length === 1) {

    tmpPath = subPaths[0];
    tmpShape = new THREE.Shape();
    tmpShape.actions = tmpPath.actions;
    tmpShape.curves = tmpPath.curves;
    shapes.push( tmpShape );
    return shapes;

  }

  var holesFirst = ! THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
  holesFirst = isCCW ? ! holesFirst : holesFirst;

  // console.log("Holes first", holesFirst);

  var betterShapeHoles = [];
  var newShapes = [];
  var newShapeHoles = [];
  var mainIdx = 0;
  var tmpPoints;

  newShapes[mainIdx] = undefined;
  newShapeHoles[mainIdx] = [];

  var i, il;

  for ( i = 0, il = subPaths.length; i < il; i ++ ) {

    tmpPath = subPaths[ i ];
    tmpPoints = tmpPath.getPoints();
    solid = THREE.Shape.Utils.isClockWise( tmpPoints );
    solid = isCCW ? ! solid : solid;

    if ( solid ) {

      if ( (! holesFirst ) && ( newShapes[mainIdx] ) )  mainIdx ++;

      newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
      newShapes[mainIdx].s.actions = tmpPath.actions;
      newShapes[mainIdx].s.curves = tmpPath.curves;

      if ( holesFirst ) mainIdx ++;
      newShapeHoles[mainIdx] = [];

      //console.log('cw', i);

    } else {

      newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

      //console.log('ccw', i);

    }

  }

  // only Holes? -> probably all Shapes with wrong orientation
  if ( ! newShapes[0] ) return  toShapesNoHoles( subPaths );


  if ( newShapes.length > 1 ) {
    var ambigious = false;
    var toChange = [];

    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
      betterShapeHoles[sIdx] = [];
    }
    for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
      var sho = newShapeHoles[sIdx];
      for (var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
        var ho = sho[hIdx];
        var hole_unassigned = true;
        for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
          if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
            if ( sIdx !== s2Idx ) toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
            if ( hole_unassigned ) {
              hole_unassigned = false;
              betterShapeHoles[s2Idx].push( ho );
            } else {
              ambigious = true;
            }
          }
        }
        if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
      }
    }
    // console.log("ambigious: ", ambigious);
    if ( toChange.length > 0 ) {
      // console.log("to change: ", toChange);
      if (! ambigious)  newShapeHoles = betterShapeHoles;
    }
  }

  var tmpHoles, j, jl;
  for ( i = 0, il = newShapes.length; i < il; i ++ ) {
    tmpShape = newShapes[i].s;
    shapes.push( tmpShape );
    tmpHoles = newShapeHoles[i];
    for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
      tmpShape.holes.push( tmpHoles[j].h );
    }
  }

  //console.log("shape", shapes);

  return shapes;

};

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

  THREE.Path.apply( this, arguments );
  this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );
THREE.Shape.prototype.constructor = THREE.Shape;

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

  var extruded = new THREE.ExtrudeGeometry( this, options );
  return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

  var geometry = new THREE.ShapeGeometry( this, options );
  return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

  var i, il = this.holes.length, holesPts = [];

  for ( i = 0; i < il; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

  }

  return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

  var i, il = this.holes.length, holesPts = [];

  for ( i = 0; i < il; i ++ ) {

    holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

  }

  return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

  return {

    shape: this.getTransformedPoints( divisions ),
    holes: this.getPointsHoles( divisions )

  };

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

  if (this.useSpacedPoints) {
    return this.extractAllSpacedPoints(divisions);
  }

  return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
//  return {
//
//    shape: this.transform( bend, divisions ),
//    holes: this.getPointsHoles( divisions, bend )
//
//  };
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

  return {

    shape: this.getTransformedSpacedPoints( divisions ),
    holes: this.getSpacedPointsHoles( divisions )

  };

};

/**************************************************************
 *  Utils
 **************************************************************/

THREE.Shape.Utils = {

  triangulateShape: function ( contour, holes ) {

    function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
      // inOtherPt needs to be colinear to the inSegment
      if ( inSegPt1.x !== inSegPt2.x ) {
        if ( inSegPt1.x < inSegPt2.x ) {
          return  ( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
        } else {
          return  ( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
        }
      } else {
        if ( inSegPt1.y < inSegPt2.y ) {
          return  ( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
        } else {
          return  ( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
        }
      }
    }

    function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
      var EPSILON = 0.0000000001;

      var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
      var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

      var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
      var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

      var limit   = seg1dy * seg2dx - seg1dx * seg2dy;
      var perpSeg1  = seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

      if ( Math.abs(limit) > EPSILON ) {      // not parallel

        var perpSeg2;
        if ( limit > 0 ) {
          if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) )     return [];
        } else {
          if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) )     return [];
          perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
          if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) )     return [];
        }

        // i.e. to reduce rounding errors
        // intersection at endpoint of segment#1?
        if ( perpSeg2 === 0 ) {
          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
          return [ inSeg1Pt1 ];
        }
        if ( perpSeg2 === limit ) {
          if ( ( inExcludeAdjacentSegs ) &&
             ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )   return [];
          return [ inSeg1Pt2 ];
        }
        // intersection at endpoint of segment#2?
        if ( perpSeg1 === 0 )   return [ inSeg2Pt1 ];
        if ( perpSeg1 === limit ) return [ inSeg2Pt2 ];

        // return real intersection point
        var factorSeg1 = perpSeg2 / limit;
        return  [ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
              y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

      } else {    // parallel or colinear
        if ( ( perpSeg1 !== 0 ) ||
           ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) )      return [];

        // they are collinear or degenerate
        var seg1Pt = ( (seg1dx === 0) && (seg1dy === 0) );  // segment1 ist just a point?
        var seg2Pt = ( (seg2dx === 0) && (seg2dy === 0) );  // segment2 ist just a point?
        // both segments are points
        if ( seg1Pt && seg2Pt ) {
          if ( (inSeg1Pt1.x !== inSeg2Pt1.x) ||
             (inSeg1Pt1.y !== inSeg2Pt1.y) )    return [];  // they are distinct  points
          return [ inSeg1Pt1 ];                             // they are the same point
        }
        // segment#1  is a single point
        if ( seg1Pt ) {
          if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )    return [];    // but not in segment#2
          return [ inSeg1Pt1 ];
        }
        // segment#2  is a single point
        if ( seg2Pt ) {
          if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )    return [];    // but not in segment#1
          return [ inSeg2Pt1 ];
        }

        // they are collinear segments, which might overlap
        var seg1min, seg1max, seg1minVal, seg1maxVal;
        var seg2min, seg2max, seg2minVal, seg2maxVal;
        if (seg1dx !== 0) {   // the segments are NOT on a vertical line
          if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
          } else {
            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
          }
          if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
          } else {
            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
          }
        } else {        // the segments are on a vertical line
          if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
            seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
            seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
          } else {
            seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
            seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
          }
          if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
            seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
            seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
          } else {
            seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
            seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
          }
        }
        if ( seg1minVal <= seg2minVal ) {
          if ( seg1maxVal <  seg2minVal ) return [];
          if ( seg1maxVal === seg2minVal )  {
            if ( inExcludeAdjacentSegs )    return [];
            return [ seg2min ];
          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg2min, seg1max ];
          return  [ seg2min, seg2max ];
        } else {
          if ( seg1minVal >  seg2maxVal ) return [];
          if ( seg1minVal === seg2maxVal )  {
            if ( inExcludeAdjacentSegs )    return [];
            return [ seg1min ];
          }
          if ( seg1maxVal <= seg2maxVal ) return [ seg1min, seg1max ];
          return  [ seg1min, seg2max ];
        }
      }
    }

    function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
      // The order of legs is important

      var EPSILON = 0.0000000001;

      // translation of all points, so that Vertex is at (0,0)
      var legFromPtX  = inLegFromPt.x - inVertex.x,  legFromPtY = inLegFromPt.y - inVertex.y;
      var legToPtX  = inLegToPt.x - inVertex.x,  legToPtY   = inLegToPt.y - inVertex.y;
      var otherPtX  = inOtherPt.x - inVertex.x,  otherPtY   = inOtherPt.y - inVertex.y;

      // main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
      var from2toAngle  = legFromPtX * legToPtY - legFromPtY * legToPtX;
      var from2otherAngle = legFromPtX * otherPtY - legFromPtY * otherPtX;

      if ( Math.abs(from2toAngle) > EPSILON ) {     // angle != 180 deg.

        var other2toAngle   = otherPtX * legToPtY - otherPtY * legToPtX;
        // console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

        if ( from2toAngle > 0 ) {       // main angle < 180 deg.
          return  ( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
        } else {                // main angle > 180 deg.
          return  ( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
        }
      } else {                    // angle == 180 deg.
        // console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
        return  ( from2otherAngle > 0 );
      }
    }


    function removeHoles( contour, holes ) {

      var shape = contour.concat(); // work on this shape
      var hole;

      function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
        // Check if hole point lies within angle around shape point
        var lastShapeIdx = shape.length - 1;

        var prevShapeIdx = inShapeIdx - 1;
        if ( prevShapeIdx < 0 )     prevShapeIdx = lastShapeIdx;

        var nextShapeIdx = inShapeIdx + 1;
        if ( nextShapeIdx > lastShapeIdx )  nextShapeIdx = 0;

        var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
        if (! insideAngle ) {
          // console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
          return  false;
        }

        // Check if shape point lies within angle around hole point
        var lastHoleIdx = hole.length - 1;

        var prevHoleIdx = inHoleIdx - 1;
        if ( prevHoleIdx < 0 )      prevHoleIdx = lastHoleIdx;

        var nextHoleIdx = inHoleIdx + 1;
        if ( nextHoleIdx > lastHoleIdx )  nextHoleIdx = 0;

        insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
        if (! insideAngle ) {
          // console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
          return  false;
        }

        return  true;
      }

      function intersectsShapeEdge( inShapePt, inHolePt ) {
        // checks for intersections with shape edges
        var sIdx, nextIdx, intersection;
        for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
          nextIdx = sIdx + 1; nextIdx %= shape.length;
          intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
          if ( intersection.length > 0 )    return  true;
        }

        return  false;
      }

      var indepHoles = [];

      function intersectsHoleEdge( inShapePt, inHolePt ) {
        // checks for intersections with hole edges
        var ihIdx, chkHole,
          hIdx, nextIdx, intersection;
        for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
          chkHole = holes[indepHoles[ihIdx]];
          for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
            nextIdx = hIdx + 1; nextIdx %= chkHole.length;
            intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
            if ( intersection.length > 0 )    return  true;
          }
        }
        return  false;
      }

      var holeIndex, shapeIndex,
        shapePt, holePt,
        holeIdx, cutKey, failedCuts = [],
        tmpShape1, tmpShape2,
        tmpHole1, tmpHole2;

      for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

        indepHoles.push( h );

      }

      var minShapeIndex = 0;
      var counter = indepHoles.length * 2;
      while ( indepHoles.length > 0 ) {
        counter --;
        if ( counter < 0 ) {
          console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
          break;
        }

        // search for shape-vertex and hole-vertex,
        // which can be connected without intersections
        for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

          shapePt = shape[ shapeIndex ];
          holeIndex = - 1;

          // search for hole which can be reached without intersections
          for ( var h = 0; h < indepHoles.length; h ++ ) {
            holeIdx = indepHoles[h];

            // prevent multiple checks
            cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
            if ( failedCuts[cutKey] !== undefined )     continue;

            hole = holes[holeIdx];
            for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
              holePt = hole[ h2 ];
              if (! isCutLineInsideAngles( shapeIndex, h2 ) )   continue;
              if ( intersectsShapeEdge( shapePt, holePt ) )   continue;
              if ( intersectsHoleEdge( shapePt, holePt ) )    continue;

              holeIndex = h2;
              indepHoles.splice(h, 1);

              tmpShape1 = shape.slice( 0, shapeIndex + 1 );
              tmpShape2 = shape.slice( shapeIndex );
              tmpHole1 = hole.slice( holeIndex );
              tmpHole2 = hole.slice( 0, holeIndex + 1 );

              shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

              minShapeIndex = shapeIndex;

              // Debug only, to show the selected cuts
              // glob_CutLines.push( [ shapePt, holePt ] );

              break;
            }
            if ( holeIndex >= 0 ) break;    // hole-vertex found

            failedCuts[cutKey] = true;      // remember failure
          }
          if ( holeIndex >= 0 ) break;    // hole-vertex found
        }
      }

      return shape;       /* shape with no holes */
    }


    var i, il, f, face,
      key, index,
      allPointsMap = {};

    // To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

    var allpoints = contour.concat();

    for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

      Array.prototype.push.apply( allpoints, holes[h] );

    }

    //console.log( "allpoints",allpoints, allpoints.length );

    // prepare all points map

    for ( i = 0, il = allpoints.length; i < il; i ++ ) {

      key = allpoints[ i ].x + ":" + allpoints[ i ].y;

      if ( allPointsMap[ key ] !== undefined ) {

        console.warn( "THREE.Shape: Duplicate point", key );

      }

      allPointsMap[ key ] = i;

    }

    // remove holes by cutting paths to holes and adding them to the shape
    var shapeWithoutHoles = removeHoles( contour, holes );

    var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
    //console.log( "triangles",triangles, triangles.length );

    // check all face vertices against all points map

    for ( i = 0, il = triangles.length; i < il; i ++ ) {

      face = triangles[ i ];

      for ( f = 0; f < 3; f ++ ) {

        key = face[ f ].x + ":" + face[ f ].y;

        index = allPointsMap[ key ];

        if ( index !== undefined ) {

          face[ f ] = index;

        }

      }

    }

    return triangles.concat();

  },

  isClockWise: function ( pts ) {

    return THREE.FontUtils.Triangulate.area( pts ) < 0;

  },

  // Bezier Curves formulas obtained from
  // http://en.wikipedia.org/wiki/B%C3%A9zier_curve

  // Quad Bezier Functions

  b2p0: function ( t, p ) {

    var k = 1 - t;
    return k * k * p;

  },

  b2p1: function ( t, p ) {

    return 2 * ( 1 - t ) * t * p;

  },

  b2p2: function ( t, p ) {

    return t * t * p;

  },

  b2: function ( t, p0, p1, p2 ) {

    return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

  },

  // Cubic Bezier Functions

  b3p0: function ( t, p ) {

    var k = 1 - t;
    return k * k * k * p;

  },

  b3p1: function ( t, p ) {

    var k = 1 - t;
    return 3 * k * k * t * p;

  },

  b3p2: function ( t, p ) {

    var k = 1 - t;
    return 3 * k * t * t * p;

  },

  b3p3: function ( t, p ) {

    return t * t * t * p;

  },

  b3: function ( t, p0, p1, p2, p3 ) {

    return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

  }

};

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *  Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

  this.v1 = v1;
  this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

  var point = this.v2.clone().sub(this.v1);
  point.multiplyScalar( t ).add( this.v1 );

  return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

  return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

  var tangent = this.v2.clone().sub(this.v1);

  return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *  Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

  var vector = new THREE.Vector2();

  vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
  vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

  return vector;

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

  var vector = new THREE.Vector2();

  vector.x = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
  vector.y = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

  // returns unit vector

  return vector.normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *  Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

  this.v0 = v0;
  this.v1 = v1;
  this.v2 = v2;
  this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

  var tx, ty;

  tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
  ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

  return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

  var tx, ty;

  tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
  ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

  var tangent = new THREE.Vector2( tx, ty );
  tangent.normalize();

  return tangent;

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *  Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

  this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

  var points = this.points;
  var point = ( points.length - 1 ) * t;

  var intPoint = Math.floor( point );
  var weight = point - intPoint;

  var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
  var point1 = points[ intPoint ];
  var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
  var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

  var vector = new THREE.Vector2();

  vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
  vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );

  return vector;

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *  Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

  this.aX = aX;
  this.aY = aY;

  this.xRadius = xRadius;
  this.yRadius = yRadius;

  this.aStartAngle = aStartAngle;
  this.aEndAngle = aEndAngle;

  this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

  var deltaAngle = this.aEndAngle - this.aStartAngle;

  if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
  if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

  var angle;

  if ( this.aClockwise === true ) {

    angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

  } else {

    angle = this.aStartAngle + t * deltaAngle;

  }

  var vector = new THREE.Vector2();

  vector.x = this.aX + this.xRadius * Math.cos( angle );
  vector.y = this.aY + this.yRadius * Math.sin( angle );

  return vector;

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *  Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

  THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *  Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

  function ( v1, v2 ) {

    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.subVectors( this.v2, this.v1 ); // diff
    vector.multiplyScalar( t );
    vector.add( this.v1 );

    return vector;

  }

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *  Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.x = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
    vector.y = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
    vector.z = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

    return vector;

  }

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *  Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

  function ( v0, v1, v2, v3 ) {

    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;

  },

  function ( t ) {

    var vector = new THREE.Vector3();

    vector.x = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
    vector.y = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
    vector.z = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

    return vector;

  }

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *  Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */) {

    console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 1 ) * t;

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
    var point1 = points[ intPoint ];
    var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
    var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

    var vector = new THREE.Vector3();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
    vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

    return vector;

  }

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

  var
    tmp = new THREE.Vector3(),
    px = new CubicPoly(),
    py = new CubicPoly(),
    pz = new CubicPoly();

  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM

  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */

  function CubicPoly() {

  }

  /*
   * Compute coefficients for a cubic polynomial
   *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
   * such that
   *   p(0) = x0, p(1) = x1
   *  and
   *   p'(0) = t0, p'(1) = t1.
   */
  CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

    this.c0 = x0;
    this.c1 = t0;
    this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
    this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

  };

  CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

    // compute tangents when parameterized in [t1,t2]
    var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
    var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

    // rescale tangents for parametrization in [0,1]
    t1 *= dt1;
    t2 *= dt1;

    // initCubicPoly
    this.init( x1, x2, t1, t2 );

  };

  // standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
  CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

    this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

  };

  CubicPoly.prototype.calc = function( t ) {

    var t2 = t * t;
    var t3 = t2 * t;
    return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

  };

  // Subclass Three.js curve
  return THREE.Curve.create(

    function ( p /* array of Vector3 */ ) {

      this.points = p || [];

    },

    function ( t ) {

      var points = this.points,
        point, intPoint, weight, l;

      l = points.length;

      if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

      point = ( l - 1 ) * t;
      intPoint = Math.floor( point );
      weight = point - intPoint;

      if ( weight === 0 && intPoint === l - 1 ) {

        intPoint = l - 2;
        weight = 1;

      }

      var p0, p1, p2, p3;

      if ( intPoint === 0 ) {

        // extrapolate first point
        tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
        p0 = tmp;

      } else {

        p0 = points[ intPoint - 1 ];

      }

      p1 = points[ intPoint ];
      p2 = points[ intPoint + 1 ];

      if ( intPoint + 2 < l ) {

        p3 = points[ intPoint + 2 ]

      } else {

        // extrapolate last point
        tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 2 ] );
        p3 = tmp;

      }

      if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

        // init Centripetal / Chordal Catmull-Rom
        var pow = this.type === 'chordal' ? 0.5 : 0.25;
        var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
        var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
        var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

        // safety check for repeated points
        if ( dt1 < 1e-4 ) dt1 = 1.0;
        if ( dt0 < 1e-4 ) dt0 = dt1;
        if ( dt2 < 1e-4 ) dt2 = dt1;

        px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
        py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
        pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

      } else if ( this.type === 'catmullrom' ) {

        var tension = this.tension !== undefined ? this.tension : 0.5;
        px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
        py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
        pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

      }

      var v = new THREE.Vector3(
        px.calc( weight ),
        py.calc( weight ),
        pz.calc( weight )
      );

      return v;

    }

  );

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *  Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

  function ( points /* array of Vector3 */) {

    this.points = ( points == undefined ) ? [] : points;

  },

  function ( t ) {

    var points = this.points;
    var point = ( points.length - 0 ) * t; // This needs to be from 0-length +1

    var intPoint = Math.floor( point );
    var weight = point - intPoint;

    intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

    var point0 = points[ ( intPoint - 1 ) % points.length ];
    var point1 = points[ ( intPoint     ) % points.length ];
    var point2 = points[ ( intPoint + 1 ) % points.length ];
    var point3 = points[ ( intPoint + 2 ) % points.length ];

    var vector = new THREE.Vector3();

    vector.x = THREE.Curve.Utils.interpolate( point0.x, point1.x, point2.x, point3.x, weight );
    vector.y = THREE.Curve.Utils.interpolate( point0.y, point1.y, point2.y, point3.y, weight );
    vector.z = THREE.Curve.Utils.interpolate( point0.z, point1.z, point2.z, point3.z, weight );

    return vector;

  }

);

// File:src/extras/animation/AnimationHandler.js

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = {

  LINEAR: 0,
  CATMULLROM: 1,
  CATMULLROM_FORWARD: 2,

  //

  add: function () { console.warn( 'THREE.AnimationHandler.add() has been deprecated.' ); },
  get: function () { console.warn( 'THREE.AnimationHandler.get() has been deprecated.' ); },
  remove: function () { console.warn( 'THREE.AnimationHandler.remove() has been deprecated.' ); },

  //

  animations: [],

  init: function ( data ) {

    if ( data.initialized === true ) return data;

    // loop through all keys

    for ( var h = 0; h < data.hierarchy.length; h ++ ) {

      for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

        // remove minus times

        if ( data.hierarchy[ h ].keys[ k ].time < 0 ) {

           data.hierarchy[ h ].keys[ k ].time = 0;

        }

        // create quaternions

        if ( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
          ! ( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

          var quat = data.hierarchy[ h ].keys[ k ].rot;
          data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion().fromArray( quat );

        }

      }

      // prepare morph target keys

      if ( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

        // get all used

        var usedMorphTargets = {};

        for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

          for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

            var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
            usedMorphTargets[ morphTargetName ] = - 1;

          }

        }

        data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


        // set all used on all frames

        for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

          var influences = {};

          for ( var morphTargetName in usedMorphTargets ) {

            for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

              if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

                influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
                break;

              }

            }

            if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

              influences[ morphTargetName ] = 0;

            }

          }

          data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

        }

      }


      // remove all keys that are on the same time

      for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

        if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

          data.hierarchy[ h ].keys.splice( k, 1 );
          k --;

        }

      }


      // set index

      for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

        data.hierarchy[ h ].keys[ k ].index = k;

      }

    }

    data.initialized = true;

    return data;

  },

  parse: function ( root ) {

    var parseRecurseHierarchy = function ( root, hierarchy ) {

      hierarchy.push( root );

      for ( var c = 0; c < root.children.length; c ++ )
        parseRecurseHierarchy( root.children[ c ], hierarchy );

    };

    // setup hierarchy

    var hierarchy = [];

    if ( root instanceof THREE.SkinnedMesh ) {

      for ( var b = 0; b < root.skeleton.bones.length; b ++ ) {

        hierarchy.push( root.skeleton.bones[ b ] );

      }

    } else {

      parseRecurseHierarchy( root, hierarchy );

    }

    return hierarchy;

  },

  play: function ( animation ) {

    if ( this.animations.indexOf( animation ) === - 1 ) {

      this.animations.push( animation );

    }

  },

  stop: function ( animation ) {

    var index = this.animations.indexOf( animation );

    if ( index !== - 1 ) {

      this.animations.splice( index, 1 );

    }

  },

  update: function ( deltaTimeMS ) {

    for ( var i = 0; i < this.animations.length; i ++ ) {

      this.animations[ i ].resetBlendWeights( );

    }

    for ( var i = 0; i < this.animations.length; i ++ ) {

      this.animations[ i ].update( deltaTimeMS );

    }

  }

};

// File:src/extras/animation/Animation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, data ) {

  this.root = root;
  this.data = THREE.AnimationHandler.init( data );
  this.hierarchy = THREE.AnimationHandler.parse( root );

  this.currentTime = 0;
  this.timeScale = 1;

  this.isPlaying = false;
  this.loop = true;
  this.weight = 0;

  this.interpolationType = THREE.AnimationHandler.LINEAR;

};

THREE.Animation.prototype = {

  constructor: THREE.Animation,

  keyTypes:  [ "pos", "rot", "scl" ],

  play: function ( startTime, weight ) {

    this.currentTime = startTime !== undefined ? startTime : 0;
    this.weight = weight !== undefined ? weight : 1;

    this.isPlaying = true;

    this.reset();

    THREE.AnimationHandler.play( this );

  },

  stop: function() {

    this.isPlaying = false;

    THREE.AnimationHandler.stop( this );

  },

  reset: function () {

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];

      if ( object.animationCache === undefined ) {

        object.animationCache = {
          animations: {},
          blending: {
            positionWeight: 0.0,
            quaternionWeight: 0.0,
            scaleWeight: 0.0
          }
        };
      }

      var name = this.data.name;
      var animations = object.animationCache.animations;
      var animationCache = animations[ name ];

      if ( animationCache === undefined ) {

        animationCache = {
          prevKey: { pos: 0, rot: 0, scl: 0 },
          nextKey: { pos: 0, rot: 0, scl: 0 },
          originalMatrix: object.matrix
        };

        animations[ name ] = animationCache;

      }

      // Get keys to match our current time

      for ( var t = 0; t < 3; t ++ ) {

        var type = this.keyTypes[ t ];

        var prevKey = this.data.hierarchy[ h ].keys[ 0 ];
        var nextKey = this.getNextKeyWith( type, h, 1 );

        while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

          prevKey = nextKey;
          nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

        }

        animationCache.prevKey[ type ] = prevKey;
        animationCache.nextKey[ type ] = nextKey;

      }

    }

  },

  resetBlendWeights: function () {

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];
      var animationCache = object.animationCache;

      if ( animationCache !== undefined ) {

        var blending = animationCache.blending;

        blending.positionWeight = 0.0;
        blending.quaternionWeight = 0.0;
        blending.scaleWeight = 0.0;

      }

    }

  },

  update: ( function() {

    var points = [];
    var target = new THREE.Vector3();
    var newVector = new THREE.Vector3();
    var newQuat = new THREE.Quaternion();

    // Catmull-Rom spline

    var interpolateCatmullRom = function ( points, scale ) {

      var c = [], v3 = [],
      point, intPoint, weight, w2, w3,
      pa, pb, pc, pd;

      point = ( points.length - 1 ) * scale;
      intPoint = Math.floor( point );
      weight = point - intPoint;

      c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
      c[ 1 ] = intPoint;
      c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
      c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

      pa = points[ c[ 0 ] ];
      pb = points[ c[ 1 ] ];
      pc = points[ c[ 2 ] ];
      pd = points[ c[ 3 ] ];

      w2 = weight * weight;
      w3 = weight * w2;

      v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
      v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
      v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

      return v3;

    };

    var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

      var v0 = ( p2 - p0 ) * 0.5,
        v1 = ( p3 - p1 ) * 0.5;

      return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

    };

    return function ( delta ) {

      if ( this.isPlaying === false ) return;

      this.currentTime += delta * this.timeScale;

      if ( this.weight === 0 )
        return;

      //

      var duration = this.data.length;

      if ( this.currentTime > duration || this.currentTime < 0 ) {

        if ( this.loop ) {

          this.currentTime %= duration;

          if ( this.currentTime < 0 )
            this.currentTime += duration;

          this.reset();

        } else {

          this.stop();

        }

      }

      for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

        var object = this.hierarchy[ h ];
        var animationCache = object.animationCache.animations[this.data.name];
        var blending = object.animationCache.blending;

        // loop through pos/rot/scl

        for ( var t = 0; t < 3; t ++ ) {

          // get keys

          var type    = this.keyTypes[ t ];
          var prevKey = animationCache.prevKey[ type ];
          var nextKey = animationCache.nextKey[ type ];

          if ( ( this.timeScale > 0 && nextKey.time <= this.currentTime ) ||
            ( this.timeScale < 0 && prevKey.time >= this.currentTime ) ) {

            prevKey = this.data.hierarchy[ h ].keys[ 0 ];
            nextKey = this.getNextKeyWith( type, h, 1 );

            while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

              prevKey = nextKey;
              nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

            }

            animationCache.prevKey[ type ] = prevKey;
            animationCache.nextKey[ type ] = nextKey;

          }

          var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );

          var prevXYZ = prevKey[ type ];
          var nextXYZ = nextKey[ type ];

          if ( scale < 0 ) scale = 0;
          if ( scale > 1 ) scale = 1;

          // interpolate

          if ( type === "pos" ) {

            if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

              newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
              newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
              newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

              // blend
              var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
              object.position.lerp( newVector, proportionalWeight );
              blending.positionWeight += this.weight;

            } else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
                  this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

              points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
              points[ 1 ] = prevXYZ;
              points[ 2 ] = nextXYZ;
              points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

              scale = scale * 0.33 + 0.33;

              var currentPoint = interpolateCatmullRom( points, scale );
              var proportionalWeight = this.weight / ( this.weight + blending.positionWeight );
              blending.positionWeight += this.weight;

              // blend

              var vector = object.position;

              vector.x = vector.x + ( currentPoint[ 0 ] - vector.x ) * proportionalWeight;
              vector.y = vector.y + ( currentPoint[ 1 ] - vector.y ) * proportionalWeight;
              vector.z = vector.z + ( currentPoint[ 2 ] - vector.z ) * proportionalWeight;

              if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

                var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );

                target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
                target.sub( vector );
                target.y = 0;
                target.normalize();

                var angle = Math.atan2( target.x, target.z );
                object.rotation.set( 0, angle, 0 );

              }

            }

          } else if ( type === "rot" ) {

            THREE.Quaternion.slerp( prevXYZ, nextXYZ, newQuat, scale );

            // Avoid paying the cost of an additional slerp if we don't have to
            if ( blending.quaternionWeight === 0 ) {

              object.quaternion.copy(newQuat);
              blending.quaternionWeight = this.weight;

            } else {

              var proportionalWeight = this.weight / ( this.weight + blending.quaternionWeight );
              THREE.Quaternion.slerp( object.quaternion, newQuat, object.quaternion, proportionalWeight );
              blending.quaternionWeight += this.weight;

            }

          } else if ( type === "scl" ) {

            newVector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
            newVector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
            newVector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

            var proportionalWeight = this.weight / ( this.weight + blending.scaleWeight );
            object.scale.lerp( newVector, proportionalWeight );
            blending.scaleWeight += this.weight;

          }

        }

      }

      return true;

    };

  } )(),

  getNextKeyWith: function ( type, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;

    if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
       this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

      key = key < keys.length - 1 ? key : keys.length - 1;

    } else {

      key = key % keys.length;

    }

    for ( ; key < keys.length; key ++ ) {

      if ( keys[ key ][ type ] !== undefined ) {

        return keys[ key ];

      }

    }

    return this.data.hierarchy[ h ].keys[ 0 ];

  },

  getPrevKeyWith: function ( type, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;

    if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
      this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

      key = key > 0 ? key : 0;

    } else {

      key = key >= 0 ? key : key + keys.length;

    }


    for ( ; key >= 0; key -- ) {

      if ( keys[ key ][ type ] !== undefined ) {

        return keys[ key ];

      }

    }

    return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

  }

};

// File:src/extras/animation/KeyFrameAnimation.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( data ) {

  this.root = data.node;
  this.data = THREE.AnimationHandler.init( data );
  this.hierarchy = THREE.AnimationHandler.parse( this.root );
  this.currentTime = 0;
  this.timeScale = 0.001;
  this.isPlaying = false;
  this.isPaused = true;
  this.loop = true;

  // initialize to first keyframes

  for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

    var keys = this.data.hierarchy[h].keys,
      sids = this.data.hierarchy[h].sids,
      obj = this.hierarchy[h];

    if ( keys.length && sids ) {

      for ( var s = 0; s < sids.length; s ++ ) {

        var sid = sids[ s ],
          next = this.getNextKeyWith( sid, h, 0 );

        if ( next ) {

          next.apply( sid );

        }

      }

      obj.matrixAutoUpdate = false;
      this.data.hierarchy[h].node.updateMatrix();
      obj.matrixWorldNeedsUpdate = true;

    }

  }

};

THREE.KeyFrameAnimation.prototype = {

  constructor: THREE.KeyFrameAnimation,

  play: function ( startTime ) {

    this.currentTime = startTime !== undefined ? startTime : 0;

    if ( this.isPlaying === false ) {

      this.isPlaying = true;

      // reset key cache

      var h, hl = this.hierarchy.length,
        object,
        node;

      for ( h = 0; h < hl; h ++ ) {

        object = this.hierarchy[ h ];
        node = this.data.hierarchy[ h ];

        if ( node.animationCache === undefined ) {

          node.animationCache = {};
          node.animationCache.prevKey = null;
          node.animationCache.nextKey = null;
          node.animationCache.originalMatrix = object.matrix;

        }

        var keys = this.data.hierarchy[h].keys;

        if (keys.length) {

          node.animationCache.prevKey = keys[ 0 ];
          node.animationCache.nextKey = keys[ 1 ];

          this.startTime = Math.min( keys[0].time, this.startTime );
          this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

        }

      }

      this.update( 0 );

    }

    this.isPaused = false;

    THREE.AnimationHandler.play( this );

  },

  stop: function () {

    this.isPlaying = false;
    this.isPaused  = false;

    THREE.AnimationHandler.stop( this );

    // reset JIT matrix and remove cache

    for ( var h = 0; h < this.data.hierarchy.length; h ++ ) {

      var obj = this.hierarchy[ h ];
      var node = this.data.hierarchy[ h ];

      if ( node.animationCache !== undefined ) {

        var original = node.animationCache.originalMatrix;

        original.copy( obj.matrix );
        obj.matrix = original;

        delete node.animationCache;

      }

    }

  },

  update: function ( delta ) {

    if ( this.isPlaying === false ) return;

    this.currentTime += delta * this.timeScale;

    //

    var duration = this.data.length;

    if ( this.loop === true && this.currentTime > duration ) {

      this.currentTime %= duration;

    }

    this.currentTime = Math.min( this.currentTime, duration );

    for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

      var object = this.hierarchy[ h ];
      var node = this.data.hierarchy[ h ];

      var keys = node.keys,
        animationCache = node.animationCache;


      if ( keys.length ) {

        var prevKey = animationCache.prevKey;
        var nextKey = animationCache.nextKey;

        if ( nextKey.time <= this.currentTime ) {

          while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

            prevKey = nextKey;
            nextKey = keys[ prevKey.index + 1 ];

          }

          animationCache.prevKey = prevKey;
          animationCache.nextKey = nextKey;

        }

        if ( nextKey.time >= this.currentTime ) {

          prevKey.interpolate( nextKey, this.currentTime );

        } else {

          prevKey.interpolate( nextKey, nextKey.time );

        }

        this.data.hierarchy[ h ].node.updateMatrix();
        object.matrixWorldNeedsUpdate = true;

      }

    }

  },

  getNextKeyWith: function ( sid, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;
    key = key % keys.length;

    for ( ; key < keys.length; key ++ ) {

      if ( keys[ key ].hasTarget( sid ) ) {

        return keys[ key ];

      }

    }

    return keys[ 0 ];

  },

  getPrevKeyWith: function ( sid, h, key ) {

    var keys = this.data.hierarchy[ h ].keys;
    key = key >= 0 ? key : key + keys.length;

    for ( ; key >= 0; key -- ) {

      if ( keys[ key ].hasTarget( sid ) ) {

        return keys[ key ];

      }

    }

    return keys[ keys.length - 1 ];

  }

};

// File:src/extras/animation/MorphAnimation.js

/**
 * @author mrdoob / http://mrdoob.com
 * @author willy-vvu / http://willy-vvu.github.io
 */

THREE.MorphAnimation = function ( mesh ) {

  this.mesh = mesh;
  this.frames = mesh.morphTargetInfluences.length;
  this.currentTime = 0;
  this.duration = 1000;
  this.loop = true;
  this.lastFrame = 0;
  this.currentFrame = 0;

  this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

  constructor: THREE.MorphAnimation,

  play: function () {

    this.isPlaying = true;

  },

  pause: function () {

    this.isPlaying = false;

  },

  update: function ( delta ) {

    if ( this.isPlaying === false ) return;

    this.currentTime += delta;

    if ( this.loop === true && this.currentTime > this.duration ) {

      this.currentTime %= this.duration;

    }

    this.currentTime = Math.min( this.currentTime, this.duration );

    var interpolation = this.duration / this.frames;
    var frame = Math.floor( this.currentTime / interpolation );

    var influences = this.mesh.morphTargetInfluences;

    if ( frame !== this.currentFrame ) {

      influences[ this.lastFrame ] = 0;
      influences[ this.currentFrame ] = 1;
      influences[ frame ] = 0;

      this.lastFrame = this.currentFrame;
      this.currentFrame = frame;

    }

    influences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
    influences[ this.lastFrame ] = 1 - influences[ frame ];

  }

};

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

  THREE.Geometry.call( this );

  this.type = 'BoxGeometry';

  this.parameters = {
    width: width,
    height: height,
    depth: depth,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    depthSegments: depthSegments
  };

  this.widthSegments = widthSegments || 1;
  this.heightSegments = heightSegments || 1;
  this.depthSegments = depthSegments || 1;

  var scope = this;

  var width_half = width / 2;
  var height_half = height / 2;
  var depth_half = depth / 2;

  buildPlane( 'z', 'y', - 1, - 1, depth, height, width_half ); // px
  buildPlane( 'z', 'y',   1, - 1, depth, height, - width_half ); // nx
  buildPlane( 'x', 'z',   1,   1, width, depth, height_half ); // py
  buildPlane( 'x', 'z',   1, - 1, width, depth, - height_half ); // ny
  buildPlane( 'x', 'y',   1, - 1, width, height, depth_half ); // pz
  buildPlane( 'x', 'y', - 1, - 1, width, height, - depth_half ); // nz

  function buildPlane( u, v, udir, vdir, width, height, depth ) {

    var w, ix, iy,
    gridX = scope.widthSegments,
    gridY = scope.heightSegments,
    width_half = width / 2,
    height_half = height / 2,
    offset = scope.vertices.length;

    if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

      w = 'z';

    } else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

      w = 'y';
      gridY = scope.depthSegments;

    } else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

      w = 'x';
      gridX = scope.depthSegments;

    }

    var gridX1 = gridX + 1,
    gridY1 = gridY + 1,
    segment_width = width / gridX,
    segment_height = height / gridY,
    normal = new THREE.Vector3();

    normal[ w ] = depth > 0 ? 1 : - 1;

    for ( iy = 0; iy < gridY1; iy ++ ) {

      for ( ix = 0; ix < gridX1; ix ++ ) {

        var vector = new THREE.Vector3();
        vector[ u ] = ( ix * segment_width - width_half ) * udir;
        vector[ v ] = ( iy * segment_height - height_half ) * vdir;
        vector[ w ] = depth;

        scope.vertices.push( vector );

      }

    }

    for ( iy = 0; iy < gridY; iy ++ ) {

      for ( ix = 0; ix < gridX; ix ++ ) {

        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * ( iy + 1 );
        var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
        var d = ( ix + 1 ) + gridX1 * iy;

        var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
        var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
        var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
        var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

        var face = new THREE.Face3( a + offset, b + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

        face = new THREE.Face3( b + offset, c + offset, d + offset );
        face.normal.copy( normal );
        face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

        scope.faces.push( face );
        scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

      }

    }

  }

  this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.CubeGeometry = THREE.BoxGeometry; // backwards compatibility

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CircleGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  var i, uvs = [],
  center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

  this.vertices.push(center);
  uvs.push( centerUV );

  for ( i = 0; i <= segments; i ++ ) {

    var vertex = new THREE.Vector3();
    var segment = thetaStart + i / segments * thetaLength;

    vertex.x = radius * Math.cos( segment );
    vertex.y = radius * Math.sin( segment );

    this.vertices.push( vertex );
    uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 1; i <= segments; i ++ ) {

    this.faces.push( new THREE.Face3( i, i + 1, 0, [ n.clone(), n.clone(), n.clone() ] ) );
    this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

  THREE.BufferGeometry.call( this );

  this.type = 'CircleBufferGeometry';

  this.parameters = {
    radius: radius,
    segments: segments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;
  segments = segments !== undefined ? Math.max( 3, segments ) : 8;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  var vertices = segments + 2;

  var positions = new Float32Array( vertices * 3 );
  var normals = new Float32Array( vertices * 3 );
  var uvs = new Float32Array( vertices * 2 );

  // center data is already zero, but need to set a few extras
  normals[3] = 1.0;
  uvs[0] = 0.5;
  uvs[1] = 0.5;

  for ( var s = 0, i = 3, ii = 2 ; s <= segments; s++, i += 3, ii += 2 ) {

    var segment = thetaStart + s / segments * thetaLength;

    positions[i] = radius * Math.cos( segment );
    positions[i + 1] = radius * Math.sin( segment );

    normals[i + 2] = 1; // normal z

    uvs[ii] = ( positions[i] / radius + 1 ) / 2;
    uvs[ii + 1] = ( positions[i + 1] / radius + 1 ) / 2;

  }

  var indices = [];

  for ( var i = 1; i <= segments; i ++ ) {

    indices.push( i );
    indices.push( i + 1 );
    indices.push( 0 );

  }

  this.addAttribute( 'index', new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'CylinderGeometry';

  this.parameters = {
    radiusTop: radiusTop,
    radiusBottom: radiusBottom,
    height: height,
    radialSegments: radialSegments,
    heightSegments: heightSegments,
    openEnded: openEnded,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radiusTop = radiusTop !== undefined ? radiusTop : 20;
  radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
  height = height !== undefined ? height : 100;

  radialSegments = radialSegments || 8;
  heightSegments = heightSegments || 1;

  openEnded = openEnded !== undefined ? openEnded : false;
  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : 2 * Math.PI;

  var heightHalf = height / 2;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    var v = y / heightSegments;
    var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

    for ( x = 0; x <= radialSegments; x ++ ) {

      var u = x / radialSegments;

      var vertex = new THREE.Vector3();
      vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
      vertex.y = - v * height + heightHalf;
      vertex.z = radius * Math.cos( u * thetaLength + thetaStart );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  var tanTheta = ( radiusBottom - radiusTop ) / height;
  var na, nb;

  for ( x = 0; x < radialSegments; x ++ ) {

    if ( radiusTop !== 0 ) {

      na = this.vertices[ vertices[ 0 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

    } else {

      na = this.vertices[ vertices[ 1 ][ x ] ].clone();
      nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

    }

    na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
    nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

    for ( y = 0; y < heightSegments; y ++ ) {

      var v1 = vertices[ y ][ x ];
      var v2 = vertices[ y + 1 ][ x ];
      var v3 = vertices[ y + 1 ][ x + 1 ];
      var v4 = vertices[ y ][ x + 1 ];

      var n1 = na.clone();
      var n2 = na.clone();
      var n3 = nb.clone();
      var n4 = nb.clone();

      var uv1 = uvs[ y ][ x ].clone();
      var uv2 = uvs[ y + 1 ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
      var uv4 = uvs[ y ][ x + 1 ].clone();

      this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

      this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

    }

  }

  // top cap

  if ( openEnded === false && radiusTop > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ 0 ][ x ];
      var v2 = vertices[ 0 ][ x + 1 ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, 1, 0 );
      var n2 = new THREE.Vector3( 0, 1, 0 );
      var n3 = new THREE.Vector3( 0, 1, 0 );

      var uv1 = uvs[ 0 ][ x ].clone();
      var uv2 = uvs[ 0 ][ x + 1 ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 0 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  // bottom cap

  if ( openEnded === false && radiusBottom > 0 ) {

    this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

    for ( x = 0; x < radialSegments; x ++ ) {

      var v1 = vertices[ heightSegments ][ x + 1 ];
      var v2 = vertices[ heightSegments ][ x ];
      var v3 = this.vertices.length - 1;

      var n1 = new THREE.Vector3( 0, - 1, 0 );
      var n2 = new THREE.Vector3( 0, - 1, 0 );
      var n3 = new THREE.Vector3( 0, - 1, 0 );

      var uv1 = uvs[ heightSegments ][ x + 1 ].clone();
      var uv2 = uvs[ heightSegments ][ x ].clone();
      var uv3 = new THREE.Vector2( uv2.x, 1 );

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
      this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

    }

  }

  this.computeFaceNormals();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

  THREE.BufferGeometry.call( this );

  thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

  var thresholdDot = Math.cos( THREE.Math.degToRad( thresholdAngle ) );

  var edge = [ 0, 0 ], hash = {};
  var sortFunction = function ( a, b ) { return a - b };

  var keys = [ 'a', 'b', 'c' ];

  var geometry2;

  if ( geometry instanceof THREE.BufferGeometry ) {

    geometry2 = new THREE.Geometry();
    geometry2.fromBufferGeometry( geometry );

  } else {

    geometry2 = geometry.clone();

  }

  geometry2.mergeVertices();
  geometry2.computeFaceNormals();

  var vertices = geometry2.vertices;
  var faces = geometry2.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0; j < 3; j ++ ) {

      edge[ 0 ] = face[ keys[ j ] ];
      edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
      edge.sort( sortFunction );

      var key = edge.toString();

      if ( hash[ key ] === undefined ) {

        hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

      } else {

        hash[ key ].face2 = i;

      }

    }

  }

  var coords = [];

  for ( var key in hash ) {

    var h = hash[ key ];

    if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

      var vertex = vertices[ h.vert1 ];
      coords.push( vertex.x );
      coords.push( vertex.y );
      coords.push( vertex.z );

      vertex = vertices[ h.vert2 ];
      coords.push( vertex.x );
      coords.push( vertex.y );
      coords.push( vertex.z );

    }

  }

  this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

  if ( typeof( shapes ) === "undefined" ) {
    shapes = [];
    return;
  }

  THREE.Geometry.call( this );

  this.type = 'ExtrudeGeometry';

  shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

  // can't really use automatic vertex normals
  // as then front and back sides get smoothed too
  // should do separate smoothing just for sides

  //this.computeVertexNormals();

  //console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
  var sl = shapes.length;

  for ( var s = 0; s < sl; s ++ ) {
    var shape = shapes[ s ];
    this.addShape( shape, options );
  }
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

  var amount = options.amount !== undefined ? options.amount : 100;

  var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
  var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
  var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

  var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var steps = options.steps !== undefined ? options.steps : 1;

  var extrudePath = options.extrudePath;
  var extrudePts, extrudeByPath = false;

  // Use default WorldUVGenerator if no UV generators are specified.
  var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

  var splineTube, binormal, normal, position2;
  if ( extrudePath ) {

    extrudePts = extrudePath.getSpacedPoints( steps );

    extrudeByPath = true;
    bevelEnabled = false; // bevels not supported for path extrusion

    // SETUP TNB variables

    // Reuse TNB from TubeGeomtry for now.
    // TODO1 - have a .isClosed in spline?

    splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

    // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

    binormal = new THREE.Vector3();
    normal = new THREE.Vector3();
    position2 = new THREE.Vector3();

  }

  // Safeguards if bevels are not enabled

  if ( ! bevelEnabled ) {

    bevelSegments = 0;
    bevelThickness = 0;
    bevelSize = 0;

  }

  // Variables initalization

  var ahole, h, hl; // looping of holes
  var scope = this;

  var shapesOffset = this.vertices.length;

  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.Shape.Utils.isClockWise( vertices ) ;

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe ...

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];

      if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

        holes[ h ] = ahole.reverse();

      }

    }

    reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

  }


  var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

  /* Vertices */

  var contour = vertices; // vertices has all points but contour has only points of circumference

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    vertices = vertices.concat( ahole );

  }


  function scalePt2 ( pt, vec, size ) {

    if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

    return vec.clone().multiplyScalar( size ).add( pt );

  }

  var b, bs, t, z,
    vert, vlen = vertices.length,
    face, flen = faces.length;


  // Find directions for point movement


  function getBevelVec( inPt, inPrev, inNext ) {

    var EPSILON = 0.0000000001;

    // computes for inPt the corresponding point inPt' on a new contour
    //   shiftet by 1 unit (length of normalized vector) to the left
    // if we walk along contour clockwise, this new contour is outside the old one
    //
    // inPt' is the intersection of the two lines parallel to the two
    //  adjacent edges of inPt at a distance of 1 unit on the left side.

    var v_trans_x, v_trans_y, shrink_by = 1;    // resulting translation vector for inPt

    // good reading for geometry algorithms (here: line-line intersection)
    // http://geomalgorithms.com/a05-_intersect-1.html

    var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
    var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

    var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

    // check for colinear edges
    var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

    if ( Math.abs( colinear0 ) > EPSILON ) {    // not colinear

      // length of vectors for normalizing

      var v_prev_len = Math.sqrt( v_prev_lensq );
      var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

      // shift adjacent points by unit vectors to the left

      var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
      var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

      var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
      var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

      // scaling factor for v_prev to intersection point

      var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
            ( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
            ( v_prev_x * v_next_y - v_prev_y * v_next_x );

      // vector from inPt to intersection point

      v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
      v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

      // Don't normalize!, otherwise sharp corners become ugly
      //  but prevent crazy spikes
      var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
      if ( v_trans_lensq <= 2 ) {
        return  new THREE.Vector2( v_trans_x, v_trans_y );
      } else {
        shrink_by = Math.sqrt( v_trans_lensq / 2 );
      }

    } else {    // handle special case of colinear edges

      var direction_eq = false;   // assumes: opposite
      if ( v_prev_x > EPSILON ) {
        if ( v_next_x > EPSILON ) { direction_eq = true; }
      } else {
        if ( v_prev_x < - EPSILON ) {
          if ( v_next_x < - EPSILON ) { direction_eq = true; }
        } else {
          if ( Math.sign(v_prev_y) === Math.sign(v_next_y) ) { direction_eq = true; }
        }
      }

      if ( direction_eq ) {
        // console.log("Warning: lines are a straight sequence");
        v_trans_x = - v_prev_y;
        v_trans_y =  v_prev_x;
        shrink_by = Math.sqrt( v_prev_lensq );
      } else {
        // console.log("Warning: lines are a straight spike");
        v_trans_x = v_prev_x;
        v_trans_y = v_prev_y;
        shrink_by = Math.sqrt( v_prev_lensq / 2 );
      }

    }

    return  new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

  }


  var contourMovements = [];

  for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

    if ( j === il ) j = 0;
    if ( k === il ) k = 0;

    //  (j)---(i)---(k)
    // console.log('i,j,k', i, j , k)

    contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

  }

  var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

  for ( h = 0, hl = holes.length; h < hl; h ++ ) {

    ahole = holes[ h ];

    oneHoleMovements = [];

    for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

      if ( j === il ) j = 0;
      if ( k === il ) k = 0;

      //  (j)---(i)---(k)
      oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

    }

    holesMovements.push( oneHoleMovements );
    verticesMovements = verticesMovements.concat( oneHoleMovements );

  }


  // Loop bevelSegments, 1 for the front, 1 for the back

  for ( b = 0; b < bevelSegments; b ++ ) {
  //for ( b = bevelSegments; b > 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );

    //z = bevelThickness * t;
    bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ) ; // curved
    //bs = bevelSize * t ; // linear

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

      v( vert.x, vert.y,  - z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        v( vert.x, vert.y,  - z );

      }

    }

  }

  bs = bevelSize;

  // Back facing vertices

  for ( i = 0; i < vlen; i ++ ) {

    vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

    if ( ! extrudeByPath ) {

      v( vert.x, vert.y, 0 );

    } else {

      // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

      normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
      binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

      position2.copy( extrudePts[0] ).add(normal).add(binormal);

      v( position2.x, position2.y, position2.z );

    }

  }

  // Add stepped vertices...
  // Including front facing vertices

  var s;

  for ( s = 1; s <= steps; s ++ ) {

    for ( i = 0; i < vlen; i ++ ) {

      vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

      if ( ! extrudeByPath ) {

        v( vert.x, vert.y, amount / steps * s );

      } else {

        // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

        normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
        binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

        position2.copy( extrudePts[s] ).add( normal ).add( binormal );

        v( position2.x, position2.y, position2.z );

      }

    }

  }


  // Add bevel segments planes

  //for ( b = 1; b <= bevelSegments; b ++ ) {
  for ( b = bevelSegments - 1; b >= 0; b -- ) {

    t = b / bevelSegments;
    z = bevelThickness * ( 1 - t );
    //bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
    bs = bevelSize * Math.sin ( t * Math.PI / 2 ) ;

    // contract shape

    for ( i = 0, il = contour.length; i < il; i ++ ) {

      vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
      v( vert.x, vert.y,  amount + z );

    }

    // expand holes

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      oneHoleMovements = holesMovements[ h ];

      for ( i = 0, il = ahole.length; i < il; i ++ ) {

        vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

        if ( ! extrudeByPath ) {

          v( vert.x, vert.y,  amount + z );

        } else {

          v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

        }

      }

    }

  }

  /* Faces */

  // Top and bottom faces

  buildLidFaces();

  // Sides faces

  buildSideFaces();


  /////  Internal functions

  function buildLidFaces() {

    if ( bevelEnabled ) {

      var layer = 0 ; // steps + 1
      var offset = vlen * layer;

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

      }

      layer = steps + bevelSegments * 2;
      offset = vlen * layer;

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

      }

    } else {

      // Bottom faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 2 ], face[ 1 ], face[ 0 ] );

      }

      // Top faces

      for ( i = 0; i < flen; i ++ ) {

        face = faces[ i ];
        f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

      }
    }

  }

  // Create faces for the z-sides of the shape

  function buildSideFaces() {

    var layeroffset = 0;
    sidewalls( contour, layeroffset );
    layeroffset += contour.length;

    for ( h = 0, hl = holes.length; h < hl; h ++ ) {

      ahole = holes[ h ];
      sidewalls( ahole, layeroffset );

      //, true
      layeroffset += ahole.length;

    }

  }

  function sidewalls( contour, layeroffset ) {

    var j, k;
    i = contour.length;

    while ( -- i >= 0 ) {

      j = i;
      k = i - 1;
      if ( k < 0 ) k = contour.length - 1;

      //console.log('b', i,j, i-1, k,vertices.length);

      var s = 0, sl = steps  + bevelSegments * 2;

      for ( s = 0; s < sl; s ++ ) {

        var slen1 = vlen * s;
        var slen2 = vlen * ( s + 1 );

        var a = layeroffset + j + slen1,
          b = layeroffset + k + slen1,
          c = layeroffset + k + slen2,
          d = layeroffset + j + slen2;

        f4( a, b, c, d, contour, s, sl, j, k );

      }
    }

  }


  function v( x, y, z ) {

    scope.vertices.push( new THREE.Vector3( x, y, z ) );

  }

  function f3( a, b, c ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, c ) );

    var uvs = uvgen.generateTopUV( scope, a, b, c );

    scope.faceVertexUvs[ 0 ].push( uvs );

  }

  function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

    a += shapesOffset;
    b += shapesOffset;
    c += shapesOffset;
    d += shapesOffset;

    scope.faces.push( new THREE.Face3( a, b, d ) );
    scope.faces.push( new THREE.Face3( b, c, d ) );

    var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

    scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
    scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

  }

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

  generateTopUV: function ( geometry, indexA, indexB, indexC ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];

    return [
      new THREE.Vector2( a.x, a.y ),
      new THREE.Vector2( b.x, b.y ),
      new THREE.Vector2( c.x, c.y )
    ];

  },

  generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

    var vertices = geometry.vertices;

    var a = vertices[ indexA ];
    var b = vertices[ indexB ];
    var c = vertices[ indexC ];
    var d = vertices[ indexD ];

    if ( Math.abs( a.y - b.y ) < 0.01 ) {
      return [
        new THREE.Vector2( a.x, 1 - a.z ),
        new THREE.Vector2( b.x, 1 - b.z ),
        new THREE.Vector2( c.x, 1 - c.z ),
        new THREE.Vector2( d.x, 1 - d.z )
      ];
    } else {
      return [
        new THREE.Vector2( a.y, 1 - a.z ),
        new THREE.Vector2( b.y, 1 - b.z ),
        new THREE.Vector2( c.y, 1 - c.z ),
        new THREE.Vector2( d.y, 1 - d.z )
      ];
    }
  }
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *  material: <int> // material index for front and back faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

  THREE.Geometry.call( this );

  this.type = 'ShapeGeometry';

  if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

  this.addShapeList( shapes, options );

  this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

  for ( var i = 0, l = shapes.length; i < l; i ++ ) {

    this.addShape( shapes[ i ], options );

  }

  return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

  if ( options === undefined ) options = {};
  var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

  var material = options.material;
  var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

  //

  var i, l, hole;

  var shapesOffset = this.vertices.length;
  var shapePoints = shape.extractPoints( curveSegments );

  var vertices = shapePoints.shape;
  var holes = shapePoints.holes;

  var reverse = ! THREE.Shape.Utils.isClockWise( vertices );

  if ( reverse ) {

    vertices = vertices.reverse();

    // Maybe we should also check if holes are in the opposite direction, just to be safe...

    for ( i = 0, l = holes.length; i < l; i ++ ) {

      hole = holes[ i ];

      if ( THREE.Shape.Utils.isClockWise( hole ) ) {

        holes[ i ] = hole.reverse();

      }

    }

    reverse = false;

  }

  var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

  // Vertices

  var contour = vertices;

  for ( i = 0, l = holes.length; i < l; i ++ ) {

    hole = holes[ i ];
    vertices = vertices.concat( hole );

  }

  //

  var vert, vlen = vertices.length;
  var face, flen = faces.length;

  for ( i = 0; i < vlen; i ++ ) {

    vert = vertices[ i ];

    this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

  }

  for ( i = 0; i < flen; i ++ ) {

    face = faces[ i ];

    var a = face[ 0 ] + shapesOffset;
    var b = face[ 1 ] + shapesOffset;
    var c = face[ 2 ] + shapesOffset;

    this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
    this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

  }

};

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

  THREE.Geometry.call( this );

  this.type = 'LatheGeometry';

  this.parameters = {
    points: points,
    segments: segments,
    phiStart: phiStart,
    phiLength: phiLength
  };

  segments = segments || 12;
  phiStart = phiStart || 0;
  phiLength = phiLength || 2 * Math.PI;

  var inversePointLength = 1.0 / ( points.length - 1 );
  var inverseSegments = 1.0 / segments;

  for ( var i = 0, il = segments; i <= il; i ++ ) {

    var phi = phiStart + i * inverseSegments * phiLength;

    var c = Math.cos( phi ),
      s = Math.sin( phi );

    for ( var j = 0, jl = points.length; j < jl; j ++ ) {

      var pt = points[ j ];

      var vertex = new THREE.Vector3();

      vertex.x = c * pt.x - s * pt.y;
      vertex.y = s * pt.x + c * pt.y;
      vertex.z = pt.z;

      this.vertices.push( vertex );

    }

  }

  var np = points.length;

  for ( var i = 0, il = segments; i < il; i ++ ) {

    for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

      var base = j + np * i;
      var a = base;
      var b = base + np;
      var c = base + 1 + np;
      var d = base + 1;

      var u0 = i * inverseSegments;
      var v0 = j * inversePointLength;
      var u1 = u0 + inverseSegments;
      var v1 = v0 + inversePointLength;

      this.faces.push( new THREE.Face3( a, b, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u0, v0 ),
        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u0, v1 )

      ] );

      this.faces.push( new THREE.Face3( b, c, d ) );

      this.faceVertexUvs[ 0 ].push( [

        new THREE.Vector2( u1, v0 ),
        new THREE.Vector2( u1, v1 ),
        new THREE.Vector2( u0, v1 )

      ] );


    }

  }

  this.mergeVertices();
  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

  console.log( 'THREE.PlaneGeometry: Consider using THREE.PlaneBufferGeometry for lower memory footprint.' );

  THREE.Geometry.call( this );

  this.type = 'PlaneGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

  THREE.BufferGeometry.call( this );

  this.type = 'PlaneBufferGeometry';

  this.parameters = {
    width: width,
    height: height,
    widthSegments: widthSegments,
    heightSegments: heightSegments
  };

  var width_half = width / 2;
  var height_half = height / 2;

  var gridX = Math.floor( widthSegments ) || 1;
  var gridY = Math.floor( heightSegments ) || 1;

  var gridX1 = gridX + 1;
  var gridY1 = gridY + 1;

  var segment_width = width / gridX;
  var segment_height = height / gridY;

  var vertices = new Float32Array( gridX1 * gridY1 * 3 );
  var normals = new Float32Array( gridX1 * gridY1 * 3 );
  var uvs = new Float32Array( gridX1 * gridY1 * 2 );

  var offset = 0;
  var offset2 = 0;

  for ( var iy = 0; iy < gridY1; iy ++ ) {

    var y = iy * segment_height - height_half;

    for ( var ix = 0; ix < gridX1; ix ++ ) {

      var x = ix * segment_width - width_half;

      vertices[ offset     ] = x;
      vertices[ offset + 1 ] = - y;

      normals[ offset + 2 ] = 1;

      uvs[ offset2     ] = ix / gridX;
      uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

      offset += 3;
      offset2 += 2;

    }

  }

  offset = 0;

  var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

  for ( var iy = 0; iy < gridY; iy ++ ) {

    for ( var ix = 0; ix < gridX; ix ++ ) {

      var a = ix + gridX1 * iy;
      var b = ix + gridX1 * ( iy + 1 );
      var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
      var d = ( ix + 1 ) + gridX1 * iy;

      indices[ offset     ] = a;
      indices[ offset + 1 ] = b;
      indices[ offset + 2 ] = d;

      indices[ offset + 3 ] = b;
      indices[ offset + 4 ] = c;
      indices[ offset + 5 ] = d;

      offset += 6;

    }

  }

  this.addAttribute( 'index', new THREE.BufferAttribute( indices, 1 ) );
  this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
  this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

  THREE.Geometry.call( this );

  this.type = 'RingGeometry';

  this.parameters = {
    innerRadius: innerRadius,
    outerRadius: outerRadius,
    thetaSegments: thetaSegments,
    phiSegments: phiSegments,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  innerRadius = innerRadius || 0;
  outerRadius = outerRadius || 50;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

  thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
  phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 8;

  var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

  for ( i = 0; i < phiSegments + 1; i ++ ) { // concentric circles inside ring

    for ( o = 0; o < thetaSegments + 1; o ++ ) { // number of segments per circle

      var vertex = new THREE.Vector3();
      var segment = thetaStart + o / thetaSegments * thetaLength;
      vertex.x = radius * Math.cos( segment );
      vertex.y = radius * Math.sin( segment );

      this.vertices.push( vertex );
      uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
    }

    radius += radiusStep;

  }

  var n = new THREE.Vector3( 0, 0, 1 );

  for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

    var thetaSegment = i * (thetaSegments + 1);

    for ( o = 0; o < thetaSegments ; o ++ ) { // number of segments per circle

      var segment = o + thetaSegment;

      var v1 = segment;
      var v2 = segment + thetaSegments + 1;
      var v3 = segment + thetaSegments + 2;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

      v1 = segment;
      v2 = segment + thetaSegments + 2;
      v3 = segment + 1;

      this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
      this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

    }
  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;


// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  console.log( 'THREE.SphereGeometry: Consider using THREE.SphereBufferGeometry for lower memory footprint.' );

  THREE.Geometry.call( this );

  this.type = 'SphereGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;

  widthSegments = Math.max( 2, Math.floor( widthSegments ) || 8 );
  heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  var x, y, vertices = [], uvs = [];

  for ( y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];
    var uvsRow = [];

    for ( x = 0; x <= widthSegments; x ++ ) {

      var u = x / widthSegments;
      var v = y / heightSegments;

      var vertex = new THREE.Vector3();
      vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
      vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
      vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

      this.vertices.push( vertex );

      verticesRow.push( this.vertices.length - 1 );
      uvsRow.push( new THREE.Vector2( u, 1 - v ) );

    }

    vertices.push( verticesRow );
    uvs.push( uvsRow );

  }

  for ( y = 0; y < heightSegments; y ++ ) {

    for ( x = 0; x < widthSegments; x ++ ) {

      var v1 = vertices[ y ][ x + 1 ];
      var v2 = vertices[ y ][ x ];
      var v3 = vertices[ y + 1 ][ x ];
      var v4 = vertices[ y + 1 ][ x + 1 ];

      var n1 = this.vertices[ v1 ].clone().normalize();
      var n2 = this.vertices[ v2 ].clone().normalize();
      var n3 = this.vertices[ v3 ].clone().normalize();
      var n4 = this.vertices[ v4 ].clone().normalize();

      var uv1 = uvs[ y ][ x + 1 ].clone();
      var uv2 = uvs[ y ][ x ].clone();
      var uv3 = uvs[ y + 1 ][ x ].clone();
      var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

      if ( Math.abs( this.vertices[ v1 ].y ) === radius ) {

        uv1.x = ( uv1.x + uv2.x ) / 2;
        this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

      } else if ( Math.abs( this.vertices[ v3 ].y ) === radius ) {

        uv3.x = ( uv3.x + uv4.x ) / 2;
        this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

      } else {

        this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

        this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
        this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

      }

    }

  }

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

  THREE.BufferGeometry.call( this );

  this.type = 'SphereBufferGeometry';

  this.parameters = {
    radius: radius,
    widthSegments: widthSegments,
    heightSegments: heightSegments,
    phiStart: phiStart,
    phiLength: phiLength,
    thetaStart: thetaStart,
    thetaLength: thetaLength
  };

  radius = radius || 50;

  widthSegments = Math.max( 2, Math.floor( widthSegments ) || 8 );
  heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

  phiStart = phiStart !== undefined ? phiStart : 0;
  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

  thetaStart = thetaStart !== undefined ? thetaStart : 0;
  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

  var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

  var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
  var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3);
  var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

  var index = 0, vertices = [], normal = new THREE.Vector3();

  for ( var y = 0; y <= heightSegments; y ++ ) {

    var verticesRow = [];

    var v = y / heightSegments;

    for ( var x = 0; x <= widthSegments; x ++ ) {

      var u = x / widthSegments;

      var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
      var py = radius * Math.cos( thetaStart + v * thetaLength );
      var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

      normal.set( px, py, pz ).normalize();

      positions.setXYZ( index, px, py, pz );
      normals.setXYZ( index, normal.x, normal.y, normal.z );
      uvs.setXY( index, u, 1 - v );

      verticesRow.push( index );

      index++;

    }

    vertices.push( verticesRow );

  }

  var indices = [];

  for ( var y = 0; y < heightSegments; y ++ ) {

    for ( var x = 0; x < widthSegments; x ++ ) {

      var v1 = vertices[ y     ][ x + 1 ];
      var v2 = vertices[ y     ][ x     ];
      var v3 = vertices[ y + 1 ][ x     ];
      var v4 = vertices[ y + 1 ][ x + 1 ];

      if ( y !== 0 ) indices.push( v1, v2, v4 );
      if ( y !== heightSegments - 1 ) indices.push( v2, v3, v4 );

    }

  }

  this.addAttribute( 'index', new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
  this.addAttribute( 'position', positions );
  this.addAttribute( 'normal', normals );
  this.addAttribute( 'uv', uvs );

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size:       <float>,  // size of the text
 *  height:     <float>,  // thickness to extrude text
 *  curveSegments:  <int>,    // number of points on the curves
 *
 *  font:       <string>,   // font name
 *  weight:     <string>,   // font weight (normal, bold)
 *  style:      <string>,   // font style  (normal, italics)
 *
 *  bevelEnabled: <bool>,     // turn on bevel
 *  bevelThickness: <float>,    // how deep into text bevel goes
 *  bevelSize:    <float>,    // how far from text outline is bevel
 *  }
 *
 */

/*  Usage Examples

  // TextGeometry wrapper

  var text3d = new TextGeometry( text, options );

  // Complete manner

  var textShapes = THREE.FontUtils.generateShapes( text, options );
  var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

  parameters = parameters || {};

  var textShapes = THREE.FontUtils.generateShapes( text, parameters );

  // translate parameters to ExtrudeGeometry API

  parameters.amount = parameters.height !== undefined ? parameters.height : 50;

  // defaults

  if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
  if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
  if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

  THREE.ExtrudeGeometry.call( this, textShapes, parameters );

  this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

  THREE.Geometry.call( this );

  this.type = 'TorusGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    arc: arc
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 8;
  tubularSegments = tubularSegments || 6;
  arc = arc || Math.PI * 2;

  var center = new THREE.Vector3(), uvs = [], normals = [];

  for ( var j = 0; j <= radialSegments; j ++ ) {

    for ( var i = 0; i <= tubularSegments; i ++ ) {

      var u = i / tubularSegments * arc;
      var v = j / radialSegments * Math.PI * 2;

      center.x = radius * Math.cos( u );
      center.y = radius * Math.sin( u );

      var vertex = new THREE.Vector3();
      vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
      vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
      vertex.z = tube * Math.sin( v );

      this.vertices.push( vertex );

      uvs.push( new THREE.Vector2( i / tubularSegments, j / radialSegments ) );
      normals.push( vertex.clone().sub( center ).normalize() );

    }

  }

  for ( var j = 1; j <= radialSegments; j ++ ) {

    for ( var i = 1; i <= tubularSegments; i ++ ) {

      var a = ( tubularSegments + 1 ) * j + i - 1;
      var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
      var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
      var d = ( tubularSegments + 1 ) * j + i;

      var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

      face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
      this.faces.push( face );
      this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

    }

  }

  this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

  THREE.Geometry.call( this );

  this.type = 'TorusKnotGeometry';

  this.parameters = {
    radius: radius,
    tube: tube,
    radialSegments: radialSegments,
    tubularSegments: tubularSegments,
    p: p,
    q: q,
    heightScale: heightScale
  };

  radius = radius || 100;
  tube = tube || 40;
  radialSegments = radialSegments || 64;
  tubularSegments = tubularSegments || 8;
  p = p || 2;
  q = q || 3;
  heightScale = heightScale || 1;

  var grid = new Array( radialSegments );
  var tang = new THREE.Vector3();
  var n = new THREE.Vector3();
  var bitan = new THREE.Vector3();

  for ( var i = 0; i < radialSegments; ++ i ) {

    grid[ i ] = new Array( tubularSegments );
    var u = i / radialSegments * 2 * p * Math.PI;
    var p1 = getPos( u, q, p, radius, heightScale );
    var p2 = getPos( u + 0.01, q, p, radius, heightScale );
    tang.subVectors( p2, p1 );
    n.addVectors( p2, p1 );

    bitan.crossVectors( tang, n );
    n.crossVectors( bitan, tang );
    bitan.normalize();
    n.normalize();

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var v = j / tubularSegments * 2 * Math.PI;
      var cx = - tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      var cy = tube * Math.sin( v );

      var pos = new THREE.Vector3();
      pos.x = p1.x + cx * n.x + cy * bitan.x;
      pos.y = p1.y + cx * n.y + cy * bitan.y;
      pos.z = p1.z + cx * n.z + cy * bitan.z;

      grid[ i ][ j ] = this.vertices.push( pos ) - 1;

    }

  }

  for ( var i = 0; i < radialSegments; ++ i ) {

    for ( var j = 0; j < tubularSegments; ++ j ) {

      var ip = ( i + 1 ) % radialSegments;
      var jp = ( j + 1 ) % tubularSegments;

      var a = grid[ i ][ j ];
      var b = grid[ ip ][ j ];
      var c = grid[ ip ][ jp ];
      var d = grid[ i ][ jp ];

      var uva = new THREE.Vector2( i / radialSegments, j / tubularSegments );
      var uvb = new THREE.Vector2( ( i + 1 ) / radialSegments, j / tubularSegments );
      var uvc = new THREE.Vector2( ( i + 1 ) / radialSegments, ( j + 1 ) / tubularSegments );
      var uvd = new THREE.Vector2( i / radialSegments, ( j + 1 ) / tubularSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }
  }

  this.computeFaceNormals();
  this.computeVertexNormals();

  function getPos( u, in_q, in_p, radius, heightScale ) {

    var cu = Math.cos( u );
    var su = Math.sin( u );
    var quOverP = in_q / in_p * u;
    var cs = Math.cos( quOverP );

    var tx = radius * ( 2 + cs ) * 0.5 * cu;
    var ty = radius * ( 2 + cs ) * su * 0.5;
    var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

    return new THREE.Vector3( tx, ty, tz );

  }

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

  THREE.Geometry.call( this );

  this.type = 'TubeGeometry';

  this.parameters = {
    path: path,
    segments: segments,
    radius: radius,
    radialSegments: radialSegments,
    closed: closed
  };

  segments = segments || 64;
  radius = radius || 1;
  radialSegments = radialSegments || 8;
  closed = closed || false;
  taper = taper || THREE.TubeGeometry.NoTaper;

  var grid = [];

  var scope = this,

    tangent,
    normal,
    binormal,

    numpoints = segments + 1,

    u, v, r,

    cx, cy,
    pos, pos2 = new THREE.Vector3(),
    i, j,
    ip, jp,
    a, b, c, d,
    uva, uvb, uvc, uvd;

  var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
    tangents = frames.tangents,
    normals = frames.normals,
    binormals = frames.binormals;

  // proxy internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  function vert( x, y, z ) {

    return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

  }

  // consruct the grid

  for ( i = 0; i < numpoints; i ++ ) {

    grid[ i ] = [];

    u = i / ( numpoints - 1 );

    pos = path.getPointAt( u );

    tangent = tangents[ i ];
    normal = normals[ i ];
    binormal = binormals[ i ];

    r = radius * taper( u );

    for ( j = 0; j < radialSegments; j ++ ) {

      v = j / radialSegments * 2 * Math.PI;

      cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
      cy = r * Math.sin( v );

      pos2.copy( pos );
      pos2.x += cx * normal.x + cy * binormal.x;
      pos2.y += cx * normal.y + cy * binormal.y;
      pos2.z += cx * normal.z + cy * binormal.z;

      grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

    }
  }


  // construct the mesh

  for ( i = 0; i < segments; i ++ ) {

    for ( j = 0; j < radialSegments; j ++ ) {

      ip = ( closed ) ? (i + 1) % segments : i + 1;
      jp = (j + 1) % radialSegments;

      a = grid[ i ][ j ];   // *** NOT NECESSARILY PLANAR ! ***
      b = grid[ ip ][ j ];
      c = grid[ ip ][ jp ];
      d = grid[ i ][ jp ];

      uva = new THREE.Vector2( i / segments, j / radialSegments );
      uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
      uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
      uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

      this.faces.push( new THREE.Face3( a, b, d ) );
      this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

      this.faces.push( new THREE.Face3( b, c, d ) );
      this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

    }
  }

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function ( u ) {

  return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

  return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

  var normal = new THREE.Vector3(),

    tangents = [],
    normals = [],
    binormals = [],

    vec = new THREE.Vector3(),
    mat = new THREE.Matrix4(),

    numpoints = segments + 1,
    theta,
    epsilon = 0.0001,
    smallest,

    tx, ty, tz,
    i, u;


  // expose internals
  this.tangents = tangents;
  this.normals = normals;
  this.binormals = binormals;

  // compute the tangent vectors for each segment on the path

  for ( i = 0; i < numpoints; i ++ ) {

    u = i / ( numpoints - 1 );

    tangents[ i ] = path.getTangentAt( u );
    tangents[ i ].normalize();

  }

  initialNormal3();

  /*
  function initialNormal1(lastBinormal) {
    // fixed start binormal. Has dangers of 0 vectors
    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
    normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
  }

  function initialNormal2() {

    // This uses the Frenet-Serret formula for deriving binormal
    var t2 = path.getTangentAt( epsilon );

    normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
    binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

    normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

  }
  */

  function initialNormal3() {
    // select an initial normal vector perpenicular to the first tangent vector,
    // and in the direction of the smallest tangent xyz component

    normals[ 0 ] = new THREE.Vector3();
    binormals[ 0 ] = new THREE.Vector3();
    smallest = Number.MAX_VALUE;
    tx = Math.abs( tangents[ 0 ].x );
    ty = Math.abs( tangents[ 0 ].y );
    tz = Math.abs( tangents[ 0 ].z );

    if ( tx <= smallest ) {
      smallest = tx;
      normal.set( 1, 0, 0 );
    }

    if ( ty <= smallest ) {
      smallest = ty;
      normal.set( 0, 1, 0 );
    }

    if ( tz <= smallest ) {
      normal.set( 0, 0, 1 );
    }

    vec.crossVectors( tangents[ 0 ], normal ).normalize();

    normals[ 0 ].crossVectors( tangents[ 0 ], vec );
    binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
  }


  // compute the slowly-varying normal and binormal vectors for each segment on the path

  for ( i = 1; i < numpoints; i ++ ) {

    normals[ i ] = normals[ i - 1 ].clone();

    binormals[ i ] = binormals[ i - 1 ].clone();

    vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

    if ( vec.length() > epsilon ) {

      vec.normalize();

      theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

      normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

    }

    binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

  }


  // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

  if ( closed ) {

    theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
    theta /= ( numpoints - 1 );

    if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

      theta = - theta;

    }

    for ( i = 1; i < numpoints; i ++ ) {

      // twist a little...
      normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
      binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

    }

  }
};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

  THREE.Geometry.call( this );

  this.type = 'PolyhedronGeometry';

  this.parameters = {
    vertices: vertices,
    indices: indices,
    radius: radius,
    detail: detail
  };

  radius = radius || 1;
  detail = detail || 0;

  var that = this;

  for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

    prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

  }

  var p = this.vertices;

  var faces = [];

  for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

    var v1 = p[ indices[ i     ] ];
    var v2 = p[ indices[ i + 1 ] ];
    var v3 = p[ indices[ i + 2 ] ];

    faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

  }

  var centroid = new THREE.Vector3();

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    subdivide( faces[ i ], detail );

  }


  // Handle case when face straddles the seam

  for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

    var uvs = this.faceVertexUvs[ 0 ][ i ];

    var x0 = uvs[ 0 ].x;
    var x1 = uvs[ 1 ].x;
    var x2 = uvs[ 2 ].x;

    var max = Math.max( x0, Math.max( x1, x2 ) );
    var min = Math.min( x0, Math.min( x1, x2 ) );

    if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

      if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
      if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
      if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

    }

  }


  // Apply radius

  for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

    this.vertices[ i ].multiplyScalar( radius );

  }


  // Merge vertices

  this.mergeVertices();

  this.computeFaceNormals();

  this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


  // Project vector onto sphere's surface

  function prepare( vector ) {

    var vertex = vector.normalize().clone();
    vertex.index = that.vertices.push( vertex ) - 1;

    // Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

    var u = azimuth( vector ) / 2 / Math.PI + 0.5;
    var v = inclination( vector ) / Math.PI + 0.5;
    vertex.uv = new THREE.Vector2( u, 1 - v );

    return vertex;

  }


  // Approximate a curved face with recursively sub-divided triangles.

  function make( v1, v2, v3 ) {

    var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
    that.faces.push( face );

    centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

    var azi = azimuth( centroid );

    that.faceVertexUvs[ 0 ].push( [
      correctUV( v1.uv, v1, azi ),
      correctUV( v2.uv, v2, azi ),
      correctUV( v3.uv, v3, azi )
    ] );

  }


  // Analytically subdivide a face to the required detail level.

  function subdivide( face, detail ) {

    var cols = Math.pow(2, detail);
    var a = prepare( that.vertices[ face.a ] );
    var b = prepare( that.vertices[ face.b ] );
    var c = prepare( that.vertices[ face.c ] );
    var v = [];

    // Construct all of the vertices for this subdivision.

    for ( var i = 0 ; i <= cols; i ++ ) {

      v[ i ] = [];

      var aj = prepare( a.clone().lerp( c, i / cols ) );
      var bj = prepare( b.clone().lerp( c, i / cols ) );
      var rows = cols - i;

      for ( var j = 0; j <= rows; j ++) {

        if ( j === 0 && i === cols ) {

          v[ i ][ j ] = aj;

        } else {

          v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

        }

      }

    }

    // Construct all of the faces.

    for ( var i = 0; i < cols ; i ++ ) {

      for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

        var k = Math.floor( j / 2 );

        if ( j % 2 === 0 ) {

          make(
            v[ i ][ k + 1],
            v[ i + 1 ][ k ],
            v[ i ][ k ]
          );

        } else {

          make(
            v[ i ][ k + 1 ],
            v[ i + 1][ k + 1],
            v[ i + 1 ][ k ]
          );

        }

      }

    }

  }


  // Angle around the Y axis, counter-clockwise when looking from above.

  function azimuth( vector ) {

    return Math.atan2( vector.z, - vector.x );

  }


  // Angle above the XZ plane.

  function inclination( vector ) {

    return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

  }


  // Texture fixing helper. Spheres have some odd behaviours.

  function correctUV( uv, vector, azimuth ) {

    if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
    if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
    return uv.clone();

  }


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

  this.parameters = {
    radius: radius,
    detail: detail
  };

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;
  var r = 1 / t;

  var vertices = [

    // (±1, ±1, ±1)
    -1, -1, -1,    -1, -1,  1,
    -1,  1, -1,    -1,  1,  1,
     1, -1, -1,     1, -1,  1,
     1,  1, -1,     1,  1,  1,

    // (0, ±1/φ, ±φ)
     0, -r, -t,     0, -r,  t,
     0,  r, -t,     0,  r,  t,

    // (±1/φ, ±φ, 0)
    -r, -t,  0,    -r,  t,  0,
     r, -t,  0,     r,  t,  0,

    // (±φ, 0, ±1/φ)
    -t,  0, -r,     t,  0, -r,
    -t,  0,  r,     t,  0,  r
  ];

  var indices = [
     3, 11,  7,      3,  7, 15,      3, 15, 13,
     7, 19, 17,      7, 17,  6,      7,  6, 15,
    17,  4,  8,     17,  8, 10,     17, 10,  6,
     8,  0, 16,      8, 16,  2,      8,  2, 10,
     0, 12,  1,      0,  1, 18,      0, 18, 16,
     6, 10,  2,      6,  2, 13,      6, 13, 15,
     2, 16, 18,      2, 18,  3,      2,  3, 13,
    18,  1,  9,     18,  9, 11,     18, 11,  3,
     4, 14, 12,      4, 12,  0,      4,  0,  8,
    11,  9,  5,     11,  5, 19,     11, 19,  7,
    19,  5, 14,     19, 14,  4,     19,  4, 17,
     1, 12, 14,      1, 14,  5,      1,  5,  9
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

  var t = ( 1 + Math.sqrt( 5 ) ) / 2;

  var vertices = [
    - 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
     0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
     t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
  ];

  var indices = [
     0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
     1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
     3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
     4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'IcosahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };
};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

  this.parameters = {
    radius: radius,
    detail: detail
  };

  var vertices = [
    1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0,- 1, 0,    0, 0, 1,    0, 0,- 1
  ];

  var indices = [
    0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'OctahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

  var vertices = [
     1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
  ];

  var indices = [
     2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
  ];

  THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

  this.type = 'TetrahedronGeometry';

  this.parameters = {
    radius: radius,
    detail: detail
  };

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

  THREE.Geometry.call( this );

  this.type = 'ParametricGeometry';

  this.parameters = {
    func: func,
    slices: slices,
    stacks: stacks
  };

  var verts = this.vertices;
  var faces = this.faces;
  var uvs = this.faceVertexUvs[ 0 ];

  var i, j, p;
  var u, v;

  var sliceCount = slices + 1;

  for ( i = 0; i <= stacks; i ++ ) {

    v = i / stacks;

    for ( j = 0; j <= slices; j ++ ) {

      u = j / slices;

      p = func( u, v );
      verts.push( p );

    }
  }

  var a, b, c, d;
  var uva, uvb, uvc, uvd;

  for ( i = 0; i < stacks; i ++ ) {

    for ( j = 0; j < slices; j ++ ) {

      a = i * sliceCount + j;
      b = i * sliceCount + j + 1;
      c = (i + 1) * sliceCount + j + 1;
      d = (i + 1) * sliceCount + j;

      uva = new THREE.Vector2( j / slices, i / stacks );
      uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
      uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
      uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

      faces.push( new THREE.Face3( a, b, d ) );
      uvs.push( [ uva, uvb, uvd ] );

      faces.push( new THREE.Face3( b, c, d ) );
      uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

    }

  }

  // console.log(this);

  // magic bullet
  // var diff = this.mergeVertices();
  // console.log('removed ', diff, ' vertices by merging');

  this.computeFaceNormals();
  this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

  THREE.BufferGeometry.call( this );

  var edge = [ 0, 0 ], hash = {};
  var sortFunction = function ( a, b ) { return a - b };

  var keys = [ 'a', 'b', 'c' ];

  if ( geometry instanceof THREE.Geometry ) {

    var vertices = geometry.vertices;
    var faces = geometry.faces;
    var numEdges = 0;

    // allocate maximal size
    var edges = new Uint32Array( 6 * faces.length );

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0; j < 3; j ++ ) {

        edge[ 0 ] = face[ keys[ j ] ];
        edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
        edge.sort( sortFunction );

        var key = edge.toString();

        if ( hash[ key ] === undefined ) {

          edges[ 2 * numEdges ] = edge[ 0 ];
          edges[ 2 * numEdges + 1 ] = edge[ 1 ];
          hash[ key ] = true;
          numEdges ++;

        }

      }

    }

    var coords = new Float32Array( numEdges * 2 * 3 );

    for ( var i = 0, l = numEdges; i < l; i ++ ) {

      for ( var j = 0; j < 2; j ++ ) {

        var vertex = vertices[ edges [ 2 * i + j] ];

        var index = 6 * i + 3 * j;
        coords[ index + 0 ] = vertex.x;
        coords[ index + 1 ] = vertex.y;
        coords[ index + 2 ] = vertex.z;

      }

    }

    this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

  } else if ( geometry instanceof THREE.BufferGeometry ) {

    if ( geometry.attributes.index !== undefined ) { // Indexed BufferGeometry

      var vertices = geometry.attributes.position;
      var indices = geometry.attributes.index.array;
      var drawcalls = geometry.drawcalls;
      var numEdges = 0;

      if ( drawcalls.length === 0 ) {

        drawcalls = [ { count : indices.length, index : 0, start : 0 } ];

      }

      // allocate maximal size
      var edges = new Uint32Array( 2 * indices.length );

      for ( var o = 0, ol = drawcalls.length; o < ol; ++ o ) {

        var start = drawcalls[ o ].start;
        var count = drawcalls[ o ].count;
        var index = drawcalls[ o ].index;

        for ( var i = start, il = start + count; i < il; i += 3 ) {

          for ( var j = 0; j < 3; j ++ ) {

            edge[ 0 ] = index + indices[ i + j ];
            edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
            edge.sort( sortFunction );

            var key = edge.toString();

            if ( hash[ key ] === undefined ) {

              edges[ 2 * numEdges ] = edge[ 0 ];
              edges[ 2 * numEdges + 1 ] = edge[ 1 ];
              hash[ key ] = true;
              numEdges ++;

            }

          }

        }

      }

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numEdges; i < l; i ++ ) {

        for ( var j = 0; j < 2; j ++ ) {

          var index = 6 * i + 3 * j;
          var index2 = edges[2 * i + j];

          coords[ index + 0 ] = vertices.getX( index2 );
          coords[ index + 1 ] = vertices.getY( index2 );
          coords[ index + 2 ] = vertices.getZ( index2 );

        }

      }

      this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    } else { // non-indexed BufferGeometry

      var vertices = geometry.attributes.position.array;
      var numEdges = vertices.length / 3;
      var numTris = numEdges / 3;

      var coords = new Float32Array( numEdges * 2 * 3 );

      for ( var i = 0, l = numTris; i < l; i ++ ) {

        for ( var j = 0; j < 3; j ++ ) {

          var index = 18 * i + 6 * j;

          var index1 = 9 * i + 3 * j;
          coords[ index + 0 ] = vertices[ index1 ];
          coords[ index + 1 ] = vertices[ index1 + 1 ];
          coords[ index + 2 ] = vertices[ index1 + 2 ];

          var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
          coords[ index + 3 ] = vertices[ index2 ];
          coords[ index + 4 ] = vertices[ index2 + 1 ];
          coords[ index + 5 ] = vertices[ index2 + 2 ];

        }

      }

      this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

    }

  }

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

  size = size || 1;

  var vertices = new Float32Array( [
    0, 0, 0,  size, 0, 0,
    0, 0, 0,  0, size, 0,
    0, 0, 0,  0, 0, size
  ] );

  var colors = new Float32Array( [
    1, 0, 0,  1, 0.6, 0,
    0, 1, 0,  0.6, 1, 0,
    0, 0, 1,  0, 0.6, 1
  ] );

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
  geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

  var lineGeometry = new THREE.Geometry();
  lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ), new THREE.Vector3( 0, 1, 0 ) );

  var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
  coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

  return function ( dir, origin, length, color, headLength, headWidth ) {

    // dir is assumed to be normalized

    THREE.Object3D.call( this );

    if ( color === undefined ) color = 0xffff00;
    if ( length === undefined ) length = 1;
    if ( headLength === undefined ) headLength = 0.2 * length;
    if ( headWidth === undefined ) headWidth = 0.2 * headLength;

    this.position.copy( origin );

    this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
    this.line.matrixAutoUpdate = false;
    this.add( this.line );

    this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
    this.cone.matrixAutoUpdate = false;
    this.add( this.cone );

    this.setDirection( dir );
    this.setLength( length, headLength, headWidth );

  }

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

  var axis = new THREE.Vector3();
  var radians;

  return function ( dir ) {

    // dir is assumed to be normalized

    if ( dir.y > 0.99999 ) {

      this.quaternion.set( 0, 0, 0, 1 );

    } else if ( dir.y < - 0.99999 ) {

      this.quaternion.set( 1, 0, 0, 0 );

    } else {

      axis.set( dir.z, 0, - dir.x ).normalize();

      radians = Math.acos( dir.y );

      this.quaternion.setFromAxisAngle( axis, radians );

    }

  };

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

  if ( headLength === undefined ) headLength = 0.2 * length;
  if ( headWidth === undefined ) headWidth = 0.2 * headLength;

  this.line.scale.set( 1, length - headLength, 1 );
  this.line.updateMatrix();

  this.cone.scale.set( headWidth, headLength, headWidth );
  this.cone.position.y = length;
  this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

  this.line.material.color.set( color );
  this.cone.material.color.set( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

  var geometry = new THREE.BufferGeometry();
  geometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 72 ), 3 ) );

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );

  if ( object !== undefined ) {

    this.update( object );

  }

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = function ( object ) {

  var geometry = object.geometry;

  if ( geometry.boundingBox === null ) {

    geometry.computeBoundingBox();

  }

  var min = geometry.boundingBox.min;
  var max = geometry.boundingBox.max;

  /*
    5____4
  1/___0/|
  | 6__|_7
  2/___3/

  0: max.x, max.y, max.z
  1: min.x, max.y, max.z
  2: min.x, min.y, max.z
  3: max.x, min.y, max.z
  4: max.x, max.y, min.z
  5: min.x, max.y, min.z
  6: min.x, min.y, min.z
  7: max.x, min.y, min.z
  */

  var vertices = this.geometry.attributes.position.array;

  vertices[  0 ] = max.x; vertices[  1 ] = max.y; vertices[  2 ] = max.z;
  vertices[  3 ] = min.x; vertices[  4 ] = max.y; vertices[  5 ] = max.z;

  vertices[  6 ] = min.x; vertices[  7 ] = max.y; vertices[  8 ] = max.z;
  vertices[  9 ] = min.x; vertices[ 10 ] = min.y; vertices[ 11 ] = max.z;

  vertices[ 12 ] = min.x; vertices[ 13 ] = min.y; vertices[ 14 ] = max.z;
  vertices[ 15 ] = max.x; vertices[ 16 ] = min.y; vertices[ 17 ] = max.z;

  vertices[ 18 ] = max.x; vertices[ 19 ] = min.y; vertices[ 20 ] = max.z;
  vertices[ 21 ] = max.x; vertices[ 22 ] = max.y; vertices[ 23 ] = max.z;

  //

  vertices[ 24 ] = max.x; vertices[ 25 ] = max.y; vertices[ 26 ] = min.z;
  vertices[ 27 ] = min.x; vertices[ 28 ] = max.y; vertices[ 29 ] = min.z;

  vertices[ 30 ] = min.x; vertices[ 31 ] = max.y; vertices[ 32 ] = min.z;
  vertices[ 33 ] = min.x; vertices[ 34 ] = min.y; vertices[ 35 ] = min.z;

  vertices[ 36 ] = min.x; vertices[ 37 ] = min.y; vertices[ 38 ] = min.z;
  vertices[ 39 ] = max.x; vertices[ 40 ] = min.y; vertices[ 41 ] = min.z;

  vertices[ 42 ] = max.x; vertices[ 43 ] = min.y; vertices[ 44 ] = min.z;
  vertices[ 45 ] = max.x; vertices[ 46 ] = max.y; vertices[ 47 ] = min.z;

  //

  vertices[ 48 ] = max.x; vertices[ 49 ] = max.y; vertices[ 50 ] = max.z;
  vertices[ 51 ] = max.x; vertices[ 52 ] = max.y; vertices[ 53 ] = min.z;

  vertices[ 54 ] = min.x; vertices[ 55 ] = max.y; vertices[ 56 ] = max.z;
  vertices[ 57 ] = min.x; vertices[ 58 ] = max.y; vertices[ 59 ] = min.z;

  vertices[ 60 ] = min.x; vertices[ 61 ] = min.y; vertices[ 62 ] = max.z;
  vertices[ 63 ] = min.x; vertices[ 64 ] = min.y; vertices[ 65 ] = min.z;

  vertices[ 66 ] = max.x; vertices[ 67 ] = min.y; vertices[ 68 ] = max.z;
  vertices[ 69 ] = max.x; vertices[ 70 ] = min.y; vertices[ 71 ] = min.z;

  this.geometry.attributes.position.needsUpdate = true;

  this.geometry.computeBoundingSphere();

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0x888888;

  this.object = object;

  this.box = new THREE.Box3();

  THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

  this.box.setFromObject( this.object );

  this.box.size( this.scale );

  this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *  - shows frustum, line of sight and up of the camera
 *  - suitable for fast updates
 *  - based on frustum visualization in lightgl.js shadowmap example
 *    http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

  var pointMap = {};

  // colors

  var hexFrustum = 0xffaa00;
  var hexCone = 0xff0000;
  var hexUp = 0x00aaff;
  var hexTarget = 0xffffff;
  var hexCross = 0x333333;

  // near

  addLine( "n1", "n2", hexFrustum );
  addLine( "n2", "n4", hexFrustum );
  addLine( "n4", "n3", hexFrustum );
  addLine( "n3", "n1", hexFrustum );

  // far

  addLine( "f1", "f2", hexFrustum );
  addLine( "f2", "f4", hexFrustum );
  addLine( "f4", "f3", hexFrustum );
  addLine( "f3", "f1", hexFrustum );

  // sides

  addLine( "n1", "f1", hexFrustum );
  addLine( "n2", "f2", hexFrustum );
  addLine( "n3", "f3", hexFrustum );
  addLine( "n4", "f4", hexFrustum );

  // cone

  addLine( "p", "n1", hexCone );
  addLine( "p", "n2", hexCone );
  addLine( "p", "n3", hexCone );
  addLine( "p", "n4", hexCone );

  // up

  addLine( "u1", "u2", hexUp );
  addLine( "u2", "u3", hexUp );
  addLine( "u3", "u1", hexUp );

  // target

  addLine( "c", "t", hexTarget );
  addLine( "p", "c", hexCross );

  // cross

  addLine( "cn1", "cn2", hexCross );
  addLine( "cn3", "cn4", hexCross );

  addLine( "cf1", "cf2", hexCross );
  addLine( "cf3", "cf4", hexCross );

  function addLine( a, b, hex ) {

    addPoint( a, hex );
    addPoint( b, hex );

  }

  function addPoint( id, hex ) {

    geometry.vertices.push( new THREE.Vector3() );
    geometry.colors.push( new THREE.Color( hex ) );

    if ( pointMap[ id ] === undefined ) {

      pointMap[ id ] = [];

    }

    pointMap[ id ].push( geometry.vertices.length - 1 );

  }

  THREE.LineSegments.call( this, geometry, material );

  this.camera = camera;
  this.matrix = camera.matrixWorld;
  this.matrixAutoUpdate = false;

  this.pointMap = pointMap;

  this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

  var geometry, pointMap;

  var vector = new THREE.Vector3();
  var camera = new THREE.Camera();

  var setPoint = function ( point, x, y, z ) {

    vector.set( x, y, z ).unproject( camera );

    var points = pointMap[ point ];

    if ( points !== undefined ) {

      for ( var i = 0, il = points.length; i < il; i ++ ) {

        geometry.vertices[ points[ i ] ].copy( vector );

      }

    }

  };

  return function () {

    geometry = this.geometry;
    pointMap = this.pointMap;

    var w = 1, h = 1;

    // we need just camera projection matrix
    // world matrix must be identity

    camera.projectionMatrix.copy( this.camera.projectionMatrix );

    // center / target

    setPoint( "c", 0, 0, - 1 );
    setPoint( "t", 0, 0,  1 );

    // near

    setPoint( "n1", - w, - h, - 1 );
    setPoint( "n2",   w, - h, - 1 );
    setPoint( "n3", - w,   h, - 1 );
    setPoint( "n4",   w,   h, - 1 );

    // far

    setPoint( "f1", - w, - h, 1 );
    setPoint( "f2",   w, - h, 1 );
    setPoint( "f3", - w,   h, 1 );
    setPoint( "f4",   w,   h, 1 );

    // up

    setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
    setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
    setPoint( "u3",         0, h * 2,   - 1 );

    // cross

    setPoint( "cf1", - w,   0, 1 );
    setPoint( "cf2",   w,   0, 1 );
    setPoint( "cf3",   0, - h, 1 );
    setPoint( "cf4",   0,   h, 1 );

    setPoint( "cn1", - w,   0, - 1 );
    setPoint( "cn2",   w,   0, - 1 );
    setPoint( "cn3",   0, - h, - 1 );
    setPoint( "cn4",   0,   h, - 1 );

    geometry.verticesNeedUpdate = true;

  };

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  size = size || 1;

  var geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3( - size,   size, 0 ),
    new THREE.Vector3(   size,   size, 0 ),
    new THREE.Vector3(   size, - size, 0 ),
    new THREE.Vector3( - size, - size, 0 ),
    new THREE.Vector3( - size,   size, 0 )
  );

  var material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.lightPlane = new THREE.Line( geometry, material );
  this.add( this.lightPlane );

  geometry = new THREE.Geometry();
  geometry.vertices.push(
    new THREE.Vector3(),
    new THREE.Vector3()
  );

  material = new THREE.LineBasicMaterial( { fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  this.targetLine = new THREE.Line( geometry, material );
  this.add( this.targetLine );

  this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

  this.lightPlane.geometry.dispose();
  this.lightPlane.material.dispose();
  this.targetLine.geometry.dispose();
  this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

  var v1 = new THREE.Vector3();
  var v2 = new THREE.Vector3();
  var v3 = new THREE.Vector3();

  return function () {

    v1.setFromMatrixPosition( this.light.matrixWorld );
    v2.setFromMatrixPosition( this.light.target.matrixWorld );
    v3.subVectors( v2, v1 );

    this.lightPlane.lookAt( v3 );
    this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

    this.targetLine.geometry.vertices[ 1 ].copy( v3 );
    this.targetLine.geometry.verticesNeedUpdate = true;
    this.targetLine.material.color.copy( this.lightPlane.material.color );

  };

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimim angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xffff00;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var faces = this.object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

  }

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  this.matrixAutoUpdate = false;

  this.normalMatrix = new THREE.Matrix3();

  this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = function () {

  var vertices = this.geometry.vertices;

  var object = this.object;
  var objectVertices = object.geometry.vertices;
  var objectFaces = object.geometry.faces;
  var objectWorldMatrix = object.matrixWorld;

  object.updateMatrixWorld( true );

  this.normalMatrix.getNormalMatrix( objectWorldMatrix );

  for ( var i = 0, i2 = 0, l = objectFaces.length; i < l; i ++, i2 += 2 ) {

    var face = objectFaces[ i ];

    vertices[ i2 ].copy( objectVertices[ face.a ] )
      .add( objectVertices[ face.b ] )
      .add( objectVertices[ face.c ] )
      .divideScalar( 3 )
      .applyMatrix4( objectWorldMatrix );

    vertices[ i2 + 1 ].copy( face.normal )
      .applyMatrix3( this.normalMatrix )
      .normalize()
      .multiplyScalar( this.size )
      .add( vertices[ i2 ] );

  }

  this.geometry.verticesNeedUpdate = true;

  return this;

};

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

  var geometry = new THREE.Geometry();
  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

  this.color1 = new THREE.Color( 0x444444 );
  this.color2 = new THREE.Color( 0x888888 );

  for ( var i = - size; i <= size; i += step ) {

    geometry.vertices.push(
      new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
      new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
    );

    var color = i === 0 ? this.color1 : this.color2;

    geometry.colors.push( color, color, color, color );

  }

  THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

  this.color1.set( colorCenterLine );
  this.color2.set( colorGrid );

  this.geometry.colorsNeedUpdate = true;

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  this.colors = [ new THREE.Color(), new THREE.Color() ];

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

  for ( var i = 0, il = 8; i < il; i ++ ) {

    geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

  }

  var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

  this.lightSphere = new THREE.Mesh( geometry, material );
  this.add( this.lightSphere );

  this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {
  this.lightSphere.geometry.dispose();
  this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();

  return function () {

    this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
    this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

    this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
    this.lightSphere.geometry.colorsNeedUpdate = true;

  }

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

  this.light = light;
  this.light.updateMatrixWorld();

  var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
  material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  THREE.Mesh.call( this, geometry, material );

  this.matrix = this.light.matrixWorld;
  this.matrixAutoUpdate = false;

  /*
  var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
  var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

  this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
  this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

  var d = light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.scale.set( d, d, d );

  }

  this.add( this.lightDistance );
  */

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

  this.geometry.dispose();
  this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

  this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  /*
  var d = this.light.distance;

  if ( d === 0.0 ) {

    this.lightDistance.visible = false;

  } else {

    this.lightDistance.visible = true;
    this.lightDistance.scale.set( d, d, d );

  }
  */

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

  this.bones = this.getBoneList( object );

  var geometry = new THREE.Geometry();

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      geometry.vertices.push( new THREE.Vector3() );
      geometry.vertices.push( new THREE.Vector3() );
      geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
      geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

    }

  }

  geometry.dynamic = true;

  var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

  THREE.LineSegments.call( this, geometry, material );

  this.root = object;

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

  this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

  var boneList = [];

  if ( object instanceof THREE.Bone ) {

    boneList.push( object );

  }

  for ( var i = 0; i < object.children.length; i ++ ) {

    boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

  }

  return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

  var geometry = this.geometry;

  var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

  var boneMatrix = new THREE.Matrix4();

  var j = 0;

  for ( var i = 0; i < this.bones.length; i ++ ) {

    var bone = this.bones[ i ];

    if ( bone.parent instanceof THREE.Bone ) {

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
      geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

      boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
      geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

      j += 2;

    }

  }

  geometry.verticesNeedUpdate = true;

  geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

  THREE.Object3D.call( this );

  this.light = light;
  this.light.updateMatrixWorld();

  this.matrix = light.matrixWorld;
  this.matrixAutoUpdate = false;

  var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

  geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );
  geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

  var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );

  this.cone = new THREE.Mesh( geometry, material );
  this.add( this.cone );

  this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {
  this.cone.geometry.dispose();
  this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

  var vector = new THREE.Vector3();
  var vector2 = new THREE.Vector3();

  return function () {

    var coneLength = this.light.distance ? this.light.distance : 10000;
    var coneWidth = coneLength * Math.tan( this.light.angle );

    this.cone.scale.set( coneWidth, coneWidth, coneLength );

    vector.setFromMatrixPosition( this.light.matrixWorld );
    vector2.setFromMatrixPosition( this.light.target.matrixWorld );

    this.cone.lookAt( vector2.sub( vector ) );

    this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

  };

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0xff0000;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var faces = object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

      geometry.vertices.push( new THREE.Vector3(), new THREE.Vector3() );

    }

  }

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  this.matrixAutoUpdate = false;

  this.normalMatrix = new THREE.Matrix3();

  this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

  var v1 = new THREE.Vector3();

  return function( object ) {

    var keys = [ 'a', 'b', 'c', 'd' ];

    this.object.updateMatrixWorld( true );

    this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

    var vertices = this.geometry.vertices;

    var verts = this.object.geometry.vertices;

    var faces = this.object.geometry.faces;

    var worldMatrix = this.object.matrixWorld;

    var idx = 0;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

        var vertexId = face[ keys[ j ] ];
        var vertex = verts[ vertexId ];

        var normal = face.vertexNormals[ j ];

        vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

        v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

        v1.add( vertices[ idx ] );
        idx = idx + 1;

        vertices[ idx ].copy( v1 );
        idx = idx + 1;

      }

    }

    this.geometry.verticesNeedUpdate = true;

    return this;

  }

}());

// File:src/extras/helpers/VertexTangentsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

  this.object = object;

  this.size = ( size !== undefined ) ? size : 1;

  var color = ( hex !== undefined ) ? hex : 0x0000ff;

  var width = ( linewidth !== undefined ) ? linewidth : 1;

  var geometry = new THREE.Geometry();

  var faces = object.geometry.faces;

  for ( var i = 0, l = faces.length; i < l; i ++ ) {

    var face = faces[ i ];

    for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

      geometry.vertices.push( new THREE.Vector3() );
      geometry.vertices.push( new THREE.Vector3() );

    }

  }

  THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

  this.matrixAutoUpdate = false;

  this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexTangentsHelper.prototype.constructor = THREE.VertexTangentsHelper;

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

  var v1 = new THREE.Vector3();

  return function( object ) {

    var keys = [ 'a', 'b', 'c', 'd' ];

    this.object.updateMatrixWorld( true );

    var vertices = this.geometry.vertices;

    var verts = this.object.geometry.vertices;

    var faces = this.object.geometry.faces;

    var worldMatrix = this.object.matrixWorld;

    var idx = 0;

    for ( var i = 0, l = faces.length; i < l; i ++ ) {

      var face = faces[ i ];

      for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

        var vertexId = face[ keys[ j ] ];
        var vertex = verts[ vertexId ];

        var tangent = face.vertexTangents[ j ];

        vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

        v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

        v1.add( vertices[ idx ] );
        idx = idx + 1;

        vertices[ idx ].copy( v1 );
        idx = idx + 1;

      }

    }

    this.geometry.verticesNeedUpdate = true;

    return this;

  }

}());

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

  var color = ( hex !== undefined ) ? hex : 0xffffff;

  THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

  this.matrix = object.matrixWorld;
  this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

  THREE.Object3D.call( this );

  this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

  THREE.Mesh.call( this, geometry, material );

  this.animationsMap = {};
  this.animationsList = [];

  // prepare default animation
  // (all frames played together in 1 second)

  var numFrames = this.geometry.morphTargets.length;

  var name = "__default";

  var startFrame = 0;
  var endFrame = numFrames - 1;

  var fps = numFrames / 1;

  this.createAnimation( name, startFrame, endFrame, fps );
  this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

  var animation = {

    startFrame: start,
    endFrame: end,

    length: end - start + 1,

    fps: fps,
    duration: ( end - start ) / fps,

    lastFrame: 0,
    currentFrame: 0,

    active: false,

    time: 0,
    direction: 1,
    weight: 1,

    directionBackwards: false,
    mirroredLoop: false

  };

  this.animationsMap[ name ] = animation;
  this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

  var pattern = /([a-z]+)_?(\d+)/;

  var firstAnimation, frameRanges = {};

  var geometry = this.geometry;

  for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

    var morph = geometry.morphTargets[ i ];
    var chunks = morph.name.match( pattern );

    if ( chunks && chunks.length > 1 ) {

      var name = chunks[ 1 ];

      if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

      var range = frameRanges[ name ];

      if ( i < range.start ) range.start = i;
      if ( i > range.end ) range.end = i;

      if ( ! firstAnimation ) firstAnimation = name;

    }

  }

  for ( var name in frameRanges ) {

    var range = frameRanges[ name ];
    this.createAnimation( name, range.start, range.end, fps );

  }

  this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = 1;
    animation.directionBackwards = false;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.direction = - 1;
    animation.directionBackwards = true;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.fps = fps;
    animation.duration = ( animation.end - animation.start ) / animation.fps;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.duration = duration;
    animation.fps = ( animation.end - animation.start ) / animation.duration;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.weight = weight;

  }

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = time;

  }

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

  var time = 0;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    time = animation.time;

  }

  return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

  var duration = - 1;

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    duration = animation.duration;

  }

  return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.time = 0;
    animation.active = true;

  } else {

    console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

  }

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

  var animation = this.animationsMap[ name ];

  if ( animation ) {

    animation.active = false;

  }

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

  for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

    var animation = this.animationsList[ i ];

    if ( ! animation.active ) continue;

    var frameTime = animation.duration / animation.length;

    animation.time += animation.direction * delta;

    if ( animation.mirroredLoop ) {

      if ( animation.time > animation.duration || animation.time < 0 ) {

        animation.direction *= - 1;

        if ( animation.time > animation.duration ) {

          animation.time = animation.duration;
          animation.directionBackwards = true;

        }

        if ( animation.time < 0 ) {

          animation.time = 0;
          animation.directionBackwards = false;

        }

      }

    } else {

      animation.time = animation.time % animation.duration;

      if ( animation.time < 0 ) animation.time += animation.duration;

    }

    var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
    var weight = animation.weight;

    if ( keyframe !== animation.currentFrame ) {

      this.morphTargetInfluences[ animation.lastFrame ] = 0;
      this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

      this.morphTargetInfluences[ keyframe ] = 0;

      animation.lastFrame = animation.currentFrame;
      animation.currentFrame = keyframe;

    }

    var mix = ( animation.time % frameTime ) / frameTime;

    if ( animation.directionBackwards ) mix = 1 - mix;

    this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
    this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

  }

};


 /* globals define */
 (function(define){'use strict';define(function(require,exports,module){

function fovToNDCScaleOffset( fov ) {

    var pxscale = 2.0 / (fov.leftTan + fov.rightTan);
    var pxoffset = (fov.leftTan - fov.rightTan) * pxscale * 0.5;
    var pyscale = 2.0 / (fov.upTan + fov.downTan);
    var pyoffset = (fov.upTan - fov.downTan) * pyscale * 0.5;
    return { scale: [ pxscale, pyscale ], offset: [ pxoffset, pyoffset ] };

  }

  function fovPortToProjection( fov, rightHanded, zNear, zFar ) {

    rightHanded = rightHanded === undefined ? true : rightHanded;
    zNear = zNear === undefined ? 0.01 : zNear;
    zFar = zFar === undefined ? 10000.0 : zFar;

    var handednessScale = rightHanded ? -1.0 : 1.0;

    // start with an identity matrix
    var mobj = new THREE.Matrix4();
    var m = mobj.elements;

    // and with scale/offset info for normalized device coords
    var scaleAndOffset = fovToNDCScaleOffset(fov);

    // X result, map clip edges to [-w,+w]
    m[0 * 4 + 0] = scaleAndOffset.scale[0];
    m[0 * 4 + 1] = 0.0;
    m[0 * 4 + 2] = scaleAndOffset.offset[0] * handednessScale;
    m[0 * 4 + 3] = 0.0;

    // Y result, map clip edges to [-w,+w]
    // Y offset is negated because this proj matrix transforms from world coords with Y=up,
    // but the NDC scaling has Y=down (thanks D3D?)
    m[1 * 4 + 0] = 0.0;
    m[1 * 4 + 1] = scaleAndOffset.scale[1];
    m[1 * 4 + 2] = -scaleAndOffset.offset[1] * handednessScale;
    m[1 * 4 + 3] = 0.0;

    // Z result (up to the app)
    m[2 * 4 + 0] = 0.0;
    m[2 * 4 + 1] = 0.0;
    m[2 * 4 + 2] = zFar / (zNear - zFar) * -handednessScale;
    m[2 * 4 + 3] = (zFar * zNear) / (zNear - zFar);

    // W result (= Z in)
    m[3 * 4 + 0] = 0.0;
    m[3 * 4 + 1] = 0.0;
    m[3 * 4 + 2] = handednessScale;
    m[3 * 4 + 3] = 0.0;

    mobj.transpose();

    return mobj;
  }

  function fovToProjection( fov, rightHanded, zNear, zFar ) {

    var DEG2RAD = Math.PI / 180.0;

    var fovPort = {
      upTan: Math.tan( fov.upDegrees * DEG2RAD ),
      downTan: Math.tan( fov.downDegrees * DEG2RAD ),
      leftTan: Math.tan( fov.leftDegrees * DEG2RAD ),
      rightTan: Math.tan( fov.rightDegrees * DEG2RAD )
    };

    return fovPortToProjection( fovPort, rightHanded, zNear, zFar );

  }

  module.exports = {
    fovToProjection: fovToProjection
  };

  });})(typeof define=='function'&&define.amd?define
:(function(n,w){'use strict';return typeof module=='object'?function(c){
c(require,exports,module);}:function(c){var m={exports:{}};c(function(n){
return w[n];},m.exports,m);w[n]=m.exports;};})('VRPerspective',this));

 /* globals define */
 (function(define){'use strict';define(function(require,exports,module){

    var vrDevices = {};
    var viewport;
    var scene = document.querySelector('#scene');
    var world;
    var camera;
    var fullscreen = false;
    var projectionTransform;
    var fov;
    var fullscreenButton = document.createElement('button');
    var x = 0;
    var y = 0;
    var z = 0;
    var rotX = 0;
    var rotY = 0;
    var rotZ = 0;
    var translation = new THREE.Matrix4();
    var rotation;
    var rotationEuler = THREE.Euler(0, 0, 0, "YXZ");
    var requestAnimationFrameID;

    setupVRDevices(function() {
      // Creates viewport, camera and world elements
      setupScene();
      // Initiates the camera perspective matrix
      setupPerspective();
      // It inserts a button on the top left corner
      // to request fullscreen
      setupFullscreenButton();
      // For mouse look mode when there's no HMD avaialable
      setupInputEventHandlers();
      setupFullscreenHandlers();
      // Function that updates the camera orientation from HMD information
      requestAnimationFrameID = window.requestAnimationFrame(updateCamera);
    });

    function setupVRDevices(done) {
      if (navigator.getVRDevices && navigator.getVRDevices().then) {
        navigator.getVRDevices().then(gotVRDevices);
      } else { done(); }
      function gotVRDevices(devices) {
          var i;
          for (var i = 0; i < devices.length; ++i) {
            if (devices[i] instanceof HMDVRDevice) {
              vrDevices.headset = devices[i];
              continue;
            }
            if (devices[i] instanceof PositionSensorVRDevice) {
              vrDevices.position = devices[i];
            }
            if (vrDevices.headset && vrDevices.position) { break; }
          }
          done();
      }
    }

    function setupFullscreenButton() {
      fullscreenButton = document.createElement('button');
      fullscreenButton.classList.add('fullscreen-button');
      fullscreenButton.innerHTML = 'Fullscreen';
      document.body.appendChild(fullscreenButton);
      var requestFullScreen = scene.mozRequestFullScreen || scene.webkitRequestFullscreen;
      fullscreenButton.addEventListener('click', function() {
        requestFullScreen.call(scene, { vrDisplay: vrDevices.headset });
      });
    }

    function setupPerspective() {
      fov = vrDevices.headset? vrDevices.headset.getEyeParameters('left').recommendedFieldOfView : { upDegrees: 45, rightDegrees: 45, downDegrees: 45, leftDegrees: 45 };
      //var perspective = VRPerspective.fovToProjection( fov, true, 1, 10000 );
      var perspective = perspectiveMatrix(THREE.Math.degToRad(fov.upDegrees), viewport.offsetWidth / viewport.offsetHeight, 1, 10000);
      perspective = perspective.clone().scale(new THREE.Vector3(viewport.offsetWidth, viewport.offsetHeight, 1));
      projectionTransform = getCSSMatrix(perspective);
      viewport.style.transform = projectionTransform;
    }

    function setupScene() {
      var i;
      var vrEls = scene.children;
      var vrElsLength = vrEls.length;
      viewport = document.createElement('div');
      viewport.classList.add('viewport');
      camera = document.createElement('div');
      camera.classList.add('vr');
      camera.classList.add('camera');
      world = document.createElement('div');
      world.classList.add('vr');
      world.classList.add('world');

      // Setup Hierarchy
      // scene
      //   viewport
      //      camera
      //        world
      //          user-elements
      for(i = 0; i < vrElsLength; ++i) {
        world.appendChild(vrEls[0]);
      }
      scene.appendChild(viewport);
      viewport.appendChild(camera);
      camera.appendChild(world);
    }

    function updateCamera() {
      var transform;
      if (fullscreen) {
        transform = 'translate3d(-50%, -50%, 0px)';
      } else {
        transform = projectionTransform;
      }
      pollHeadOrientation();
      viewport.style.transform = transform;
      window.requestAnimationFrame(updateCamera);
    }

    function pollHeadOrientation() {
      var orientation;
      var quaternion;
      var position
      var state;
      if (vrDevices.position) {
        state = vrDevices.position.getState()
        orientation = state.orientation;
        position = state.position;
        if (orientation) {
          quaternion = new THREE.Quaternion(orientation.x, -orientation.y, orientation.z, orientation.w);
          rotation = new THREE.Matrix4().makeRotationFromQuaternion(quaternion);
        }
        if (position) {
          translation = new THREE.Matrix4().makeTranslation(position.x , position.y , position.z);
        }
      }
      updateElement(camera, {
        rotation: rotation,
        translation: translation
      });
    }

    function setupFullscreenHandlers() {
      document.addEventListener("webkitfullscreenchange", onfullscreenchange);
      document.addEventListener("mozfullscreenchange",    onfullscreenchange);
      document.addEventListener("fullscreenchange",       onfullscreenchange);

      function onfullscreenchange() {
        if ( !document.mozFullScreenElement && !document.webkitFullScreenElement ) {
          viewport.classList.remove('fullscreen');
          fullscreen = false;
          return;
        }
        fullscreen = true;
        viewport.classList.add('fullscreen');
      }
    }

    function perspectiveMatrix(fov, aspect, nearz, farz) {
      var matrix = new THREE.Matrix4();
      var range = Math.tan(fov * 0.5) * nearz;

      matrix.elements[0] = (2 * nearz) / ((range * aspect) - (-range * aspect));
      matrix.elements[1] = 0;
      matrix.elements[2] = 0;
      matrix.elements[3] = 0;
      matrix.elements[4] = 0;
      matrix.elements[5] = (2 * nearz) / (2 * range);
      matrix.elements[6] = 0;
      matrix.elements[7] = 0;
      matrix.elements[8] = 0;
      matrix.elements[9] = 0;
      matrix.elements[10] = -(farz + nearz) / (farz - nearz);
      matrix.elements[11] = -1;
      matrix.elements[12] = 0;
      matrix.elements[13] = 0;
      matrix.elements[14] = -(2 * farz * nearz) / (farz - nearz);
      matrix.elements[15] = 0;
      return matrix.transpose();
    };

    function getCSSMatrix(matrix) {
      var elements = matrix.elements;

      return 'matrix3d(' +
        epsilon( elements[ 0 ] ) + ',' +
        epsilon( elements[ 1 ] ) + ',' +
        epsilon( elements[ 2 ] ) + ',' +
        epsilon( elements[ 3 ] ) + ',' +
        epsilon( elements[ 4 ] ) + ',' +
        epsilon( elements[ 5 ] ) + ',' +
        epsilon( elements[ 6 ] ) + ',' +
        epsilon( elements[ 7 ] ) + ',' +
        epsilon( elements[ 8 ] ) + ',' +
        epsilon( elements[ 9 ] ) + ',' +
        epsilon( elements[ 10 ] ) + ',' +
        epsilon( elements[ 11 ] ) + ',' +
        epsilon( elements[ 12 ] ) + ',' +
        epsilon( elements[ 13 ] ) + ',' +
        epsilon( elements[ 14 ] ) + ',' +
        epsilon( elements[ 15 ] ) +
      ')';
    };

    function epsilon( value ) {
      return Math.abs( value ) < 0.000001 ? 0 : value;
    };

    var rotationEnabled;
    var lastMouseX;
    var lastMouseY;
    var PI_2 = Math.PI / 2;
    var cameraRotation;
    var cameraTranslation;

    function setupInputEventHandlers() {
      scene.addEventListener('mousedown', function(event) {
        rotationEnabled = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
      }, true);

      scene.addEventListener('mouseup', function(event) {
        rotationEnabled = false;
      }, true);

      scene.addEventListener('mousemove', function(event) {
        if (!rotationEnabled) {
          return;
        }
        var deltaX = (event.clientX - lastMouseX) * 0.2;
        var deltaY = (event.clientY - lastMouseY) * 0.2;
        rotX += deltaX;
        rotY -= deltaY;
        // Clamp to [-PI / 2, PI / 2]
        rotY = Math.max( -90, Math.min( 90, rotY ) );

        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
        translation = new THREE.Matrix4().makeTranslation(x , y , z);
        rotationEuler = new THREE.Euler(
          THREE.Math.degToRad(rotY),
          THREE.Math.degToRad(rotX),
          THREE.Math.degToRad(rotZ),
          "XYZ" );
        rotation = new THREE.Matrix4().makeRotationFromEuler(rotationEuler);

      }, true);

      document.documentElement.addEventListener('keydown', function (e) {
          if ( ( e.keycode || e.which ) == 32) {
              e.preventDefault();
          }
      }, false);

    }

    var updateElement = function(object, data) {
      var translation = data.translation.clone() || new THREE.Matrix4();
      var rotation = data.rotation || new THREE.Matrix4();
      object.style.transform = "translate3d(-50%, -50%, 0px) " + getCSSMatrix(translation.multiply(rotation));
    };

    module.exports = {
      zeroSensor: function () {
        rotX = 0;
        rotY = 0;
        rotation = new THREE.Matrix4();
        translation = new THREE.Matrix4();
        if (vrDevices.position) { vrDevices.position.resetSensor(); }
      }
    };

});})(typeof define=='function'&&define.amd?define
:(function(n,w){'use strict';return typeof module=='object'?function(c){
c(require,exports,module);}:function(c){var m={exports:{}};c(function(n){
return w[n];},m.exports,m);w[n]=m.exports;};})('VRCSS',this));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRocmVlLmpzIiwicGVyc3BlY3RpdmUuanMiLCJjc3N2ci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNsaWtDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJjc3N2ci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGU6c3JjL1RocmVlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG52YXIgVEhSRUUgPSB7IFJFVklTSU9OOiAnNzJkZXYnIH07XG5cbi8vIGJyb3dzZXJpZnkgc3VwcG9ydFxuXG5pZiAoIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICkge1xuXG4gIG1vZHVsZS5leHBvcnRzID0gVEhSRUU7XG5cbn1cblxuLy8gcG9seWZpbGxzXG5cbmlmICggTWF0aC5zaWduID09PSB1bmRlZmluZWQgKSB7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXG5cbiAgTWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgcmV0dXJuICggeCA8IDAgKSA/IC0gMSA6ICggeCA+IDAgKSA/IDEgOiAreDtcblxuICB9O1xuXG59XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50LmJ1dHRvblxuXG5USFJFRS5NT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xuXG4vLyBHTCBTVEFURSBDT05TVEFOVFNcblxuVEhSRUUuQ3VsbEZhY2VOb25lID0gMDtcblRIUkVFLkN1bGxGYWNlQmFjayA9IDE7XG5USFJFRS5DdWxsRmFjZUZyb250ID0gMjtcblRIUkVFLkN1bGxGYWNlRnJvbnRCYWNrID0gMztcblxuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgPSAwO1xuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gMTtcblxuLy8gU0hBRE9XSU5HIFRZUEVTXG5cblRIUkVFLkJhc2ljU2hhZG93TWFwID0gMDtcblRIUkVFLlBDRlNoYWRvd01hcCA9IDE7XG5USFJFRS5QQ0ZTb2Z0U2hhZG93TWFwID0gMjtcblxuLy8gTUFURVJJQUwgQ09OU1RBTlRTXG5cbi8vIHNpZGVcblxuVEhSRUUuRnJvbnRTaWRlID0gMDtcblRIUkVFLkJhY2tTaWRlID0gMTtcblRIUkVFLkRvdWJsZVNpZGUgPSAyO1xuXG4vLyBzaGFkaW5nXG5cblRIUkVFLk5vU2hhZGluZyA9IDA7XG5USFJFRS5GbGF0U2hhZGluZyA9IDE7XG5USFJFRS5TbW9vdGhTaGFkaW5nID0gMjtcblxuLy8gY29sb3JzXG5cblRIUkVFLk5vQ29sb3JzID0gMDtcblRIUkVFLkZhY2VDb2xvcnMgPSAxO1xuVEhSRUUuVmVydGV4Q29sb3JzID0gMjtcblxuLy8gYmxlbmRpbmcgbW9kZXNcblxuVEhSRUUuTm9CbGVuZGluZyA9IDA7XG5USFJFRS5Ob3JtYWxCbGVuZGluZyA9IDE7XG5USFJFRS5BZGRpdGl2ZUJsZW5kaW5nID0gMjtcblRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xuVEhSRUUuTXVsdGlwbHlCbGVuZGluZyA9IDQ7XG5USFJFRS5DdXN0b21CbGVuZGluZyA9IDU7XG5cbi8vIGN1c3RvbSBibGVuZGluZyBlcXVhdGlvbnNcbi8vIChudW1iZXJzIHN0YXJ0IGZyb20gMTAwIG5vdCB0byBjbGFzaCB3aXRoIG90aGVyXG4vLyAgbWFwcGluZ3MgdG8gT3BlbkdMIGNvbnN0YW50cyBkZWZpbmVkIGluIFRleHR1cmUuanMpXG5cblRIUkVFLkFkZEVxdWF0aW9uID0gMTAwO1xuVEhSRUUuU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcblRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xuVEhSRUUuTWluRXF1YXRpb24gPSAxMDM7XG5USFJFRS5NYXhFcXVhdGlvbiA9IDEwNDtcblxuLy8gY3VzdG9tIGJsZW5kaW5nIGRlc3RpbmF0aW9uIGZhY3RvcnNcblxuVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcblRIUkVFLk9uZUZhY3RvciA9IDIwMTtcblRIUkVFLlNyY0NvbG9yRmFjdG9yID0gMjAyO1xuVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcblRIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xuVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcblRIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xuVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcblxuLy8gY3VzdG9tIGJsZW5kaW5nIHNvdXJjZSBmYWN0b3JzXG5cbi8vVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcbi8vVEhSRUUuT25lRmFjdG9yID0gMjAxO1xuLy9USFJFRS5TcmNBbHBoYUZhY3RvciA9IDIwNDtcbi8vVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IDIwNTtcbi8vVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XG4vL1RIUkVFLk9uZU1pbnVzRHN0QWxwaGFGYWN0b3IgPSAyMDc7XG5USFJFRS5Ec3RDb2xvckZhY3RvciA9IDIwODtcblRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XG5USFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gMjEwO1xuXG4vLyBkZXB0aCBtb2Rlc1xuXG5USFJFRS5OZXZlckRlcHRoID0gMDtcblRIUkVFLkFsd2F5c0RlcHRoID0gMTtcblRIUkVFLkxlc3NEZXB0aCA9IDI7XG5USFJFRS5MZXNzRXF1YWxEZXB0aCA9IDM7XG5USFJFRS5FcXVhbERlcHRoID0gNDtcblRIUkVFLkdyZWF0ZXJFcXVhbERlcHRoID0gNTtcblRIUkVFLkdyZWF0ZXJEZXB0aCA9IDY7XG5USFJFRS5Ob3RFcXVhbERlcHRoID0gNztcblxuXG4vLyBURVhUVVJFIENPTlNUQU5UU1xuXG5USFJFRS5NdWx0aXBseU9wZXJhdGlvbiA9IDA7XG5USFJFRS5NaXhPcGVyYXRpb24gPSAxO1xuVEhSRUUuQWRkT3BlcmF0aW9uID0gMjtcblxuLy8gTWFwcGluZyBtb2Rlc1xuXG5USFJFRS5VVk1hcHBpbmcgPSAzMDA7XG5cblRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZyA9IDMwMTtcblRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcblxuVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XG5USFJFRS5FcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZyA9IDMwNDtcblxuVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDU7XG5cbi8vIFdyYXBwaW5nIG1vZGVzXG5cblRIUkVFLlJlcGVhdFdyYXBwaW5nID0gMTAwMDtcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xuVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyA9IDEwMDI7XG5cbi8vIEZpbHRlcnNcblxuVEhSRUUuTmVhcmVzdEZpbHRlciA9IDEwMDM7XG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XG5USFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyID0gMTAwNTtcblRIUkVFLkxpbmVhckZpbHRlciA9IDEwMDY7XG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcblRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IDEwMDg7XG5cbi8vIERhdGEgdHlwZXNcblxuVEhSRUUuVW5zaWduZWRCeXRlVHlwZSA9IDEwMDk7XG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XG5USFJFRS5TaG9ydFR5cGUgPSAxMDExO1xuVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgPSAxMDEyO1xuVEhSRUUuSW50VHlwZSA9IDEwMTM7XG5USFJFRS5VbnNpZ25lZEludFR5cGUgPSAxMDE0O1xuVEhSRUUuRmxvYXRUeXBlID0gMTAxNTtcblRIUkVFLkhhbGZGbG9hdFR5cGUgPSAxMDI1O1xuXG4vLyBQaXhlbCB0eXBlc1xuXG4vL1RIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xuVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNjtcblRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSA9IDEwMTc7XG5USFJFRS5VbnNpZ25lZFNob3J0NTY1VHlwZSA9IDEwMTg7XG5cbi8vIFBpeGVsIGZvcm1hdHNcblxuVEhSRUUuQWxwaGFGb3JtYXQgPSAxMDE5O1xuVEhSRUUuUkdCRm9ybWF0ID0gMTAyMDtcblRIUkVFLlJHQkFGb3JtYXQgPSAxMDIxO1xuVEhSRUUuTHVtaW5hbmNlRm9ybWF0ID0gMTAyMjtcblRIUkVFLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gMTAyMztcbi8vIFRIUkVFLlJHQkVGb3JtYXQgaGFuZGxlZCBhcyBUSFJFRS5SR0JBRm9ybWF0IGluIHNoYWRlcnNcblRIUkVFLlJHQkVGb3JtYXQgPSBUSFJFRS5SR0JBRm9ybWF0OyAvLzEwMjQ7XG5cbi8vIEREUyAvIFNUM0MgQ29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcblxuVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgPSAyMDAxO1xuVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMjtcblRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCA9IDIwMDM7XG5USFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgPSAyMDA0O1xuXG5cbi8vIFBWUlRDIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXRzXG5cblRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ID0gMjEwMDtcblRIUkVFLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gMjEwMTtcblRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XG5USFJFRS5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSAyMTAzO1xuXG5cbi8vIERFUFJFQ0FURURcblxuVEhSRUUuUHJvamVjdG9yID0gZnVuY3Rpb24gKCkge1xuXG4gIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3IgaGFzIGJlZW4gbW92ZWQgdG8gL2V4YW1wbGVzL2pzL3JlbmRlcmVycy9Qcm9qZWN0b3IuanMuJyApO1xuXG4gIHRoaXMucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Qcm9qZWN0b3I6IC5wcm9qZWN0VmVjdG9yKCkgaXMgbm93IHZlY3Rvci5wcm9qZWN0KCkuJyApO1xuICAgIHZlY3Rvci5wcm9qZWN0KCBjYW1lcmEgKTtcblxuICB9O1xuXG4gIHRoaXMudW5wcm9qZWN0VmVjdG9yID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnVucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IudW5wcm9qZWN0KCkuJyApO1xuICAgIHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xuXG4gIH07XG5cbiAgdGhpcy5waWNraW5nUmF5ID0gZnVuY3Rpb24gKCB2ZWN0b3IsIGNhbWVyYSApIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xuXG4gIH07XG5cbn07XG5cblRIUkVFLkNhbnZhc1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuXG4gIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5DYW52YXNSZW5kZXJlciBoYXMgYmVlbiBtb3ZlZCB0byAvZXhhbXBsZXMvanMvcmVuZGVyZXJzL0NhbnZhc1JlbmRlcmVyLmpzJyApO1xuXG4gIHRoaXMuZG9tRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gIHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7fTtcbiAgdGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge307XG4gIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL0NvbG9yLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Db2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgaWYgKCBhcmd1bWVudHMubGVuZ3RoID09PSAzICkge1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0UkdCKCBhcmd1bWVudHNbIDAgXSwgYXJndW1lbnRzWyAxIF0sIGFyZ3VtZW50c1sgMiBdICk7XG5cbiAgfVxuXG4gIHJldHVybiB0aGlzLnNldCggY29sb3IgKVxuXG59O1xuXG5USFJFRS5Db2xvci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkNvbG9yLFxuXG4gIHI6IDEsIGc6IDEsIGI6IDEsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgaWYgKCB2YWx1ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkge1xuXG4gICAgICB0aGlzLmNvcHkoIHZhbHVlICk7XG5cbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xuXG4gICAgICB0aGlzLnNldEhleCggdmFsdWUgKTtcblxuICAgIH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cbiAgICAgIHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEhleDogZnVuY3Rpb24gKCBoZXggKSB7XG5cbiAgICBoZXggPSBNYXRoLmZsb29yKCBoZXggKTtcblxuICAgIHRoaXMuciA9ICggaGV4ID4+IDE2ICYgMjU1ICkgLyAyNTU7XG4gICAgdGhpcy5nID0gKCBoZXggPj4gOCAmIDI1NSApIC8gMjU1O1xuICAgIHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFJHQjogZnVuY3Rpb24gKCByLCBnLCBiICkge1xuXG4gICAgdGhpcy5yID0gcjtcbiAgICB0aGlzLmcgPSBnO1xuICAgIHRoaXMuYiA9IGI7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xuXG4gICAgLy8gaCxzLGwgcmFuZ2VzIGFyZSBpbiAwLjAgLSAxLjBcblxuICAgIGlmICggcyA9PT0gMCApIHtcblxuICAgICAgdGhpcy5yID0gdGhpcy5nID0gdGhpcy5iID0gbDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciBodWUycmdiID0gZnVuY3Rpb24gKCBwLCBxLCB0ICkge1xuXG4gICAgICAgIGlmICggdCA8IDAgKSB0ICs9IDE7XG4gICAgICAgIGlmICggdCA+IDEgKSB0IC09IDE7XG4gICAgICAgIGlmICggdCA8IDEgLyA2ICkgcmV0dXJuIHAgKyAoIHEgLSBwICkgKiA2ICogdDtcbiAgICAgICAgaWYgKCB0IDwgMSAvIDIgKSByZXR1cm4gcTtcbiAgICAgICAgaWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xuICAgICAgICByZXR1cm4gcDtcblxuICAgICAgfTtcblxuICAgICAgdmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcbiAgICAgIHZhciBxID0gKCAyICogbCApIC0gcDtcblxuICAgICAgdGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XG4gICAgICB0aGlzLmcgPSBodWUycmdiKCBxLCBwLCBoICk7XG4gICAgICB0aGlzLmIgPSBodWUycmdiKCBxLCBwLCBoIC0gMSAvIDMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0U3R5bGU6IGZ1bmN0aW9uICggc3R5bGUgKSB7XG5cbiAgICAvLyByZ2IoMjU1LDAsMClcblxuICAgIGlmICggL15yZ2JcXCgoXFxkKyksID8oXFxkKyksID8oXFxkKylcXCkkL2kudGVzdCggc3R5bGUgKSApIHtcblxuICAgICAgdmFyIGNvbG9yID0gL15yZ2JcXCgoXFxkKyksID8oXFxkKyksID8oXFxkKylcXCkkL2kuZXhlYyggc3R5bGUgKTtcblxuICAgICAgdGhpcy5yID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDI1NTtcbiAgICAgIHRoaXMuZyA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMiBdLCAxMCApICkgLyAyNTU7XG4gICAgICB0aGlzLmIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMjU1O1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIC8vIHJnYigxMDAlLDAlLDAlKVxuXG4gICAgaWYgKCAvXnJnYlxcKChcXGQrKVxcJSwgPyhcXGQrKVxcJSwgPyhcXGQrKVxcJVxcKSQvaS50ZXN0KCBzdHlsZSApICkge1xuXG4gICAgICB2YXIgY29sb3IgPSAvXnJnYlxcKChcXGQrKVxcJSwgPyhcXGQrKVxcJSwgPyhcXGQrKVxcJVxcKSQvaS5leGVjKCBzdHlsZSApO1xuXG4gICAgICB0aGlzLnIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMTAwO1xuICAgICAgdGhpcy5nID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMDtcbiAgICAgIHRoaXMuYiA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApICkgLyAxMDA7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgLy8gI2ZmMDAwMFxuXG4gICAgaWYgKCAvXlxcIyhbMC05YS1mXXs2fSkkL2kudGVzdCggc3R5bGUgKSApIHtcblxuICAgICAgdmFyIGNvbG9yID0gL15cXCMoWzAtOWEtZl17Nn0pJC9pLmV4ZWMoIHN0eWxlICk7XG5cbiAgICAgIHRoaXMuc2V0SGV4KCBwYXJzZUludCggY29sb3JbIDEgXSwgMTYgKSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIC8vICNmMDBcblxuICAgIGlmICggL15cXCMoWzAtOWEtZl0pKFswLTlhLWZdKShbMC05YS1mXSkkL2kudGVzdCggc3R5bGUgKSApIHtcblxuICAgICAgdmFyIGNvbG9yID0gL15cXCMoWzAtOWEtZl0pKFswLTlhLWZdKShbMC05YS1mXSkkL2kuZXhlYyggc3R5bGUgKTtcblxuICAgICAgdGhpcy5zZXRIZXgoIHBhcnNlSW50KCBjb2xvclsgMSBdICsgY29sb3JbIDEgXSArIGNvbG9yWyAyIF0gKyBjb2xvclsgMiBdICsgY29sb3JbIDMgXSArIGNvbG9yWyAzIF0sIDE2ICkgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICAvLyByZWRcblxuICAgIGlmICggL14oXFx3KykkL2kudGVzdCggc3R5bGUgKSApIHtcblxuICAgICAgdGhpcy5zZXRIZXgoIFRIUkVFLkNvbG9yS2V5d29yZHNbIHN0eWxlIF0gKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgICB0aGlzLnIgPSBjb2xvci5yO1xuICAgIHRoaXMuZyA9IGNvbG9yLmc7XG4gICAgdGhpcy5iID0gY29sb3IuYjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG4gICAgaWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cbiAgICB0aGlzLnIgPSBNYXRoLnBvdyggY29sb3IuciwgZ2FtbWFGYWN0b3IgKTtcbiAgICB0aGlzLmcgPSBNYXRoLnBvdyggY29sb3IuZywgZ2FtbWFGYWN0b3IgKTtcbiAgICB0aGlzLmIgPSBNYXRoLnBvdyggY29sb3IuYiwgZ2FtbWFGYWN0b3IgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xuXG4gICAgaWYgKCBnYW1tYUZhY3RvciA9PT0gdW5kZWZpbmVkICkgZ2FtbWFGYWN0b3IgPSAyLjA7XG5cbiAgICB2YXIgc2FmZUludmVyc2UgPSAoIGdhbW1hRmFjdG9yID4gMCApID8gKCAxLjAgLyBnYW1tYUZhY3RvciApIDogMS4wO1xuXG4gICAgdGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XG4gICAgdGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIHNhZmVJbnZlcnNlICk7XG4gICAgdGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIHNhZmVJbnZlcnNlICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuICAgIHRoaXMuciA9IHIgKiByO1xuICAgIHRoaXMuZyA9IGcgKiBnO1xuICAgIHRoaXMuYiA9IGIgKiBiO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5yID0gTWF0aC5zcXJ0KCB0aGlzLnIgKTtcbiAgICB0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xuICAgIHRoaXMuYiA9IE1hdGguc3FydCggdGhpcy5iICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldEhleDogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiAoIHRoaXMuYiAqIDI1NSApIDw8IDA7XG5cbiAgfSxcblxuICBnZXRIZXhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcblxuICB9LFxuXG4gIGdldEhTTDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXG5cbiAgICB2YXIgaHNsID0gb3B0aW9uYWxUYXJnZXQgfHwgeyBoOiAwLCBzOiAwLCBsOiAwIH07XG5cbiAgICB2YXIgciA9IHRoaXMuciwgZyA9IHRoaXMuZywgYiA9IHRoaXMuYjtcblxuICAgIHZhciBtYXggPSBNYXRoLm1heCggciwgZywgYiApO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xuXG4gICAgdmFyIGh1ZSwgc2F0dXJhdGlvbjtcbiAgICB2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcblxuICAgIGlmICggbWluID09PSBtYXggKSB7XG5cbiAgICAgIGh1ZSA9IDA7XG4gICAgICBzYXR1cmF0aW9uID0gMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciBkZWx0YSA9IG1heCAtIG1pbjtcblxuICAgICAgc2F0dXJhdGlvbiA9IGxpZ2h0bmVzcyA8PSAwLjUgPyBkZWx0YSAvICggbWF4ICsgbWluICkgOiBkZWx0YSAvICggMiAtIG1heCAtIG1pbiApO1xuXG4gICAgICBzd2l0Y2ggKCBtYXggKSB7XG5cbiAgICAgICAgY2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcbiAgICAgICAgY2FzZSBnOiBodWUgPSAoIGIgLSByICkgLyBkZWx0YSArIDI7IGJyZWFrO1xuICAgICAgICBjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XG5cbiAgICAgIH1cblxuICAgICAgaHVlIC89IDY7XG5cbiAgICB9XG5cbiAgICBoc2wuaCA9IGh1ZTtcbiAgICBoc2wucyA9IHNhdHVyYXRpb247XG4gICAgaHNsLmwgPSBsaWdodG5lc3M7XG5cbiAgICByZXR1cm4gaHNsO1xuXG4gIH0sXG5cbiAgZ2V0U3R5bGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XG5cbiAgfSxcblxuICBvZmZzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcblxuICAgIHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xuXG4gICAgaHNsLmggKz0gaDsgaHNsLnMgKz0gczsgaHNsLmwgKz0gbDtcblxuICAgIHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24gKCBjb2xvciApIHtcblxuICAgIHRoaXMuciArPSBjb2xvci5yO1xuICAgIHRoaXMuZyArPSBjb2xvci5nO1xuICAgIHRoaXMuYiArPSBjb2xvci5iO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhZGRDb2xvcnM6IGZ1bmN0aW9uICggY29sb3IxLCBjb2xvcjIgKSB7XG5cbiAgICB0aGlzLnIgPSBjb2xvcjEuciArIGNvbG9yMi5yO1xuICAgIHRoaXMuZyA9IGNvbG9yMS5nICsgY29sb3IyLmc7XG4gICAgdGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnIgKz0gcztcbiAgICB0aGlzLmcgKz0gcztcbiAgICB0aGlzLmIgKz0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgICB0aGlzLnIgKj0gY29sb3IucjtcbiAgICB0aGlzLmcgKj0gY29sb3IuZztcbiAgICB0aGlzLmIgKj0gY29sb3IuYjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIHRoaXMuciAqPSBzO1xuICAgIHRoaXMuZyAqPSBzO1xuICAgIHRoaXMuYiAqPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsZXJwOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcblxuICAgIHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xuICAgIHRoaXMuZyArPSAoIGNvbG9yLmcgLSB0aGlzLmcgKSAqIGFscGhhO1xuICAgIHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggYyApIHtcblxuICAgIHJldHVybiAoIGMuciA9PT0gdGhpcy5yICkgJiYgKCBjLmcgPT09IHRoaXMuZyApICYmICggYy5iID09PSB0aGlzLmIgKTtcblxuICB9LFxuXG4gIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuICAgIHRoaXMuciA9IGFycmF5WyAwIF07XG4gICAgdGhpcy5nID0gYXJyYXlbIDEgXTtcbiAgICB0aGlzLmIgPSBhcnJheVsgMiBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5yO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLmc7XG4gICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuYjtcblxuICAgIHJldHVybiBhcnJheTtcbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQiggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuQ29sb3JLZXl3b3JkcyA9IHsgJ2FsaWNlYmx1ZSc6IDB4RjBGOEZGLCAnYW50aXF1ZXdoaXRlJzogMHhGQUVCRDcsICdhcXVhJzogMHgwMEZGRkYsICdhcXVhbWFyaW5lJzogMHg3RkZGRDQsICdhenVyZSc6IDB4RjBGRkZGLFxuJ2JlaWdlJzogMHhGNUY1REMsICdiaXNxdWUnOiAweEZGRTRDNCwgJ2JsYWNrJzogMHgwMDAwMDAsICdibGFuY2hlZGFsbW9uZCc6IDB4RkZFQkNELCAnYmx1ZSc6IDB4MDAwMEZGLCAnYmx1ZXZpb2xldCc6IDB4OEEyQkUyLFxuJ2Jyb3duJzogMHhBNTJBMkEsICdidXJseXdvb2QnOiAweERFQjg4NywgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLCAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLCAnY2hvY29sYXRlJzogMHhEMjY5MUUsICdjb3JhbCc6IDB4RkY3RjUwLFxuJ2Nvcm5mbG93ZXJibHVlJzogMHg2NDk1RUQsICdjb3Juc2lsayc6IDB4RkZGOERDLCAnY3JpbXNvbic6IDB4REMxNDNDLCAnY3lhbic6IDB4MDBGRkZGLCAnZGFya2JsdWUnOiAweDAwMDA4QiwgJ2RhcmtjeWFuJzogMHgwMDhCOEIsXG4nZGFya2dvbGRlbnJvZCc6IDB4Qjg4NjBCLCAnZGFya2dyYXknOiAweEE5QTlBOSwgJ2RhcmtncmVlbic6IDB4MDA2NDAwLCAnZGFya2dyZXknOiAweEE5QTlBOSwgJ2RhcmtraGFraSc6IDB4QkRCNzZCLCAnZGFya21hZ2VudGEnOiAweDhCMDA4QixcbidkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLCAnZGFya29yYW5nZSc6IDB4RkY4QzAwLCAnZGFya29yY2hpZCc6IDB4OTkzMkNDLCAnZGFya3JlZCc6IDB4OEIwMDAwLCAnZGFya3NhbG1vbic6IDB4RTk5NjdBLCAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXG4nZGFya3NsYXRlYmx1ZSc6IDB4NDgzRDhCLCAnZGFya3NsYXRlZ3JheSc6IDB4MkY0RjRGLCAnZGFya3NsYXRlZ3JleSc6IDB4MkY0RjRGLCAnZGFya3R1cnF1b2lzZSc6IDB4MDBDRUQxLCAnZGFya3Zpb2xldCc6IDB4OTQwMEQzLFxuJ2RlZXBwaW5rJzogMHhGRjE0OTMsICdkZWVwc2t5Ymx1ZSc6IDB4MDBCRkZGLCAnZGltZ3JheSc6IDB4Njk2OTY5LCAnZGltZ3JleSc6IDB4Njk2OTY5LCAnZG9kZ2VyYmx1ZSc6IDB4MUU5MEZGLCAnZmlyZWJyaWNrJzogMHhCMjIyMjIsXG4nZmxvcmFsd2hpdGUnOiAweEZGRkFGMCwgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsICdmdWNoc2lhJzogMHhGRjAwRkYsICdnYWluc2Jvcm8nOiAweERDRENEQywgJ2dob3N0d2hpdGUnOiAweEY4RjhGRiwgJ2dvbGQnOiAweEZGRDcwMCxcbidnb2xkZW5yb2QnOiAweERBQTUyMCwgJ2dyYXknOiAweDgwODA4MCwgJ2dyZWVuJzogMHgwMDgwMDAsICdncmVlbnllbGxvdyc6IDB4QURGRjJGLCAnZ3JleSc6IDB4ODA4MDgwLCAnaG9uZXlkZXcnOiAweEYwRkZGMCwgJ2hvdHBpbmsnOiAweEZGNjlCNCxcbidpbmRpYW5yZWQnOiAweENENUM1QywgJ2luZGlnbyc6IDB4NEIwMDgyLCAnaXZvcnknOiAweEZGRkZGMCwgJ2toYWtpJzogMHhGMEU2OEMsICdsYXZlbmRlcic6IDB4RTZFNkZBLCAnbGF2ZW5kZXJibHVzaCc6IDB4RkZGMEY1LCAnbGF3bmdyZWVuJzogMHg3Q0ZDMDAsXG4nbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsICdsaWdodGJsdWUnOiAweEFERDhFNiwgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCwgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMiwgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxuJ2xpZ2h0Z3JlZW4nOiAweDkwRUU5MCwgJ2xpZ2h0Z3JleSc6IDB4RDNEM0QzLCAnbGlnaHRwaW5rJzogMHhGRkI2QzEsICdsaWdodHNhbG1vbic6IDB4RkZBMDdBLCAnbGlnaHRzZWFncmVlbic6IDB4MjBCMkFBLCAnbGlnaHRza3libHVlJzogMHg4N0NFRkEsXG4nbGlnaHRzbGF0ZWdyYXknOiAweDc3ODg5OSwgJ2xpZ2h0c2xhdGVncmV5JzogMHg3Nzg4OTksICdsaWdodHN0ZWVsYmx1ZSc6IDB4QjBDNERFLCAnbGlnaHR5ZWxsb3cnOiAweEZGRkZFMCwgJ2xpbWUnOiAweDAwRkYwMCwgJ2xpbWVncmVlbic6IDB4MzJDRDMyLFxuJ2xpbmVuJzogMHhGQUYwRTYsICdtYWdlbnRhJzogMHhGRjAwRkYsICdtYXJvb24nOiAweDgwMDAwMCwgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSwgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCwgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxuJ21lZGl1bXB1cnBsZSc6IDB4OTM3MERCLCAnbWVkaXVtc2VhZ3JlZW4nOiAweDNDQjM3MSwgJ21lZGl1bXNsYXRlYmx1ZSc6IDB4N0I2OEVFLCAnbWVkaXVtc3ByaW5nZ3JlZW4nOiAweDAwRkE5QSwgJ21lZGl1bXR1cnF1b2lzZSc6IDB4NDhEMUNDLFxuJ21lZGl1bXZpb2xldHJlZCc6IDB4QzcxNTg1LCAnbWlkbmlnaHRibHVlJzogMHgxOTE5NzAsICdtaW50Y3JlYW0nOiAweEY1RkZGQSwgJ21pc3R5cm9zZSc6IDB4RkZFNEUxLCAnbW9jY2FzaW4nOiAweEZGRTRCNSwgJ25hdmFqb3doaXRlJzogMHhGRkRFQUQsXG4nbmF2eSc6IDB4MDAwMDgwLCAnb2xkbGFjZSc6IDB4RkRGNUU2LCAnb2xpdmUnOiAweDgwODAwMCwgJ29saXZlZHJhYic6IDB4NkI4RTIzLCAnb3JhbmdlJzogMHhGRkE1MDAsICdvcmFuZ2VyZWQnOiAweEZGNDUwMCwgJ29yY2hpZCc6IDB4REE3MEQ2LFxuJ3BhbGVnb2xkZW5yb2QnOiAweEVFRThBQSwgJ3BhbGVncmVlbic6IDB4OThGQjk4LCAncGFsZXR1cnF1b2lzZSc6IDB4QUZFRUVFLCAncGFsZXZpb2xldHJlZCc6IDB4REI3MDkzLCAncGFwYXlhd2hpcCc6IDB4RkZFRkQ1LCAncGVhY2hwdWZmJzogMHhGRkRBQjksXG4ncGVydSc6IDB4Q0Q4NTNGLCAncGluayc6IDB4RkZDMENCLCAncGx1bSc6IDB4RERBMERELCAncG93ZGVyYmx1ZSc6IDB4QjBFMEU2LCAncHVycGxlJzogMHg4MDAwODAsICdyZWQnOiAweEZGMDAwMCwgJ3Jvc3licm93bic6IDB4QkM4RjhGLFxuJ3JveWFsYmx1ZSc6IDB4NDE2OUUxLCAnc2FkZGxlYnJvd24nOiAweDhCNDUxMywgJ3NhbG1vbic6IDB4RkE4MDcyLCAnc2FuZHlicm93bic6IDB4RjRBNDYwLCAnc2VhZ3JlZW4nOiAweDJFOEI1NywgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXG4nc2llbm5hJzogMHhBMDUyMkQsICdzaWx2ZXInOiAweEMwQzBDMCwgJ3NreWJsdWUnOiAweDg3Q0VFQiwgJ3NsYXRlYmx1ZSc6IDB4NkE1QUNELCAnc2xhdGVncmF5JzogMHg3MDgwOTAsICdzbGF0ZWdyZXknOiAweDcwODA5MCwgJ3Nub3cnOiAweEZGRkFGQSxcbidzcHJpbmdncmVlbic6IDB4MDBGRjdGLCAnc3RlZWxibHVlJzogMHg0NjgyQjQsICd0YW4nOiAweEQyQjQ4QywgJ3RlYWwnOiAweDAwODA4MCwgJ3RoaXN0bGUnOiAweEQ4QkZEOCwgJ3RvbWF0byc6IDB4RkY2MzQ3LCAndHVycXVvaXNlJzogMHg0MEUwRDAsXG4ndmlvbGV0JzogMHhFRTgyRUUsICd3aGVhdCc6IDB4RjVERUIzLCAnd2hpdGUnOiAweEZGRkZGRiwgJ3doaXRlc21va2UnOiAweEY1RjVGNSwgJ3llbGxvdyc6IDB4RkZGRjAwLCAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMiB9O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1F1YXRlcm5pb24uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUXVhdGVybmlvbiA9IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuICB0aGlzLl94ID0geCB8fCAwO1xuICB0aGlzLl95ID0geSB8fCAwO1xuICB0aGlzLl96ID0geiB8fCAwO1xuICB0aGlzLl93ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xuXG59O1xuXG5USFJFRS5RdWF0ZXJuaW9uLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuUXVhdGVybmlvbixcblxuICBfeDogMCxfeTogMCwgX3o6IDAsIF93OiAwLFxuXG4gIGdldCB4ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl94O1xuXG4gIH0sXG5cbiAgc2V0IHggKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCB5ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl95O1xuXG4gIH0sXG5cbiAgc2V0IHkgKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCB6ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl96O1xuXG4gIH0sXG5cbiAgc2V0IHogKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3ogPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCB3ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl93O1xuXG4gIH0sXG5cbiAgc2V0IHcgKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3cgPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgdGhpcy5feCA9IHg7XG4gICAgdGhpcy5feSA9IHk7XG4gICAgdGhpcy5feiA9IHo7XG4gICAgdGhpcy5fdyA9IHc7XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG4gICAgdGhpcy5feCA9IHF1YXRlcm5pb24ueDtcbiAgICB0aGlzLl95ID0gcXVhdGVybmlvbi55O1xuICAgIHRoaXMuX3ogPSBxdWF0ZXJuaW9uLno7XG4gICAgdGhpcy5fdyA9IHF1YXRlcm5pb24udztcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIsIHVwZGF0ZSApIHtcblxuICAgIGlmICggZXVsZXIgaW5zdGFuY2VvZiBUSFJFRS5FdWxlciA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuICAgIH1cblxuICAgIC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cbiAgICAvLyAgMjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXG4gICAgLy8gIGNvbnRlbnQvU3BpbkNhbGMubVxuXG4gICAgdmFyIGMxID0gTWF0aC5jb3MoIGV1bGVyLl94IC8gMiApO1xuICAgIHZhciBjMiA9IE1hdGguY29zKCBldWxlci5feSAvIDIgKTtcbiAgICB2YXIgYzMgPSBNYXRoLmNvcyggZXVsZXIuX3ogLyAyICk7XG4gICAgdmFyIHMxID0gTWF0aC5zaW4oIGV1bGVyLl94IC8gMiApO1xuICAgIHZhciBzMiA9IE1hdGguc2luKCBldWxlci5feSAvIDIgKTtcbiAgICB2YXIgczMgPSBNYXRoLnNpbiggZXVsZXIuX3ogLyAyICk7XG5cbiAgICBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcblxuICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVhaJyApIHtcblxuICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcblxuICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xuICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcblxuICAgICAgdGhpcy5feCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgIHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICB0aGlzLl96ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgdGhpcy5fdyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIH1cblxuICAgIGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxuXG4gICAgLy8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuICAgIHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsIHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XG5cbiAgICB0aGlzLl94ID0gYXhpcy54ICogcztcbiAgICB0aGlzLl95ID0gYXhpcy55ICogcztcbiAgICB0aGlzLl96ID0gYXhpcy56ICogcztcbiAgICB0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgLy8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cblxuICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICB2YXIgdGUgPSBtLmVsZW1lbnRzLFxuXG4gICAgICBtMTEgPSB0ZVsgMCBdLCBtMTIgPSB0ZVsgNCBdLCBtMTMgPSB0ZVsgOCBdLFxuICAgICAgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcbiAgICAgIG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdLFxuXG4gICAgICB0cmFjZSA9IG0xMSArIG0yMiArIG0zMyxcbiAgICAgIHM7XG5cbiAgICBpZiAoIHRyYWNlID4gMCApIHtcblxuICAgICAgcyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcblxuICAgICAgdGhpcy5fdyA9IDAuMjUgLyBzO1xuICAgICAgdGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xuICAgICAgdGhpcy5feSA9ICggbTEzIC0gbTMxICkgKiBzO1xuICAgICAgdGhpcy5feiA9ICggbTIxIC0gbTEyICkgKiBzO1xuXG4gICAgfSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcblxuICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTExIC0gbTIyIC0gbTMzICk7XG5cbiAgICAgIHRoaXMuX3cgPSAoIG0zMiAtIG0yMyApIC8gcztcbiAgICAgIHRoaXMuX3ggPSAwLjI1ICogcztcbiAgICAgIHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcbiAgICAgIHRoaXMuX3ogPSAoIG0xMyArIG0zMSApIC8gcztcblxuICAgIH0gZWxzZSBpZiAoIG0yMiA+IG0zMyApIHtcblxuICAgICAgcyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XG5cbiAgICAgIHRoaXMuX3cgPSAoIG0xMyAtIG0zMSApIC8gcztcbiAgICAgIHRoaXMuX3ggPSAoIG0xMiArIG0yMSApIC8gcztcbiAgICAgIHRoaXMuX3kgPSAwLjI1ICogcztcbiAgICAgIHRoaXMuX3ogPSAoIG0yMyArIG0zMiApIC8gcztcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xuXG4gICAgICB0aGlzLl93ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG4gICAgICB0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XG4gICAgICB0aGlzLl95ID0gKCBtMjMgKyBtMzIgKSAvIHM7XG4gICAgICB0aGlzLl96ID0gMC4yNSAqIHM7XG5cbiAgICB9XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBodHRwOi8vbG9sZW5naW5lLm5ldC9ibG9nLzIwMTQvMDIvMjQvcXVhdGVybmlvbi1mcm9tLXR3by12ZWN0b3JzLWZpbmFsXG5cbiAgICAvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcblxuICAgIHZhciB2MSwgcjtcblxuICAgIHZhciBFUFMgPSAwLjAwMDAwMTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHZGcm9tLCB2VG8gKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgciA9IHZGcm9tLmRvdCggdlRvICkgKyAxO1xuXG4gICAgICBpZiAoIHIgPCBFUFMgKSB7XG5cbiAgICAgICAgciA9IDA7XG5cbiAgICAgICAgaWYgKCBNYXRoLmFicyggdkZyb20ueCApID4gTWF0aC5hYnMoIHZGcm9tLnogKSApIHtcblxuICAgICAgICAgIHYxLnNldCggLSB2RnJvbS55LCB2RnJvbS54LCAwICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHYxLnNldCggMCwgLSB2RnJvbS56LCB2RnJvbS55ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHYxLmNyb3NzVmVjdG9ycyggdkZyb20sIHZUbyApO1xuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ggPSB2MS54O1xuICAgICAgdGhpcy5feSA9IHYxLnk7XG4gICAgICB0aGlzLl96ID0gdjEuejtcbiAgICAgIHRoaXMuX3cgPSByO1xuXG4gICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KCksXG5cbiAgaW52ZXJzZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29uanVnYXRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLl94ICo9IC0gMTtcbiAgICB0aGlzLl95ICo9IC0gMTtcbiAgICB0aGlzLl96ICo9IC0gMTtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiB0aGlzLl94ICogdi5feCArIHRoaXMuX3kgKiB2Ll95ICsgdGhpcy5feiAqIHYuX3ogKyB0aGlzLl93ICogdi5fdztcblxuICB9LFxuXG4gIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XG5cbiAgfSxcblxuICBsZW5ndGg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBNYXRoLnNxcnQoIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kgKyB0aGlzLl96ICogdGhpcy5feiArIHRoaXMuX3cgKiB0aGlzLl93ICk7XG5cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBsID0gdGhpcy5sZW5ndGgoKTtcblxuICAgIGlmICggbCA9PT0gMCApIHtcblxuICAgICAgdGhpcy5feCA9IDA7XG4gICAgICB0aGlzLl95ID0gMDtcbiAgICAgIHRoaXMuX3ogPSAwO1xuICAgICAgdGhpcy5fdyA9IDE7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBsID0gMSAvIGw7XG5cbiAgICAgIHRoaXMuX3ggPSB0aGlzLl94ICogbDtcbiAgICAgIHRoaXMuX3kgPSB0aGlzLl95ICogbDtcbiAgICAgIHRoaXMuX3ogPSB0aGlzLl96ICogbDtcbiAgICAgIHRoaXMuX3cgPSB0aGlzLl93ICogbDtcblxuICAgIH1cblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseTogZnVuY3Rpb24gKCBxLCBwICkge1xuXG4gICAgaWYgKCBwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlF1YXRlcm5pb246IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHAgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHRoaXMsIHEgKTtcblxuICB9LFxuXG4gIG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIC8vIGZyb20gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9jb2RlL2luZGV4Lmh0bVxuXG4gICAgdmFyIHFheCA9IGEuX3gsIHFheSA9IGEuX3ksIHFheiA9IGEuX3osIHFhdyA9IGEuX3c7XG4gICAgdmFyIHFieCA9IGIuX3gsIHFieSA9IGIuX3ksIHFieiA9IGIuX3osIHFidyA9IGIuX3c7XG5cbiAgICB0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xuICAgIHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XG4gICAgdGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcbiAgICB0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMgKTtcblxuICB9LFxuXG4gIHNsZXJwOiBmdW5jdGlvbiAoIHFiLCB0ICkge1xuXG4gICAgaWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcblxuICAgIHZhciB4ID0gdGhpcy5feCwgeSA9IHRoaXMuX3ksIHogPSB0aGlzLl96LCB3ID0gdGhpcy5fdztcblxuICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvc2xlcnAvXG5cbiAgICB2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xuXG4gICAgaWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xuXG4gICAgICB0aGlzLl93ID0gLSBxYi5fdztcbiAgICAgIHRoaXMuX3ggPSAtIHFiLl94O1xuICAgICAgdGhpcy5feSA9IC0gcWIuX3k7XG4gICAgICB0aGlzLl96ID0gLSBxYi5fejtcblxuICAgICAgY29zSGFsZlRoZXRhID0gLSBjb3NIYWxmVGhldGE7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB0aGlzLmNvcHkoIHFiICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGNvc0hhbGZUaGV0YSA+PSAxLjAgKSB7XG5cbiAgICAgIHRoaXMuX3cgPSB3O1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIHRoaXMuX3ogPSB6O1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoIGNvc0hhbGZUaGV0YSApO1xuICAgIHZhciBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoIDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSApO1xuXG4gICAgaWYgKCBNYXRoLmFicyggc2luSGFsZlRoZXRhICkgPCAwLjAwMSApIHtcblxuICAgICAgdGhpcy5fdyA9IDAuNSAqICggdyArIHRoaXMuX3cgKTtcbiAgICAgIHRoaXMuX3ggPSAwLjUgKiAoIHggKyB0aGlzLl94ICk7XG4gICAgICB0aGlzLl95ID0gMC41ICogKCB5ICsgdGhpcy5feSApO1xuICAgICAgdGhpcy5feiA9IDAuNSAqICggeiArIHRoaXMuX3ogKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICB2YXIgcmF0aW9BID0gTWF0aC5zaW4oICggMSAtIHQgKSAqIGhhbGZUaGV0YSApIC8gc2luSGFsZlRoZXRhLFxuICAgIHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XG5cbiAgICB0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xuICAgIHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XG4gICAgdGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcbiAgICB0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCBxdWF0ZXJuaW9uICkge1xuXG4gICAgcmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuX3ggPSBhcnJheVsgb2Zmc2V0IF07XG4gICAgdGhpcy5feSA9IGFycmF5WyBvZmZzZXQgKyAxIF07XG4gICAgdGhpcy5feiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG4gICAgdGhpcy5fdyA9IGFycmF5WyBvZmZzZXQgKyAzIF07XG5cbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XG4gICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XG4gICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XG5cbiAgICByZXR1cm4gYXJyYXk7XG5cbiAgfSxcblxuICBvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93ICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5RdWF0ZXJuaW9uLnNsZXJwID0gZnVuY3Rpb24gKCBxYSwgcWIsIHFtLCB0ICkge1xuXG4gIHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKi9cblxuVEhSRUUuVmVjdG9yMiA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcblxufTtcblxuVEhSRUUuVmVjdG9yMi5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlZlY3RvcjIsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuICAgIHRoaXMueCA9IHg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuICAgIHRoaXMueSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cbiAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgY2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgY2FzZSAwOiByZXR1cm4gdGhpcy54O1xuICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy55O1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHRoaXMueCA9IHYueDtcbiAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy54ICs9IHM7XG4gICAgdGhpcy55ICs9IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCArIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgKyBiLnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggLT0gdi54O1xuICAgIHRoaXMueSAtPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdGhpcy54IC09IHM7XG4gICAgdGhpcy55IC09IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcblxuICAgIHRoaXMueCA9IGEueCAtIGIueDtcbiAgICB0aGlzLnkgPSBhLnkgLSBiLnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB0aGlzLnggKj0gdi54O1xuICAgIHRoaXMueSAqPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnggKj0gcztcbiAgICB0aGlzLnkgKj0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZGl2aWRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB0aGlzLnggLz0gdi54O1xuICAgIHRoaXMueSAvPSB2Lnk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgIHRoaXMueCAqPSBpbnZTY2FsYXI7XG4gICAgICB0aGlzLnkgKj0gaW52U2NhbGFyO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1pbjogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgaWYgKCB0aGlzLnggPiB2LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IHYueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55ID4gdi55ICkge1xuXG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgaWYgKCB0aGlzLnggPCB2LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IHYueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55IDwgdi55ICkge1xuXG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgIGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cbiAgICAgIHRoaXMueCA9IG1pbi54O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IG1heC54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuICAgICAgdGhpcy55ID0gbWluLnk7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuICAgICAgdGhpcy55ID0gbWF4Lnk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjbGFtcFNjYWxhcjogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWluLCBtYXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgICAgaWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtaW4gPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgICAgICBtYXggPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gICAgICB9XG5cbiAgICAgIG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XG4gICAgICBtYXguc2V0KCBtYXhWYWwsIG1heFZhbCApO1xuXG4gICAgICByZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuICAgIH07XG5cbiAgfSApKCksXG5cbiAgZmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjZWlsOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcbiAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IC0gdGhpcy54O1xuICAgIHRoaXMueSA9IC0gdGhpcy55O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG5cbiAgfSxcblxuICBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcblxuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XG5cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgfSxcblxuICBzZXRMZW5ndGg6IGZ1bmN0aW9uICggbCApIHtcblxuICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgaWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICkge1xuXG4gICAgICB0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG4gICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSApO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xuICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XG5cbiAgICByZXR1cm4gYXJyYXk7XG5cbiAgfSxcblxuICBmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgaW5kZXggPSBpbmRleCAqIGF0dHJpYnV0ZS5pdGVtU2l6ZSArIG9mZnNldDtcblxuICAgIHRoaXMueCA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggXTtcbiAgICB0aGlzLnkgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMSBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0aGlzLngsIHRoaXMueSApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9WZWN0b3IzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgKmtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXG4gKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5WZWN0b3IzID0gZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG4gIHRoaXMueCA9IHggfHwgMDtcbiAgdGhpcy55ID0geSB8fCAwO1xuICB0aGlzLnogPSB6IHx8IDA7XG5cbn07XG5cblRIUkVFLlZlY3RvcjMucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3IzLFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xuXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFg6IGZ1bmN0aW9uICggeCApIHtcblxuICAgIHRoaXMueCA9IHg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFk6IGZ1bmN0aW9uICggeSApIHtcblxuICAgIHRoaXMueSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFo6IGZ1bmN0aW9uICggeiApIHtcblxuICAgIHRoaXMueiA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XG5cbiAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgY2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHJldHVybiB0aGlzLng7XG4gICAgICBjYXNlIDE6IHJldHVybiB0aGlzLnk7XG4gICAgICBjYXNlIDI6IHJldHVybiB0aGlzLno7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdGhpcy54ID0gdi54O1xuICAgIHRoaXMueSA9IHYueTtcbiAgICB0aGlzLnogPSB2Lno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG4gICAgdGhpcy56ICs9IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnggKz0gcztcbiAgICB0aGlzLnkgKz0gcztcbiAgICB0aGlzLnogKz0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgdGhpcy54ID0gYS54ICsgYi54O1xuICAgIHRoaXMueSA9IGEueSArIGIueTtcbiAgICB0aGlzLnogPSBhLnogKyBiLno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggLT0gdi54O1xuICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgdGhpcy56IC09IHYuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XG5cbiAgICB0aGlzLnggLT0gcztcbiAgICB0aGlzLnkgLT0gcztcbiAgICB0aGlzLnogLT0gcztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgdGhpcy54ID0gYS54IC0gYi54O1xuICAgIHRoaXMueSA9IGEueSAtIGIueTtcbiAgICB0aGlzLnogPSBhLnogLSBiLno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHRoaXMueCAqPSB2Lng7XG4gICAgdGhpcy55ICo9IHYueTtcbiAgICB0aGlzLnogKj0gdi56O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICB0aGlzLnggKj0gc2NhbGFyO1xuICAgIHRoaXMueSAqPSBzY2FsYXI7XG4gICAgdGhpcy56ICo9IHNjYWxhcjtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICB0aGlzLnggPSBhLnggKiBiLng7XG4gICAgdGhpcy55ID0gYS55ICogYi55O1xuICAgIHRoaXMueiA9IGEueiAqIGIuejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHF1YXRlcm5pb247XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBldWxlciApIHtcblxuICAgICAgaWYgKCBldWxlciBpbnN0YW5jZW9mIFRIUkVFLkV1bGVyID09PSBmYWxzZSApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5RXVsZXIoKSBub3cgZXhwZWN0cyBhIEV1bGVyIHJvdGF0aW9uIHJhdGhlciB0aGFuIGEgVmVjdG9yMyBhbmQgb3JkZXIuJyApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggcXVhdGVybmlvbiA9PT0gdW5kZWZpbmVkICkgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgIHRoaXMuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLnNldEZyb21FdWxlciggZXVsZXIgKSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGFwcGx5QXhpc0FuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcXVhdGVybmlvbjtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICBpZiAoIHF1YXRlcm5pb24gPT09IHVuZGVmaW5lZCApIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgICB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgYXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBlID0gbS5lbGVtZW50cztcblxuICAgIHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcbiAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XG4gICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcblxuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGhpcy54ID0gZVsgMCBdICogeCArIGVbIDQgXSAqIHkgKyBlWyA4IF0gICogeiArIGVbIDEyIF07XG4gICAgdGhpcy55ID0gZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF07XG4gICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFwcGx5UHJvamVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgcHJvamVjdGlvbiBtYXRyaXhcblxuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG4gICAgdmFyIGUgPSBtLmVsZW1lbnRzO1xuICAgIHZhciBkID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTsgLy8gcGVyc3BlY3RpdmUgZGl2aWRlXG5cbiAgICB0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICAqIHogKyBlWyAxMiBdICkgKiBkO1xuICAgIHRoaXMueSA9ICggZVsgMSBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA5IF0gICogeiArIGVbIDEzIF0gKSAqIGQ7XG4gICAgdGhpcy56ID0gKCBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSApICogZDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgYXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB2YXIgeSA9IHRoaXMueTtcbiAgICB2YXIgeiA9IHRoaXMuejtcblxuICAgIHZhciBxeCA9IHEueDtcbiAgICB2YXIgcXkgPSBxLnk7XG4gICAgdmFyIHF6ID0gcS56O1xuICAgIHZhciBxdyA9IHEudztcblxuICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjdG9yXG5cbiAgICB2YXIgaXggPSAgcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICAgIHZhciBpeSA9ICBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgdmFyIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgICB2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcblxuICAgIHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC0gcXggKyBpeSAqIC0gcXogLSBpeiAqIC0gcXk7XG4gICAgdGhpcy55ID0gaXkgKiBxdyArIGl3ICogLSBxeSArIGl6ICogLSBxeCAtIGl4ICogLSBxejtcbiAgICB0aGlzLnogPSBpeiAqIHF3ICsgaXcgKiAtIHF6ICsgaXggKiAtIHF5IC0gaXkgKiAtIHF4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWF0cml4O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG4gICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgbWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICkgKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5UHJvamVjdGlvbiggbWF0cml4ICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICB1bnByb2plY3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtYXRyaXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cbiAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICBtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkLCBtYXRyaXguZ2V0SW52ZXJzZSggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKSApO1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlQcm9qZWN0aW9uKCBtYXRyaXggKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHRyYW5zZm9ybURpcmVjdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDQgYWZmaW5lIG1hdHJpeFxuICAgIC8vIHZlY3RvciBpbnRlcnByZXRlZCBhcyBhIGRpcmVjdGlvblxuXG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG5cbiAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAgKiB6O1xuICAgIHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICAqIHo7XG4gICAgdGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcblxuICAgIHRoaXMubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdGhpcy54IC89IHYueDtcbiAgICB0aGlzLnkgLz0gdi55O1xuICAgIHRoaXMueiAvPSB2Lno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICBpZiAoIHNjYWxhciAhPT0gMCApIHtcblxuICAgICAgdmFyIGludlNjYWxhciA9IDEgLyBzY2FsYXI7XG5cbiAgICAgIHRoaXMueCAqPSBpbnZTY2FsYXI7XG4gICAgICB0aGlzLnkgKj0gaW52U2NhbGFyO1xuICAgICAgdGhpcy56ICo9IGludlNjYWxhcjtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy56ID0gMDtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBpZiAoIHRoaXMueCA+IHYueCApIHtcblxuICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPiB2LnkgKSB7XG5cbiAgICAgIHRoaXMueSA9IHYueTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy56ID4gdi56ICkge1xuXG4gICAgICB0aGlzLnogPSB2Lno7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1heDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgaWYgKCB0aGlzLnggPCB2LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IHYueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55IDwgdi55ICkge1xuXG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueiA8IHYueiApIHtcblxuICAgICAgdGhpcy56ID0gdi56O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XG5cbiAgICBpZiAoIHRoaXMueCA8IG1pbi54ICkge1xuXG4gICAgICB0aGlzLnggPSBtaW4ueDtcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xuXG4gICAgICB0aGlzLnggPSBtYXgueDtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy55IDwgbWluLnkgKSB7XG5cbiAgICAgIHRoaXMueSA9IG1pbi55O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy55ID4gbWF4LnkgKSB7XG5cbiAgICAgIHRoaXMueSA9IG1heC55O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnogPCBtaW4ueiApIHtcblxuICAgICAgdGhpcy56ID0gbWluLno7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcblxuICAgICAgdGhpcy56ID0gbWF4Lno7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsYW1wU2NhbGFyOiAoIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtaW4sIG1heDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG1pblZhbCwgbWF4VmFsICkge1xuXG4gICAgICBpZiAoIG1pbiA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIG1pbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIG1heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIH1cblxuICAgICAgbWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuICAgICAgbWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCApO1xuXG4gICAgICByZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcblxuICAgIH07XG5cbiAgfSApKCksXG5cbiAgZmxvb3I6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgIHRoaXMueiA9IE1hdGguZmxvb3IoIHRoaXMueiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjZWlsOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSBNYXRoLmNlaWwoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGguY2VpbCggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gTWF0aC5jZWlsKCB0aGlzLnogKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcm91bmQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xuICAgIHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xuICAgIHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICByb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gKCB0aGlzLnogPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueiApIDogTWF0aC5mbG9vciggdGhpcy56ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gLSB0aGlzLng7XG4gICAgdGhpcy55ID0gLSB0aGlzLnk7XG4gICAgdGhpcy56ID0gLSB0aGlzLno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRvdDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcblxuICB9LFxuXG4gIGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56O1xuXG4gIH0sXG5cbiAgbGVuZ3RoOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcblxuICB9LFxuXG4gIGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKCB0aGlzLnggKSArIE1hdGguYWJzKCB0aGlzLnkgKSArIE1hdGguYWJzKCB0aGlzLnogKTtcblxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpICk7XG5cbiAgfSxcblxuICBzZXRMZW5ndGg6IGZ1bmN0aW9uICggbCApIHtcblxuICAgIHZhciBvbGRMZW5ndGggPSB0aGlzLmxlbmd0aCgpO1xuXG4gICAgaWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICApIHtcblxuICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcblxuICAgIHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XG4gICAgdGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcbiAgICB0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsZXJwVmVjdG9yczogZnVuY3Rpb24gKCB2MSwgdjIsIGFscGhhICkge1xuXG4gICAgdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNyb3NzOiBmdW5jdGlvbiAoIHYsIHcgKSB7XG5cbiAgICBpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmNyb3NzKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuY3Jvc3NWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHYsIHcgKTtcblxuICAgIH1cblxuICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuXG4gICAgdGhpcy54ID0geSAqIHYueiAtIHogKiB2Lnk7XG4gICAgdGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XG4gICAgdGhpcy56ID0geCAqIHYueSAtIHkgKiB2Lng7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgdmFyIGF4ID0gYS54LCBheSA9IGEueSwgYXogPSBhLno7XG4gICAgdmFyIGJ4ID0gYi54LCBieSA9IGIueSwgYnogPSBiLno7XG5cbiAgICB0aGlzLnggPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgICB0aGlzLnkgPSBheiAqIGJ4IC0gYXggKiBiejtcbiAgICB0aGlzLnogPSBheCAqIGJ5IC0gYXkgKiBieDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEsIGRvdDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICB2MS5jb3B5KCB2ZWN0b3IgKS5ub3JtYWxpemUoKTtcblxuICAgICAgZG90ID0gdGhpcy5kb3QoIHYxICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNvcHkoIHYxICkubXVsdGlwbHlTY2FsYXIoIGRvdCApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgcHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHBsYW5lTm9ybWFsICkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHYxLmNvcHkoIHRoaXMgKS5wcm9qZWN0T25WZWN0b3IoIHBsYW5lTm9ybWFsICk7XG5cbiAgICAgIHJldHVybiB0aGlzLnN1YiggdjEgKTtcblxuICAgIH1cblxuICB9KCksXG5cbiAgcmVmbGVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gcmVmbGVjdCBpbmNpZGVudCB2ZWN0b3Igb2ZmIHBsYW5lIG9ydGhvZ29uYWwgdG8gbm9ybWFsXG4gICAgLy8gbm9ybWFsIGlzIGFzc3VtZWQgdG8gaGF2ZSB1bml0IGxlbmd0aFxuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggbm9ybWFsICkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHJldHVybiB0aGlzLnN1YiggdjEuY29weSggbm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIDIgKiB0aGlzLmRvdCggbm9ybWFsICkgKSApO1xuXG4gICAgfVxuXG4gIH0oKSxcblxuICBhbmdsZVRvOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB2YXIgdGhldGEgPSB0aGlzLmRvdCggdiApIC8gKCB0aGlzLmxlbmd0aCgpICogdi5sZW5ndGgoKSApO1xuXG4gICAgLy8gY2xhbXAsIHRvIGhhbmRsZSBudW1lcmljYWwgcHJvYmxlbXNcblxuICAgIHJldHVybiBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRoZXRhLCAtIDEsIDEgKSApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xuXG4gICAgdmFyIGR4ID0gdGhpcy54IC0gdi54O1xuICAgIHZhciBkeSA9IHRoaXMueSAtIHYueTtcbiAgICB2YXIgZHogPSB0aGlzLnogLSB2Lno7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuXG4gIH0sXG5cbiAgc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuVmVjdG9yMzogLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGluc3RlYWQuJyApO1xuXG4gIH0sXG5cbiAgc2V0RXVsZXJGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxLCBvcmRlciApIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBFdWxlci5zZXRGcm9tUXVhdGVybmlvbigpIGluc3RlYWQuJyApO1xuXG4gIH0sXG5cbiAgZ2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xuXG4gICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtICk7XG5cbiAgfSxcblxuICBnZXRTY2FsZUZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5nZXRTY2FsZUZyb21NYXRyaXgoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5zZXRGcm9tTWF0cml4U2NhbGUoKS4nICk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcbiAgfSxcblxuICBnZXRDb2x1bW5Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XG5cbiAgICByZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCBpbmRleCwgbWF0cml4ICk7XG5cbiAgfSxcblxuICBzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcblxuICAgIHRoaXMueCA9IG0uZWxlbWVudHNbIDEyIF07XG4gICAgdGhpcy55ID0gbS5lbGVtZW50c1sgMTMgXTtcbiAgICB0aGlzLnogPSBtLmVsZW1lbnRzWyAxNCBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIHZhciBzeCA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyAwIF0sIG0uZWxlbWVudHNbIDEgXSwgbS5lbGVtZW50c1sgIDIgXSApLmxlbmd0aCgpO1xuICAgIHZhciBzeSA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA0IF0sIG0uZWxlbWVudHNbIDUgXSwgbS5lbGVtZW50c1sgIDYgXSApLmxlbmd0aCgpO1xuICAgIHZhciBzeiA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWyA4IF0sIG0uZWxlbWVudHNbIDkgXSwgbS5lbGVtZW50c1sgMTAgXSApLmxlbmd0aCgpO1xuXG4gICAgdGhpcy54ID0gc3g7XG4gICAgdGhpcy55ID0gc3k7XG4gICAgdGhpcy56ID0gc3o7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRGcm9tTWF0cml4Q29sdW1uOiBmdW5jdGlvbiAoIGluZGV4LCBtYXRyaXggKSB7XG5cbiAgICB2YXIgb2Zmc2V0ID0gaW5kZXggKiA0O1xuXG4gICAgdmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xuXG4gICAgdGhpcy54ID0gbWVbIG9mZnNldCBdO1xuICAgIHRoaXMueSA9IG1lWyBvZmZzZXQgKyAxIF07XG4gICAgdGhpcy56ID0gbWVbIG9mZnNldCArIDIgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICByZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSApO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgIHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLng7XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMueTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy56O1xuXG4gICAgcmV0dXJuIGFycmF5O1xuXG4gIH0sXG5cbiAgZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGluZGV4ID0gaW5kZXggKiBhdHRyaWJ1dGUuaXRlbVNpemUgKyBvZmZzZXQ7XG5cbiAgICB0aGlzLnggPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4IF07XG4gICAgdGhpcy55ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDEgXTtcbiAgICB0aGlzLnogPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMiBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1ZlY3RvcjQuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuVmVjdG9yNCA9IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbiAgdGhpcy56ID0geiB8fCAwO1xuICB0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XG5cbn07XG5cblRIUkVFLlZlY3RvcjQucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5WZWN0b3I0LFxuXG4gIHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xuXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMueiA9IHo7XG4gICAgdGhpcy53ID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WDogZnVuY3Rpb24gKCB4ICkge1xuXG4gICAgdGhpcy54ID0geDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WTogZnVuY3Rpb24gKCB5ICkge1xuXG4gICAgdGhpcy55ID0geTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0WjogZnVuY3Rpb24gKCB6ICkge1xuXG4gICAgdGhpcy56ID0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0VzogZnVuY3Rpb24gKCB3ICkge1xuXG4gICAgdGhpcy53ID0gdztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcblxuICAgIHN3aXRjaCAoIGluZGV4ICkge1xuXG4gICAgICBjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLnogPSB2YWx1ZTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICBzd2l0Y2ggKCBpbmRleCApIHtcblxuICAgICAgY2FzZSAwOiByZXR1cm4gdGhpcy54O1xuICAgICAgY2FzZSAxOiByZXR1cm4gdGhpcy55O1xuICAgICAgY2FzZSAyOiByZXR1cm4gdGhpcy56O1xuICAgICAgY2FzZSAzOiByZXR1cm4gdGhpcy53O1xuICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHRoaXMueCA9IHYueDtcbiAgICB0aGlzLnkgPSB2Lnk7XG4gICAgdGhpcy56ID0gdi56O1xuICAgIHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5hZGRWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggKz0gdi54O1xuICAgIHRoaXMueSArPSB2Lnk7XG4gICAgdGhpcy56ICs9IHYuejtcbiAgICB0aGlzLncgKz0gdi53O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIHRoaXMueCArPSBzO1xuICAgIHRoaXMueSArPSBzO1xuICAgIHRoaXMueiArPSBzO1xuICAgIHRoaXMudyArPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICB0aGlzLnggPSBhLnggKyBiLng7XG4gICAgdGhpcy55ID0gYS55ICsgYi55O1xuICAgIHRoaXMueiA9IGEueiArIGIuejtcbiAgICB0aGlzLncgPSBhLncgKyBiLnc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xuXG4gICAgaWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5zdWIoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5zdWJWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnggLT0gdi54O1xuICAgIHRoaXMueSAtPSB2Lnk7XG4gICAgdGhpcy56IC09IHYuejtcbiAgICB0aGlzLncgLT0gdi53O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIHRoaXMueCAtPSBzO1xuICAgIHRoaXMueSAtPSBzO1xuICAgIHRoaXMueiAtPSBzO1xuICAgIHRoaXMudyAtPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICB0aGlzLnggPSBhLnggLSBiLng7XG4gICAgdGhpcy55ID0gYS55IC0gYi55O1xuICAgIHRoaXMueiA9IGEueiAtIGIuejtcbiAgICB0aGlzLncgPSBhLncgLSBiLnc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcblxuICAgIHRoaXMueCAqPSBzY2FsYXI7XG4gICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICB0aGlzLnogKj0gc2NhbGFyO1xuICAgIHRoaXMudyAqPSBzY2FsYXI7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG4gICAgdmFyIHcgPSB0aGlzLnc7XG5cbiAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG5cbiAgICB0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDggXSAqIHogKyBlWyAxMiBdICogdztcbiAgICB0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICogdztcbiAgICB0aGlzLnogPSBlWyAyIF0gKiB4ICsgZVsgNiBdICogeSArIGVbIDEwIF0gKiB6ICsgZVsgMTQgXSAqIHc7XG4gICAgdGhpcy53ID0gZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKiB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgaWYgKCBzY2FsYXIgIT09IDAgKSB7XG5cbiAgICAgIHZhciBpbnZTY2FsYXIgPSAxIC8gc2NhbGFyO1xuXG4gICAgICB0aGlzLnggKj0gaW52U2NhbGFyO1xuICAgICAgdGhpcy55ICo9IGludlNjYWxhcjtcbiAgICAgIHRoaXMueiAqPSBpbnZTY2FsYXI7XG4gICAgICB0aGlzLncgKj0gaW52U2NhbGFyO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnogPSAwO1xuICAgICAgdGhpcy53ID0gMTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0QXhpc0FuZ2xlRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcblxuICAgIC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9xdWF0ZXJuaW9uVG9BbmdsZS9pbmRleC5odG1cblxuICAgIC8vIHEgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICB0aGlzLncgPSAyICogTWF0aC5hY29zKCBxLncgKTtcblxuICAgIHZhciBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XG5cbiAgICBpZiAoIHMgPCAwLjAwMDEgKSB7XG5cbiAgICAgICB0aGlzLnggPSAxO1xuICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgdGhpcy56ID0gMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICB0aGlzLnggPSBxLnggLyBzO1xuICAgICAgIHRoaXMueSA9IHEueSAvIHM7XG4gICAgICAgdGhpcy56ID0gcS56IC8gcztcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9BbmdsZS9pbmRleC5odG1cblxuICAgIC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXG5cbiAgICB2YXIgYW5nbGUsIHgsIHksIHosICAgLy8gdmFyaWFibGVzIGZvciByZXN1bHRcbiAgICAgIGVwc2lsb24gPSAwLjAxLCAgIC8vIG1hcmdpbiB0byBhbGxvdyBmb3Igcm91bmRpbmcgZXJyb3JzXG4gICAgICBlcHNpbG9uMiA9IDAuMSwgICAvLyBtYXJnaW4gdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiAwIGFuZCAxODAgZGVncmVlc1xuXG4gICAgICB0ZSA9IG0uZWxlbWVudHMsXG5cbiAgICAgIG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXG4gICAgICBtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxuICAgICAgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cbiAgICBpZiAoICggTWF0aC5hYnMoIG0xMiAtIG0yMSApIDwgZXBzaWxvbiApXG4gICAgICAgJiYgKCBNYXRoLmFicyggbTEzIC0gbTMxICkgPCBlcHNpbG9uIClcbiAgICAgICAmJiAoIE1hdGguYWJzKCBtMjMgLSBtMzIgKSA8IGVwc2lsb24gKSApIHtcblxuICAgICAgLy8gc2luZ3VsYXJpdHkgZm91bmRcbiAgICAgIC8vIGZpcnN0IGNoZWNrIGZvciBpZGVudGl0eSBtYXRyaXggd2hpY2ggbXVzdCBoYXZlICsxIGZvciBhbGwgdGVybXNcbiAgICAgIC8vIGluIGxlYWRpbmcgZGlhZ29uYWwgYW5kIHplcm8gaW4gb3RoZXIgdGVybXNcblxuICAgICAgaWYgKCAoIE1hdGguYWJzKCBtMTIgKyBtMjEgKSA8IGVwc2lsb24yIClcbiAgICAgICAgICYmICggTWF0aC5hYnMoIG0xMyArIG0zMSApIDwgZXBzaWxvbjIgKVxuICAgICAgICAgJiYgKCBNYXRoLmFicyggbTIzICsgbTMyICkgPCBlcHNpbG9uMiApXG4gICAgICAgICAmJiAoIE1hdGguYWJzKCBtMTEgKyBtMjIgKyBtMzMgLSAzICkgPCBlcHNpbG9uMiApICkge1xuXG4gICAgICAgIC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxuXG4gICAgICAgIHRoaXMuc2V0KCAxLCAwLCAwLCAwICk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHplcm8gYW5nbGUsIGFyYml0cmFyeSBheGlzXG5cbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIHRoaXMgc2luZ3VsYXJpdHkgaXMgYW5nbGUgPSAxODBcblxuICAgICAgYW5nbGUgPSBNYXRoLlBJO1xuXG4gICAgICB2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XG4gICAgICB2YXIgeXkgPSAoIG0yMiArIDEgKSAvIDI7XG4gICAgICB2YXIgenogPSAoIG0zMyArIDEgKSAvIDI7XG4gICAgICB2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcbiAgICAgIHZhciB4eiA9ICggbTEzICsgbTMxICkgLyA0O1xuICAgICAgdmFyIHl6ID0gKCBtMjMgKyBtMzIgKSAvIDQ7XG5cbiAgICAgIGlmICggKCB4eCA+IHl5ICkgJiYgKCB4eCA+IHp6ICkgKSB7IC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cbiAgICAgICAgaWYgKCB4eCA8IGVwc2lsb24gKSB7XG5cbiAgICAgICAgICB4ID0gMDtcbiAgICAgICAgICB5ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgeiA9IDAuNzA3MTA2NzgxO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB4ID0gTWF0aC5zcXJ0KCB4eCApO1xuICAgICAgICAgIHkgPSB4eSAvIHg7XG4gICAgICAgICAgeiA9IHh6IC8geDtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoIHl5ID4genogKSB7IC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXG5cbiAgICAgICAgaWYgKCB5eSA8IGVwc2lsb24gKSB7XG5cbiAgICAgICAgICB4ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgeiA9IDAuNzA3MTA2NzgxO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB5ID0gTWF0aC5zcXJ0KCB5eSApO1xuICAgICAgICAgIHggPSB4eSAvIHk7XG4gICAgICAgICAgeiA9IHl6IC8geTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7IC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcblxuICAgICAgICBpZiAoIHp6IDwgZXBzaWxvbiApIHtcblxuICAgICAgICAgIHggPSAwLjcwNzEwNjc4MTtcbiAgICAgICAgICB5ID0gMC43MDcxMDY3ODE7XG4gICAgICAgICAgeiA9IDA7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHogPSBNYXRoLnNxcnQoIHp6ICk7XG4gICAgICAgICAgeCA9IHh6IC8gejtcbiAgICAgICAgICB5ID0geXogLyB6O1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIHJldHVybiAxODAgZGVnIHJvdGF0aW9uXG5cbiAgICB9XG5cbiAgICAvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XG5cbiAgICB2YXIgcyA9IE1hdGguc3FydCggKCBtMzIgLSBtMjMgKSAqICggbTMyIC0gbTIzIClcbiAgICAgICAgICAgICAgKyAoIG0xMyAtIG0zMSApICogKCBtMTMgLSBtMzEgKVxuICAgICAgICAgICAgICArICggbTIxIC0gbTEyICkgKiAoIG0yMSAtIG0xMiApICk7IC8vIHVzZWQgdG8gbm9ybWFsaXplXG5cbiAgICBpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xuXG4gICAgLy8gcHJldmVudCBkaXZpZGUgYnkgemVybywgc2hvdWxkIG5vdCBoYXBwZW4gaWYgbWF0cml4IGlzIG9ydGhvZ29uYWwgYW5kIHNob3VsZCBiZVxuICAgIC8vIGNhdWdodCBieSBzaW5ndWxhcml0eSB0ZXN0IGFib3ZlLCBidXQgSSd2ZSBsZWZ0IGl0IGluIGp1c3QgaW4gY2FzZVxuXG4gICAgdGhpcy54ID0gKCBtMzIgLSBtMjMgKSAvIHM7XG4gICAgdGhpcy55ID0gKCBtMTMgLSBtMzEgKSAvIHM7XG4gICAgdGhpcy56ID0gKCBtMjEgLSBtMTIgKSAvIHM7XG4gICAgdGhpcy53ID0gTWF0aC5hY29zKCAoIG0xMSArIG0yMiArIG0zMyAtIDEgKSAvIDIgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWluOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBpZiAoIHRoaXMueCA+IHYueCApIHtcblxuICAgICAgdGhpcy54ID0gdi54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPiB2LnkgKSB7XG5cbiAgICAgIHRoaXMueSA9IHYueTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy56ID4gdi56ICkge1xuXG4gICAgICB0aGlzLnogPSB2Lno7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMudyA+IHYudyApIHtcblxuICAgICAgdGhpcy53ID0gdi53O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYXg6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIGlmICggdGhpcy54IDwgdi54ICkge1xuXG4gICAgICB0aGlzLnggPSB2Lng7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueSA8IHYueSApIHtcblxuICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnogPCB2LnogKSB7XG5cbiAgICAgIHRoaXMueiA9IHYuejtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy53IDwgdi53ICkge1xuXG4gICAgICB0aGlzLncgPSB2Lnc7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcblxuICAgIGlmICggdGhpcy54IDwgbWluLnggKSB7XG5cbiAgICAgIHRoaXMueCA9IG1pbi54O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XG5cbiAgICAgIHRoaXMueCA9IG1heC54O1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcblxuICAgICAgdGhpcy55ID0gbWluLnk7XG5cbiAgICB9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcblxuICAgICAgdGhpcy55ID0gbWF4Lnk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMueiA8IG1pbi56ICkge1xuXG4gICAgICB0aGlzLnogPSBtaW4uejtcblxuICAgIH0gZWxzZSBpZiAoIHRoaXMueiA+IG1heC56ICkge1xuXG4gICAgICB0aGlzLnogPSBtYXguejtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy53IDwgbWluLncgKSB7XG5cbiAgICAgIHRoaXMudyA9IG1pbi53O1xuXG4gICAgfSBlbHNlIGlmICggdGhpcy53ID4gbWF4LncgKSB7XG5cbiAgICAgIHRoaXMudyA9IG1heC53O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbGFtcFNjYWxhcjogKCBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWluLCBtYXg7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBtaW5WYWwsIG1heFZhbCApIHtcblxuICAgICAgaWYgKCBtaW4gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBtaW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuICAgICAgICBtYXggPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xuXG4gICAgICB9XG5cbiAgICAgIG1pbi5zZXQoIG1pblZhbCwgbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xuICAgICAgbWF4LnNldCggbWF4VmFsLCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNsYW1wKCBtaW4sIG1heCApO1xuXG4gICAgfTtcblxuICB9ICkoKSxcblxuICBmbG9vcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XG4gICAgdGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XG4gICAgdGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNlaWw6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IE1hdGguY2VpbCggdGhpcy54ICk7XG4gICAgdGhpcy55ID0gTWF0aC5jZWlsKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSBNYXRoLmNlaWwoIHRoaXMueiApO1xuICAgIHRoaXMudyA9IE1hdGguY2VpbCggdGhpcy53ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHJvdW5kOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcbiAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcbiAgICB0aGlzLnogPSBNYXRoLnJvdW5kKCB0aGlzLnogKTtcbiAgICB0aGlzLncgPSBNYXRoLnJvdW5kKCB0aGlzLncgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xuICAgIHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xuICAgIHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xuICAgIHRoaXMudyA9ICggdGhpcy53IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLncgKSA6IE1hdGguZmxvb3IoIHRoaXMudyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBuZWdhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMueCA9IC0gdGhpcy54O1xuICAgIHRoaXMueSA9IC0gdGhpcy55O1xuICAgIHRoaXMueiA9IC0gdGhpcy56O1xuICAgIHRoaXMudyA9IC0gdGhpcy53O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkb3Q6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XG5cbiAgfSxcblxuICBsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcblxuICB9LFxuXG4gIGxlbmd0aDogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53ICk7XG5cbiAgfSxcblxuICBsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICkgKyBNYXRoLmFicyggdGhpcy53ICk7XG5cbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xuXG4gIH0sXG5cbiAgc2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGwgKSB7XG5cbiAgICB2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcblxuICAgIGlmICggb2xkTGVuZ3RoICE9PSAwICYmIGwgIT09IG9sZExlbmd0aCApIHtcblxuICAgICAgdGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xuXG4gICAgdGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcbiAgICB0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xuICAgIHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XG4gICAgdGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcblxuICAgIHRoaXMuc3ViVmVjdG9ycyggdjIsIHYxICkubXVsdGlwbHlTY2FsYXIoIGFscGhhICkuYWRkKCB2MSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcbiAgICB0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xuICAgIHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XG4gICAgdGhpcy53ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xuICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XG4gICAgYXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcblxuICAgIHJldHVybiBhcnJheTtcblxuICB9LFxuXG4gIGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xuXG4gICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG5cbiAgICBpbmRleCA9IGluZGV4ICogYXR0cmlidXRlLml0ZW1TaXplICsgb2Zmc2V0O1xuXG4gICAgdGhpcy54ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCBdO1xuICAgIHRoaXMueSA9IGF0dHJpYnV0ZS5hcnJheVsgaW5kZXggKyAxIF07XG4gICAgdGhpcy56ID0gYXR0cmlidXRlLmFycmF5WyBpbmRleCArIDIgXTtcbiAgICB0aGlzLncgPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4ICsgMyBdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3I0KCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvRXVsZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5FdWxlciA9IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XG5cbiAgdGhpcy5feCA9IHggfHwgMDtcbiAgdGhpcy5feSA9IHkgfHwgMDtcbiAgdGhpcy5feiA9IHogfHwgMDtcbiAgdGhpcy5fb3JkZXIgPSBvcmRlciB8fCBUSFJFRS5FdWxlci5EZWZhdWx0T3JkZXI7XG5cbn07XG5cblRIUkVFLkV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XG5cblRIUkVFLkV1bGVyLkRlZmF1bHRPcmRlciA9ICdYWVonO1xuXG5USFJFRS5FdWxlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkV1bGVyLFxuXG4gIF94OiAwLCBfeTogMCwgX3o6IDAsIF9vcmRlcjogVEhSRUUuRXVsZXIuRGVmYXVsdE9yZGVyLFxuXG4gIGdldCB4ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl94O1xuXG4gIH0sXG5cbiAgc2V0IHggKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3ggPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCB5ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl95O1xuXG4gIH0sXG5cbiAgc2V0IHkgKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3kgPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCB6ICgpIHtcblxuICAgIHJldHVybiB0aGlzLl96O1xuXG4gIH0sXG5cbiAgc2V0IHogKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX3ogPSB2YWx1ZTtcbiAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcblxuICB9LFxuXG4gIGdldCBvcmRlciAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fb3JkZXI7XG5cbiAgfSxcblxuICBzZXQgb3JkZXIgKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuX29yZGVyID0gdmFsdWU7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XG5cbiAgICB0aGlzLl94ID0geDtcbiAgICB0aGlzLl95ID0geTtcbiAgICB0aGlzLl96ID0gejtcbiAgICB0aGlzLl9vcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cbiAgICB0aGlzLl94ID0gZXVsZXIuX3g7XG4gICAgdGhpcy5feSA9IGV1bGVyLl95O1xuICAgIHRoaXMuX3ogPSBldWxlci5fejtcbiAgICB0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSwgb3JkZXIsIHVwZGF0ZSApIHtcblxuICAgIHZhciBjbGFtcCA9IFRIUkVFLk1hdGguY2xhbXA7XG5cbiAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgdmFyIHRlID0gbS5lbGVtZW50cztcbiAgICB2YXIgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXTtcbiAgICB2YXIgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcbiAgICB2YXIgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XG5cbiAgICBvcmRlciA9IG9yZGVyIHx8IHRoaXMuX29yZGVyO1xuXG4gICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgIHRoaXMuX3kgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMsIC0gMSwgMSApICk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcblxuICAgICAgICB0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xuICAgICAgICB0aGlzLl96ID0gMDtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICB0aGlzLl94ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMjMsIC0gMSwgMSApICk7XG5cbiAgICAgIGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OSApIHtcblxuICAgICAgICB0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcbiAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcbiAgICAgICAgdGhpcy5feiA9IDA7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgdGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcblxuICAgICAgaWYgKCBNYXRoLmFicyggbTMyICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTMzICk7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTIyICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICAgIHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICAgIHRoaXMuX3kgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSwgLSAxLCAxICkgKTtcblxuICAgICAgaWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xuXG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xuICAgICAgICB0aGlzLl96ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgdGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICB0aGlzLl96ID0gTWF0aC5hc2luKCBjbGFtcCggbTIxLCAtIDEsIDEgKSApO1xuXG4gICAgICBpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgICAgdGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuICAgICAgdGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xuXG4gICAgICBpZiAoIE1hdGguYWJzKCBtMTIgKSA8IDAuOTk5OTkgKSB7XG5cbiAgICAgICAgdGhpcy5feCA9IE1hdGguYXRhbjIoIG0zMiwgbTIyICk7XG4gICAgICAgIHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0xMSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XG4gICAgICAgIHRoaXMuX3kgPSAwO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGdpdmVuIHVuc3VwcG9ydGVkIG9yZGVyOiAnICsgb3JkZXIgKVxuXG4gICAgfVxuXG4gICAgdGhpcy5fb3JkZXIgPSBvcmRlcjtcblxuICAgIGlmICggdXBkYXRlICE9PSBmYWxzZSApIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1hdHJpeDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHEsIG9yZGVyLCB1cGRhdGUgKSB7XG5cbiAgICAgIGlmICggbWF0cml4ID09PSB1bmRlZmluZWQgKSBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgbWF0cml4Lm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxICk7XG4gICAgICB0aGlzLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4LCBvcmRlciwgdXBkYXRlICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgc2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5zZXQoIHYueCwgdi55LCB2LnosIG9yZGVyIHx8IHRoaXMuX29yZGVyICk7XG5cbiAgfSxcblxuICByZW9yZGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXG5cbiAgICB2YXIgcSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBuZXdPcmRlciApIHtcblxuICAgICAgcS5zZXRGcm9tRXVsZXIoIHRoaXMgKTtcbiAgICAgIHRoaXMuc2V0RnJvbVF1YXRlcm5pb24oIHEsIG5ld09yZGVyICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cbiAgICByZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XG5cbiAgfSxcblxuICBmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XG5cbiAgICB0aGlzLl94ID0gYXJyYXlbIDAgXTtcbiAgICB0aGlzLl95ID0gYXJyYXlbIDEgXTtcbiAgICB0aGlzLl96ID0gYXJyYXlbIDIgXTtcbiAgICBpZiAoIGFycmF5WyAzIF0gIT09IHVuZGVmaW5lZCApIHRoaXMuX29yZGVyID0gYXJyYXlbIDMgXTtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgYXJyYXlbIG9mZnNldCBdID0gdGhpcy5feDtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5feTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGhpcy5fejtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGhpcy5fb3JkZXI7XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG5cbiAgdG9WZWN0b3IzOiBmdW5jdGlvbiAoIG9wdGlvbmFsUmVzdWx0ICkge1xuXG4gICAgaWYgKCBvcHRpb25hbFJlc3VsdCApIHtcblxuICAgICAgcmV0dXJuIG9wdGlvbmFsUmVzdWx0LnNldCggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcblxuICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGNhbGxiYWNrO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5FdWxlciggdGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvTGluZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5MaW5lMyA9IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuICB0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHRoaXMuZW5kID0gKCBlbmQgIT09IHVuZGVmaW5lZCApID8gZW5kIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxufTtcblxuVEhSRUUuTGluZTMucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5MaW5lMyxcblxuICBzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcblxuICAgIHRoaXMuc3RhcnQuY29weSggc3RhcnQgKTtcbiAgICB0aGlzLmVuZC5jb3B5KCBlbmQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBsaW5lICkge1xuXG4gICAgdGhpcy5zdGFydC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG4gICAgdGhpcy5lbmQuY29weSggbGluZS5lbmQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcblxuICB9LFxuXG4gIGRlbHRhOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLmVuZCwgdGhpcy5zdGFydCApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VTcTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUbyggdGhpcy5lbmQgKTtcblxuICB9LFxuXG4gIGF0OiBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuICB9LFxuXG4gIGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzdGFydFAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBzdGFydEVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XG5cbiAgICAgIHN0YXJ0UC5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5zdGFydCApO1xuICAgICAgc3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcblxuICAgICAgdmFyIHN0YXJ0RW5kMiA9IHN0YXJ0RW5kLmRvdCggc3RhcnRFbmQgKTtcbiAgICAgIHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xuXG4gICAgICB2YXIgdCA9IHN0YXJ0RW5kX3N0YXJ0UCAvIHN0YXJ0RW5kMjtcblxuICAgICAgaWYgKCBjbGFtcFRvTGluZSApIHtcblxuICAgICAgICB0ID0gVEhSRUUuTWF0aC5jbGFtcCggdCwgMCwgMSApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0O1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgY2xhbXBUb0xpbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHQgPSB0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXIoIHBvaW50LCBjbGFtcFRvTGluZSApO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcblxuICB9LFxuXG4gIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICB0aGlzLnN0YXJ0LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG4gICAgdGhpcy5lbmQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XG5cbiAgICByZXR1cm4gbGluZS5zdGFydC5lcXVhbHMoIHRoaXMuc3RhcnQgKSAmJiBsaW5lLmVuZC5lcXVhbHMoIHRoaXMuZW5kICk7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5MaW5lMygpLmNvcHkoIHRoaXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94Mi5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLkJveDIgPSBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xuXG4gIHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xuICB0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IyKCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gyLFxuXG4gIHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIHRoaXMubWluLmNvcHkoIG1pbiApO1xuICAgIHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdIClcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0RnJvbUNlbnRlckFuZFNpemU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XG5cbiAgICAgIHZhciBoYWxmU2l6ZSA9IHYxLmNvcHkoIHNpemUgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG4gICAgICB0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG4gICAgICB0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgY29weTogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICB0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XG4gICAgdGhpcy5tYXguY29weSggYm94Lm1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gSW5maW5pdHk7XG4gICAgdGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtIEluZmluaXR5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuICAgIHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApO1xuXG4gIH0sXG5cbiAgY2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XG5cbiAgfSxcblxuICBzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcblxuICB9LFxuXG4gIGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICB0aGlzLm1pbi5taW4oIHBvaW50ICk7XG4gICAgdGhpcy5tYXgubWF4KCBwb2ludCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgdGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcbiAgICB0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xuXG4gICAgdGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xuICAgIHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgaWYgKCBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxuICAgICAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgKSB7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0sXG5cbiAgY29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgaWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXG4gICAgICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9LFxuXG4gIGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxuICAgIC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICAgIHJldHVybiByZXN1bHQuc2V0KFxuICAgICAgKCBwb2ludC54IC0gdGhpcy5taW4ueCApIC8gKCB0aGlzLm1heC54IC0gdGhpcy5taW4ueCApLFxuICAgICAgKCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApXG4gICAgKTtcblxuICB9LFxuXG4gIGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxuXG4gICAgaWYgKCBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcbiAgICAgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSApIHtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSxcblxuICBjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xuICAgIHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgICAgdmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuICAgICAgcmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgdGhpcy5taW4ubWF4KCBib3gubWluICk7XG4gICAgdGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuICAgIHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xuXG4gICAgdGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcbiAgICB0aGlzLm1heC5hZGQoIG9mZnNldCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgcmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuQm94MigpLmNvcHkoIHRoaXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvQm94My5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuQm94MyA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XG5cbiAgdGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVEhSRUUuVmVjdG9yMyggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuICB0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbn07XG5cblRIUkVFLkJveDMucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5Cb3gzLFxuXG4gIHNldDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcblxuICAgIHRoaXMubWluLmNvcHkoIG1pbiApO1xuICAgIHRoaXMubWF4LmNvcHkoIG1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoIHBvaW50cyApIHtcblxuICAgIHRoaXMubWFrZUVtcHR5KCk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoIHBvaW50c1sgaSBdICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21DZW50ZXJBbmRTaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggY2VudGVyLCBzaXplICkge1xuXG4gICAgICB2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gICAgICB0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XG4gICAgICB0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgc2V0RnJvbU9iamVjdDogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gQ29tcHV0ZXMgdGhlIHdvcmxkLWF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggb2YgYW4gb2JqZWN0IChpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKSxcbiAgICAvLyBhY2NvdW50aW5nIGZvciBib3RoIHRoZSBvYmplY3QncywgYW5kIGNoaWxkcmVucycsIHdvcmxkIHRyYW5zZm9ybXNcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICAgIG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuXG4gICAgICBvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggbm9kZSApIHtcblxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBub2RlLmdlb21ldHJ5O1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgICAgICB2MS5jb3B5KCB2ZXJ0aWNlc1sgaSBdICk7XG5cbiAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgc2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5hdHRyaWJ1dGVzWyAncG9zaXRpb24nIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbICdwb3NpdGlvbicgXS5hcnJheTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgICAgIHYxLnNldCggcG9zaXRpb25zWyBpIF0sIHBvc2l0aW9uc1sgaSArIDEgXSwgcG9zaXRpb25zWyBpICsgMiBdICk7XG5cbiAgICAgICAgICAgICAgdjEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICAgICAgc2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgdGhpcy5taW4uY29weSggYm94Lm1pbiApO1xuICAgIHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IHRoaXMubWluLnogPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlbXB0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcblxuICAgIHJldHVybiAoIHRoaXMubWF4LnggPCB0aGlzLm1pbi54ICkgfHwgKCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSApIHx8ICggdGhpcy5tYXgueiA8IHRoaXMubWluLnogKTtcblxuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xuXG4gIH0sXG5cbiAgc2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHJldHVybiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XG5cbiAgfSxcblxuICBleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgdGhpcy5taW4ubWluKCBwb2ludCApO1xuICAgIHRoaXMubWF4Lm1heCggcG9pbnQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXhwYW5kQnlWZWN0b3I6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgdGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcbiAgICB0aGlzLm1heC5hZGQoIHZlY3RvciApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XG5cbiAgICB0aGlzLm1pbi5hZGRTY2FsYXIoIC0gc2NhbGFyICk7XG4gICAgdGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcbiAgICAgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8XG4gICAgICAgICBwb2ludC56IDwgdGhpcy5taW4ueiB8fCBwb2ludC56ID4gdGhpcy5tYXgueiApIHtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSxcblxuICBjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICBpZiAoICggdGhpcy5taW4ueCA8PSBib3gubWluLnggKSAmJiAoIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICkgJiZcbiAgICAgICAoIHRoaXMubWluLnkgPD0gYm94Lm1pbi55ICkgJiYgKCBib3gubWF4LnkgPD0gdGhpcy5tYXgueSApICYmXG4gICAgICAgKCB0aGlzLm1pbi56IDw9IGJveC5taW4ueiApICYmICggYm94Lm1heC56IDw9IHRoaXMubWF4LnogKSApIHtcblxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgfSxcblxuICBnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgLy8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcbiAgICAvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnNldChcbiAgICAgICggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcbiAgICAgICggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKSxcbiAgICAgICggcG9pbnQueiAtIHRoaXMubWluLnogKSAvICggdGhpcy5tYXgueiAtIHRoaXMubWluLnogKVxuICAgICk7XG5cbiAgfSxcblxuICBpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XG5cbiAgICAvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cblxuICAgIGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XG4gICAgICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcbiAgICAgICAgIGJveC5tYXgueiA8IHRoaXMubWluLnogfHwgYm94Lm1pbi56ID4gdGhpcy5tYXgueiApIHtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSxcblxuICBjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHJldHVybiByZXN1bHQuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XG5cbiAgfSxcblxuICBkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgICAgdmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xuICAgICAgcmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBnZXRCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlNwaGVyZSgpO1xuXG4gICAgICByZXN1bHQuY2VudGVyID0gdGhpcy5jZW50ZXIoKTtcbiAgICAgIHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgdGhpcy5taW4ubWF4KCBib3gubWluICk7XG4gICAgdGhpcy5tYXgubWluKCBib3gubWF4ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xuICAgIHRoaXMubWF4Lm1heCggYm94Lm1heCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBwb2ludHMgPSBbXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjMoKVxuICAgIF07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICAgIC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XG4gICAgICBwb2ludHNbIDAgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWluLnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMDBcbiAgICAgIHBvaW50c1sgMSBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMVxuICAgICAgcG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXG4gICAgICBwb2ludHNbIDMgXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTFcbiAgICAgIHBvaW50c1sgNCBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDEwMFxuICAgICAgcG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXG4gICAgICBwb2ludHNbIDYgXS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMTBcbiAgICAgIHBvaW50c1sgNyBdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7ICAvLyAxMTFcblxuICAgICAgdGhpcy5tYWtlRW1wdHkoKTtcbiAgICAgIHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuICAgIHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XG4gICAgdGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgIHJldHVybiBib3gubWluLmVxdWFscyggdGhpcy5taW4gKSAmJiBib3gubWF4LmVxdWFscyggdGhpcy5tYXggKTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkJveDMoKS5jb3B5KCB0aGlzICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDMuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5NYXRyaXgzID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG5cbiAgICAxLCAwLCAwLFxuICAgIDAsIDEsIDAsXG4gICAgMCwgMCwgMVxuXG4gIF0gKTtcblxuICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDM6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTWF0cml4My5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDMsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4yMSwgbjIyLCBuMjMsIG4zMSwgbjMyLCBuMzMgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdGVbIDAgXSA9IG4xMTsgdGVbIDMgXSA9IG4xMjsgdGVbIDYgXSA9IG4xMztcbiAgICB0ZVsgMSBdID0gbjIxOyB0ZVsgNCBdID0gbjIyOyB0ZVsgNyBdID0gbjIzO1xuICAgIHRlWyAyIF0gPSBuMzE7IHRlWyA1IF0gPSBuMzI7IHRlWyA4IF0gPSBuMzM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGlkZW50aXR5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgMSwgMCwgMCxcbiAgICAgIDAsIDEsIDAsXG4gICAgICAwLCAwLCAxXG5cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgIG1lWyAwIF0sIG1lWyAzIF0sIG1lWyA2IF0sXG4gICAgICBtZVsgMSBdLCBtZVsgNCBdLCBtZVsgNyBdLFxuICAgICAgbWVbIDIgXSwgbWVbIDUgXSwgbWVbIDggXVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDM6IC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDMoIHRoaXMgKTtcblxuICB9LFxuXG4gIG11bHRpcGx5VmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIGEgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW5hbWVkLiBVc2UgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIGFycmF5ICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlUb1ZlY3RvcjNBcnJheSggYSApO1xuXG4gIH0sXG5cbiAgYXBwbHlUb1ZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaiA9IG9mZnNldDsgaSA8IGxlbmd0aDsgaSArPSAzLCBqICs9IDMgKSB7XG5cbiAgICAgICAgdjEuZnJvbUFycmF5KCBhcnJheSwgaiApO1xuICAgICAgICB2MS5hcHBseU1hdHJpeDMoIHRoaXMgKTtcbiAgICAgICAgdjEudG9BcnJheSggYXJyYXksIGogKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBhcHBseVRvQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gYXBwbHlUb0J1ZmZlciggYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCApIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgaWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XG4gICAgICBpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCAvIGJ1ZmZlci5pdGVtU2l6ZTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICsrLCBqICsrICkge1xuXG4gICAgICAgIHYxLnggPSBidWZmZXIuZ2V0WCggaiApO1xuICAgICAgICB2MS55ID0gYnVmZmVyLmdldFkoIGogKTtcbiAgICAgICAgdjEueiA9IGJ1ZmZlci5nZXRaKCBqICk7XG5cbiAgICAgICAgdjEuYXBwbHlNYXRyaXgzKCB0aGlzICk7XG5cbiAgICAgICAgYnVmZmVyLnNldFhZWiggdjEueCwgdjEueSwgdjEueiApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWZmZXI7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XG4gICAgdGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcbiAgICB0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxuICAgICAgZCA9IHRlWyAzIF0sIGUgPSB0ZVsgNCBdLCBmID0gdGVbIDUgXSxcbiAgICAgIGcgPSB0ZVsgNiBdLCBoID0gdGVbIDcgXSwgaSA9IHRlWyA4IF07XG5cbiAgICByZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xuXG4gIH0sXG5cbiAgZ2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25JbnZlcnRpYmxlICkge1xuXG4gICAgLy8gaW5wdXQ6IFRIUkVFLk1hdHJpeDRcbiAgICAvLyAoIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC93ZWJnbC1tanMvIClcblxuICAgIHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cztcbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdGVbIDAgXSA9ICAgbWVbIDEwIF0gKiBtZVsgNSBdIC0gbWVbIDYgXSAqIG1lWyA5IF07XG4gICAgdGVbIDEgXSA9IC0gbWVbIDEwIF0gKiBtZVsgMSBdICsgbWVbIDIgXSAqIG1lWyA5IF07XG4gICAgdGVbIDIgXSA9ICAgbWVbIDYgXSAqIG1lWyAxIF0gLSBtZVsgMiBdICogbWVbIDUgXTtcbiAgICB0ZVsgMyBdID0gLSBtZVsgMTAgXSAqIG1lWyA0IF0gKyBtZVsgNiBdICogbWVbIDggXTtcbiAgICB0ZVsgNCBdID0gICBtZVsgMTAgXSAqIG1lWyAwIF0gLSBtZVsgMiBdICogbWVbIDggXTtcbiAgICB0ZVsgNSBdID0gLSBtZVsgNiBdICogbWVbIDAgXSArIG1lWyAyIF0gKiBtZVsgNCBdO1xuICAgIHRlWyA2IF0gPSAgIG1lWyA5IF0gKiBtZVsgNCBdIC0gbWVbIDUgXSAqIG1lWyA4IF07XG4gICAgdGVbIDcgXSA9IC0gbWVbIDkgXSAqIG1lWyAwIF0gKyBtZVsgMSBdICogbWVbIDggXTtcbiAgICB0ZVsgOCBdID0gICBtZVsgNSBdICogbWVbIDAgXSAtIG1lWyAxIF0gKiBtZVsgNCBdO1xuXG4gICAgdmFyIGRldCA9IG1lWyAwIF0gKiB0ZVsgMCBdICsgbWVbIDEgXSAqIHRlWyAzIF0gKyBtZVsgMiBdICogdGVbIDYgXTtcblxuICAgIC8vIG5vIGludmVyc2VcblxuICAgIGlmICggZGV0ID09PSAwICkge1xuXG4gICAgICB2YXIgbXNnID0gXCJNYXRyaXgzLmdldEludmVyc2UoKTogY2FuJ3QgaW52ZXJ0IG1hdHJpeCwgZGV0ZXJtaW5hbnQgaXMgMFwiO1xuXG4gICAgICBpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCBtc2cgKTtcblxuICAgICAgfVxuXG4gICAgICB0aGlzLmlkZW50aXR5KCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgdGhpcy5tdWx0aXBseVNjYWxhciggMS4wIC8gZGV0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0bXAgPSBtWyAxIF07IG1bIDEgXSA9IG1bIDMgXTsgbVsgMyBdID0gdG1wO1xuICAgIHRtcCA9IG1bIDIgXTsgbVsgMiBdID0gbVsgNiBdOyBtWyA2IF0gPSB0bXA7XG4gICAgdG1wID0gbVsgNSBdOyBtWyA1IF0gPSBtWyA3IF07IG1bIDcgXSA9IHRtcDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBhcnJheVsgb2Zmc2V0ICAgICBdID0gdGVbIDAgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcblxuICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyA0IF0gPSB0ZVsgNCBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyA1IF0gPSB0ZVsgNSBdO1xuXG4gICAgYXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDggXSAgPSB0ZVsgOCBdO1xuXG4gICAgcmV0dXJuIGFycmF5O1xuXG4gIH0sXG5cbiAgZ2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxuXG4gICAgdGhpcy5nZXRJbnZlcnNlKCBtICkudHJhbnNwb3NlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRyYW5zcG9zZUludG9BcnJheTogZnVuY3Rpb24gKCByICkge1xuXG4gICAgdmFyIG0gPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgclsgMCBdID0gbVsgMCBdO1xuICAgIHJbIDEgXSA9IG1bIDMgXTtcbiAgICByWyAyIF0gPSBtWyA2IF07XG4gICAgclsgMyBdID0gbVsgMSBdO1xuICAgIHJbIDQgXSA9IG1bIDQgXTtcbiAgICByWyA1IF0gPSBtWyA3IF07XG4gICAgclsgNiBdID0gbVsgMiBdO1xuICAgIHJbIDcgXSA9IG1bIDUgXTtcbiAgICByWyA4IF0gPSBtWyA4IF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcblxuICAgIHRoaXMuZWxlbWVudHMuc2V0KCBhcnJheSApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICB0b0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIHRlWyAwIF0sIHRlWyAxIF0sIHRlWyAyIF0sXG4gICAgICB0ZVsgMyBdLCB0ZVsgNCBdLCB0ZVsgNSBdLFxuICAgICAgdGVbIDYgXSwgdGVbIDcgXSwgdGVbIDggXVxuICAgIF07XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5NYXRyaXgzKCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdHJpeDQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXG4gKiBAYXV0aG9yIGpvcmRpX3JvcyAvIGh0dHA6Ly9wbGF0dHNvZnQuY29tXG4gKiBAYXV0aG9yIEQxcGxvMWQgLyBodHRwOi8vZ2l0aHViLmNvbS9EMXBsbzFkXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgdGlta25pcCAvIGh0dHA6Ly93d3cuZmxvb3JwbGFubmVyLmNvbS9cbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKi9cblxuVEhSRUUuTWF0cml4NCA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmVsZW1lbnRzID0gbmV3IEZsb2F0MzJBcnJheSggW1xuXG4gICAgMSwgMCwgMCwgMCxcbiAgICAwLCAxLCAwLCAwLFxuICAgIDAsIDAsIDEsIDAsXG4gICAgMCwgMCwgMCwgMVxuXG4gIF0gKTtcblxuICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IHRoZSBjb25zdHJ1Y3RvciBubyBsb25nZXIgcmVhZHMgYXJndW1lbnRzLiB1c2UgLnNldCgpIGluc3RlYWQuJyApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTWF0cml4NC5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLk1hdHJpeDQsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIG4xMSwgbjEyLCBuMTMsIG4xNCwgbjIxLCBuMjIsIG4yMywgbjI0LCBuMzEsIG4zMiwgbjMzLCBuMzQsIG40MSwgbjQyLCBuNDMsIG40NCApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcbiAgICB0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcbiAgICB0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XG4gICAgdGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBpZGVudGl0eTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAwLCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDFcblxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggbSApIHtcblxuICAgIHRoaXMuZWxlbWVudHMuc2V0KCBtLmVsZW1lbnRzICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGV4dHJhY3RQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLicgKTtcbiAgICByZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oIG0gKTtcblxuICB9LFxuXG4gIGNvcHlQb3NpdGlvbjogZnVuY3Rpb24gKCBtICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICB2YXIgbWUgPSBtLmVsZW1lbnRzO1xuXG4gICAgdGVbIDEyIF0gPSBtZVsgMTIgXTtcbiAgICB0ZVsgMTMgXSA9IG1lWyAxMyBdO1xuICAgIHRlWyAxNCBdID0gbWVbIDE0IF07XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGV4dHJhY3RCYXNpczogZnVuY3Rpb24gKCB4QXhpcywgeUF4aXMsIHpBeGlzICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHhBeGlzLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApO1xuICAgIHlBeGlzLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApO1xuICAgIHpBeGlzLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZUJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XG5cbiAgICB0aGlzLnNldChcbiAgICAgIHhBeGlzLngsIHlBeGlzLngsIHpBeGlzLngsIDAsXG4gICAgICB4QXhpcy55LCB5QXhpcy55LCB6QXhpcy55LCAwLFxuICAgICAgeEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcbiAgICAgIDAsICAgICAgIDAsICAgICAgIDAsICAgICAgIDFcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICAgIHZhciBzY2FsZVggPSAxIC8gdjEuc2V0KCBtZVsgMCBdLCBtZVsgMSBdLCBtZVsgMiBdICkubGVuZ3RoKCk7XG4gICAgICB2YXIgc2NhbGVZID0gMSAvIHYxLnNldCggbWVbIDQgXSwgbWVbIDUgXSwgbWVbIDYgXSApLmxlbmd0aCgpO1xuICAgICAgdmFyIHNjYWxlWiA9IDEgLyB2MS5zZXQoIG1lWyA4IF0sIG1lWyA5IF0sIG1lWyAxMCBdICkubGVuZ3RoKCk7XG5cbiAgICAgIHRlWyAwIF0gPSBtZVsgMCBdICogc2NhbGVYO1xuICAgICAgdGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XG4gICAgICB0ZVsgMiBdID0gbWVbIDIgXSAqIHNjYWxlWDtcblxuICAgICAgdGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XG4gICAgICB0ZVsgNSBdID0gbWVbIDUgXSAqIHNjYWxlWTtcbiAgICAgIHRlWyA2IF0gPSBtZVsgNiBdICogc2NhbGVZO1xuXG4gICAgICB0ZVsgOCBdID0gbWVbIDggXSAqIHNjYWxlWjtcbiAgICAgIHRlWyA5IF0gPSBtZVsgOSBdICogc2NhbGVaO1xuICAgICAgdGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cbiAgICBpZiAoIGV1bGVyIGluc3RhbmNlb2YgVEhSRUUuRXVsZXIgPT09IGZhbHNlICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcblxuICAgIH1cblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcbiAgICB2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xuICAgIHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XG4gICAgdmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcblxuICAgIGlmICggZXVsZXIub3JkZXIgPT09ICdYWVonICkge1xuXG4gICAgICB2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcblxuICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgdGVbIDQgXSA9IC0gYyAqIGY7XG4gICAgICB0ZVsgOCBdID0gZDtcblxuICAgICAgdGVbIDEgXSA9IGFmICsgYmUgKiBkO1xuICAgICAgdGVbIDUgXSA9IGFlIC0gYmYgKiBkO1xuICAgICAgdGVbIDkgXSA9IC0gYiAqIGM7XG5cbiAgICAgIHRlWyAyIF0gPSBiZiAtIGFlICogZDtcbiAgICAgIHRlWyA2IF0gPSBiZSArIGFmICogZDtcbiAgICAgIHRlWyAxMCBdID0gYSAqIGM7XG5cbiAgICB9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1lYWicgKSB7XG5cbiAgICAgIHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG4gICAgICB0ZVsgMCBdID0gY2UgKyBkZiAqIGI7XG4gICAgICB0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XG4gICAgICB0ZVsgOCBdID0gYSAqIGQ7XG5cbiAgICAgIHRlWyAxIF0gPSBhICogZjtcbiAgICAgIHRlWyA1IF0gPSBhICogZTtcbiAgICAgIHRlWyA5IF0gPSAtIGI7XG5cbiAgICAgIHRlWyAyIF0gPSBjZiAqIGIgLSBkZTtcbiAgICAgIHRlWyA2IF0gPSBkZiArIGNlICogYjtcbiAgICAgIHRlWyAxMCBdID0gYSAqIGM7XG5cbiAgICB9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pYWScgKSB7XG5cbiAgICAgIHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xuXG4gICAgICB0ZVsgMCBdID0gY2UgLSBkZiAqIGI7XG4gICAgICB0ZVsgNCBdID0gLSBhICogZjtcbiAgICAgIHRlWyA4IF0gPSBkZSArIGNmICogYjtcblxuICAgICAgdGVbIDEgXSA9IGNmICsgZGUgKiBiO1xuICAgICAgdGVbIDUgXSA9IGEgKiBlO1xuICAgICAgdGVbIDkgXSA9IGRmIC0gY2UgKiBiO1xuXG4gICAgICB0ZVsgMiBdID0gLSBhICogZDtcbiAgICAgIHRlWyA2IF0gPSBiO1xuICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWllYJyApIHtcblxuICAgICAgdmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XG5cbiAgICAgIHRlWyAwIF0gPSBjICogZTtcbiAgICAgIHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcbiAgICAgIHRlWyA4IF0gPSBhZSAqIGQgKyBiZjtcblxuICAgICAgdGVbIDEgXSA9IGMgKiBmO1xuICAgICAgdGVbIDUgXSA9IGJmICogZCArIGFlO1xuICAgICAgdGVbIDkgXSA9IGFmICogZCAtIGJlO1xuXG4gICAgICB0ZVsgMiBdID0gLSBkO1xuICAgICAgdGVbIDYgXSA9IGIgKiBjO1xuICAgICAgdGVbIDEwIF0gPSBhICogYztcblxuICAgIH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWVpYJyApIHtcblxuICAgICAgdmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XG5cbiAgICAgIHRlWyAwIF0gPSBjICogZTtcbiAgICAgIHRlWyA0IF0gPSBiZCAtIGFjICogZjtcbiAgICAgIHRlWyA4IF0gPSBiYyAqIGYgKyBhZDtcblxuICAgICAgdGVbIDEgXSA9IGY7XG4gICAgICB0ZVsgNSBdID0gYSAqIGU7XG4gICAgICB0ZVsgOSBdID0gLSBiICogZTtcblxuICAgICAgdGVbIDIgXSA9IC0gZCAqIGU7XG4gICAgICB0ZVsgNiBdID0gYWQgKiBmICsgYmM7XG4gICAgICB0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xuXG4gICAgfSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdYWlknICkge1xuXG4gICAgICB2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcblxuICAgICAgdGVbIDAgXSA9IGMgKiBlO1xuICAgICAgdGVbIDQgXSA9IC0gZjtcbiAgICAgIHRlWyA4IF0gPSBkICogZTtcblxuICAgICAgdGVbIDEgXSA9IGFjICogZiArIGJkO1xuICAgICAgdGVbIDUgXSA9IGEgKiBlO1xuICAgICAgdGVbIDkgXSA9IGFkICogZiAtIGJjO1xuXG4gICAgICB0ZVsgMiBdID0gYmMgKiBmIC0gYWQ7XG4gICAgICB0ZVsgNiBdID0gYiAqIGU7XG4gICAgICB0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xuXG4gICAgfVxuXG4gICAgLy8gbGFzdCBjb2x1bW5cbiAgICB0ZVsgMyBdID0gMDtcbiAgICB0ZVsgNyBdID0gMDtcbiAgICB0ZVsgMTEgXSA9IDA7XG5cbiAgICAvLyBib3R0b20gcm93XG4gICAgdGVbIDEyIF0gPSAwO1xuICAgIHRlWyAxMyBdID0gMDtcbiAgICB0ZVsgMTQgXSA9IDA7XG4gICAgdGVbIDE1IF0gPSAxO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkuJyApO1xuXG4gICAgcmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcblxuICB9LFxuXG4gIG1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLnc7XG4gICAgdmFyIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHo7XG4gICAgdmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XG4gICAgdmFyIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejI7XG4gICAgdmFyIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejI7XG5cbiAgICB0ZVsgMCBdID0gMSAtICggeXkgKyB6eiApO1xuICAgIHRlWyA0IF0gPSB4eSAtIHd6O1xuICAgIHRlWyA4IF0gPSB4eiArIHd5O1xuXG4gICAgdGVbIDEgXSA9IHh5ICsgd3o7XG4gICAgdGVbIDUgXSA9IDEgLSAoIHh4ICsgenogKTtcbiAgICB0ZVsgOSBdID0geXogLSB3eDtcblxuICAgIHRlWyAyIF0gPSB4eiAtIHd5O1xuICAgIHRlWyA2IF0gPSB5eiArIHd4O1xuICAgIHRlWyAxMCBdID0gMSAtICggeHggKyB5eSApO1xuXG4gICAgLy8gbGFzdCBjb2x1bW5cbiAgICB0ZVsgMyBdID0gMDtcbiAgICB0ZVsgNyBdID0gMDtcbiAgICB0ZVsgMTEgXSA9IDA7XG5cbiAgICAvLyBib3R0b20gcm93XG4gICAgdGVbIDEyIF0gPSAwO1xuICAgIHRlWyAxMyBdID0gMDtcbiAgICB0ZVsgMTQgXSA9IDA7XG4gICAgdGVbIDE1IF0gPSAxO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB4LCB5LCB6O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggZXllLCB0YXJnZXQsIHVwICkge1xuXG4gICAgICBpZiAoIHggPT09IHVuZGVmaW5lZCApIHggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgaWYgKCB5ID09PSB1bmRlZmluZWQgKSB5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGlmICggeiA9PT0gdW5kZWZpbmVkICkgeiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICAgIHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKS5ub3JtYWxpemUoKTtcblxuICAgICAgaWYgKCB6Lmxlbmd0aCgpID09PSAwICkge1xuXG4gICAgICAgIHoueiA9IDE7XG5cbiAgICAgIH1cblxuICAgICAgeC5jcm9zc1ZlY3RvcnMoIHVwLCB6ICkubm9ybWFsaXplKCk7XG5cbiAgICAgIGlmICggeC5sZW5ndGgoKSA9PT0gMCApIHtcblxuICAgICAgICB6LnggKz0gMC4wMDAxO1xuICAgICAgICB4LmNyb3NzVmVjdG9ycyggdXAsIHogKS5ub3JtYWxpemUoKTtcblxuICAgICAgfVxuXG4gICAgICB5LmNyb3NzVmVjdG9ycyggeiwgeCApO1xuXG5cbiAgICAgIHRlWyAwIF0gPSB4Lng7IHRlWyA0IF0gPSB5Lng7IHRlWyA4IF0gPSB6Lng7XG4gICAgICB0ZVsgMSBdID0geC55OyB0ZVsgNSBdID0geS55OyB0ZVsgOSBdID0gei55O1xuICAgICAgdGVbIDIgXSA9IHguejsgdGVbIDYgXSA9IHkuejsgdGVbIDEwIF0gPSB6Lno7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcblxuICAgIGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseU1hdHJpY2VzKCBhLCBiICkgaW5zdGVhZC4nICk7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XG5cbiAgfSxcblxuICBtdWx0aXBseU1hdHJpY2VzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICB2YXIgYWUgPSBhLmVsZW1lbnRzO1xuICAgIHZhciBiZSA9IGIuZWxlbWVudHM7XG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHZhciBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgNCBdLCBhMTMgPSBhZVsgOCBdLCBhMTQgPSBhZVsgMTIgXTtcbiAgICB2YXIgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XG4gICAgdmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcbiAgICB2YXIgYTQxID0gYWVbIDMgXSwgYTQyID0gYWVbIDcgXSwgYTQzID0gYWVbIDExIF0sIGE0NCA9IGFlWyAxNSBdO1xuXG4gICAgdmFyIGIxMSA9IGJlWyAwIF0sIGIxMiA9IGJlWyA0IF0sIGIxMyA9IGJlWyA4IF0sIGIxNCA9IGJlWyAxMiBdO1xuICAgIHZhciBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNSBdLCBiMjMgPSBiZVsgOSBdLCBiMjQgPSBiZVsgMTMgXTtcbiAgICB2YXIgYjMxID0gYmVbIDIgXSwgYjMyID0gYmVbIDYgXSwgYjMzID0gYmVbIDEwIF0sIGIzNCA9IGJlWyAxNCBdO1xuICAgIHZhciBiNDEgPSBiZVsgMyBdLCBiNDIgPSBiZVsgNyBdLCBiNDMgPSBiZVsgMTEgXSwgYjQ0ID0gYmVbIDE1IF07XG5cbiAgICB0ZVsgMCBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xuICAgIHRlWyA0IF0gPSBhMTEgKiBiMTIgKyBhMTIgKiBiMjIgKyBhMTMgKiBiMzIgKyBhMTQgKiBiNDI7XG4gICAgdGVbIDggXSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcbiAgICB0ZVsgMTIgXSA9IGExMSAqIGIxNCArIGExMiAqIGIyNCArIGExMyAqIGIzNCArIGExNCAqIGI0NDtcblxuICAgIHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XG4gICAgdGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0MjtcbiAgICB0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xuICAgIHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xuXG4gICAgdGVbIDIgXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcbiAgICB0ZVsgNiBdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xuICAgIHRlWyAxMCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzICsgYTM0ICogYjQzO1xuICAgIHRlWyAxNCBdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xuXG4gICAgdGVbIDMgXSA9IGE0MSAqIGIxMSArIGE0MiAqIGIyMSArIGE0MyAqIGIzMSArIGE0NCAqIGI0MTtcbiAgICB0ZVsgNyBdID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xuICAgIHRlWyAxMSBdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xuICAgIHRlWyAxNSBdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtdWx0aXBseVRvQXJyYXk6IGZ1bmN0aW9uICggYSwgYiwgciApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcblxuICAgIHJbIDAgXSA9IHRlWyAwIF07IHJbIDEgXSA9IHRlWyAxIF07IHJbIDIgXSA9IHRlWyAyIF07IHJbIDMgXSA9IHRlWyAzIF07XG4gICAgclsgNCBdID0gdGVbIDQgXTsgclsgNSBdID0gdGVbIDUgXTsgclsgNiBdID0gdGVbIDYgXTsgclsgNyBdID0gdGVbIDcgXTtcbiAgICByWyA4IF0gID0gdGVbIDggXTsgclsgOSBdICA9IHRlWyA5IF07IHJbIDEwIF0gPSB0ZVsgMTAgXTsgclsgMTEgXSA9IHRlWyAxMSBdO1xuICAgIHJbIDEyIF0gPSB0ZVsgMTIgXTsgclsgMTMgXSA9IHRlWyAxMyBdOyByWyAxNCBdID0gdGVbIDE0IF07IHJbIDE1IF0gPSB0ZVsgMTUgXTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICB0ZVsgMCBdICo9IHM7IHRlWyA0IF0gKj0gczsgdGVbIDggXSAqPSBzOyB0ZVsgMTIgXSAqPSBzO1xuICAgIHRlWyAxIF0gKj0gczsgdGVbIDUgXSAqPSBzOyB0ZVsgOSBdICo9IHM7IHRlWyAxMyBdICo9IHM7XG4gICAgdGVbIDIgXSAqPSBzOyB0ZVsgNiBdICo9IHM7IHRlWyAxMCBdICo9IHM7IHRlWyAxNCBdICo9IHM7XG4gICAgdGVbIDMgXSAqPSBzOyB0ZVsgNyBdICo9IHM7IHRlWyAxMSBdICo9IHM7IHRlWyAxNSBdICo9IHM7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIG9yIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xuICAgIHJldHVybiB2ZWN0b3IuYXBwbHlQcm9qZWN0aW9uKCB0aGlzICk7XG5cbiAgfSxcblxuICBtdWx0aXBseVZlY3RvcjQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yNCgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xuXG4gIH0sXG5cbiAgbXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggYSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbmFtZWQuIFVzZSBtYXRyaXguYXBwbHlUb1ZlY3RvcjNBcnJheSggYXJyYXkgKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gdGhpcy5hcHBseVRvVmVjdG9yM0FycmF5KCBhICk7XG5cbiAgfSxcblxuICBhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjE7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0LCBsZW5ndGggKSB7XG5cbiAgICAgIGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuICAgICAgaWYgKCBsZW5ndGggPT09IHVuZGVmaW5lZCApIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gb2Zmc2V0OyBpIDwgbGVuZ3RoOyBpICs9IDMsIGogKz0gMyApIHtcblxuICAgICAgICB2MS5mcm9tQXJyYXkoIGFycmF5LCBqICk7XG4gICAgICAgIHYxLmFwcGx5TWF0cml4NCggdGhpcyApO1xuICAgICAgICB2MS50b0FycmF5KCBhcnJheSwgaiApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhcnJheTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBhcHBseVRvQnVmZmVyKCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoICkge1xuXG4gICAgICBpZiAoIHYxID09PSB1bmRlZmluZWQgKSB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcbiAgICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSBidWZmZXIubGVuZ3RoIC8gYnVmZmVyLml0ZW1TaXplO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCBsZW5ndGg7IGkgKyssIGogKysgKSB7XG5cbiAgICAgICAgdjEueCA9IGJ1ZmZlci5nZXRYKCBqICk7XG4gICAgICAgIHYxLnkgPSBidWZmZXIuZ2V0WSggaiApO1xuICAgICAgICB2MS56ID0gYnVmZmVyLmdldFooIGogKTtcblxuICAgICAgICB2MS5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuICAgICAgICBidWZmZXIuc2V0WFlaKCB2MS54LCB2MS55LCB2MS56ICk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZmZlcjtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHJvdGF0ZUF4aXM6IGZ1bmN0aW9uICggdiApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVBeGlzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMudHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblxuICAgIHYudHJhbnNmb3JtRGlyZWN0aW9uKCB0aGlzICk7XG5cbiAgfSxcblxuICBjcm9zc1ZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuY3Jvc3NWZWN0b3IoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XG4gICAgcmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcblxuICB9LFxuXG4gIGRldGVybWluYW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdmFyIG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xuICAgIHZhciBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcbiAgICB2YXIgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xuICAgIHZhciBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XG5cbiAgICAvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxuICAgIC8vKCBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG0gKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIG40MSAqIChcbiAgICAgICAgKyBuMTQgKiBuMjMgKiBuMzJcbiAgICAgICAgIC0gbjEzICogbjI0ICogbjMyXG4gICAgICAgICAtIG4xNCAqIG4yMiAqIG4zM1xuICAgICAgICAgKyBuMTIgKiBuMjQgKiBuMzNcbiAgICAgICAgICsgbjEzICogbjIyICogbjM0XG4gICAgICAgICAtIG4xMiAqIG4yMyAqIG4zNFxuICAgICAgKSArXG4gICAgICBuNDIgKiAoXG4gICAgICAgICsgbjExICogbjIzICogbjM0XG4gICAgICAgICAtIG4xMSAqIG4yNCAqIG4zM1xuICAgICAgICAgKyBuMTQgKiBuMjEgKiBuMzNcbiAgICAgICAgIC0gbjEzICogbjIxICogbjM0XG4gICAgICAgICArIG4xMyAqIG4yNCAqIG4zMVxuICAgICAgICAgLSBuMTQgKiBuMjMgKiBuMzFcbiAgICAgICkgK1xuICAgICAgbjQzICogKFxuICAgICAgICArIG4xMSAqIG4yNCAqIG4zMlxuICAgICAgICAgLSBuMTEgKiBuMjIgKiBuMzRcbiAgICAgICAgIC0gbjE0ICogbjIxICogbjMyXG4gICAgICAgICArIG4xMiAqIG4yMSAqIG4zNFxuICAgICAgICAgKyBuMTQgKiBuMjIgKiBuMzFcbiAgICAgICAgIC0gbjEyICogbjI0ICogbjMxXG4gICAgICApICtcbiAgICAgIG40NCAqIChcbiAgICAgICAgLSBuMTMgKiBuMjIgKiBuMzFcbiAgICAgICAgIC0gbjExICogbjIzICogbjMyXG4gICAgICAgICArIG4xMSAqIG4yMiAqIG4zM1xuICAgICAgICAgKyBuMTMgKiBuMjEgKiBuMzJcbiAgICAgICAgIC0gbjEyICogbjIxICogbjMzXG4gICAgICAgICArIG4xMiAqIG4yMyAqIG4zMVxuICAgICAgKVxuXG4gICAgKTtcblxuICB9LFxuXG4gIHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICB2YXIgdG1wO1xuXG4gICAgdG1wID0gdGVbIDEgXTsgdGVbIDEgXSA9IHRlWyA0IF07IHRlWyA0IF0gPSB0bXA7XG4gICAgdG1wID0gdGVbIDIgXTsgdGVbIDIgXSA9IHRlWyA4IF07IHRlWyA4IF0gPSB0bXA7XG4gICAgdG1wID0gdGVbIDYgXTsgdGVbIDYgXSA9IHRlWyA5IF07IHRlWyA5IF0gPSB0bXA7XG5cbiAgICB0bXAgPSB0ZVsgMyBdOyB0ZVsgMyBdID0gdGVbIDEyIF07IHRlWyAxMiBdID0gdG1wO1xuICAgIHRtcCA9IHRlWyA3IF07IHRlWyA3IF0gPSB0ZVsgMTMgXTsgdGVbIDEzIF0gPSB0bXA7XG4gICAgdG1wID0gdGVbIDExIF07IHRlWyAxMSBdID0gdGVbIDE0IF07IHRlWyAxNCBdID0gdG1wO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBmbGF0dGVuVG9BcnJheU9mZnNldDogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIGFycmF5WyBvZmZzZXQgICAgIF0gPSB0ZVsgMCBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0ZVsgMSBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0ZVsgMiBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0ZVsgMyBdO1xuXG4gICAgYXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XG5cbiAgICBhcnJheVsgb2Zmc2V0ICsgOCBdICA9IHRlWyA4IF07XG4gICAgYXJyYXlbIG9mZnNldCArIDkgXSAgPSB0ZVsgOSBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxMCBdID0gdGVbIDEwIF07XG4gICAgYXJyYXlbIG9mZnNldCArIDExIF0gPSB0ZVsgMTEgXTtcblxuICAgIGFycmF5WyBvZmZzZXQgKyAxMiBdID0gdGVbIDEyIF07XG4gICAgYXJyYXlbIG9mZnNldCArIDEzIF0gPSB0ZVsgMTMgXTtcbiAgICBhcnJheVsgb2Zmc2V0ICsgMTQgXSA9IHRlWyAxNCBdO1xuICAgIGFycmF5WyBvZmZzZXQgKyAxNSBdID0gdGVbIDE1IF07XG5cbiAgICByZXR1cm4gYXJyYXk7XG5cbiAgfSxcblxuICBnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCB2MSA9PT0gdW5kZWZpbmVkICkgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmdldFBvc2l0aW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcblxuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHJldHVybiB2MS5zZXQoIHRlWyAxMiBdLCB0ZVsgMTMgXSwgdGVbIDE0IF0gKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgdGVbIDEyIF0gPSB2Lng7XG4gICAgdGVbIDEzIF0gPSB2Lnk7XG4gICAgdGVbIDE0IF0gPSB2Lno7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldEludmVyc2U6IGZ1bmN0aW9uICggbSwgdGhyb3dPbkludmVydGlibGUgKSB7XG5cbiAgICAvLyBiYXNlZCBvbiBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9hbGdlYnJhL21hdHJpeC9mdW5jdGlvbnMvaW52ZXJzZS9mb3VyRC9pbmRleC5odG1cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciBtZSA9IG0uZWxlbWVudHM7XG5cbiAgICB2YXIgbjExID0gbWVbIDAgXSwgbjEyID0gbWVbIDQgXSwgbjEzID0gbWVbIDggXSwgbjE0ID0gbWVbIDEyIF07XG4gICAgdmFyIG4yMSA9IG1lWyAxIF0sIG4yMiA9IG1lWyA1IF0sIG4yMyA9IG1lWyA5IF0sIG4yNCA9IG1lWyAxMyBdO1xuICAgIHZhciBuMzEgPSBtZVsgMiBdLCBuMzIgPSBtZVsgNiBdLCBuMzMgPSBtZVsgMTAgXSwgbjM0ID0gbWVbIDE0IF07XG4gICAgdmFyIG40MSA9IG1lWyAzIF0sIG40MiA9IG1lWyA3IF0sIG40MyA9IG1lWyAxMSBdLCBuNDQgPSBtZVsgMTUgXTtcblxuICAgIHRlWyAwIF0gPSBuMjMgKiBuMzQgKiBuNDIgLSBuMjQgKiBuMzMgKiBuNDIgKyBuMjQgKiBuMzIgKiBuNDMgLSBuMjIgKiBuMzQgKiBuNDMgLSBuMjMgKiBuMzIgKiBuNDQgKyBuMjIgKiBuMzMgKiBuNDQ7XG4gICAgdGVbIDQgXSA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NDtcbiAgICB0ZVsgOCBdID0gbjEzICogbjI0ICogbjQyIC0gbjE0ICogbjIzICogbjQyICsgbjE0ICogbjIyICogbjQzIC0gbjEyICogbjI0ICogbjQzIC0gbjEzICogbjIyICogbjQ0ICsgbjEyICogbjIzICogbjQ0O1xuICAgIHRlWyAxMiBdID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xuICAgIHRlWyAxIF0gPSBuMjQgKiBuMzMgKiBuNDEgLSBuMjMgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzEgKiBuNDMgKyBuMjEgKiBuMzQgKiBuNDMgKyBuMjMgKiBuMzEgKiBuNDQgLSBuMjEgKiBuMzMgKiBuNDQ7XG4gICAgdGVbIDUgXSA9IG4xMyAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMyAqIG40MSArIG4xNCAqIG4zMSAqIG40MyAtIG4xMSAqIG4zNCAqIG40MyAtIG4xMyAqIG4zMSAqIG40NCArIG4xMSAqIG4zMyAqIG40NDtcbiAgICB0ZVsgOSBdID0gbjE0ICogbjIzICogbjQxIC0gbjEzICogbjI0ICogbjQxIC0gbjE0ICogbjIxICogbjQzICsgbjExICogbjI0ICogbjQzICsgbjEzICogbjIxICogbjQ0IC0gbjExICogbjIzICogbjQ0O1xuICAgIHRlWyAxMyBdID0gbjEzICogbjI0ICogbjMxIC0gbjE0ICogbjIzICogbjMxICsgbjE0ICogbjIxICogbjMzIC0gbjExICogbjI0ICogbjMzIC0gbjEzICogbjIxICogbjM0ICsgbjExICogbjIzICogbjM0O1xuICAgIHRlWyAyIF0gPSBuMjIgKiBuMzQgKiBuNDEgLSBuMjQgKiBuMzIgKiBuNDEgKyBuMjQgKiBuMzEgKiBuNDIgLSBuMjEgKiBuMzQgKiBuNDIgLSBuMjIgKiBuMzEgKiBuNDQgKyBuMjEgKiBuMzIgKiBuNDQ7XG4gICAgdGVbIDYgXSA9IG4xNCAqIG4zMiAqIG40MSAtIG4xMiAqIG4zNCAqIG40MSAtIG4xNCAqIG4zMSAqIG40MiArIG4xMSAqIG4zNCAqIG40MiArIG4xMiAqIG4zMSAqIG40NCAtIG4xMSAqIG4zMiAqIG40NDtcbiAgICB0ZVsgMTAgXSA9IG4xMiAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMiAqIG40MSArIG4xNCAqIG4yMSAqIG40MiAtIG4xMSAqIG4yNCAqIG40MiAtIG4xMiAqIG4yMSAqIG40NCArIG4xMSAqIG4yMiAqIG40NDtcbiAgICB0ZVsgMTQgXSA9IG4xNCAqIG4yMiAqIG4zMSAtIG4xMiAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMSAqIG4zMiArIG4xMSAqIG4yNCAqIG4zMiArIG4xMiAqIG4yMSAqIG4zNCAtIG4xMSAqIG4yMiAqIG4zNDtcbiAgICB0ZVsgMyBdID0gbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzO1xuICAgIHRlWyA3IF0gPSBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDM7XG4gICAgdGVbIDExIF0gPSBuMTMgKiBuMjIgKiBuNDEgLSBuMTIgKiBuMjMgKiBuNDEgLSBuMTMgKiBuMjEgKiBuNDIgKyBuMTEgKiBuMjMgKiBuNDIgKyBuMTIgKiBuMjEgKiBuNDMgLSBuMTEgKiBuMjIgKiBuNDM7XG4gICAgdGVbIDE1IF0gPSBuMTIgKiBuMjMgKiBuMzEgLSBuMTMgKiBuMjIgKiBuMzEgKyBuMTMgKiBuMjEgKiBuMzIgLSBuMTEgKiBuMjMgKiBuMzIgLSBuMTIgKiBuMjEgKiBuMzMgKyBuMTEgKiBuMjIgKiBuMzM7XG5cbiAgICB2YXIgZGV0ID0gbjExICogdGVbIDAgXSArIG4yMSAqIHRlWyA0IF0gKyBuMzEgKiB0ZVsgOCBdICsgbjQxICogdGVbIDEyIF07XG5cbiAgICBpZiAoIGRldCA9PT0gMCApIHtcblxuICAgICAgdmFyIG1zZyA9IFwiVEhSRUUuTWF0cml4NC5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcblxuICAgICAgaWYgKCB0aHJvd09uSW52ZXJ0aWJsZSB8fCBmYWxzZSApIHtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggbXNnICk7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5pZGVudGl0eSgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBkZXQgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gIH0sXG5cbiAgcm90YXRlWDogZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gIH0sXG5cbiAgcm90YXRlWTogZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gIH0sXG5cbiAgcm90YXRlWjogZnVuY3Rpb24gKCBhbmdsZSApIHtcblxuICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAucm90YXRlWigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gIH0sXG5cbiAgcm90YXRlQnlBeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVCeUF4aXMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB9LFxuXG4gIHNjYWxlOiBmdW5jdGlvbiAoIHYgKSB7XG5cbiAgICB2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHZhciB4ID0gdi54LCB5ID0gdi55LCB6ID0gdi56O1xuXG4gICAgdGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcbiAgICB0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xuICAgIHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xuICAgIHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRNYXhTY2FsZU9uQXhpczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgIHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcbiAgICB2YXIgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XG4gICAgdmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIE1hdGgubWF4KCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApICk7XG5cbiAgfSxcblxuICBtYWtlVHJhbnNsYXRpb246IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcblxuICAgIHRoaXMuc2V0KFxuXG4gICAgICAxLCAwLCAwLCB4LFxuICAgICAgMCwgMSwgMCwgeSxcbiAgICAgIDAsIDAsIDEsIHosXG4gICAgICAwLCAwLCAwLCAxXG5cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xuXG4gICAgdmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xuXG4gICAgdGhpcy5zZXQoXG5cbiAgICAgIDEsIDAsICAwLCAwLFxuICAgICAgMCwgYywgLSBzLCAwLFxuICAgICAgMCwgcywgIGMsIDAsXG4gICAgICAwLCAwLCAgMCwgMVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKCB0aGV0YSApIHtcblxuICAgIHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcblxuICAgIHRoaXMuc2V0KFxuXG4gICAgICAgYywgMCwgcywgMCxcbiAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgLSBzLCAwLCBjLCAwLFxuICAgICAgIDAsIDAsIDAsIDFcblxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XG5cbiAgICB2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgYywgLSBzLCAwLCAwLFxuICAgICAgcywgIGMsIDAsIDAsXG4gICAgICAwLCAgMCwgMSwgMCxcbiAgICAgIDAsICAwLCAwLCAxXG5cbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgLy8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG5cbiAgICB2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xuICAgIHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XG4gICAgdmFyIHQgPSAxIC0gYztcbiAgICB2YXIgeCA9IGF4aXMueCwgeSA9IGF4aXMueSwgeiA9IGF4aXMuejtcbiAgICB2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcblxuICAgIHRoaXMuc2V0KFxuXG4gICAgICB0eCAqIHggKyBjLCB0eCAqIHkgLSBzICogeiwgdHggKiB6ICsgcyAqIHksIDAsXG4gICAgICB0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXG4gICAgICB0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXG4gICAgICAwLCAwLCAwLCAxXG5cbiAgICApO1xuXG4gICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XG5cbiAgICB0aGlzLnNldChcblxuICAgICAgeCwgMCwgMCwgMCxcbiAgICAgIDAsIHksIDAsIDAsXG4gICAgICAwLCAwLCB6LCAwLFxuICAgICAgMCwgMCwgMCwgMVxuXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29tcG9zZTogZnVuY3Rpb24gKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKSB7XG5cbiAgICB0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG4gICAgdGhpcy5zY2FsZSggc2NhbGUgKTtcbiAgICB0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkZWNvbXBvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2ZWN0b3IsIG1hdHJpeDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcblxuICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICBpZiAoIG1hdHJpeCA9PT0gdW5kZWZpbmVkICkgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgdmFyIHN4ID0gdmVjdG9yLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xuICAgICAgdmFyIHN5ID0gdmVjdG9yLnNldCggdGVbIDQgXSwgdGVbIDUgXSwgdGVbIDYgXSApLmxlbmd0aCgpO1xuICAgICAgdmFyIHN6ID0gdmVjdG9yLnNldCggdGVbIDggXSwgdGVbIDkgXSwgdGVbIDEwIF0gKS5sZW5ndGgoKTtcblxuICAgICAgLy8gaWYgZGV0ZXJtaW5lIGlzIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGludmVydCBvbmUgc2NhbGVcbiAgICAgIHZhciBkZXQgPSB0aGlzLmRldGVybWluYW50KCk7XG4gICAgICBpZiAoIGRldCA8IDAgKSB7XG5cbiAgICAgICAgc3ggPSAtIHN4O1xuXG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9uLnggPSB0ZVsgMTIgXTtcbiAgICAgIHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcbiAgICAgIHBvc2l0aW9uLnogPSB0ZVsgMTQgXTtcblxuICAgICAgLy8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcblxuICAgICAgbWF0cml4LmVsZW1lbnRzLnNldCggdGhpcy5lbGVtZW50cyApOyAvLyBhdCB0aGlzIHBvaW50IG1hdHJpeCBpcyBpbmNvbXBsZXRlIHNvIHdlIGNhbid0IHVzZSAuY29weSgpXG5cbiAgICAgIHZhciBpbnZTWCA9IDEgLyBzeDtcbiAgICAgIHZhciBpbnZTWSA9IDEgLyBzeTtcbiAgICAgIHZhciBpbnZTWiA9IDEgLyBzejtcblxuICAgICAgbWF0cml4LmVsZW1lbnRzWyAwIF0gKj0gaW52U1g7XG4gICAgICBtYXRyaXguZWxlbWVudHNbIDEgXSAqPSBpbnZTWDtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xuXG4gICAgICBtYXRyaXguZWxlbWVudHNbIDQgXSAqPSBpbnZTWTtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgNSBdICo9IGludlNZO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWyA2IF0gKj0gaW52U1k7XG5cbiAgICAgIG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWyA5IF0gKj0gaW52U1o7XG4gICAgICBtYXRyaXguZWxlbWVudHNbIDEwIF0gKj0gaW52U1o7XG5cbiAgICAgIHF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtYXRyaXggKTtcblxuICAgICAgc2NhbGUueCA9IHN4O1xuICAgICAgc2NhbGUueSA9IHN5O1xuICAgICAgc2NhbGUueiA9IHN6O1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIG1ha2VGcnVzdHVtOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICB2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcbiAgICB2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcblxuICAgIHZhciBhID0gKCByaWdodCArIGxlZnQgKSAvICggcmlnaHQgLSBsZWZ0ICk7XG4gICAgdmFyIGIgPSAoIHRvcCArIGJvdHRvbSApIC8gKCB0b3AgLSBib3R0b20gKTtcbiAgICB2YXIgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcbiAgICB2YXIgZCA9IC0gMiAqIGZhciAqIG5lYXIgLyAoIGZhciAtIG5lYXIgKTtcblxuICAgIHRlWyAwIF0gPSB4OyAgdGVbIDQgXSA9IDA7ICB0ZVsgOCBdID0gYTsgIHRlWyAxMiBdID0gMDtcbiAgICB0ZVsgMSBdID0gMDsgIHRlWyA1IF0gPSB5OyAgdGVbIDkgXSA9IGI7ICB0ZVsgMTMgXSA9IDA7XG4gICAgdGVbIDIgXSA9IDA7ICB0ZVsgNiBdID0gMDsgIHRlWyAxMCBdID0gYzsgdGVbIDE0IF0gPSBkO1xuICAgIHRlWyAzIF0gPSAwOyAgdGVbIDcgXSA9IDA7ICB0ZVsgMTEgXSA9IC0gMTsgdGVbIDE1IF0gPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcblxuICAgIHZhciB5bWF4ID0gbmVhciAqIE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCBmb3YgKiAwLjUgKSApO1xuICAgIHZhciB5bWluID0gLSB5bWF4O1xuICAgIHZhciB4bWluID0geW1pbiAqIGFzcGVjdDtcbiAgICB2YXIgeG1heCA9IHltYXggKiBhc3BlY3Q7XG5cbiAgICByZXR1cm4gdGhpcy5tYWtlRnJ1c3R1bSggeG1pbiwgeG1heCwgeW1pbiwgeW1heCwgbmVhciwgZmFyICk7XG5cbiAgfSxcblxuICBtYWtlT3J0aG9ncmFwaGljOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xuXG4gICAgdmFyIHRlID0gdGhpcy5lbGVtZW50cztcbiAgICB2YXIgdyA9IHJpZ2h0IC0gbGVmdDtcbiAgICB2YXIgaCA9IHRvcCAtIGJvdHRvbTtcbiAgICB2YXIgcCA9IGZhciAtIG5lYXI7XG5cbiAgICB2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgLyB3O1xuICAgIHZhciB5ID0gKCB0b3AgKyBib3R0b20gKSAvIGg7XG4gICAgdmFyIHogPSAoIGZhciArIG5lYXIgKSAvIHA7XG5cbiAgICB0ZVsgMCBdID0gMiAvIHc7ICB0ZVsgNCBdID0gMDsgIHRlWyA4IF0gPSAwOyAgdGVbIDEyIF0gPSAtIHg7XG4gICAgdGVbIDEgXSA9IDA7ICB0ZVsgNSBdID0gMiAvIGg7ICB0ZVsgOSBdID0gMDsgIHRlWyAxMyBdID0gLSB5O1xuICAgIHRlWyAyIF0gPSAwOyAgdGVbIDYgXSA9IDA7ICB0ZVsgMTAgXSA9IC0gMiAvIHA7IHRlWyAxNCBdID0gLSB6O1xuICAgIHRlWyAzIF0gPSAwOyAgdGVbIDcgXSA9IDA7ICB0ZVsgMTEgXSA9IDA7IHRlWyAxNSBdID0gMTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgdGhpcy5lbGVtZW50cy5zZXQoIGFycmF5ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICByZXR1cm4gW1xuICAgICAgdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSwgdGVbIDMgXSxcbiAgICAgIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0sIHRlWyA3IF0sXG4gICAgICB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSwgdGVbIDExIF0sXG4gICAgICB0ZVsgMTIgXSwgdGVbIDEzIF0sIHRlWyAxNCBdLCB0ZVsgMTUgXVxuICAgIF07XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5NYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1JheS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cblRIUkVFLlJheSA9IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgdGhpcy5vcmlnaW4gPSAoIG9yaWdpbiAhPT0gdW5kZWZpbmVkICkgPyBvcmlnaW4gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB0aGlzLmRpcmVjdGlvbiA9ICggZGlyZWN0aW9uICE9PSB1bmRlZmluZWQgKSA/IGRpcmVjdGlvbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbn07XG5cblRIUkVFLlJheS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlJheSxcblxuICBzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICB0aGlzLm9yaWdpbi5jb3B5KCBvcmlnaW4gKTtcbiAgICB0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCByYXkgKSB7XG5cbiAgICB0aGlzLm9yaWdpbi5jb3B5KCByYXkub3JpZ2luICk7XG4gICAgdGhpcy5kaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gIH0sXG5cbiAgcmVjYXN0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdCApIHtcblxuICAgICAgdGhpcy5vcmlnaW4uY29weSggdGhpcy5hdCggdCwgdjEgKSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xuICAgIHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICBpZiAoIGRpcmVjdGlvbkRpc3RhbmNlIDwgMCApIHtcblxuICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm9yaWdpbiApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCBkaXJlY3Rpb25EaXN0YW5jZSApLmFkZCggdGhpcy5vcmlnaW4gKTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgICB2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB2MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICAgIC8vIHBvaW50IGJlaGluZCB0aGUgcmF5XG5cbiAgICAgIGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xuXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvKCBwb2ludCApO1xuXG4gICAgICB9XG5cbiAgICAgIHYxLmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xuXG4gICAgICByZXR1cm4gdjEuZGlzdGFuY2VUbyggcG9pbnQgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzZWdDZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBzZWdEaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBkaWZmID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG4gICAgICAvLyBmcm9tIGh0dHA6Ly93d3cuZ2VvbWV0cmljdG9vbHMuY29tL0xpYk1hdGhlbWF0aWNzL0Rpc3RhbmNlL1dtNURpc3RSYXkzU2VnbWVudDMuY3BwXG4gICAgICAvLyBJdCByZXR1cm5zIHRoZSBtaW4gZGlzdGFuY2UgYmV0d2VlbiB0aGUgcmF5IGFuZCB0aGUgc2VnbWVudFxuICAgICAgLy8gZGVmaW5lZCBieSB2MCBhbmQgdjFcbiAgICAgIC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XG4gICAgICAvLyAtIFRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSByYXlcbiAgICAgIC8vIC0gVGhlIGNsb3Nlc3QgcG9pbnQgb24gdGhlIHNlZ21lbnRcblxuICAgICAgc2VnQ2VudGVyLmNvcHkoIHYwICkuYWRkKCB2MSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcbiAgICAgIHNlZ0Rpci5jb3B5KCB2MSApLnN1YiggdjAgKS5ub3JtYWxpemUoKTtcbiAgICAgIGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xuXG4gICAgICB2YXIgc2VnRXh0ZW50ID0gdjAuZGlzdGFuY2VUbyggdjEgKSAqIDAuNTtcbiAgICAgIHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XG4gICAgICB2YXIgYjAgPSBkaWZmLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcbiAgICAgIHZhciBiMSA9IC0gZGlmZi5kb3QoIHNlZ0RpciApO1xuICAgICAgdmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XG4gICAgICB2YXIgZGV0ID0gTWF0aC5hYnMoIDEgLSBhMDEgKiBhMDEgKTtcbiAgICAgIHZhciBzMCwgczEsIHNxckRpc3QsIGV4dERldDtcblxuICAgICAgaWYgKCBkZXQgPiAwICkge1xuXG4gICAgICAgIC8vIFRoZSByYXkgYW5kIHNlZ21lbnQgYXJlIG5vdCBwYXJhbGxlbC5cblxuICAgICAgICBzMCA9IGEwMSAqIGIxIC0gYjA7XG4gICAgICAgIHMxID0gYTAxICogYjAgLSBiMTtcbiAgICAgICAgZXh0RGV0ID0gc2VnRXh0ZW50ICogZGV0O1xuXG4gICAgICAgIGlmICggczAgPj0gMCApIHtcblxuICAgICAgICAgIGlmICggczEgPj0gLSBleHREZXQgKSB7XG5cbiAgICAgICAgICAgIGlmICggczEgPD0gZXh0RGV0ICkge1xuXG4gICAgICAgICAgICAgIC8vIHJlZ2lvbiAwXG4gICAgICAgICAgICAgIC8vIE1pbmltdW0gYXQgaW50ZXJpb3IgcG9pbnRzIG9mIHJheSBhbmQgc2VnbWVudC5cblxuICAgICAgICAgICAgICB2YXIgaW52RGV0ID0gMSAvIGRldDtcbiAgICAgICAgICAgICAgczAgKj0gaW52RGV0O1xuICAgICAgICAgICAgICBzMSAqPSBpbnZEZXQ7XG4gICAgICAgICAgICAgIHNxckRpc3QgPSBzMCAqICggczAgKyBhMDEgKiBzMSArIDIgKiBiMCApICsgczEgKiAoIGEwMSAqIHMwICsgczEgKyAyICogYjEgKSArIGM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgLy8gcmVnaW9uIDFcblxuICAgICAgICAgICAgICBzMSA9IHNlZ0V4dGVudDtcbiAgICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuICAgICAgICAgICAgICBzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyByZWdpb24gNVxuXG4gICAgICAgICAgICBzMSA9IC0gc2VnRXh0ZW50O1xuICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xuICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKCBzMSA8PSAtIGV4dERldCApIHtcblxuICAgICAgICAgICAgLy8gcmVnaW9uIDRcblxuICAgICAgICAgICAgczAgPSBNYXRoLm1heCggMCwgLSAoIC0gYTAxICogc2VnRXh0ZW50ICsgYjAgKSApO1xuICAgICAgICAgICAgczEgPSAoIHMwID4gMCApID8gLSBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgIH0gZWxzZSBpZiAoIHMxIDw9IGV4dERldCApIHtcblxuICAgICAgICAgICAgLy8gcmVnaW9uIDNcblxuICAgICAgICAgICAgczAgPSAwO1xuICAgICAgICAgICAgczEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgc3FyRGlzdCA9IHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIHJlZ2lvbiAyXG5cbiAgICAgICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XG4gICAgICAgICAgICBzMSA9ICggczAgPiAwICkgPyBzZWdFeHRlbnQgOiBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xuICAgICAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gUmF5IGFuZCBzZWdtZW50IGFyZSBwYXJhbGxlbC5cblxuICAgICAgICBzMSA9ICggYTAxID4gMCApID8gLSBzZWdFeHRlbnQgOiBzZWdFeHRlbnQ7XG4gICAgICAgIHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzMSArIGIwICkgKTtcbiAgICAgICAgc3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG9wdGlvbmFsUG9pbnRPblJheSApIHtcblxuICAgICAgICBvcHRpb25hbFBvaW50T25SYXkuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggczAgKS5hZGQoIHRoaXMub3JpZ2luICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xuXG4gICAgICAgIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQuY29weSggc2VnRGlyICkubXVsdGlwbHlTY2FsYXIoIHMxICkuYWRkKCBzZWdDZW50ZXIgKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3FyRGlzdDtcblxuICAgIH07XG5cbiAgfSgpLFxuXG5cbiAgaXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBzcGhlcmUuY2VudGVyICkgPD0gc3BoZXJlLnJhZGl1cztcblxuICB9LFxuXG4gIGludGVyc2VjdFNwaGVyZTogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gZnJvbSBodHRwOi8vd3d3LnNjcmF0Y2hhcGl4ZWwuY29tL2xlc3NvbnMvM2QtYmFzaWMtbGVzc29ucy9sZXNzb24tNy1pbnRlcnNlY3Rpbmctc2ltcGxlLXNoYXBlcy9yYXktc3BoZXJlLWludGVyc2VjdGlvbi9cblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBzcGhlcmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2MS5zdWJWZWN0b3JzKCBzcGhlcmUuY2VudGVyLCB0aGlzLm9yaWdpbiApO1xuXG4gICAgICB2YXIgdGNhID0gdjEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xuXG4gICAgICB2YXIgZDIgPSB2MS5kb3QoIHYxICkgLSB0Y2EgKiB0Y2E7XG5cbiAgICAgIHZhciByYWRpdXMyID0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7XG5cbiAgICAgIGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XG5cbiAgICAgIHZhciB0aGMgPSBNYXRoLnNxcnQoIHJhZGl1czIgLSBkMiApO1xuXG4gICAgICAvLyB0MCA9IGZpcnN0IGludGVyc2VjdCBwb2ludCAtIGVudHJhbmNlIG9uIGZyb250IG9mIHNwaGVyZVxuICAgICAgdmFyIHQwID0gdGNhIC0gdGhjO1xuXG4gICAgICAvLyB0MSA9IHNlY29uZCBpbnRlcnNlY3QgcG9pbnQgLSBleGl0IHBvaW50IG9uIGJhY2sgb2Ygc3BoZXJlXG4gICAgICB2YXIgdDEgPSB0Y2EgKyB0aGM7XG5cbiAgICAgIC8vIHRlc3QgdG8gc2VlIGlmIGJvdGggdDAgYW5kIHQxIGFyZSBiZWhpbmQgdGhlIHJheSAtIGlmIHNvLCByZXR1cm4gbnVsbFxuICAgICAgaWYgKCB0MCA8IDAgJiYgdDEgPCAwICkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIHRlc3QgdG8gc2VlIGlmIHQwIGlzIGJlaGluZCB0aGUgcmF5OlxuICAgICAgLy8gaWYgaXQgaXMsIHRoZSByYXkgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHNvIHJldHVybiB0aGUgc2Vjb25kIGV4aXQgcG9pbnQgc2NhbGVkIGJ5IHQxLFxuICAgICAgLy8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxuICAgICAgaWYgKCB0MCA8IDAgKSByZXR1cm4gdGhpcy5hdCggdDEsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICAgIC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwXG4gICAgICByZXR1cm4gdGhpcy5hdCggdDAsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIGlzSW50ZXJzZWN0aW9uUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgcmF5IGxpZXMgb24gdGhlIHBsYW5lIGZpcnN0XG5cbiAgICB2YXIgZGlzdFRvUG9pbnQgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICk7XG5cbiAgICBpZiAoIGRpc3RUb1BvaW50ID09PSAwICkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgICBpZiAoIGRlbm9taW5hdG9yICogZGlzdFRvUG9pbnQgPCAwICkge1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIC8vIHJheSBvcmlnaW4gaXMgYmVoaW5kIHRoZSBwbGFuZSAoYW5kIGlzIHBvaW50aW5nIGJlaGluZCBpdClcblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuICAgIHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XG4gICAgaWYgKCBkZW5vbWluYXRvciA9PT0gMCApIHtcblxuICAgICAgLy8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxuICAgICAgaWYgKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT09IDAgKSB7XG5cbiAgICAgICAgcmV0dXJuIDA7XG5cbiAgICAgIH1cblxuICAgICAgLy8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIH1cblxuICAgIHZhciB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cbiAgICAvLyBSZXR1cm4gaWYgdGhlIHJheSBuZXZlciBpbnRlcnNlY3RzIHRoZSBwbGFuZVxuXG4gICAgcmV0dXJuIHQgPj0gMCA/IHQgOiAgbnVsbDtcblxuICB9LFxuXG4gIGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciB0ID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoIHBsYW5lICk7XG5cbiAgICBpZiAoIHQgPT09IG51bGwgKSB7XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmF0KCB0LCBvcHRpb25hbFRhcmdldCApO1xuXG4gIH0sXG5cbiAgaXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGJveCApIHtcblxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0Qm94KCBib3gsIHYgKSAhPT0gbnVsbDtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGludGVyc2VjdEJveDogZnVuY3Rpb24gKCBib3gsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgLy8gaHR0cDovL3d3dy5zY3JhdGNoYXBpeGVsLmNvbS9sZXNzb25zLzNkLWJhc2ljLWxlc3NvbnMvbGVzc29uLTctaW50ZXJzZWN0aW5nLXNpbXBsZS1zaGFwZXMvcmF5LWJveC1pbnRlcnNlY3Rpb24vXG5cbiAgICB2YXIgdG1pbix0bWF4LHR5bWluLHR5bWF4LHR6bWluLHR6bWF4O1xuXG4gICAgdmFyIGludmRpcnggPSAxIC8gdGhpcy5kaXJlY3Rpb24ueCxcbiAgICAgIGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcbiAgICAgIGludmRpcnogPSAxIC8gdGhpcy5kaXJlY3Rpb24uejtcblxuICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuICAgIGlmICggaW52ZGlyeCA+PSAwICkge1xuXG4gICAgICB0bWluID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcbiAgICAgIHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XG4gICAgICB0bWF4ID0gKCBib3gubWluLnggLSBvcmlnaW4ueCApICogaW52ZGlyeDtcbiAgICB9XG5cbiAgICBpZiAoIGludmRpcnkgPj0gMCApIHtcblxuICAgICAgdHltaW4gPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgICAgdHltYXggPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdHltaW4gPSAoIGJveC5tYXgueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgICAgdHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xuICAgIH1cblxuICAgIGlmICggKCB0bWluID4gdHltYXggKSB8fCAoIHR5bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBUaGVzZSBsaW5lcyBhbHNvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0bWluIG9yIHRtYXggaXMgTmFOXG4gICAgLy8gKHJlc3VsdCBvZiAwICogSW5maW5pdHkpLiB4ICE9PSB4IHJldHVybnMgdHJ1ZSBpZiB4IGlzIE5hTlxuXG4gICAgaWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcblxuICAgIGlmICggdHltYXggPCB0bWF4IHx8IHRtYXggIT09IHRtYXggKSB0bWF4ID0gdHltYXg7XG5cbiAgICBpZiAoIGludmRpcnogPj0gMCApIHtcblxuICAgICAgdHptaW4gPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuICAgICAgdHptYXggPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdHptaW4gPSAoIGJveC5tYXgueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuICAgICAgdHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xuICAgIH1cblxuICAgIGlmICggKCB0bWluID4gdHptYXggKSB8fCAoIHR6bWluID4gdG1heCApICkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoIHR6bWluID4gdG1pbiB8fCB0bWluICE9PSB0bWluICkgdG1pbiA9IHR6bWluO1xuXG4gICAgaWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcblxuICAgIC8vcmV0dXJuIHBvaW50IGNsb3Nlc3QgdG8gdGhlIHJheSAocG9zaXRpdmUgc2lkZSlcblxuICAgIGlmICggdG1heCA8IDAgKSByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICB9LFxuXG4gIGludGVyc2VjdFRyaWFuZ2xlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBvZmZzZXQgb3JpZ2luLCBlZGdlcywgYW5kIG5vcm1hbC5cbiAgICB2YXIgZGlmZiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGVkZ2UxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgZWRnZTIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYywgYmFja2ZhY2VDdWxsaW5nLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgLy8gZnJvbSBodHRwOi8vd3d3Lmdlb21ldHJpY3Rvb2xzLmNvbS9MaWJNYXRoZW1hdGljcy9JbnRlcnNlY3Rpb24vV201SW50clJheTNUcmlhbmdsZTMuY3BwXG5cbiAgICAgIGVkZ2UxLnN1YlZlY3RvcnMoIGIsIGEgKTtcbiAgICAgIGVkZ2UyLnN1YlZlY3RvcnMoIGMsIGEgKTtcbiAgICAgIG5vcm1hbC5jcm9zc1ZlY3RvcnMoIGVkZ2UxLCBlZGdlMiApO1xuXG4gICAgICAvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcbiAgICAgIC8vIEUxID0ga0VkZ2UxLCBFMiA9IGtFZGdlMiwgTiA9IENyb3NzKEUxLEUyKSkgYnlcbiAgICAgIC8vICAgfERvdChELE4pfCpiMSA9IHNpZ24oRG90KEQsTikpKkRvdChELENyb3NzKFEsRTIpKVxuICAgICAgLy8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXG4gICAgICAvLyAgIHxEb3QoRCxOKXwqdCA9IC1zaWduKERvdChELE4pKSpEb3QoUSxOKVxuICAgICAgdmFyIERkTiA9IHRoaXMuZGlyZWN0aW9uLmRvdCggbm9ybWFsICk7XG4gICAgICB2YXIgc2lnbjtcblxuICAgICAgaWYgKCBEZE4gPiAwICkge1xuXG4gICAgICAgIGlmICggYmFja2ZhY2VDdWxsaW5nICkgcmV0dXJuIG51bGw7XG4gICAgICAgIHNpZ24gPSAxO1xuXG4gICAgICB9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xuXG4gICAgICAgIHNpZ24gPSAtIDE7XG4gICAgICAgIERkTiA9IC0gRGROO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICB9XG5cbiAgICAgIGRpZmYuc3ViVmVjdG9ycyggdGhpcy5vcmlnaW4sIGEgKTtcbiAgICAgIHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcblxuICAgICAgLy8gYjEgPCAwLCBubyBpbnRlcnNlY3Rpb25cbiAgICAgIGlmICggRGRReEUyIDwgMCApIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgfVxuXG4gICAgICB2YXIgRGRFMXhRID0gc2lnbiAqIHRoaXMuZGlyZWN0aW9uLmRvdCggZWRnZTEuY3Jvc3MoIGRpZmYgKSApO1xuXG4gICAgICAvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxuICAgICAgaWYgKCBEZEUxeFEgPCAwICkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIGIxK2IyID4gMSwgbm8gaW50ZXJzZWN0aW9uXG4gICAgICBpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcblxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgfVxuXG4gICAgICAvLyBMaW5lIGludGVyc2VjdHMgdHJpYW5nbGUsIGNoZWNrIGlmIHJheSBkb2VzLlxuICAgICAgdmFyIFFkTiA9IC0gc2lnbiAqIGRpZmYuZG90KCBub3JtYWwgKTtcblxuICAgICAgLy8gdCA8IDAsIG5vIGludGVyc2VjdGlvblxuICAgICAgaWYgKCBRZE4gPCAwICkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxuICAgICAgcmV0dXJuIHRoaXMuYXQoIFFkTiAvIERkTiwgb3B0aW9uYWxUYXJnZXQgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtYXRyaXg0ICkge1xuXG4gICAgdGhpcy5kaXJlY3Rpb24uYWRkKCB0aGlzLm9yaWdpbiApLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuICAgIHRoaXMub3JpZ2luLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xuICAgIHRoaXMuZGlyZWN0aW9uLnN1YiggdGhpcy5vcmlnaW4gKTtcbiAgICB0aGlzLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGVxdWFsczogZnVuY3Rpb24gKCByYXkgKSB7XG5cbiAgICByZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5SYXkoKS5jb3B5KCB0aGlzICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1NwaGVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TcGhlcmUgPSBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG4gIHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAwO1xuXG59O1xuXG5USFJFRS5TcGhlcmUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5TcGhlcmUsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIGNlbnRlciwgcmFkaXVzICkge1xuXG4gICAgdGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XG4gICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XG5cbiAgICAgIHZhciBjZW50ZXIgPSB0aGlzLmNlbnRlcjtcblxuICAgICAgaWYgKCBvcHRpb25hbENlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNlbnRlci5jb3B5KCBvcHRpb25hbENlbnRlciApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGJveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5jZW50ZXIoIGNlbnRlciApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhSYWRpdXNTcSA9IDA7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xuXG4gICAgICB9XG5cbiAgICAgIHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGNvcHk6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgdGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xuICAgIHRoaXMucmFkaXVzID0gc3BoZXJlLnJhZGl1cztcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZW1wdHk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcblxuICB9LFxuXG4gIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICByZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgcmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XG5cbiAgfSxcblxuICBpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcblxuICAgIHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XG5cbiAgICByZXR1cm4gc3BoZXJlLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHJhZGl1c1N1bSAqIHJhZGl1c1N1bSApO1xuXG4gIH0sXG5cbiAgY2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmVzdWx0LmNvcHkoIHBvaW50ICk7XG5cbiAgICBpZiAoIGRlbHRhTGVuZ3RoU3EgPiAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApIHtcblxuICAgICAgcmVzdWx0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcbiAgICAgIHJlc3VsdC5tdWx0aXBseVNjYWxhciggdGhpcy5yYWRpdXMgKS5hZGQoIHRoaXMuY2VudGVyICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIH0sXG5cbiAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgYm94ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xuICAgIGJveC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcblxuICAgIHJldHVybiBib3g7XG5cbiAgfSxcblxuICBhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgdGhpcy5jZW50ZXIuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcbiAgICB0aGlzLnJhZGl1cyA9IHRoaXMucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XG5cbiAgICB0aGlzLmNlbnRlci5hZGQoIG9mZnNldCApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgcmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLlNwaGVyZSgpLmNvcHkoIHRoaXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvRnJ1c3R1bS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcblxuICB0aGlzLnBsYW5lcyA9IFtcblxuICAgICggcDAgIT09IHVuZGVmaW5lZCApID8gcDAgOiBuZXcgVEhSRUUuUGxhbmUoKSxcbiAgICAoIHAxICE9PSB1bmRlZmluZWQgKSA/IHAxIDogbmV3IFRIUkVFLlBsYW5lKCksXG4gICAgKCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBUSFJFRS5QbGFuZSgpLFxuICAgICggcDMgIT09IHVuZGVmaW5lZCApID8gcDMgOiBuZXcgVEhSRUUuUGxhbmUoKSxcbiAgICAoIHA0ICE9PSB1bmRlZmluZWQgKSA/IHA0IDogbmV3IFRIUkVFLlBsYW5lKCksXG4gICAgKCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBUSFJFRS5QbGFuZSgpXG5cbiAgXTtcblxufTtcblxuVEhSRUUuRnJ1c3R1bS5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLkZydXN0dW0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XG5cbiAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICBwbGFuZXNbIDAgXS5jb3B5KCBwMCApO1xuICAgIHBsYW5lc1sgMSBdLmNvcHkoIHAxICk7XG4gICAgcGxhbmVzWyAyIF0uY29weSggcDIgKTtcbiAgICBwbGFuZXNbIDMgXS5jb3B5KCBwMyApO1xuICAgIHBsYW5lc1sgNCBdLmNvcHkoIHA0ICk7XG4gICAgcGxhbmVzWyA1IF0uY29weSggcDUgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCBmcnVzdHVtICkge1xuXG4gICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcblxuICAgICAgcGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG4gICAgdmFyIG1lID0gbS5lbGVtZW50cztcbiAgICB2YXIgbWUwID0gbWVbIDAgXSwgbWUxID0gbWVbIDEgXSwgbWUyID0gbWVbIDIgXSwgbWUzID0gbWVbIDMgXTtcbiAgICB2YXIgbWU0ID0gbWVbIDQgXSwgbWU1ID0gbWVbIDUgXSwgbWU2ID0gbWVbIDYgXSwgbWU3ID0gbWVbIDcgXTtcbiAgICB2YXIgbWU4ID0gbWVbIDggXSwgbWU5ID0gbWVbIDkgXSwgbWUxMCA9IG1lWyAxMCBdLCBtZTExID0gbWVbIDExIF07XG4gICAgdmFyIG1lMTIgPSBtZVsgMTIgXSwgbWUxMyA9IG1lWyAxMyBdLCBtZTE0ID0gbWVbIDE0IF0sIG1lMTUgPSBtZVsgMTUgXTtcblxuICAgIHBsYW5lc1sgMCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMCwgbWU3IC0gbWU0LCBtZTExIC0gbWU4LCBtZTE1IC0gbWUxMiApLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1sgMSBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMCwgbWU3ICsgbWU0LCBtZTExICsgbWU4LCBtZTE1ICsgbWUxMiApLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1sgMiBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMyApLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1sgMyBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMSwgbWU3IC0gbWU1LCBtZTExIC0gbWU5LCBtZTE1IC0gbWUxMyApLm5vcm1hbGl6ZSgpO1xuICAgIHBsYW5lc1sgNCBdLnNldENvbXBvbmVudHMoIG1lMyAtIG1lMiwgbWU3IC0gbWU2LCBtZTExIC0gbWUxMCwgbWUxNSAtIG1lMTQgKS5ub3JtYWxpemUoKTtcbiAgICBwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0ICkubm9ybWFsaXplKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGludGVyc2VjdHNPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBzcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gICAgICBzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcbiAgICAgIHNwaGVyZS5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xuXG4gICAgdmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xuICAgIHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xuICAgIHZhciBuZWdSYWRpdXMgPSAtIHNwaGVyZS5yYWRpdXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgICB2YXIgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xuXG4gICAgICBpZiAoIGRpc3RhbmNlIDwgbmVnUmFkaXVzICkge1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSxcblxuICBpbnRlcnNlY3RzQm94OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcDEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgcDIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYm94ICkge1xuXG4gICAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDYgOyBpICsrICkge1xuXG4gICAgICAgIHZhciBwbGFuZSA9IHBsYW5lc1sgaSBdO1xuXG4gICAgICAgIHAxLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWluLnggOiBib3gubWF4Lng7XG4gICAgICAgIHAyLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWF4LnggOiBib3gubWluLng7XG4gICAgICAgIHAxLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWluLnkgOiBib3gubWF4Lnk7XG4gICAgICAgIHAyLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWF4LnkgOiBib3gubWluLnk7XG4gICAgICAgIHAxLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWluLnogOiBib3gubWF4Lno7XG4gICAgICAgIHAyLnogPSBwbGFuZS5ub3JtYWwueiA+IDAgPyBib3gubWF4LnogOiBib3gubWluLno7XG5cbiAgICAgICAgdmFyIGQxID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCBwMSApO1xuICAgICAgICB2YXIgZDIgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAyICk7XG5cbiAgICAgICAgLy8gaWYgYm90aCBvdXRzaWRlIHBsYW5lLCBubyBpbnRlcnNlY3Rpb25cblxuICAgICAgICBpZiAoIGQxIDwgMCAmJiBkMiA8IDAgKSB7XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gIH0oKSxcblxuXG4gIGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XG5cbiAgICB2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgICBpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkZydXN0dW0oKS5jb3B5KCB0aGlzICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL1BsYW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXG4gKi9cblxuVEhSRUUuUGxhbmUgPSBmdW5jdGlvbiAoIG5vcm1hbCwgY29uc3RhbnQgKSB7XG5cbiAgdGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuICB0aGlzLmNvbnN0YW50ID0gKCBjb25zdGFudCAhPT0gdW5kZWZpbmVkICkgPyBjb25zdGFudCA6IDA7XG5cbn07XG5cblRIUkVFLlBsYW5lLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuUGxhbmUsXG5cbiAgc2V0OiBmdW5jdGlvbiAoIG5vcm1hbCwgY29uc3RhbnQgKSB7XG5cbiAgICB0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcbiAgICB0aGlzLmNvbnN0YW50ID0gY29uc3RhbnQ7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldENvbXBvbmVudHM6IGZ1bmN0aW9uICggeCwgeSwgeiwgdyApIHtcblxuICAgIHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xuICAgIHRoaXMuY29uc3RhbnQgPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludDogZnVuY3Rpb24gKCBub3JtYWwsIHBvaW50ICkge1xuXG4gICAgdGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgdGhpcy5jb25zdGFudCA9IC0gcG9pbnQuZG90KCB0aGlzLm5vcm1hbCApOyAvLyBtdXN0IGJlIHRoaXMubm9ybWFsLCBub3Qgbm9ybWFsLCBhcyB0aGlzLm5vcm1hbCBpcyBub3JtYWxpemVkXG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldEZyb21Db3BsYW5hclBvaW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuICAgICAgdmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XG5cbiAgICAgIC8vIFE6IHNob3VsZCBhbiBlcnJvciBiZSB0aHJvd24gaWYgbm9ybWFsIGlzIHplcm8gKGUuZy4gZGVnZW5lcmF0ZSBwbGFuZSk/XG5cbiAgICAgIHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH07XG5cbiAgfSgpLFxuXG5cbiAgY29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcblxuICAgIHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xuICAgIHRoaXMuY29uc3RhbnQgPSBwbGFuZS5jb25zdGFudDtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cblxuICAgIHZhciBpbnZlcnNlTm9ybWFsTGVuZ3RoID0gMS4wIC8gdGhpcy5ub3JtYWwubGVuZ3RoKCk7XG4gICAgdGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcbiAgICB0aGlzLmNvbnN0YW50ICo9IGludmVyc2VOb3JtYWxMZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5jb25zdGFudCAqPSAtIDE7XG4gICAgdGhpcy5ub3JtYWwubmVnYXRlKCk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcblxuICAgIHJldHVybiB0aGlzLm5vcm1hbC5kb3QoIHBvaW50ICkgKyB0aGlzLmNvbnN0YW50O1xuXG4gIH0sXG5cbiAgZGlzdGFuY2VUb1NwaGVyZTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XG5cbiAgfSxcblxuICBwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgcmV0dXJuIHRoaXMub3J0aG9Qb2ludCggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkuc3ViKCBwb2ludCApLm5lZ2F0ZSgpO1xuXG4gIH0sXG5cbiAgb3J0aG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcGVycGVuZGljdWxhck1hZ25pdHVkZSA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCBwZXJwZW5kaWN1bGFyTWFnbml0dWRlICk7XG5cbiAgfSxcblxuICBpc0ludGVyc2VjdGlvbkxpbmU6IGZ1bmN0aW9uICggbGluZSApIHtcblxuICAgIC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxuXG4gICAgdmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XG4gICAgdmFyIGVuZFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5lbmQgKTtcblxuICAgIHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcblxuICB9LFxuXG4gIGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSBsaW5lLmRlbHRhKCB2MSApO1xuXG4gICAgICB2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xuXG4gICAgICBpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xuXG4gICAgICAgIC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cbiAgICAgICAgaWYgKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApID09PSAwICkge1xuXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5jb3B5KCBsaW5lLnN0YXJ0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVuc3VyZSBpZiB0aGlzIGlzIHRoZSBjb3JyZWN0IG1ldGhvZCB0byBoYW5kbGUgdGhpcyBjYXNlLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gLSAoIGxpbmUuc3RhcnQuZG90KCB0aGlzLm5vcm1hbCApICsgdGhpcy5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XG5cbiAgICAgIGlmICggdCA8IDAgfHwgdCA+IDEgKSB7XG5cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0LmNvcHkoIGRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCBsaW5lLnN0YXJ0ICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuXG4gIGNvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIC0gdGhpcy5jb25zdGFudCApO1xuXG4gIH0sXG5cbiAgYXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG1hdHJpeCwgb3B0aW9uYWxOb3JtYWxNYXRyaXggKSB7XG5cbiAgICAgIC8vIGNvbXB1dGUgbmV3IG5vcm1hbCBiYXNlZCBvbiB0aGVvcnkgaGVyZTpcbiAgICAgIC8vIGh0dHA6Ly93d3cuc29uZ2hvLmNhL29wZW5nbC9nbF9ub3JtYWx0cmFuc2Zvcm0uaHRtbFxuICAgICAgdmFyIG5vcm1hbE1hdHJpeCA9IG9wdGlvbmFsTm9ybWFsTWF0cml4IHx8IG0xLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG4gICAgICB2YXIgbmV3Tm9ybWFsID0gdjEuY29weSggdGhpcy5ub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApO1xuXG4gICAgICB2YXIgbmV3Q29wbGFuYXJQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjIgKTtcbiAgICAgIG5ld0NvcGxhbmFyUG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcblxuICAgICAgdGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbmV3Tm9ybWFsLCBuZXdDb3BsYW5hclBvaW50ICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcblxuICAgIHRoaXMuY29uc3RhbnQgPSB0aGlzLmNvbnN0YW50IC0gb2Zmc2V0LmRvdCggdGhpcy5ub3JtYWwgKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xuXG4gICAgcmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PT0gdGhpcy5jb25zdGFudCApO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBuZXcgVEhSRUUuUGxhbmUoKS5jb3B5KCB0aGlzICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRoL01hdGguanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5NYXRoID0ge1xuXG4gIGdlbmVyYXRlVVVJRDogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gaHR0cDovL3d3dy5icm9vZmEuY29tL1Rvb2xzL01hdGgudXVpZC5odG1cblxuICAgIHZhciBjaGFycyA9ICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eicuc3BsaXQoICcnICk7XG4gICAgdmFyIHV1aWQgPSBuZXcgQXJyYXkoIDM2ICk7XG4gICAgdmFyIHJuZCA9IDAsIHI7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCAzNjsgaSArKyApIHtcblxuICAgICAgICBpZiAoIGkgPT09IDggfHwgaSA9PT0gMTMgfHwgaSA9PT0gMTggfHwgaSA9PT0gMjMgKSB7XG5cbiAgICAgICAgICB1dWlkWyBpIF0gPSAnLSc7XG5cbiAgICAgICAgfSBlbHNlIGlmICggaSA9PT0gMTQgKSB7XG5cbiAgICAgICAgICB1dWlkWyBpIF0gPSAnNCc7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmICggcm5kIDw9IDB4MDIgKSBybmQgPSAweDIwMDAwMDAgKyAoIE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAgKSB8IDA7XG4gICAgICAgICAgciA9IHJuZCAmIDB4ZjtcbiAgICAgICAgICBybmQgPSBybmQgPj4gNDtcbiAgICAgICAgICB1dWlkWyBpIF0gPSBjaGFyc1sgKCBpID09PSAxOSApID8gKCByICYgMHgzICkgfCAweDggOiByIF07XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXVpZC5qb2luKCAnJyApO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgLy8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGI+XG5cbiAgY2xhbXA6IGZ1bmN0aW9uICggeCwgYSwgYiApIHtcblxuICAgIHJldHVybiAoIHggPCBhICkgPyBhIDogKCAoIHggPiBiICkgPyBiIDogeCApO1xuXG4gIH0sXG5cbiAgLy8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGluZilcblxuICBjbGFtcEJvdHRvbTogZnVuY3Rpb24gKCB4LCBhICkge1xuXG4gICAgcmV0dXJuIHggPCBhID8gYSA6IHg7XG5cbiAgfSxcblxuICAvLyBMaW5lYXIgbWFwcGluZyBmcm9tIHJhbmdlIDxhMSwgYTI+IHRvIHJhbmdlIDxiMSwgYjI+XG5cbiAgbWFwTGluZWFyOiBmdW5jdGlvbiAoIHgsIGExLCBhMiwgYjEsIGIyICkge1xuXG4gICAgcmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XG5cbiAgfSxcblxuICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1Ntb290aHN0ZXBcblxuICBzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG4gICAgaWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuICAgIGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuICAgIHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cbiAgICByZXR1cm4geCAqIHggKiAoIDMgLSAyICogeCApO1xuXG4gIH0sXG5cbiAgc21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xuXG4gICAgaWYgKCB4IDw9IG1pbiApIHJldHVybiAwO1xuICAgIGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcblxuICAgIHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XG5cbiAgICByZXR1cm4geCAqIHggKiB4ICogKCB4ICogKCB4ICogNiAtIDE1ICkgKyAxMCApO1xuXG4gIH0sXG5cbiAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPDAsIDE+IHdpdGggMTYgYml0cyBvZiByYW5kb21uZXNzXG4gIC8vIChzdGFuZGFyZCBNYXRoLnJhbmRvbSgpIGNyZWF0ZXMgcmVwZXRpdGl2ZSBwYXR0ZXJucyB3aGVuIGFwcGxpZWQgb3ZlciBsYXJnZXIgc3BhY2UpXG5cbiAgcmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiAoIDY1MjgwICogTWF0aC5yYW5kb20oKSArIDI1NSAqIE1hdGgucmFuZG9tKCkgKSAvIDY1NTM1O1xuXG4gIH0sXG5cbiAgLy8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxuXG4gIHJhbmRJbnQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoIHRoaXMucmFuZEZsb2F0KCBsb3csIGhpZ2ggKSApO1xuXG4gIH0sXG5cbiAgLy8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcblxuICByYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xuXG4gICAgcmV0dXJuIGxvdyArIE1hdGgucmFuZG9tKCkgKiAoIGhpZ2ggLSBsb3cgKTtcblxuICB9LFxuXG4gIC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcblxuICByYW5kRmxvYXRTcHJlYWQ6IGZ1bmN0aW9uICggcmFuZ2UgKSB7XG5cbiAgICByZXR1cm4gcmFuZ2UgKiAoIDAuNSAtIE1hdGgucmFuZG9tKCkgKTtcblxuICB9LFxuXG4gIGRlZ1RvUmFkOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZGVncmVlVG9SYWRpYW5zRmFjdG9yID0gTWF0aC5QSSAvIDE4MDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGRlZ3JlZXMgKSB7XG5cbiAgICAgIHJldHVybiBkZWdyZWVzICogZGVncmVlVG9SYWRpYW5zRmFjdG9yO1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgcmFkVG9EZWc6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByYWRpYW5Ub0RlZ3JlZXNGYWN0b3IgPSAxODAgLyBNYXRoLlBJO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggcmFkaWFucyApIHtcblxuICAgICAgcmV0dXJuIHJhZGlhbnMgKiByYWRpYW5Ub0RlZ3JlZXNGYWN0b3I7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBpc1Bvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICByZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcblxuICB9LFxuXG4gIG5leHRQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdmFsdWUgLS07XG4gICAgdmFsdWUgfD0gdmFsdWUgPj4gMTtcbiAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAyO1xuICAgIHZhbHVlIHw9IHZhbHVlID4+IDQ7XG4gICAgdmFsdWUgfD0gdmFsdWUgPj4gODtcbiAgICB2YWx1ZSB8PSB2YWx1ZSA+PiAxNjtcbiAgICB2YWx1ZSArKztcblxuICAgIHJldHVybiB2YWx1ZTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGgvU3BsaW5lLmpzXG5cbi8qKlxuICogU3BsaW5lIGZyb20gVHdlZW4uanMsIHNsaWdodGx5IG9wdGltaXplZCAoYW5kIHRyYXNoZWQpXG4gKiBodHRwOi8vc29sZS5naXRodWIuY29tL3R3ZWVuLmpzL2V4YW1wbGVzLzA1X3NwbGluZS5odG1sXG4gKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU3BsaW5lID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cbiAgdGhpcy5wb2ludHMgPSBwb2ludHM7XG5cbiAgdmFyIGMgPSBbXSwgdjMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcbiAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcbiAgcGEsIHBiLCBwYywgcGQ7XG5cbiAgdGhpcy5pbml0RnJvbUFycmF5ID0gZnVuY3Rpb24gKCBhICkge1xuXG4gICAgdGhpcy5wb2ludHMgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB0aGlzLnBvaW50c1sgaSBdID0geyB4OiBhWyBpIF1bIDAgXSwgeTogYVsgaSBdWyAxIF0sIHo6IGFbIGkgXVsgMiBdIH07XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKCBrICkge1xuXG4gICAgcG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGs7XG4gICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICBjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xuICAgIGNbIDEgXSA9IGludFBvaW50O1xuICAgIGNbIDIgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDIgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAxO1xuICAgIGNbIDMgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xuXG4gICAgcGEgPSB0aGlzLnBvaW50c1sgY1sgMCBdIF07XG4gICAgcGIgPSB0aGlzLnBvaW50c1sgY1sgMSBdIF07XG4gICAgcGMgPSB0aGlzLnBvaW50c1sgY1sgMiBdIF07XG4gICAgcGQgPSB0aGlzLnBvaW50c1sgY1sgMyBdIF07XG5cbiAgICB3MiA9IHdlaWdodCAqIHdlaWdodDtcbiAgICB3MyA9IHdlaWdodCAqIHcyO1xuXG4gICAgdjMueCA9IGludGVycG9sYXRlKCBwYS54LCBwYi54LCBwYy54LCBwZC54LCB3ZWlnaHQsIHcyLCB3MyApO1xuICAgIHYzLnkgPSBpbnRlcnBvbGF0ZSggcGEueSwgcGIueSwgcGMueSwgcGQueSwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICB2My56ID0gaW50ZXJwb2xhdGUoIHBhLnosIHBiLnosIHBjLnosIHBkLnosIHdlaWdodCwgdzIsIHczICk7XG5cbiAgICByZXR1cm4gdjM7XG5cbiAgfTtcblxuICB0aGlzLmdldENvbnRyb2xQb2ludHNBcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBpLCBwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoLFxuICAgICAgY29vcmRzID0gW107XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHAgPSB0aGlzLnBvaW50c1sgaSBdO1xuICAgICAgY29vcmRzWyBpIF0gPSBbIHAueCwgcC55LCBwLnogXTtcblxuICAgIH1cblxuICAgIHJldHVybiBjb29yZHM7XG5cbiAgfTtcblxuICAvLyBhcHByb3hpbWF0ZSBsZW5ndGggYnkgc3VtbWluZyBsaW5lYXIgc2VnbWVudHNcblxuICB0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uICggblN1YkRpdmlzaW9ucyApIHtcblxuICAgIHZhciBpLCBpbmRleCwgblNhbXBsZXMsIHBvc2l0aW9uLFxuICAgICAgcG9pbnQgPSAwLCBpbnRQb2ludCA9IDAsIG9sZEludFBvaW50ID0gMCxcbiAgICAgIG9sZFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBjaHVua0xlbmd0aHMgPSBbXSxcbiAgICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgIC8vIGZpcnN0IHBvaW50IGhhcyAwIGxlbmd0aFxuXG4gICAgY2h1bmtMZW5ndGhzWyAwIF0gPSAwO1xuXG4gICAgaWYgKCAhIG5TdWJEaXZpc2lvbnMgKSBuU3ViRGl2aXNpb25zID0gMTAwO1xuXG4gICAgblNhbXBsZXMgPSB0aGlzLnBvaW50cy5sZW5ndGggKiBuU3ViRGl2aXNpb25zO1xuXG4gICAgb2xkUG9zaXRpb24uY29weSggdGhpcy5wb2ludHNbIDAgXSApO1xuXG4gICAgZm9yICggaSA9IDE7IGkgPCBuU2FtcGxlczsgaSArKyApIHtcblxuICAgICAgaW5kZXggPSBpIC8gblNhbXBsZXM7XG5cbiAgICAgIHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcbiAgICAgIHRtcFZlYy5jb3B5KCBwb3NpdGlvbiApO1xuXG4gICAgICB0b3RhbExlbmd0aCArPSB0bXBWZWMuZGlzdGFuY2VUbyggb2xkUG9zaXRpb24gKTtcblxuICAgICAgb2xkUG9zaXRpb24uY29weSggcG9zaXRpb24gKTtcblxuICAgICAgcG9pbnQgPSAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKSAqIGluZGV4O1xuICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuXG4gICAgICBpZiAoIGludFBvaW50ICE9PSBvbGRJbnRQb2ludCApIHtcblxuICAgICAgICBjaHVua0xlbmd0aHNbIGludFBvaW50IF0gPSB0b3RhbExlbmd0aDtcbiAgICAgICAgb2xkSW50UG9pbnQgPSBpbnRQb2ludDtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gbGFzdCBwb2ludCBlbmRzIHdpdGggdG90YWwgbGVuZ3RoXG5cbiAgICBjaHVua0xlbmd0aHNbIGNodW5rTGVuZ3Rocy5sZW5ndGggXSA9IHRvdGFsTGVuZ3RoO1xuXG4gICAgcmV0dXJuIHsgY2h1bmtzOiBjaHVua0xlbmd0aHMsIHRvdGFsOiB0b3RhbExlbmd0aCB9O1xuXG4gIH07XG5cbiAgdGhpcy5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGggPSBmdW5jdGlvbiAoIHNhbXBsaW5nQ29lZiApIHtcblxuICAgIHZhciBpLCBqLFxuICAgICAgaW5kZXgsIGluZGV4Q3VycmVudCwgaW5kZXhOZXh0LFxuICAgICAgcmVhbERpc3RhbmNlLFxuICAgICAgc2FtcGxpbmcsIHBvc2l0aW9uLFxuICAgICAgbmV3cG9pbnRzID0gW10sXG4gICAgICB0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgc2wgPSB0aGlzLmdldExlbmd0aCgpO1xuXG4gICAgbmV3cG9pbnRzLnB1c2goIHRtcFZlYy5jb3B5KCB0aGlzLnBvaW50c1sgMCBdICkuY2xvbmUoKSApO1xuXG4gICAgZm9yICggaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIC8vdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIC0gMSBdICk7XG4gICAgICAvL2xpbmVhckRpc3RhbmNlID0gdG1wVmVjLmRpc3RhbmNlVG8oIHRoaXMucG9pbnRzWyBpIF0gKTtcblxuICAgICAgcmVhbERpc3RhbmNlID0gc2wuY2h1bmtzWyBpIF0gLSBzbC5jaHVua3NbIGkgLSAxIF07XG5cbiAgICAgIHNhbXBsaW5nID0gTWF0aC5jZWlsKCBzYW1wbGluZ0NvZWYgKiByZWFsRGlzdGFuY2UgLyBzbC50b3RhbCApO1xuXG4gICAgICBpbmRleEN1cnJlbnQgPSAoIGkgLSAxICkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcbiAgICAgIGluZGV4TmV4dCA9IGkgLyAoIHRoaXMucG9pbnRzLmxlbmd0aCAtIDEgKTtcblxuICAgICAgZm9yICggaiA9IDE7IGogPCBzYW1wbGluZyAtIDE7IGogKysgKSB7XG5cbiAgICAgICAgaW5kZXggPSBpbmRleEN1cnJlbnQgKyBqICogKCAxIC8gc2FtcGxpbmcgKSAqICggaW5kZXhOZXh0IC0gaW5kZXhDdXJyZW50ICk7XG5cbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xuICAgICAgICBuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHBvc2l0aW9uICkuY2xvbmUoKSApO1xuXG4gICAgICB9XG5cbiAgICAgIG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggdGhpcy5wb2ludHNbIGkgXSApLmNsb25lKCkgKTtcblxuICAgIH1cblxuICAgIHRoaXMucG9pbnRzID0gbmV3cG9pbnRzO1xuXG4gIH07XG5cbiAgLy8gQ2F0bXVsbC1Sb21cblxuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZSggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcblxuICAgIHZhciB2MCA9ICggcDIgLSBwMCApICogMC41LFxuICAgICAgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcblxuICAgIHJldHVybiAoIDIgKiAoIHAxIC0gcDIgKSArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiAoIHAxIC0gcDIgKSAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0aC9UcmlhbmdsZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5UcmlhbmdsZSA9IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuICB0aGlzLmEgPSAoIGEgIT09IHVuZGVmaW5lZCApID8gYSA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdGhpcy5jID0gKCBjICE9PSB1bmRlZmluZWQgKSA/IGMgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG59O1xuXG5USFJFRS5UcmlhbmdsZS5ub3JtYWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgcmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcbiAgICB2MC5zdWJWZWN0b3JzKCBhLCBiICk7XG4gICAgcmVzdWx0LmNyb3NzKCB2MCApO1xuXG4gICAgdmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XG4gICAgaWYgKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XG5cbiAgICAgIHJldHVybiByZXN1bHQubXVsdGlwbHlTY2FsYXIoIDEgLyBNYXRoLnNxcnQoIHJlc3VsdExlbmd0aFNxICkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XG5cbiAgfTtcblxufSgpO1xuXG4vLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y29vcmRpbmF0ZXNcbi8vIGJhc2VkIG9uOiBodHRwOi8vd3d3LmJsYWNrcGF3bi5jb20vdGV4dHMvcG9pbnRpbnBvbHkvZGVmYXVsdC5odG1sXG5USFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHYwID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2MC5zdWJWZWN0b3JzKCBjLCBhICk7XG4gICAgdjEuc3ViVmVjdG9ycyggYiwgYSApO1xuICAgIHYyLnN1YlZlY3RvcnMoIHBvaW50LCBhICk7XG5cbiAgICB2YXIgZG90MDAgPSB2MC5kb3QoIHYwICk7XG4gICAgdmFyIGRvdDAxID0gdjAuZG90KCB2MSApO1xuICAgIHZhciBkb3QwMiA9IHYwLmRvdCggdjIgKTtcbiAgICB2YXIgZG90MTEgPSB2MS5kb3QoIHYxICk7XG4gICAgdmFyIGRvdDEyID0gdjEuZG90KCB2MiApO1xuXG4gICAgdmFyIGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAvLyBjb2xpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxuICAgIGlmICggZGVub20gPT09IDAgKSB7XG4gICAgICAvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cbiAgICAgIC8vIG5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGJlc3QgaWRlYSwgbWF5YmUgc2hvdWxkIGJlIHJldHVybmluZyB1bmRlZmluZWRcbiAgICAgIHJldHVybiByZXN1bHQuc2V0KCAtIDIsIC0gMSwgLSAxICk7XG4gICAgfVxuXG4gICAgdmFyIGludkRlbm9tID0gMSAvIGRlbm9tO1xuICAgIHZhciB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XG4gICAgdmFyIHYgPSAoIGRvdDAwICogZG90MTIgLSBkb3QwMSAqIGRvdDAyICkgKiBpbnZEZW5vbTtcblxuICAgIC8vIGJhcnljb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxuICAgIHJldHVybiByZXN1bHQuc2V0KCAxIC0gdSAtIHYsIHYsIHUgKTtcblxuICB9O1xuXG59KCk7XG5cblRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYyApIHtcblxuICAgIHZhciByZXN1bHQgPSBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xuXG4gICAgcmV0dXJuICggcmVzdWx0LnggPj0gMCApICYmICggcmVzdWx0LnkgPj0gMCApICYmICggKCByZXN1bHQueCArIHJlc3VsdC55ICkgPD0gMSApO1xuXG4gIH07XG5cbn0oKTtcblxuVEhSRUUuVHJpYW5nbGUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5UcmlhbmdsZSxcblxuICBzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuICAgIHRoaXMuYS5jb3B5KCBhICk7XG4gICAgdGhpcy5iLmNvcHkoIGIgKTtcbiAgICB0aGlzLmMuY29weSggYyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRGcm9tUG9pbnRzQW5kSW5kaWNlczogZnVuY3Rpb24gKCBwb2ludHMsIGkwLCBpMSwgaTIgKSB7XG5cbiAgICB0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XG4gICAgdGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xuICAgIHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcblxuICAgIHRoaXMuYS5jb3B5KCB0cmlhbmdsZS5hICk7XG4gICAgdGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcbiAgICB0aGlzLmMuY29weSggdHJpYW5nbGUuYyApO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBhcmVhOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjAgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgICB2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xuICAgICAgdjEuc3ViVmVjdG9ycyggdGhpcy5hLCB0aGlzLmIgKTtcblxuICAgICAgcmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xuXG4gICAgfTtcblxuICB9KCksXG5cbiAgbWlkcG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICByZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICkuYWRkKCB0aGlzLmMgKS5tdWx0aXBseVNjYWxhciggMSAvIDMgKTtcblxuICB9LFxuXG4gIG5vcm1hbDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHJldHVybiBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgfSxcblxuICBwbGFuZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuUGxhbmUoKTtcblxuICAgIHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cbiAgfSxcblxuICBiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgcmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XG5cbiAgfSxcblxuICBjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xuXG4gICAgcmV0dXJuIFRIUkVFLlRyaWFuZ2xlLmNvbnRhaW5zUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cbiAgfSxcblxuICBlcXVhbHM6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XG5cbiAgICByZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5UcmlhbmdsZSgpLmNvcHkoIHRoaXMgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvQ2xvY2suanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkNsb2NrID0gZnVuY3Rpb24gKCBhdXRvU3RhcnQgKSB7XG5cbiAgdGhpcy5hdXRvU3RhcnQgPSAoIGF1dG9TdGFydCAhPT0gdW5kZWZpbmVkICkgPyBhdXRvU3RhcnQgOiB0cnVlO1xuXG4gIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgdGhpcy5vbGRUaW1lID0gMDtcbiAgdGhpcy5lbGFwc2VkVGltZSA9IDA7XG5cbiAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkNsb2NrLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuQ2xvY2ssXG5cbiAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuc3RhcnRUaW1lID0gc2VsZi5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHNlbGYucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgPyBzZWxmLnBlcmZvcm1hbmNlLm5vdygpXG4gICAgICAgICAgIDogRGF0ZS5ub3coKTtcblxuICAgIHRoaXMub2xkVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gIH0sXG5cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5nZXRFbGFwc2VkVGltZSgpO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gIH0sXG5cbiAgZ2V0RWxhcHNlZFRpbWU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZ2V0RGVsdGEoKTtcbiAgICByZXR1cm4gdGhpcy5lbGFwc2VkVGltZTtcblxuICB9LFxuXG4gIGdldERlbHRhOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZGlmZiA9IDA7XG5cbiAgICBpZiAoIHRoaXMuYXV0b1N0YXJ0ICYmICEgdGhpcy5ydW5uaW5nICkge1xuXG4gICAgICB0aGlzLnN0YXJ0KCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMucnVubmluZyApIHtcblxuICAgICAgdmFyIG5ld1RpbWUgPSBzZWxmLnBlcmZvcm1hbmNlICE9PSB1bmRlZmluZWQgJiYgc2VsZi5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICA/IHNlbGYucGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgICAgOiBEYXRlLm5vdygpO1xuXG4gICAgICBkaWZmID0gMC4wMDEgKiAoIG5ld1RpbWUgLSB0aGlzLm9sZFRpbWUgKTtcbiAgICAgIHRoaXMub2xkVGltZSA9IG5ld1RpbWU7XG5cbiAgICAgIHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcblxuICAgIH1cblxuICAgIHJldHVybiBkaWZmO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9FdmVudERpc3BhdGNoZXIuanNcblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL2V2ZW50ZGlzcGF0Y2hlci5qcy9cbiAqL1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuRXZlbnREaXNwYXRjaGVyLFxuXG4gIGFwcGx5OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIG9iamVjdC5hZGRFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuICAgIG9iamVjdC5oYXNFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5oYXNFdmVudExpc3RlbmVyO1xuICAgIG9iamVjdC5yZW1vdmVFdmVudExpc3RlbmVyID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50ID0gVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50O1xuXG4gIH0sXG5cbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG5cbiAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG5cbiAgICB9XG5cbiAgICBpZiAoIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgPT09IC0gMSApIHtcblxuICAgICAgbGlzdGVuZXJzWyB0eXBlIF0ucHVzaCggbGlzdGVuZXIgKTtcblxuICAgIH1cblxuICB9LFxuXG4gIGhhc0V2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XG5cbiAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcblxuICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gIT09IHVuZGVmaW5lZCAmJiBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApICE9PSAtIDEgKSB7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIH0sXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcblxuICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzWyB0eXBlIF07XG5cbiAgICBpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJBcnJheS5pbmRleE9mKCBsaXN0ZW5lciApO1xuXG4gICAgICBpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cbiAgICAgICAgbGlzdGVuZXJBcnJheS5zcGxpY2UoIGluZGV4LCAxICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9LFxuXG4gIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICB2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xuXG4gICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7XG5cbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVyQXJyYXkubGVuZ3RoO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgYXJyYXlbIGkgXSA9IGxpc3RlbmVyQXJyYXlbIGkgXTtcblxuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgYXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL1JheWNhc3Rlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb20vXG4gKiBAYXV0aG9yIHN0ZXBob21pIC8gaHR0cDovL3N0ZXBoYW5lZ2luaWVyLmNvbS9cbiAqL1xuXG4oIGZ1bmN0aW9uICggVEhSRUUgKSB7XG5cbiAgVEhSRUUuUmF5Y2FzdGVyID0gZnVuY3Rpb24gKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xuXG4gICAgdGhpcy5yYXkgPSBuZXcgVEhSRUUuUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xuICAgIC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cbiAgICB0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XG4gICAgdGhpcy5mYXIgPSBmYXIgfHwgSW5maW5pdHk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHtcbiAgICAgIFNwcml0ZToge30sXG4gICAgICBNZXNoOiB7fSxcbiAgICAgIFBvaW50Q2xvdWQ6IHsgdGhyZXNob2xkOiAxIH0sXG4gICAgICBMT0Q6IHt9LFxuICAgICAgTGluZToge31cbiAgICB9O1xuXG4gIH07XG5cbiAgdmFyIGRlc2NTb3J0ID0gZnVuY3Rpb24gKCBhLCBiICkge1xuXG4gICAgcmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xuXG4gIH07XG5cbiAgdmFyIGludGVyc2VjdE9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcblxuICAgIG9iamVjdC5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuICAgIGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBvYmplY3QuY2hpbGRyZW47XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgaW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbiAgLy9cblxuICBUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFRIUkVFLlJheWNhc3RlcixcblxuICAgIGxpbmVQcmVjaXNpb246IDEsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XG5cbiAgICAgIC8vIGRpcmVjdGlvbiBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWQgKGZvciBhY2N1cmF0ZSBkaXN0YW5jZSBjYWxjdWxhdGlvbnMpXG5cbiAgICAgIHRoaXMucmF5LnNldCggb3JpZ2luLCBkaXJlY3Rpb24gKTtcblxuICAgIH0sXG5cbiAgICBzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xuXG4gICAgICBpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhICkge1xuXG4gICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgICAgICB0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcblxuICAgICAgfSBlbHNlIGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhICkge1xuXG4gICAgICAgIHRoaXMucmF5Lm9yaWdpbi5zZXQoIGNvb3Jkcy54LCBjb29yZHMueSwgLSAxICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcbiAgICAgICAgdGhpcy5yYXkuZGlyZWN0aW9uLnNldCggMCwgMCwgLSAxICkudHJhbnNmb3JtRGlyZWN0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuUmF5Y2FzdGVyOiBVbnN1cHBvcnRlZCBjYW1lcmEgdHlwZS4nICk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RPYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0LCByZWN1cnNpdmUgKSB7XG5cbiAgICAgIHZhciBpbnRlcnNlY3RzID0gW107XG5cbiAgICAgIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcblxuICAgICAgaW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0cztcblxuICAgIH0sXG5cbiAgICBpbnRlcnNlY3RPYmplY3RzOiBmdW5jdGlvbiAoIG9iamVjdHMsIHJlY3Vyc2l2ZSApIHtcblxuICAgICAgdmFyIGludGVyc2VjdHMgPSBbXTtcblxuICAgICAgaWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3RzICkgPT09IGZhbHNlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS4nICk7XG4gICAgICAgIHJldHVybiBpbnRlcnNlY3RzO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XG5cbiAgICAgIH1cblxuICAgICAgaW50ZXJzZWN0cy5zb3J0KCBkZXNjU29ydCApO1xuXG4gICAgICByZXR1cm4gaW50ZXJzZWN0cztcblxuICAgIH1cblxuICB9O1xuXG59KCBUSFJFRSApICk7XG5cbi8vIEZpbGU6c3JjL2NvcmUvT2JqZWN0M0QuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3IgZWxlcGhhbnRhdHdvcmsgLyB3d3cuZWxlcGhhbnRhdHdvcmsuY2hcbiAqL1xuXG5USFJFRS5PYmplY3QzRCA9IGZ1bmN0aW9uICgpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLk9iamVjdDNESWRDb3VudCArKyB9ICk7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLm5hbWUgPSAnJztcbiAgdGhpcy50eXBlID0gJ09iamVjdDNEJztcblxuICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gIHRoaXMudXAgPSBUSFJFRS5PYmplY3QzRC5EZWZhdWx0VXAuY2xvbmUoKTtcblxuICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgcm90YXRpb24gPSBuZXcgVEhSRUUuRXVsZXIoKTtcbiAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICB2YXIgc2NhbGUgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApO1xuXG4gIHZhciBvblJvdGF0aW9uQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcbiAgfTtcblxuICB2YXIgb25RdWF0ZXJuaW9uQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XG4gIH07XG5cbiAgcm90YXRpb24ub25DaGFuZ2UoIG9uUm90YXRpb25DaGFuZ2UgKTtcbiAgcXVhdGVybmlvbi5vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBwb3NpdGlvblxuICAgIH0sXG4gICAgcm90YXRpb246IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcm90YXRpb25cbiAgICB9LFxuICAgIHF1YXRlcm5pb246IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogcXVhdGVybmlvblxuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogc2NhbGVcbiAgICB9XG4gIH0gKTtcblxuICB0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRydWU7XG5cbiAgdGhpcy5tYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xuICB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLnZpc2libGUgPSB0cnVlO1xuXG4gIHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xuICB0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcblxuICB0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xuICB0aGlzLnJlbmRlck9yZGVyID0gMDtcblxuICB0aGlzLnVzZXJEYXRhID0ge307XG5cbn07XG5cblRIUkVFLk9iamVjdDNELkRlZmF1bHRVcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cblRIUkVFLk9iamVjdDNELnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuT2JqZWN0M0QsXG5cbiAgZ2V0IGV1bGVyT3JkZXIgKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGhhcyBiZWVuIG1vdmVkIHRvIC5yb3RhdGlvbi5vcmRlci4nICk7XG5cbiAgICByZXR1cm4gdGhpcy5yb3RhdGlvbi5vcmRlcjtcblxuICB9LFxuXG4gIHNldCBldWxlck9yZGVyICggdmFsdWUgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLmV1bGVyT3JkZXIgaGFzIGJlZW4gbW92ZWQgdG8gLnJvdGF0aW9uLm9yZGVyLicgKTtcblxuICAgIHRoaXMucm90YXRpb24ub3JkZXIgPSB2YWx1ZTtcblxuICB9LFxuXG4gIGdldCB1c2VRdWF0ZXJuaW9uICgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcblxuICB9LFxuXG4gIHNldCB1c2VRdWF0ZXJuaW9uICggdmFsdWUgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnVzZVF1YXRlcm5pb24gaGFzIGJlZW4gcmVtb3ZlZC4gVGhlIGxpYnJhcnkgbm93IHVzZXMgcXVhdGVybmlvbnMgYnkgZGVmYXVsdC4nICk7XG5cbiAgfSxcblxuICBhcHBseU1hdHJpeDogZnVuY3Rpb24gKCBtYXRyaXggKSB7XG5cbiAgICB0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMubWF0cml4ICk7XG5cbiAgICB0aGlzLm1hdHJpeC5kZWNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xuXG4gIH0sXG5cbiAgc2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgLy8gYXNzdW1lcyBheGlzIGlzIG5vcm1hbGl6ZWRcblxuICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG4gIH0sXG5cbiAgc2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XG5cbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xuXG4gIH0sXG5cbiAgc2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XG5cbiAgICAvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxuXG4gICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbSApO1xuXG4gIH0sXG5cbiAgc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xuXG4gICAgLy8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcblxuICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KCBxICk7XG5cbiAgfSxcblxuICByb3RhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiBvYmplY3Qgc3BhY2VcbiAgICAvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG4gICAgdmFyIHExID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xuXG4gICAgICBxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xuXG4gICAgICB0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoIHExICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0oKSxcblxuICByb3RhdGVYOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMCwgMCApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICByb3RhdGVZOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICByb3RhdGVaOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggYW5nbGUgKSB7XG5cbiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICB0cmFuc2xhdGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIHRyYW5zbGF0ZSBvYmplY3QgYnkgZGlzdGFuY2UgYWxvbmcgYXhpcyBpbiBvYmplY3Qgc3BhY2VcbiAgICAvLyBheGlzIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxuXG4gICAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGF4aXMsIGRpc3RhbmNlICkge1xuXG4gICAgICB2MS5jb3B5KCBheGlzICkuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLnF1YXRlcm5pb24gKTtcblxuICAgICAgdGhpcy5wb3NpdGlvbi5hZGQoIHYxLm11bHRpcGx5U2NhbGFyKCBkaXN0YW5jZSApICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0oKSxcblxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uICggZGlzdGFuY2UsIGF4aXMgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKTtcblxuICB9LFxuXG4gIHRyYW5zbGF0ZVg6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHRyYW5zbGF0ZVk6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcblxuICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGxvY2FsVG9Xb3JsZDogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XG5cbiAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gIH0sXG5cbiAgd29ybGRUb0xvY2FsOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xuXG4gICAgICByZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBsb29rQXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIFRoaXMgcm91dGluZSBkb2VzIG5vdCBzdXBwb3J0IG9iamVjdHMgd2l0aCByb3RhdGVkIGFuZC9vciB0cmFuc2xhdGVkIHBhcmVudChzKVxuXG4gICAgdmFyIG0xID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgICAgbTEubG9va0F0KCB2ZWN0b3IsIHRoaXMucG9zaXRpb24sIHRoaXMudXAgKTtcblxuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbTEgKTtcblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGFkZDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICBpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgIHRoaXMuYWRkKCBhcmd1bWVudHNbIGkgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gICAgaWYgKCBvYmplY3QgPT09IHRoaXMgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXCIsIG9iamVjdCApO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk9iamVjdDNEICkge1xuXG4gICAgICBpZiAoIG9iamVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBvYmplY3QucGFyZW50LnJlbW92ZSggb2JqZWN0ICk7XG5cbiAgICAgIH1cblxuICAgICAgb2JqZWN0LnBhcmVudCA9IHRoaXM7XG4gICAgICBvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcblxuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKCBvYmplY3QgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoIFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3Qgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk9iamVjdDNELlwiLCBvYmplY3QgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgdGhpcy5yZW1vdmUoIGFyZ3VtZW50c1sgaSBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICk7XG5cbiAgICBpZiAoIGluZGV4ICE9PSAtIDEgKSB7XG5cbiAgICAgIG9iamVjdC5wYXJlbnQgPSB1bmRlZmluZWQ7XG5cbiAgICAgIG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdyZW1vdmVkJyB9ICk7XG5cbiAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgZ2V0Q2hpbGRCeU5hbWU6IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZ2V0Q2hpbGRCeU5hbWUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRPYmplY3RCeU5hbWUoKS4nICk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlOYW1lKCBuYW1lICk7XG5cbiAgfSxcblxuICBnZXRPYmplY3RCeUlkOiBmdW5jdGlvbiAoIGlkICkge1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ2lkJywgaWQgKTtcblxuICB9LFxuXG4gIGdldE9iamVjdEJ5TmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XG5cbiAgfSxcblxuICBnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xuXG4gICAgaWYgKCB0aGlzWyBuYW1lIF0gPT09IHZhbHVlICkgcmV0dXJuIHRoaXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcbiAgICAgIHZhciBvYmplY3QgPSBjaGlsZC5nZXRPYmplY3RCeVByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXG4gICAgICBpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgfSxcblxuICBnZXRXb3JsZFBvc2l0aW9uOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gIH0sXG5cbiAgZ2V0V29ybGRRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgICAgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHBvc2l0aW9uLCByZXN1bHQsIHNjYWxlICk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIGdldFdvcmxkUm90YXRpb246IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLkV1bGVyKCk7XG5cbiAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICAgIHJldHVybiByZXN1bHQuc2V0RnJvbVF1YXRlcm5pb24oIHF1YXRlcm5pb24sIHRoaXMucm90YXRpb24ub3JkZXIsIGZhbHNlICk7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIGdldFdvcmxkU2NhbGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICAgIHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG5cbiAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgcmVzdWx0ICk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIGdldFdvcmxkRGlyZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICAgIHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICB9XG5cbiAgfSgpLFxuXG4gIHJheWNhc3Q6IGZ1bmN0aW9uICgpIHt9LFxuXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgY2FsbGJhY2soIHRoaXMgKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdGhpcy5jaGlsZHJlblsgaSBdLnRyYXZlcnNlKCBjYWxsYmFjayApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgdHJhdmVyc2VWaXNpYmxlOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgaWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgY2FsbGJhY2soIHRoaXMgKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdGhpcy5jaGlsZHJlblsgaSBdLnRyYXZlcnNlVmlzaWJsZSggY2FsbGJhY2sgKTtcblxuICAgIH1cblxuICB9LFxuXG4gIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xuXG4gICAgaWYgKCB0aGlzLnBhcmVudCApIHtcblxuICAgICAgY2FsbGJhY2soIHRoaXMucGFyZW50ICk7XG5cbiAgICAgIHRoaXMucGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgdXBkYXRlTWF0cml4OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLm1hdHJpeC5jb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcblxuICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgfSxcblxuICB1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuICAgIGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkgdGhpcy51cGRhdGVNYXRyaXgoKTtcblxuICAgIGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID09PSB0cnVlIHx8IGZvcmNlID09PSB0cnVlICkge1xuXG4gICAgICBpZiAoIHRoaXMucGFyZW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQubXVsdGlwbHlNYXRyaWNlcyggdGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4ICk7XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgIGZvcmNlID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIC8vIHVwZGF0ZSBjaGlsZHJlblxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlTWF0cml4V29ybGQoIGZvcmNlICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICAgIHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCApO1xuXG4gICAgdmFyIGRhdGEgPSB7fTtcblxuICAgIC8vIG1ldGEgaXMgYSBoYXNoIHVzZWQgdG8gY29sbGVjdCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMuXG4gICAgLy8gbm90IHByb3ZpZGluZyBpdCBpbXBsaWVzIHRoYXQgdGhpcyBpcyB0aGUgcm9vdCBvYmplY3RcbiAgICAvLyBiZWluZyBzZXJpYWxpemVkLlxuICAgIGlmICggaXNSb290T2JqZWN0ICkge1xuXG4gICAgICAvLyBpbml0aWFsaXplIG1ldGEgb2JqXG4gICAgICBtZXRhID0ge1xuICAgICAgICBnZW9tZXRyaWVzOiB7fSxcbiAgICAgICAgbWF0ZXJpYWxzOiB7fSxcbiAgICAgICAgdGV4dHVyZXM6IHt9LFxuICAgICAgICBpbWFnZXM6IHt9XG4gICAgICB9O1xuXG4gICAgICBkYXRhLm1ldGFkYXRhID0ge1xuICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgIHR5cGU6ICdPYmplY3QnLFxuICAgICAgICBnZW5lcmF0b3I6ICdPYmplY3QzRC50b0pTT04nXG4gICAgICB9O1xuXG4gICAgfVxuXG4gICAgLy8gc3RhbmRhcmQgT2JqZWN0M0Qgc2VyaWFsaXphdGlvblxuXG4gICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcblxuICAgIGlmICggdGhpcy5uYW1lICE9PSAnJyApIGRhdGEubmFtZSA9IHRoaXMubmFtZTtcbiAgICBpZiAoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgIT09ICd7fScgKSBkYXRhLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcbiAgICBpZiAoIHRoaXMudmlzaWJsZSAhPT0gdHJ1ZSApIGRhdGEudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblxuICAgIGRhdGEubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xuXG4gICAgaWYgKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIGRhdGEuY2hpbGRyZW4gPSBbXTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgZGF0YS5jaGlsZHJlbi5wdXNoKCB0aGlzLmNoaWxkcmVuWyBpIF0udG9KU09OKCBtZXRhICkub2JqZWN0ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSB7fTtcblxuICAgIGlmICggaXNSb290T2JqZWN0ICkge1xuXG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEuZ2VvbWV0cmllcyApO1xuICAgICAgdmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XG4gICAgICB2YXIgdGV4dHVyZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnRleHR1cmVzICk7XG4gICAgICB2YXIgaW1hZ2VzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5pbWFnZXMgKTtcblxuICAgICAgaWYgKCBnZW9tZXRyaWVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuZ2VvbWV0cmllcyA9IGdlb21ldHJpZXM7XG4gICAgICBpZiAoIG1hdGVyaWFscy5sZW5ndGggPiAwICkgb3V0cHV0Lm1hdGVyaWFscyA9IG1hdGVyaWFscztcbiAgICAgIGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xuICAgICAgaWYgKCBpbWFnZXMubGVuZ3RoID4gMCApIG91dHB1dC5pbWFnZXMgPSBpbWFnZXM7XG5cbiAgICB9XG5cbiAgICBvdXRwdXQub2JqZWN0ID0gZGF0YTtcblxuICAgIHJldHVybiBvdXRwdXQ7XG5cbiAgICAvLyBleHRyYWN0IGRhdGEgZnJvbSB0aGUgY2FjaGUgaGFzaFxuICAgIC8vIHJlbW92ZSBtZXRhZGF0YSBvbiBlYWNoIGl0ZW1cbiAgICAvLyBhbmQgcmV0dXJuIGFzIGFycmF5XG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSAoIGNhY2hlICkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICggdmFyIGtleSBpbiBjYWNoZSApIHtcbiAgICAgICAgdmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XG4gICAgICAgIGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xuICAgICAgICB2YWx1ZXMucHVzaCggZGF0YSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcblxuICAgIGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICBpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcblxuICAgIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgb2JqZWN0LnVwLmNvcHkoIHRoaXMudXAgKTtcblxuICAgIG9iamVjdC5wb3NpdGlvbi5jb3B5KCB0aGlzLnBvc2l0aW9uICk7XG4gICAgb2JqZWN0LnF1YXRlcm5pb24uY29weSggdGhpcy5xdWF0ZXJuaW9uICk7XG4gICAgb2JqZWN0LnNjYWxlLmNvcHkoIHRoaXMuc2NhbGUgKTtcblxuICAgIG9iamVjdC5yb3RhdGlvbkF1dG9VcGRhdGUgPSB0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZTtcblxuICAgIG9iamVjdC5tYXRyaXguY29weSggdGhpcy5tYXRyaXggKTtcbiAgICBvYmplY3QubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSB0aGlzLm1hdHJpeEF1dG9VcGRhdGU7XG4gICAgb2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XG5cbiAgICBvYmplY3QudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcblxuICAgIG9iamVjdC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICAgIG9iamVjdC5yZWNlaXZlU2hhZG93ID0gdGhpcy5yZWNlaXZlU2hhZG93O1xuXG4gICAgb2JqZWN0LmZydXN0dW1DdWxsZWQgPSB0aGlzLmZydXN0dW1DdWxsZWQ7XG4gICAgb2JqZWN0LnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlcjtcblxuICAgIG9iamVjdC51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCB0aGlzLnVzZXJEYXRhICkgKTtcblxuICAgIGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XG4gICAgICAgIG9iamVjdC5hZGQoIGNoaWxkLmNsb25lKCkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIG9iamVjdDtcblxuICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuXG5USFJFRS5PYmplY3QzRElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2UzLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRmFjZTMgPSBmdW5jdGlvbiAoIGEsIGIsIGMsIG5vcm1hbCwgY29sb3IgKSB7XG5cbiAgdGhpcy5hID0gYTtcbiAgdGhpcy5iID0gYjtcbiAgdGhpcy5jID0gYztcblxuICB0aGlzLm5vcm1hbCA9IG5vcm1hbCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB0aGlzLnZlcnRleE5vcm1hbHMgPSBBcnJheS5pc0FycmF5KCBub3JtYWwgKSA/IG5vcm1hbCA6IFtdO1xuXG4gIHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcblxuICB0aGlzLnZlcnRleFRhbmdlbnRzID0gW107XG5cbn07XG5cblRIUkVFLkZhY2UzLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTMsXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XG5cbiAgICBmYWNlLm5vcm1hbC5jb3B5KCB0aGlzLm5vcm1hbCApO1xuICAgIGZhY2UuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSB0aGlzLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBmYWNlLnZlcnRleENvbG9yc1sgaSBdID0gdGhpcy52ZXJ0ZXhDb2xvcnNbIGkgXS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMudmVydGV4VGFuZ2VudHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IHRoaXMudmVydGV4VGFuZ2VudHNbIGkgXS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGZhY2U7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ZhY2U0LmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5GYWNlNCA9IGZ1bmN0aW9uICggYSwgYiwgYywgZCwgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcblxuICBjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlNCBoYXMgYmVlbiByZW1vdmVkLiBBIFRIUkVFLkZhY2UzIHdpbGwgYmUgY3JlYXRlZCBpbnN0ZWFkLicgKTtcbiAgcmV0dXJuIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgdGhpcy5hcnJheSA9IGFycmF5O1xuICB0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG5cbiAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5CdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUsXG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IC5sZW5ndGggaGFzIGJlZW4gcmVuYW1lZCB0byAuY291bnQuJyApO1xuICAgIHJldHVybiB0aGlzLmNvdW50O1xuXG4gIH0sXG5cbiAgZ2V0IGNvdW50KCkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXkubGVuZ3RoIC8gdGhpcy5pdGVtU2l6ZTtcblxuICB9LFxuXG4gIGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xuXG4gICAgaW5kZXgxICo9IHRoaXMuaXRlbVNpemU7XG4gICAgaW5kZXgyICo9IGF0dHJpYnV0ZS5pdGVtU2l6ZTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuaXRlbVNpemU7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xuXG4gICAgdGhpcy5hcnJheS5zZXQoIGFycmF5ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvcHlDb2xvcnNBcnJheTogZnVuY3Rpb24gKCBjb2xvcnMgKSB7XG5cbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBjb2xvciA9IGNvbG9yc1sgaSBdO1xuXG4gICAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlDb2xvcnNBcnJheSgpOiBjb2xvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCk7XG5cbiAgICAgIH1cblxuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IucjtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmc7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5iO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5SW5kaWNlc0FycmF5OiBmdW5jdGlvbiAoIGluZGljZXMgKSB7XG5cbiAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgaW5kZXggPSBpbmRpY2VzWyBpIF07XG5cbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmE7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5iO1xuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYztcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weVZlY3RvcjJzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Iyc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG5cbiAgICAgIH1cblxuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY29weVZlY3RvcjNzQXJyYXk6IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXksIG9mZnNldCA9IDA7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB2ZWN0b3IgPSB2ZWN0b3JzWyBpIF07XG5cbiAgICAgIGlmICggdmVjdG9yID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCk6IHZlY3RvciBpcyB1bmRlZmluZWQnLCBpICk7XG4gICAgICAgIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIH1cblxuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLng7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueTtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb3B5VmVjdG9yNHNBcnJheTogZnVuY3Rpb24gKCB2ZWN0b3JzICkge1xuXG4gICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHZlY3RvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcblxuICAgICAgaWYgKCB2ZWN0b3IgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weVZlY3RvcjRzQXJyYXkoKTogdmVjdG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcbiAgICAgICAgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcblxuICAgICAgfVxuXG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IueDtcbiAgICAgIGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xuICAgICAgYXJyYXlbIG9mZnNldCArKyBdID0gdmVjdG9yLno7XG4gICAgICBhcnJheVsgb2Zmc2V0ICsrIF0gPSB2ZWN0b3IudztcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGdldFg6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF07XG5cbiAgfSxcblxuICBzZXRYOiBmdW5jdGlvbiAoIGluZGV4LCB4ICkge1xuXG4gICAgdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRZOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDEgXTtcblxuICB9LFxuXG4gIHNldFk6IGZ1bmN0aW9uICggaW5kZXgsIHkgKSB7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRaOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDIgXTtcblxuICB9LFxuXG4gIHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXJyYXlbIGluZGV4ICogdGhpcy5pdGVtU2l6ZSArIDMgXTtcblxuICB9LFxuXG4gIHNldFc6IGZ1bmN0aW9uICggaW5kZXgsIHcgKSB7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRYWTogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSApIHtcblxuICAgIGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XG5cbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XG5cbiAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cbiAgICBpbmRleCAqPSB0aGlzLml0ZW1TaXplO1xuXG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcbiAgICB0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG4gICAgdGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKCB0aGlzLmFycmF5ICksIHRoaXMuaXRlbVNpemUgKTtcblxuICB9XG5cbn07XG5cbi8vXG5cblRIUkVFLkludDhBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IEludDhBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDhBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDhDbGFtcGVkQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cblRIUkVFLkludDE2QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBJbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5VaW50MTZBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGFycmF5LCBpdGVtU2l6ZSApIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5JbnQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgSW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuVWludDMyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MzJBcnJheSggYXJyYXkgKSwgaXRlbVNpemUgKTtcblxufTtcblxuVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSA9IGZ1bmN0aW9uICggYXJyYXksIGl0ZW1TaXplICkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSApO1xuXG59O1xuXG5USFJFRS5GbG9hdDY0QXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgcmV0dXJuIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDY0QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvRHluYW1pY0J1ZmZlckF0dHJpYnV0ZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhcnJheSwgaXRlbVNpemUgKSB7XG5cbiAgVEhSRUUuQnVmZmVyQXR0cmlidXRlLmNhbGwoIHRoaXMsIGFycmF5LCBpdGVtU2l6ZSApO1xuXG4gIHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0xIH07XG5cbn07XG5cblRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlO1xuXG5USFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUoIG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKCB0aGlzLmFycmF5ICksIHRoaXMuaXRlbVNpemUgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcbiAqL1xuXG5USFJFRS5JbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoYXJyYXksIGl0ZW1TaXplLCBtZXNoUGVyQXR0cmlidXRlLCBkeW5hbWljKSB7XG5cbiAgVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBhcnJheSwgaXRlbVNpemUgKTtcblxuICB0aGlzLmR5bmFtaWMgPSBkeW5hbWljIHx8IGZhbHNlO1xuICB0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XG5cbn07XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5EeW5hbWljQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTtcblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSggbmV3IHRoaXMuYXJyYXkuY29uc3RydWN0b3IoIHRoaXMuYXJyYXkgKSwgdGhpcy5pdGVtU2l6ZSwgdGhpcy5tZXNoUGVyQXR0cmlidXRlLCB0aGlzLmR5bmFtaWMgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvY29yZS9JbnRlcmxlYXZlZEJ1ZmZlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyID0gZnVuY3Rpb24gKCBhcnJheSwgc3RyaWRlLCBkeW5hbWljICkge1xuXG4gIHRoaXMuYXJyYXkgPSBhcnJheTtcbiAgdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG5cbiAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHRoaXMuZHluYW1pYyA9IGR5bmFtaWMgfHwgZmFsc2U7XG4gIHRoaXMudXBkYXRlUmFuZ2UgPSB7IG9mZnNldDogMCwgY291bnQ6IC0xIH07XG5cbn07XG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIsXG5cbiAgZ2V0IGxlbmd0aCAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheS5sZW5ndGg7XG5cbiAgfSxcblxuICBjb3B5QXQ6IGZ1bmN0aW9uICggaW5kZXgxLCBhdHRyaWJ1dGUsIGluZGV4MiApIHtcblxuICAgIGluZGV4MSAqPSB0aGlzLnN0cmlkZTtcbiAgICBpbmRleDIgKj0gYXR0cmlidXRlLnN0cmlkZTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSsrICkge1xuXG4gICAgICB0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICBpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcblxuICAgIHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gbmV3IFRIUkVFLkludGVybGVhdmVkQnVmZmVyKCBuZXcgdGhpcy5hcnJheS5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSApLCB0aGlzLnN0cmlkZSwgdGhpcy5keW5hbWljICk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgPSBmdW5jdGlvbiAoIGFycmF5LCBzdHJpZGUsIGR5bmFtaWMsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XG5cbiAgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIuY2FsbCggdGhpcywgYXJyYXksIHN0cmlkZSwgZHluYW1pYyApO1xuXG4gIHRoaXMubWVzaFBlckF0dHJpYnV0ZSA9IG1lc2hQZXJBdHRyaWJ1dGUgfHwgMTtcblxufTtcblxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlICk7XG5USFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlcjtcblxuVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIoIG5ldyB0aGlzLmFycmF5LmNvbnN0cnVjdG9yKCB0aGlzLmFycmF5ICksIHRoaXMuc3RyaWRlLCB0aGlzLmR5bmFtaWMsIHRoaXMubWVzaFBlckF0dHJpYnV0ZSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoIGludGVybGVhdmVkQnVmZmVyLCBpdGVtU2l6ZSwgb2Zmc2V0ICkge1xuXG4gIHRoaXMuZGF0YSA9IGludGVybGVhdmVkQnVmZmVyO1xuICB0aGlzLml0ZW1TaXplID0gaXRlbVNpemU7XG4gIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuXG59O1xuXG5cblRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUsXG5cbiAgZ2V0IGxlbmd0aCgpIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlOiAubGVuZ3RoIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvdW50LicgKTtcbiAgICByZXR1cm4gdGhpcy5jb3VudDtcblxuICB9LFxuXG4gIGdldCBjb3VudCgpIHtcblxuICAgIHJldHVybiB0aGlzLmRhdGEuYXJyYXkubGVuZ3RoIC8gdGhpcy5kYXRhLnN0cmlkZTtcblxuICB9LFxuXG4gIHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XG5cbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRZOiBmdW5jdGlvbiAoIGluZGV4LCB5ICkge1xuXG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXSA9IHk7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XG5cbiAgICB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMiBdID0gejtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgc2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcblxuICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgXTtcblxuICB9LFxuXG4gIGdldFk6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXTtcblxuICB9LFxuXG4gIGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXTtcblxuICB9LFxuXG4gIGdldFc6IGZ1bmN0aW9uICggaW5kZXggKSB7XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDMgXTtcblxuICB9LFxuXG4gIHNldFhZOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5ICkge1xuXG4gICAgaW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcblxuICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xuICAgIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBzZXRYWVo6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHogKSB7XG5cbiAgICBpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIHNldFhZWlc6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHksIHosIHcgKSB7XG5cbiAgICBpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xuXG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDEgXSA9IHk7XG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XG4gICAgdGhpcy5kYXRhLmFycmF5WyBpbmRleCArIDMgXSA9IHc7XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NvcmUvR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBraWxlIC8gaHR0cDovL2tpbGUuc3RyYXZhZ2FuemEub3JnL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cbiAqL1xuXG5USFJFRS5HZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKyB9ICk7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLm5hbWUgPSAnJztcbiAgdGhpcy50eXBlID0gJ0dlb21ldHJ5JztcblxuICB0aGlzLnZlcnRpY2VzID0gW107XG4gIHRoaXMuY29sb3JzID0gW107XG4gIHRoaXMuZmFjZXMgPSBbXTtcbiAgdGhpcy5mYWNlVmVydGV4VXZzID0gWyBbXSBdO1xuXG4gIHRoaXMubW9ycGhUYXJnZXRzID0gW107XG4gIHRoaXMubW9ycGhDb2xvcnMgPSBbXTtcbiAgdGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcblxuICB0aGlzLnNraW5XZWlnaHRzID0gW107XG4gIHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuICB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbiAgdGhpcy5oYXNUYW5nZW50cyA9IGZhbHNlO1xuXG4gIC8vIHVwZGF0ZSBmbGFnc1xuXG4gIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMudGFuZ2VudHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gIHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuR2VvbWV0cnksXG5cbiAgYXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xuXG4gICAgdmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgdmVydGV4ID0gdGhpcy52ZXJ0aWNlc1sgaSBdO1xuICAgICAgdmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG4gICAgICBmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgIH1cblxuICAgIGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIH1cblxuICAgIHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICB9LFxuXG4gIGZyb21CdWZmZXJHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICB2YXIgdmVydGljZXMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgIHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5pbmRleC5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgY29sb3JzID0gYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5jb2xvci5hcnJheSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciB0ZW1wTm9ybWFscyA9IFtdO1xuICAgIHZhciB0ZW1wVVZzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDMsIGogKz0gMiApIHtcblxuICAgICAgc2NvcGUudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cbiAgICAgIGlmICggbm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRlbXBOb3JtYWxzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCBub3JtYWxzWyBpIF0sIG5vcm1hbHNbIGkgKyAxIF0sIG5vcm1hbHNbIGkgKyAyIF0gKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgc2NvcGUuY29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggY29sb3JzWyBpIF0sIGNvbG9yc1sgaSArIDEgXSwgY29sb3JzWyBpICsgMiBdICkgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHRlbXBVVnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2c1sgaiBdLCB1dnNbIGogKyAxIF0gKSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgYWRkRmFjZSA9IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcblxuICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBub3JtYWxzICE9PSB1bmRlZmluZWQgPyBbIHRlbXBOb3JtYWxzWyBhIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGIgXS5jbG9uZSgpLCB0ZW1wTm9ybWFsc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xuICAgICAgdmFyIHZlcnRleENvbG9ycyA9IGNvbG9ycyAhPT0gdW5kZWZpbmVkID8gWyBzY29wZS5jb2xvcnNbIGEgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGIgXS5jbG9uZSgpLCBzY29wZS5jb2xvcnNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcblxuICAgICAgc2NvcGUuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMgKSApO1xuXG4gICAgICBpZiAoIHV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHRlbXBVVnNbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzWyBiIF0uY2xvbmUoKSwgdGVtcFVWc1sgYyBdLmNsb25lKCkgXSApO1xuXG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgaWYgKCBpbmRpY2VzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBkcmF3Y2FsbHMgPSBnZW9tZXRyeS5kcmF3Y2FsbHM7XG5cbiAgICAgIGlmICggZHJhd2NhbGxzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZHJhd2NhbGxzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICAgIHZhciBkcmF3Y2FsbCA9IGRyYXdjYWxsc1sgaSBdO1xuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gZHJhd2NhbGwuc3RhcnQ7XG4gICAgICAgICAgdmFyIGNvdW50ID0gZHJhd2NhbGwuY291bnQ7XG4gICAgICAgICAgdmFyIGluZGV4ID0gZHJhd2NhbGwuaW5kZXg7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xuXG4gICAgICAgICAgICBhZGRGYWNlKCBpbmRleCArIGluZGljZXNbIGogXSwgaW5kZXggKyBpbmRpY2VzWyBqICsgMSBdLCBpbmRleCArIGluZGljZXNbIGogKyAyIF0gKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcblxuICAgICAgICAgIGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoIC8gMzsgaSArPSAzICkge1xuXG4gICAgICAgIGFkZEZhY2UoIGksIGkgKyAxLCBpICsgMiApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgY2VudGVyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guY2VudGVyKCkubmVnYXRlKCk7XG5cbiAgICB0aGlzLmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLnNldFBvc2l0aW9uKCBvZmZzZXQgKSApO1xuXG4gICAgcmV0dXJuIG9mZnNldDtcblxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcbiAgICB2YXIgcmFkaXVzID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXM7XG5cbiAgICB2YXIgcyA9IHJhZGl1cyA9PT0gMCA/IDEgOiAxLjAgLyByYWRpdXM7XG5cbiAgICB2YXIgbWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICBtYXRyaXguc2V0KFxuICAgICAgcywgMCwgMCwgLXMgKiBjZW50ZXIueCxcbiAgICAgIDAsIHMsIDAsIC1zICogY2VudGVyLnksXG4gICAgICAwLCAwLCBzLCAtcyAqIGNlbnRlci56LFxuICAgICAgMCwgMCwgMCwgMVxuICAgICk7XG5cbiAgICB0aGlzLmFwcGx5TWF0cml4KCBtYXRyaXggKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICB2YXIgdkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcbiAgICAgIHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuICAgICAgdmFyIHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICAgIGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuICAgICAgYWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XG4gICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgY2Iubm9ybWFsaXplKCk7XG5cbiAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XG5cbiAgICB2YXIgdiwgdmwsIGYsIGZsLCBmYWNlLCB2ZXJ0aWNlcztcblxuICAgIHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xuXG4gICAgZm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcblxuICAgICAgdmVydGljZXNbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGFyZWFXZWlnaHRlZCApIHtcblxuICAgICAgLy8gdmVydGV4IG5vcm1hbHMgd2VpZ2h0ZWQgYnkgdHJpYW5nbGUgYXJlYXNcbiAgICAgIC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cblxuICAgICAgdmFyIHZBLCB2QiwgdkM7XG4gICAgICB2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xuICAgICAgICB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xuICAgICAgICB2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xuXG4gICAgICAgIGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xuICAgICAgICBhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcbiAgICAgICAgY2IuY3Jvc3MoIGFiICk7XG5cbiAgICAgICAgdmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcbiAgICAgICAgdmVydGljZXNbIGZhY2UuYiBdLmFkZCggY2IgKTtcbiAgICAgICAgdmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICAgIHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG4gICAgICAgIHZlcnRpY2VzWyBmYWNlLmIgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG4gICAgICAgIHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XG5cbiAgICAgIHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuICAgICAgaWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcblxuICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggdmVydGljZXNbIGZhY2UuYSBdICk7XG4gICAgICAgIHZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcbiAgICAgICAgdmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZlcnRleE5vcm1hbHNbIDAgXSA9IHZlcnRpY2VzWyBmYWNlLmEgXS5jbG9uZSgpO1xuICAgICAgICB2ZXJ0ZXhOb3JtYWxzWyAxIF0gPSB2ZXJ0aWNlc1sgZmFjZS5iIF0uY2xvbmUoKTtcbiAgICAgICAgdmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9LFxuXG4gIGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XG5cbiAgICAvLyBzYXZlIG9yaWdpbmFsIG5vcm1hbHNcbiAgICAvLyAtIGNyZWF0ZSB0ZW1wIHZhcmlhYmxlcyBvbiBmaXJzdCBhY2Nlc3NcbiAgICAvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXG5cbiAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xuXG4gICAgICBpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcblxuICAgICAgICBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XG5cbiAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICBpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdICkge1xuXG4gICAgICAgICAgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyB1c2UgdGVtcCBnZW9tZXRyeSB0byBjb21wdXRlIGZhY2UgYW5kIHZlcnRleCBub3JtYWxzIGZvciBlYWNoIG1vcnBoXG5cbiAgICB2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgdG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXG5cbiAgICAgIGlmICggISB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdICkge1xuXG4gICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcbiAgICAgICAgdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscyA9IFtdO1xuICAgICAgICB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcblxuICAgICAgICB2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xuICAgICAgICB2YXIgZHN0Tm9ybWFsc1ZlcnRleCA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscztcblxuICAgICAgICB2YXIgZmFjZU5vcm1hbCwgdmVydGV4Tm9ybWFscztcblxuICAgICAgICBmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICAgICAgZmFjZU5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgdmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYjogbmV3IFRIUkVFLlZlY3RvcjMoKSwgYzogbmV3IFRIUkVFLlZlY3RvcjMoKSB9O1xuXG4gICAgICAgICAgZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xuICAgICAgICAgIGRzdE5vcm1hbHNWZXJ0ZXgucHVzaCggdmVydGV4Tm9ybWFscyApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgbW9ycGhOb3JtYWxzID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXTtcblxuICAgICAgLy8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxuXG4gICAgICB0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xuXG4gICAgICAvLyBjb21wdXRlIG1vcnBoIG5vcm1hbHNcblxuICAgICAgdG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICAgICAgdG1wR2VvLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgICAgIC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcblxuICAgICAgdmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XG5cbiAgICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcblxuICAgICAgICBmYWNlTm9ybWFsID0gbW9ycGhOb3JtYWxzLmZhY2VOb3JtYWxzWyBmIF07XG4gICAgICAgIHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xuXG4gICAgICAgIGZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcblxuICAgICAgICB2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcbiAgICAgICAgdmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XG4gICAgICAgIHZlcnRleE5vcm1hbHMuYy5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDIgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcblxuICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgIGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcbiAgICAgIGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXG4gICAgLy8gdGFuZ2VudHMgZ28gdG8gdmVydGljZXNcblxuICAgIHZhciBmLCBmbCwgdiwgdmwsIGksIHZlcnRleEluZGV4LFxuICAgICAgZmFjZSwgdXYsIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMsXG4gICAgICB4MSwgeDIsIHkxLCB5MiwgejEsIHoyLFxuICAgICAgczEsIHMyLCB0MSwgdDIsIHIsIHQsIHRlc3QsXG4gICAgICB0YW4xID0gW10sIHRhbjIgPSBbXSxcbiAgICAgIHNkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0ZGlyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRtcDIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHc7XG5cbiAgICBmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xuXG4gICAgICB0YW4xWyB2IF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdGFuMlsgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKCBjb250ZXh0LCBhLCBiLCBjLCB1YSwgdWIsIHVjICkge1xuXG4gICAgICB2QSA9IGNvbnRleHQudmVydGljZXNbIGEgXTtcbiAgICAgIHZCID0gY29udGV4dC52ZXJ0aWNlc1sgYiBdO1xuICAgICAgdkMgPSBjb250ZXh0LnZlcnRpY2VzWyBjIF07XG5cbiAgICAgIHV2QSA9IHV2WyB1YSBdO1xuICAgICAgdXZCID0gdXZbIHViIF07XG4gICAgICB1dkMgPSB1dlsgdWMgXTtcblxuICAgICAgeDEgPSB2Qi54IC0gdkEueDtcbiAgICAgIHgyID0gdkMueCAtIHZBLng7XG4gICAgICB5MSA9IHZCLnkgLSB2QS55O1xuICAgICAgeTIgPSB2Qy55IC0gdkEueTtcbiAgICAgIHoxID0gdkIueiAtIHZBLno7XG4gICAgICB6MiA9IHZDLnogLSB2QS56O1xuXG4gICAgICBzMSA9IHV2Qi54IC0gdXZBLng7XG4gICAgICBzMiA9IHV2Qy54IC0gdXZBLng7XG4gICAgICB0MSA9IHV2Qi55IC0gdXZBLnk7XG4gICAgICB0MiA9IHV2Qy55IC0gdXZBLnk7XG5cbiAgICAgIHIgPSAxLjAgLyAoIHMxICogdDIgLSBzMiAqIHQxICk7XG4gICAgICBzZGlyLnNldCggKCB0MiAqIHgxIC0gdDEgKiB4MiApICogcixcbiAgICAgICAgICAgICggdDIgKiB5MSAtIHQxICogeTIgKSAqIHIsXG4gICAgICAgICAgICAoIHQyICogejEgLSB0MSAqIHoyICkgKiByICk7XG4gICAgICB0ZGlyLnNldCggKCBzMSAqIHgyIC0gczIgKiB4MSApICogcixcbiAgICAgICAgICAgICggczEgKiB5MiAtIHMyICogeTEgKSAqIHIsXG4gICAgICAgICAgICAoIHMxICogejIgLSBzMiAqIHoxICkgKiByICk7XG5cbiAgICAgIHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcbiAgICAgIHRhbjFbIGIgXS5hZGQoIHNkaXIgKTtcbiAgICAgIHRhbjFbIGMgXS5hZGQoIHNkaXIgKTtcblxuICAgICAgdGFuMlsgYSBdLmFkZCggdGRpciApO1xuICAgICAgdGFuMlsgYiBdLmFkZCggdGRpciApO1xuICAgICAgdGFuMlsgYyBdLmFkZCggdGRpciApO1xuXG4gICAgfVxuXG4gICAgZm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcblxuICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcbiAgICAgIHV2ID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGYgXTsgLy8gdXNlIFVWIGxheWVyIDAgZm9yIHRhbmdlbnRzXG5cbiAgICAgIGhhbmRsZVRyaWFuZ2xlKCB0aGlzLCBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jLCAwLCAxLCAyICk7XG5cbiAgICB9XG5cbiAgICB2YXIgZmFjZUluZGV4ID0gWyAnYScsICdiJywgJ2MnLCAnZCcgXTtcblxuICAgIGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XG5cbiAgICAgIGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgTWF0aC5taW4oIGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGgsIDMgKTsgaSArKyApIHtcblxuICAgICAgICBuLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdICk7XG5cbiAgICAgICAgdmVydGV4SW5kZXggPSBmYWNlWyBmYWNlSW5kZXhbIGkgXSBdO1xuXG4gICAgICAgIHQgPSB0YW4xWyB2ZXJ0ZXhJbmRleCBdO1xuXG4gICAgICAgIC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cbiAgICAgICAgdG1wLmNvcHkoIHQgKTtcbiAgICAgICAgdG1wLnN1Yiggbi5tdWx0aXBseVNjYWxhciggbi5kb3QoIHQgKSApICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuICAgICAgICB0bXAyLmNyb3NzVmVjdG9ycyggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0sIHQgKTtcbiAgICAgICAgdGVzdCA9IHRtcDIuZG90KCB0YW4yWyB2ZXJ0ZXhJbmRleCBdICk7XG4gICAgICAgIHcgPSAoIHRlc3QgPCAwLjAgKSA/IC0gMS4wIDogMS4wO1xuXG4gICAgICAgIGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IG5ldyBUSFJFRS5WZWN0b3I0KCB0bXAueCwgdG1wLnksIHRtcC56LCB3ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuaGFzVGFuZ2VudHMgPSB0cnVlO1xuXG4gIH0sXG5cbiAgY29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBpZiAoIGkgPiAwICkge1xuXG4gICAgICAgIGQgKz0gdmVydGljZXNbIGkgXS5kaXN0YW5jZVRvKCB2ZXJ0aWNlc1sgaSAtIDEgXSApO1xuXG4gICAgICB9XG5cbiAgICAgIHRoaXMubGluZURpc3RhbmNlc1sgaSBdID0gZDtcblxuICAgIH1cblxuICB9LFxuXG4gIGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xuXG4gIH0sXG5cbiAgY29tcHV0ZUJvdW5kaW5nU3BoZXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XG5cbiAgICB9XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldEZyb21Qb2ludHMoIHRoaXMudmVydGljZXMgKTtcblxuICB9LFxuXG4gIG1lcmdlOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRyaXggKSB7XG5cbiAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgPT09IGZhbHNlICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsTWF0cml4LFxuICAgIHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgIHZlcnRpY2VzMSA9IHRoaXMudmVydGljZXMsXG4gICAgdmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXG4gICAgZmFjZXMxID0gdGhpcy5mYWNlcyxcbiAgICBmYWNlczIgPSBnZW9tZXRyeS5mYWNlcyxcbiAgICB1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXG4gICAgdXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXTtcblxuICAgIGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCkuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcblxuICAgIH1cblxuICAgIC8vIHZlcnRpY2VzXG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XG5cbiAgICAgIHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XG5cbiAgICAgIGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XG5cbiAgICAgIHZlcnRpY2VzMS5wdXNoKCB2ZXJ0ZXhDb3B5ICk7XG5cbiAgICB9XG5cbiAgICAvLyBmYWNlc1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgZmFjZSA9IGZhY2VzMlsgaSBdLCBmYWNlQ29weSwgbm9ybWFsLCBjb2xvcixcbiAgICAgIGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxuICAgICAgZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG4gICAgICBmYWNlQ29weSA9IG5ldyBUSFJFRS5GYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xuICAgICAgZmFjZUNvcHkubm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XG5cbiAgICAgIGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIG5vcm1hbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzWyBqIF0uY2xvbmUoKTtcblxuICAgICAgICBpZiAoIG5vcm1hbE1hdHJpeCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgbm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICAgIH1cblxuICAgICAgZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xuXG4gICAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICBjb2xvciA9IGZhY2VWZXJ0ZXhDb2xvcnNbIGogXTtcbiAgICAgICAgZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcblxuICAgICAgfVxuXG4gICAgICBmYWNlczEucHVzaCggZmFjZUNvcHkgKTtcblxuICAgIH1cblxuICAgIC8vIHV2c1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gdXZzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIHV2ID0gdXZzMlsgaSBdLCB1dkNvcHkgPSBbXTtcblxuICAgICAgaWYgKCB1diA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICB1dkNvcHkucHVzaCggdXZbIGogXS5jbG9uZSgpICk7XG5cbiAgICAgIH1cblxuICAgICAgdXZzMS5wdXNoKCB1dkNvcHkgKTtcblxuICAgIH1cblxuICB9LFxuXG4gIG1lcmdlTWVzaDogZnVuY3Rpb24gKCBtZXNoICkge1xuXG4gICAgaWYgKCBtZXNoIGluc3RhbmNlb2YgVEhSRUUuTWVzaCA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5HZW9tZXRyeS5tZXJnZU1lc2goKTogbWVzaCBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuTWVzaC4nLCBtZXNoICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICBtZXNoLm1hdHJpeEF1dG9VcGRhdGUgJiYgbWVzaC51cGRhdGVNYXRyaXgoKTtcblxuICAgIHRoaXMubWVyZ2UoIG1lc2guZ2VvbWV0cnksIG1lc2gubWF0cml4ICk7XG5cbiAgfSxcblxuICAvKlxuICAgKiBDaGVja3MgZm9yIGR1cGxpY2F0ZSB2ZXJ0aWNlcyB3aXRoIGhhc2htYXAuXG4gICAqIER1cGxpY2F0ZWQgdmVydGljZXMgYXJlIHJlbW92ZWRcbiAgICogYW5kIGZhY2VzJyB2ZXJ0aWNlcyBhcmUgdXBkYXRlZC5cbiAgICovXG5cbiAgbWVyZ2VWZXJ0aWNlczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZSBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcbiAgICB2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcblxuICAgIHZhciB2LCBrZXk7XG4gICAgdmFyIHByZWNpc2lvblBvaW50cyA9IDQ7IC8vIG51bWJlciBvZiBkZWNpbWFsIHBvaW50cywgZWcuIDQgZm9yIGVwc2lsb24gb2YgMC4wMDAxXG4gICAgdmFyIHByZWNpc2lvbiA9IE1hdGgucG93KCAxMCwgcHJlY2lzaW9uUG9pbnRzICk7XG4gICAgdmFyIGksIGlsLCBmYWNlO1xuICAgIHZhciBpbmRpY2VzLCBqLCBqbDtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWyBpIF07XG4gICAgICBrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XG5cbiAgICAgIGlmICggdmVydGljZXNNYXBbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmVydGljZXNNYXBbIGtleSBdID0gaTtcbiAgICAgICAgdW5pcXVlLnB1c2goIHRoaXMudmVydGljZXNbIGkgXSApO1xuICAgICAgICBjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xuICAgICAgICBjaGFuZ2VzWyBpIF0gPSBjaGFuZ2VzWyB2ZXJ0aWNlc01hcFsga2V5IF0gXTtcblxuICAgICAgfVxuXG4gICAgfVxuXG5cbiAgICAvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXG4gICAgLy8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cbiAgICB2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xuXG4gICAgZm9yICggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcblxuICAgICAgZmFjZS5hID0gY2hhbmdlc1sgZmFjZS5hIF07XG4gICAgICBmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcbiAgICAgIGZhY2UuYyA9IGNoYW5nZXNbIGZhY2UuYyBdO1xuXG4gICAgICBpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XG5cbiAgICAgIHZhciBkdXBJbmRleCA9IC0gMTtcblxuICAgICAgLy8gaWYgYW55IGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhcmUgZm91bmQgaW4gYSBGYWNlM1xuICAgICAgLy8gd2UgaGF2ZSB0byByZW1vdmUgdGhlIGZhY2UgYXMgbm90aGluZyBjYW4gYmUgc2F2ZWRcbiAgICAgIGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XG4gICAgICAgIGlmICggaW5kaWNlc1sgbiBdID09PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XG5cbiAgICAgICAgICBkdXBJbmRleCA9IG47XG4gICAgICAgICAgZmFjZUluZGljZXNUb1JlbW92ZS5wdXNoKCBpICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICggaSA9IGZhY2VJbmRpY2VzVG9SZW1vdmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC0tICkge1xuICAgICAgdmFyIGlkeCA9IGZhY2VJbmRpY2VzVG9SZW1vdmVbIGkgXTtcblxuICAgICAgdGhpcy5mYWNlcy5zcGxpY2UoIGlkeCwgMSApO1xuXG4gICAgICBmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gVXNlIHVuaXF1ZSBzZXQgb2YgdmVydGljZXNcblxuICAgIHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xuICAgIHRoaXMudmVydGljZXMgPSB1bmlxdWU7XG4gICAgcmV0dXJuIGRpZmY7XG5cbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgdmVyc2lvbjogNC40LFxuICAgICAgICB0eXBlOiAnR2VvbWV0cnknLFxuICAgICAgICBnZW5lcmF0b3I6ICdHZW9tZXRyeS50b0pTT04nXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0YW5kYXJkIEdlb21ldHJ5IHNlcmlhbGl6YXRpb25cblxuICAgIGRhdGEudXVpZCA9IHRoaXMudXVpZDtcbiAgICBkYXRhLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgaWYgKCB0aGlzLm5hbWUgIT09ICcnICkgZGF0YS5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgaWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XG5cbiAgICAgIGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcblxuICAgICAgICBpZiAoIHBhcmFtZXRlcnNbIGtleSBdICE9PSB1bmRlZmluZWQgKSBkYXRhWyBrZXkgXSA9IHBhcmFtZXRlcnNbIGtleSBdO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgfVxuXG4gICAgdmFyIHZlcnRpY2VzID0gW107XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbIGkgXTtcbiAgICAgIHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcblxuICAgIH1cblxuICAgIHZhciBmYWNlcyA9IFtdO1xuICAgIHZhciBub3JtYWxzID0gW107XG4gICAgdmFyIG5vcm1hbHNIYXNoID0ge307XG4gICAgdmFyIGNvbG9ycyA9IFtdO1xuICAgIHZhciBjb2xvcnNIYXNoID0ge307XG4gICAgdmFyIHV2cyA9IFtdO1xuICAgIHZhciB1dnNIYXNoID0ge307XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmZhY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XG5cbiAgICAgIHZhciBoYXNNYXRlcmlhbCA9IGZhbHNlOyAvLyBmYWNlLm1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBoYXNGYWNlVXYgPSBmYWxzZTsgLy8gZGVwcmVjYXRlZFxuICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF0gIT09IHVuZGVmaW5lZDtcbiAgICAgIHZhciBoYXNGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwubGVuZ3RoKCkgPiAwO1xuICAgICAgdmFyIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoID4gMDtcbiAgICAgIHZhciBoYXNGYWNlQ29sb3IgPSBmYWNlLmNvbG9yLnIgIT09IDEgfHwgZmFjZS5jb2xvci5nICE9PSAxIHx8IGZhY2UuY29sb3IuYiAhPT0gMTtcbiAgICAgIHZhciBoYXNGYWNlVmVydGV4Q29sb3IgPSBmYWNlLnZlcnRleENvbG9ycy5sZW5ndGggPiAwO1xuXG4gICAgICB2YXIgZmFjZVR5cGUgPSAwO1xuXG4gICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDAsIDAgKTtcbiAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMSwgaGFzTWF0ZXJpYWwgKTtcbiAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMiwgaGFzRmFjZVV2ICk7XG4gICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDMsIGhhc0ZhY2VWZXJ0ZXhVdiApO1xuICAgICAgZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA0LCBoYXNGYWNlTm9ybWFsICk7XG4gICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDUsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKTtcbiAgICAgIGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNiwgaGFzRmFjZUNvbG9yICk7XG4gICAgICBmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDcsIGhhc0ZhY2VWZXJ0ZXhDb2xvciApO1xuXG4gICAgICBmYWNlcy5wdXNoKCBmYWNlVHlwZSApO1xuICAgICAgZmFjZXMucHVzaCggZmFjZS5hLCBmYWNlLmIsIGZhY2UuYyApO1xuXG4gICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgICAgICB2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XG5cbiAgICAgICAgZmFjZXMucHVzaChcbiAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcbiAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAxIF0gKSxcbiAgICAgICAgICBnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxuICAgICAgICApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgICAgICBmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgICAgICB2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcblxuICAgICAgICBmYWNlcy5wdXNoKFxuICAgICAgICAgIGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAwIF0gKSxcbiAgICAgICAgICBnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMSBdICksXG4gICAgICAgICAgZ2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDIgXSApXG4gICAgICAgICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cbiAgICAgICAgZmFjZXMucHVzaCggZ2V0Q29sb3JJbmRleCggZmFjZS5jb2xvciApICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xuXG4gICAgICAgIGZhY2VzLnB1c2goXG4gICAgICAgICAgZ2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAwIF0gKSxcbiAgICAgICAgICBnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDEgXSApLFxuICAgICAgICAgIGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMiBdIClcbiAgICAgICAgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0Qml0KCB2YWx1ZSwgcG9zaXRpb24sIGVuYWJsZWQgKSB7XG5cbiAgICAgIHJldHVybiBlbmFibGVkID8gdmFsdWUgfCAoIDEgPDwgcG9zaXRpb24gKSA6IHZhbHVlICYgKCB+ICggMSA8PCBwb3NpdGlvbikgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE5vcm1hbEluZGV4KCBub3JtYWwgKSB7XG5cbiAgICAgIHZhciBoYXNoID0gbm9ybWFsLngudG9TdHJpbmcoKSArIG5vcm1hbC55LnRvU3RyaW5nKCkgKyBub3JtYWwuei50b1N0cmluZygpO1xuXG4gICAgICBpZiAoIG5vcm1hbHNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICByZXR1cm4gbm9ybWFsc0hhc2hbIGhhc2ggXTtcblxuICAgICAgfVxuXG4gICAgICBub3JtYWxzSGFzaFsgaGFzaCBdID0gbm9ybWFscy5sZW5ndGggLyAzO1xuICAgICAgbm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XG5cbiAgICAgIHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Q29sb3JJbmRleCggY29sb3IgKSB7XG5cbiAgICAgIHZhciBoYXNoID0gY29sb3Iuci50b1N0cmluZygpICsgY29sb3IuZy50b1N0cmluZygpICsgY29sb3IuYi50b1N0cmluZygpO1xuXG4gICAgICBpZiAoIGNvbG9yc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XG5cbiAgICAgIH1cblxuICAgICAgY29sb3JzSGFzaFsgaGFzaCBdID0gY29sb3JzLmxlbmd0aDtcbiAgICAgIGNvbG9ycy5wdXNoKCBjb2xvci5nZXRIZXgoKSApO1xuXG4gICAgICByZXR1cm4gY29sb3JzSGFzaFsgaGFzaCBdO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XG5cbiAgICAgIHZhciBoYXNoID0gdXYueC50b1N0cmluZygpICsgdXYueS50b1N0cmluZygpO1xuXG4gICAgICBpZiAoIHV2c0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiB1dnNIYXNoWyBoYXNoIF07XG5cbiAgICAgIH1cblxuICAgICAgdXZzSGFzaFsgaGFzaCBdID0gdXZzLmxlbmd0aCAvIDI7XG4gICAgICB1dnMucHVzaCggdXYueCwgdXYueSApO1xuXG4gICAgICByZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xuXG4gICAgfVxuXG4gICAgZGF0YS5kYXRhID0ge307XG5cbiAgICBkYXRhLmRhdGEudmVydGljZXMgPSB2ZXJ0aWNlcztcbiAgICBkYXRhLmRhdGEubm9ybWFscyA9IG5vcm1hbHM7XG4gICAgaWYgKCBjb2xvcnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS5jb2xvcnMgPSBjb2xvcnM7XG4gICAgaWYgKCB1dnMubGVuZ3RoID4gMCApIGRhdGEuZGF0YS51dnMgPSBbIHV2cyBdOyAvLyB0ZW1wb3JhbCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgZGF0YS5kYXRhLmZhY2VzID0gZmFjZXM7XG5cbiAgICByZXR1cm4gZGF0YTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBpIF0uY2xvbmUoKSApO1xuXG4gICAgfVxuXG4gICAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICB2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdO1xuXG4gICAgICBpZiAoIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIHZhciB1dnMgPSBmYWNlVmVydGV4VXZzWyBqIF0sIHV2c0NvcHkgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgayA9IDAsIGtsID0gdXZzLmxlbmd0aDsgayA8IGtsOyBrICsrICkge1xuXG4gICAgICAgICAgdmFyIHV2ID0gdXZzWyBrIF07XG5cbiAgICAgICAgICB1dnNDb3B5LnB1c2goIHV2LmNsb25lKCkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdLnB1c2goIHV2c0NvcHkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuXG4gIH0sXG5cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblxuVEhSRUUuR2VvbWV0cnlJZENvdW50ID0gMDtcblxuLy8gRmlsZTpzcmMvY29yZS9EaXJlY3RHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuRGlyZWN0R2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xuXG4gIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgdGhpcy5uYW1lID0gJyc7XG4gIHRoaXMudHlwZSA9ICdEaXJlY3RHZW9tZXRyeSc7XG5cbiAgdGhpcy5pbmRpY2VzID0gW107XG4gIHRoaXMudmVydGljZXMgPSBbXTtcbiAgdGhpcy5jb2xvcnMgPSBbXTtcbiAgdGhpcy5ub3JtYWxzID0gW107XG4gIHRoaXMuY29sb3JzID0gW107XG4gIHRoaXMudXZzID0gW107XG4gIHRoaXMudXZzMiA9IFtdO1xuXG4gIHRoaXMubW9ycGhUYXJnZXRzID0gW107XG4gIHRoaXMubW9ycGhDb2xvcnMgPSBbXTtcbiAgdGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcblxuICB0aGlzLnNraW5XZWlnaHRzID0gW107XG4gIHRoaXMuc2tpbkluZGljZXMgPSBbXTtcblxuICAvLyB0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcblxuICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbiAgLy8gdXBkYXRlIGZsYWdzXG5cbiAgdGhpcy52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgdGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuRGlyZWN0R2VvbWV0cnksXG5cbiAgY29tcHV0ZUJvdW5kaW5nQm94OiBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUuY29tcHV0ZUJvdW5kaW5nQm94LFxuICBjb21wdXRlQm91bmRpbmdTcGhlcmU6IFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlQm91bmRpbmdTcGhlcmUsXG5cbiAgY29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeTogY29tcHV0ZUZhY2VOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnk6IGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkgaXMgbm90IGEgbWV0aG9kIG9mIHRoaXMgdHlwZSBvZiBnZW9tZXRyeS4nICk7XG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gICAgbWF0ZXJpYWwgPSBtYXRlcmlhbCB8fCB7ICd2ZXJ0ZXhDb2xvcnMnOiBUSFJFRS5Ob0NvbG9ycyB9O1xuXG4gICAgdmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XG4gICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG4gICAgdmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xuICAgIHZhciBtYXRlcmlhbFZlcnRleENvbG9ycyA9IG1hdGVyaWFsLnZlcnRleENvbG9ycztcblxuICAgIHZhciBoYXNGYWNlVmVydGV4VXYgPSBmYWNlVmVydGV4VXZzWyAwIF0gJiYgZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCA+IDA7XG4gICAgdmFyIGhhc0ZhY2VWZXJ0ZXhVdjIgPSBmYWNlVmVydGV4VXZzWyAxIF0gJiYgZmFjZVZlcnRleFV2c1sgMSBdLmxlbmd0aCA+IDA7XG5cbiAgICAvLyBtb3JwaHNcblxuICAgIHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XG4gICAgdmFyIG1vcnBoVGFyZ2V0c0xlbmd0aCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaFRhcmdldHNMZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMubW9ycGhUYXJnZXRzWyBpIF0gPSBbXTtcblxuICAgIH1cblxuICAgIHZhciBtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XG4gICAgdmFyIG1vcnBoTm9ybWFsc0xlbmd0aCA9IG1vcnBoTm9ybWFscy5sZW5ndGg7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSBbXTtcblxuICAgIH1cblxuICAgIHZhciBtb3JwaENvbG9ycyA9IGdlb21ldHJ5Lm1vcnBoQ29sb3JzO1xuICAgIHZhciBtb3JwaENvbG9yc0xlbmd0aCA9IG1vcnBoQ29sb3JzLmxlbmd0aDtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1vcnBoQ29sb3JzTGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB0aGlzLm1vcnBoQ29sb3JzWyBpIF0gPSBbXTtcblxuICAgIH1cblxuICAgIC8vIHNraW5zXG5cbiAgICB2YXIgc2tpbkluZGljZXMgPSBnZW9tZXRyeS5za2luSW5kaWNlcztcbiAgICB2YXIgc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cztcblxuICAgIHZhciBoYXNTa2luSW5kaWNlcyA9IHNraW5JbmRpY2VzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuICAgIHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgLy9cblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGZhY2VzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcblxuICAgICAgdmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XG5cbiAgICAgIGlmICggdmVydGV4Tm9ybWFscy5sZW5ndGggPT09IDMgKSB7XG5cbiAgICAgICAgdGhpcy5ub3JtYWxzLnB1c2goIHZlcnRleE5vcm1hbHNbIDAgXSwgdmVydGV4Tm9ybWFsc1sgMSBdLCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XG5cbiAgICAgICAgdGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XG5cbiAgICAgIGlmICggbWF0ZXJpYWxWZXJ0ZXhDb2xvcnMgPT09IFRIUkVFLlZlcnRleENvbG9ycyApIHtcblxuICAgICAgICB0aGlzLmNvbG9ycy5wdXNoKCB2ZXJ0ZXhDb2xvcnNbIDAgXSwgdmVydGV4Q29sb3JzWyAxIF0sIHZlcnRleENvbG9yc1sgMiBdICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsVmVydGV4Q29sb3JzID09PSBUSFJFRS5GYWNlQ29sb3JzICkge1xuXG4gICAgICAgIHZhciBjb2xvciA9IGZhY2UuY29sb3I7XG5cbiAgICAgICAgdGhpcy5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaGFzRmFjZVZlcnRleFV2ID09PSB0cnVlICkge1xuXG4gICAgICAgIHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgICAgICBpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgdGhpcy51dnMucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2JywgaSApO1xuXG4gICAgICAgICAgdGhpcy51dnMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSwgbmV3IFRIUkVFLlZlY3RvcjIoKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdjIgPT09IHRydWUgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDEgXVsgaSBdO1xuXG4gICAgICAgIGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICB0aGlzLnV2czIucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MicsIGkgKTtcblxuICAgICAgICAgIHRoaXMudXZzMi5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpLCBuZXcgVEhSRUUuVmVjdG9yMigpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIG1vcnBoc1xuXG4gICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaFRhcmdldHNMZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBqIF0udmVydGljZXM7XG5cbiAgICAgICAgdGhpcy5tb3JwaFRhcmdldHNbIGogXS5wdXNoKCBtb3JwaFRhcmdldFsgZmFjZS5hIF0sIG1vcnBoVGFyZ2V0WyBmYWNlLmIgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYyBdICk7XG5cbiAgICAgIH1cbiAgICAgIC8qXG4gICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGogKysgKSB7XG5cbiAgICAgICAgdmFyIG1vcnBoTm9ybWFsID0gbW9ycGhOb3JtYWxzWyBqIF0udmVydGV4Tm9ybWFsc1sgaSBdO1xuXG4gICAgICAgIHRoaXMubW9ycGhOb3JtYWxzWyBqIF0ucHVzaCggbW9ycGhOb3JtYWwuYSwgbW9ycGhOb3JtYWwuYiwgbW9ycGhOb3JtYWwuYyApO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoQ29sb3JzTGVuZ3RoOyBqICsrICkge1xuXG4gICAgICAgIHZhciBtb3JwaENvbG9yID0gbW9ycGhDb2xvcnNbIGogXS5jb2xvcnM7XG5cbiAgICAgICAgdGhpcy5tb3JwaENvbG9yc1sgaiBdLnB1c2goIG1vcnBoQ29sb3JbIGZhY2UuYSBdLCBtb3JwaENvbG9yWyBmYWNlLmIgXSwgbW9ycGhDb2xvclsgZmFjZS5jIF0gKTtcblxuICAgICAgfVxuICAgICAgKi9cblxuICAgICAgLy8gc2tpbnNcblxuICAgICAgaWYgKCBoYXNTa2luSW5kaWNlcyApIHtcblxuICAgICAgICB0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBmYWNlLmEgXSwgc2tpbkluZGljZXNbIGZhY2UuYiBdLCBza2luSW5kaWNlc1sgZmFjZS5jIF0gKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGhhc1NraW5XZWlnaHRzICkge1xuXG4gICAgICAgIHRoaXMuc2tpbldlaWdodHMucHVzaCggc2tpbldlaWdodHNbIGZhY2UuYSBdLCBza2luV2VpZ2h0c1sgZmFjZS5iIF0sIHNraW5XZWlnaHRzWyBmYWNlLmMgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcbiAgICB0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG4gICAgdGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcbiAgICB0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfSxcblxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkRpcmVjdEdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9jb3JlL0J1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKysgfSApO1xuXG4gIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgdGhpcy5uYW1lID0gJyc7XG4gIHRoaXMudHlwZSA9ICdCdWZmZXJHZW9tZXRyeSc7XG5cbiAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG5cbiAgdGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSBbXTtcblxuICB0aGlzLmRyYXdjYWxscyA9IFtdO1xuICB0aGlzLm9mZnNldHMgPSB0aGlzLmRyYXdjYWxsczsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcbiAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XG5cbn07XG5cblRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuQnVmZmVyR2VvbWV0cnksXG5cbiAgYWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUsIGF0dHJpYnV0ZSApIHtcblxuICAgIGlmICggYXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyQXR0cmlidXRlID09PSBmYWxzZSAmJiBhdHRyaWJ1dGUgaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgbm93IGV4cGVjdHMgKCBuYW1lLCBhdHRyaWJ1dGUgKS4nICk7XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdID0geyBhcnJheTogYXJndW1lbnRzWyAxIF0sIGl0ZW1TaXplOiBhcmd1bWVudHNbIDIgXSB9O1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcblxuICB9LFxuXG4gIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gIH0sXG5cbiAgYWRkRHJhd0NhbGw6IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCApIHtcblxuICAgIHRoaXMuZHJhd2NhbGxzLnB1c2goIHtcblxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgY291bnQ6IGNvdW50LFxuICAgICAgaW5kZXg6IGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBpbmRleE9mZnNldCA6IDBcblxuICAgIH0gKTtcblxuICB9LFxuXG4gIGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcblxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbWF0cml4LmFwcGx5VG9WZWN0b3IzQXJyYXkoIHBvc2l0aW9uLmFycmF5ICk7XG4gICAgICBwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgICB2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgIGlmICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XG5cbiAgICAgIG5vcm1hbE1hdHJpeC5hcHBseVRvVmVjdG9yM0FycmF5KCBub3JtYWwuYXJyYXkgKTtcbiAgICAgIG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XG5cbiAgICB9XG5cbiAgfSxcblxuICBjb3B5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgIHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCBuYW1lLCBhdHRyaWJ1dGUuY2xvbmUoKSApO1xuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRzWyBpIF07XG5cbiAgICAgIHRoaXMub2Zmc2V0cy5wdXNoKCB7XG5cbiAgICAgICAgc3RhcnQ6IG9mZnNldC5zdGFydCxcbiAgICAgICAgaW5kZXg6IG9mZnNldC5pbmRleCxcbiAgICAgICAgY291bnQ6IG9mZnNldC5jb3VudFxuXG4gICAgICB9ICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNlbnRlcjogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuICAgIHZhciBvZmZzZXQgPSB0aGlzLmJvdW5kaW5nQm94LmNlbnRlcigpLm5lZ2F0ZSgpO1xuXG4gICAgdGhpcy5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5zZXRQb3NpdGlvbiggb2Zmc2V0ICkgKTtcblxuICAgIHJldHVybiBvZmZzZXQ7XG5cbiAgfSxcblxuICBzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIGNvbnNvbGUubG9nKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuc2V0RnJvbU9iamVjdCgpLiBDb252ZXJ0aW5nJywgb2JqZWN0LCB0aGlzICk7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG4gICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XG5cbiAgICAgIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuRmxvYXQzMkF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMywgMyApO1xuICAgICAgdmFyIGNvbG9ycyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMywgMyApO1xuXG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgY29sb3JzLmNvcHlDb2xvcnNBcnJheSggZ2VvbWV0cnkuY29sb3JzICkgKTtcblxuICAgICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG4gICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XG5cbiAgICAgICAgdGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgdXBkYXRlRnJvbU9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XG5cbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XG5cbiAgICAgIHZhciBkaXJlY3QgPSBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5O1xuXG4gICAgICBkaXJlY3QudmVydGljZXNOZWVkVXBkYXRlID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlO1xuICAgICAgZGlyZWN0Lm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XG4gICAgICBkaXJlY3QuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XG4gICAgICBkaXJlY3QudXZzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGU7XG5cbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgIGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgICAgZ2VvbWV0cnkgPSBkaXJlY3Q7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzICk7XG4gICAgICAgIGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIH1cblxuICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcblxuICAgICAgaWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBhdHRyaWJ1dGUuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKTtcbiAgICAgICAgYXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgfVxuXG4gICAgICBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzLmNvbG9yO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xuICAgICAgICBhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICB9XG5cbiAgICAgIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH0sXG5cbiAgZnJvbUdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICAgIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgPSBuZXcgVEhSRUUuRGlyZWN0R2VvbWV0cnkoKS5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gICAgcmV0dXJuIHRoaXMuZnJvbURpcmVjdEdlb21ldHJ5KCBnZW9tZXRyeS5fX2RpcmVjdEdlb21ldHJ5ICk7XG5cbiAgfSxcblxuICBmcm9tRGlyZWN0R2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICBpZiAoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoID4gMCApIHtcblxuICAgICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIGdlb21ldHJ5LmluZGljZXMubGVuZ3RoICogMyApO1xuICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdpbmRleCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKS5jb3B5SW5kaWNlc0FycmF5KCBnZW9tZXRyeS5pbmRpY2VzICkgKTtcblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoID4gMCApIHtcblxuICAgICAgdmFyIHBvc2l0aW9ucyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCAqIDMgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS5ub3JtYWxzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKiAzICk7XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkubm9ybWFscyApICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgY29sb3JzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LnV2cy5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudXZzLmxlbmd0aCAqIDIgKTtcbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICkgKTtcblxuICAgIH1cblxuICAgIC8vIG1vcnBoc1xuXG4gICAgaWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgdmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XG5cbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5sZW5ndGggKiAzLCAzICk7XG5cbiAgICAgICAgdGhpcy5tb3JwaEF0dHJpYnV0ZXMucHVzaCggYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBtb3JwaFRhcmdldCApICk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyBub3JtYWxzLCBjb2xvcnNcblxuICAgIH1cblxuICAgIC8vIHNraW5uaW5nXG5cbiAgICBpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIHZhciBza2luSW5kaWNlcyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKiA0LCA0ICk7XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIHNraW5JbmRpY2VzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luSW5kaWNlcyApICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCA+IDAgKSB7XG5cbiAgICAgIHZhciBza2luV2VpZ2h0cyA9IG5ldyBUSFJFRS5GbG9hdDMyQXR0cmlidXRlKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKiA0LCA0ICk7XG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5XZWlnaHQnLCBza2luV2VpZ2h0cy5jb3B5VmVjdG9yNHNBcnJheSggZ2VvbWV0cnkuc2tpbldlaWdodHMgKSApO1xuXG4gICAgfVxuXG4gICAgLy9cblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XG5cbiAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xuXG4gICAgfVxuXG4gICAgaWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcblxuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGdlb21ldHJ5LmJvdW5kaW5nQm94LmNsb25lKCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgICAgaWYgKCBwb3NpdGlvbnMgKSB7XG5cbiAgICAgICAgdmFyIGJiID0gdGhpcy5ib3VuZGluZ0JveDtcbiAgICAgICAgYmIubWFrZUVtcHR5KCk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgYmIuZXhwYW5kQnlQb2ludCggdmVjdG9yICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICggcG9zaXRpb25zID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICB0aGlzLmJvdW5kaW5nQm94Lm1pbi5zZXQoIDAsIDAsIDAgKTtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveC5tYXguc2V0KCAwLCAwLCAwICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94OiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cbiAgICAgIH1cblxuICAgIH07XG5cbiAgfSgpLFxuXG4gIGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGJveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgICBpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICBpZiAoIHBvc2l0aW9ucyApIHtcblxuICAgICAgICBib3gubWFrZUVtcHR5KCk7XG5cbiAgICAgICAgdmFyIGNlbnRlciA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgIHZlY3Rvci5mcm9tQXJyYXkoIHBvc2l0aW9ucywgaSApO1xuICAgICAgICAgIGJveC5leHBhbmRCeVBvaW50KCB2ZWN0b3IgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgYm94LmNlbnRlciggY2VudGVyICk7XG5cbiAgICAgICAgLy8gaG9waW5nIHRvIGZpbmQgYSBib3VuZGluZ1NwaGVyZSB3aXRoIGEgcmFkaXVzIHNtYWxsZXIgdGhhbiB0aGVcbiAgICAgICAgLy8gYm91bmRpbmdTcGhlcmUgb2YgdGhlIGJvdW5kaW5nQm94OiBzcXJ0KDMpIHNtYWxsZXIgaW4gdGhlIGJlc3QgY2FzZVxuXG4gICAgICAgIHZhciBtYXhSYWRpdXNTcSA9IDA7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgICAgdmVjdG9yLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgbWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggdmVjdG9yICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgPSBNYXRoLnNxcnQoIG1heFJhZGl1c1NxICk7XG5cbiAgICAgICAgaWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMgKSApIHtcblxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogQ29tcHV0ZWQgcmFkaXVzIGlzIE5hTi4gVGhlIFwicG9zaXRpb25cIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9O1xuXG4gIH0oKSxcblxuICBjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbiAgfSxcblxuICBjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICBpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XG5cbiAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBwb3NpdGlvbnMubGVuZ3RoICksIDMgKSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xuXG4gICAgICAgIHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICBub3JtYWxzWyBpIF0gPSAwO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xuXG4gICAgICB2YXIgdkEsIHZCLCB2QyxcblxuICAgICAgcEEgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgcEIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgICAgcEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgICBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgICBhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIC8vIGluZGV4ZWQgZWxlbWVudHNcblxuICAgICAgaWYgKCBhdHRyaWJ1dGVzLmluZGV4ICkge1xuXG4gICAgICAgIHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcblxuICAgICAgICB2YXIgb2Zmc2V0cyA9ICggdGhpcy5vZmZzZXRzLmxlbmd0aCA+IDAgPyB0aGlzLm9mZnNldHMgOiBbIHsgc3RhcnQ6IDAsIGNvdW50OiBpbmRpY2VzLmxlbmd0aCwgaW5kZXg6IDAgfSBdICk7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IG9mZnNldHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXRzWyBqIF0uc3RhcnQ7XG4gICAgICAgICAgdmFyIGNvdW50ID0gb2Zmc2V0c1sgaiBdLmNvdW50O1xuICAgICAgICAgIHZhciBpbmRleCA9IG9mZnNldHNbIGogXS5pbmRleDtcblxuICAgICAgICAgIGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgICAgIHZBID0gKCBpbmRleCArIGluZGljZXNbIGkgICAgIF0gKSAqIDM7XG4gICAgICAgICAgICB2QiA9ICggaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdICkgKiAzO1xuICAgICAgICAgICAgdkMgPSAoIGluZGV4ICsgaW5kaWNlc1sgaSArIDIgXSApICogMztcblxuICAgICAgICAgICAgcEEuZnJvbUFycmF5KCBwb3NpdGlvbnMsIHZBICk7XG4gICAgICAgICAgICBwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkIgKTtcbiAgICAgICAgICAgIHBDLmZyb21BcnJheSggcG9zaXRpb25zLCB2QyApO1xuXG4gICAgICAgICAgICBjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcbiAgICAgICAgICAgIGFiLnN1YlZlY3RvcnMoIHBBLCBwQiApO1xuICAgICAgICAgICAgY2IuY3Jvc3MoIGFiICk7XG5cbiAgICAgICAgICAgIG5vcm1hbHNbIHZBICAgICBdICs9IGNiLng7XG4gICAgICAgICAgICBub3JtYWxzWyB2QSArIDEgXSArPSBjYi55O1xuICAgICAgICAgICAgbm9ybWFsc1sgdkEgKyAyIF0gKz0gY2IuejtcblxuICAgICAgICAgICAgbm9ybWFsc1sgdkIgICAgIF0gKz0gY2IueDtcbiAgICAgICAgICAgIG5vcm1hbHNbIHZCICsgMSBdICs9IGNiLnk7XG4gICAgICAgICAgICBub3JtYWxzWyB2QiArIDIgXSArPSBjYi56O1xuXG4gICAgICAgICAgICBub3JtYWxzWyB2QyAgICAgXSArPSBjYi54O1xuICAgICAgICAgICAgbm9ybWFsc1sgdkMgKyAxIF0gKz0gY2IueTtcbiAgICAgICAgICAgIG5vcm1hbHNbIHZDICsgMiBdICs9IGNiLno7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIG5vbi1pbmRleGVkIGVsZW1lbnRzICh1bmNvbm5lY3RlZCB0cmlhbmdsZSBzb3VwKVxuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gOSApIHtcblxuICAgICAgICAgIHBBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XG4gICAgICAgICAgcEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XG4gICAgICAgICAgcEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XG5cbiAgICAgICAgICBjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcbiAgICAgICAgICBhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcbiAgICAgICAgICBjYi5jcm9zcyggYWIgKTtcblxuICAgICAgICAgIG5vcm1hbHNbIGkgICAgIF0gPSBjYi54O1xuICAgICAgICAgIG5vcm1hbHNbIGkgKyAxIF0gPSBjYi55O1xuICAgICAgICAgIG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xuXG4gICAgICAgICAgbm9ybWFsc1sgaSArIDMgXSA9IGNiLng7XG4gICAgICAgICAgbm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XG4gICAgICAgICAgbm9ybWFsc1sgaSArIDUgXSA9IGNiLno7XG5cbiAgICAgICAgICBub3JtYWxzWyBpICsgNiBdID0gY2IueDtcbiAgICAgICAgICBub3JtYWxzWyBpICsgNyBdID0gY2IueTtcbiAgICAgICAgICBub3JtYWxzWyBpICsgOCBdID0gY2IuejtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7XG5cbiAgICAgIGF0dHJpYnV0ZXMubm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIH1cblxuICB9LFxuXG4gIGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gYmFzZWQgb24gaHR0cDovL3d3dy50ZXJhdGhvbi5jb20vY29kZS90YW5nZW50Lmh0bWxcbiAgICAvLyAocGVyIHZlcnRleCB0YW5nZW50cylcblxuICAgIGlmICggdGhpcy5hdHRyaWJ1dGVzLmluZGV4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgIHRoaXMuYXR0cmlidXRlcy5ub3JtYWwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgIHRoaXMuYXR0cmlidXRlcy51diA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1dikgaW4gQnVmZmVyR2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCknICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICB2YXIgaW5kaWNlcyA9IHRoaXMuYXR0cmlidXRlcy5pbmRleC5hcnJheTtcbiAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgIHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcbiAgICB2YXIgdXZzID0gdGhpcy5hdHRyaWJ1dGVzLnV2LmFycmF5O1xuXG4gICAgdmFyIG5WZXJ0aWNlcyA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXG4gICAgaWYgKCB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3RhbmdlbnQnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA0ICogblZlcnRpY2VzICksIDQgKSApO1xuXG4gICAgfVxuXG4gICAgdmFyIHRhbmdlbnRzID0gdGhpcy5hdHRyaWJ1dGVzLnRhbmdlbnQuYXJyYXk7XG5cbiAgICB2YXIgdGFuMSA9IFtdLCB0YW4yID0gW107XG5cbiAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBuVmVydGljZXM7IGsgKysgKSB7XG5cbiAgICAgIHRhbjFbIGsgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICB0YW4yWyBrIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgfVxuXG4gICAgdmFyIHZBID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIHZCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICAgIHZDID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAgICAgdXZBID0gbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAgICAgIHV2QiA9IG5ldyBUSFJFRS5WZWN0b3IyKCksXG4gICAgICB1dkMgPSBuZXcgVEhSRUUuVmVjdG9yMigpLFxuXG4gICAgICB4MSwgeDIsIHkxLCB5MiwgejEsIHoyLFxuICAgICAgczEsIHMyLCB0MSwgdDIsIHI7XG5cbiAgICB2YXIgc2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgZnVuY3Rpb24gaGFuZGxlVHJpYW5nbGUoIGEsIGIsIGMgKSB7XG5cbiAgICAgIHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuICAgICAgdkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG4gICAgICB2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcblxuICAgICAgdXZBLmZyb21BcnJheSggdXZzLCBhICogMiApO1xuICAgICAgdXZCLmZyb21BcnJheSggdXZzLCBiICogMiApO1xuICAgICAgdXZDLmZyb21BcnJheSggdXZzLCBjICogMiApO1xuXG4gICAgICB4MSA9IHZCLnggLSB2QS54O1xuICAgICAgeDIgPSB2Qy54IC0gdkEueDtcblxuICAgICAgeTEgPSB2Qi55IC0gdkEueTtcbiAgICAgIHkyID0gdkMueSAtIHZBLnk7XG5cbiAgICAgIHoxID0gdkIueiAtIHZBLno7XG4gICAgICB6MiA9IHZDLnogLSB2QS56O1xuXG4gICAgICBzMSA9IHV2Qi54IC0gdXZBLng7XG4gICAgICBzMiA9IHV2Qy54IC0gdXZBLng7XG5cbiAgICAgIHQxID0gdXZCLnkgLSB1dkEueTtcbiAgICAgIHQyID0gdXZDLnkgLSB1dkEueTtcblxuICAgICAgciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcblxuICAgICAgc2Rpci5zZXQoXG4gICAgICAgICggdDIgKiB4MSAtIHQxICogeDIgKSAqIHIsXG4gICAgICAgICggdDIgKiB5MSAtIHQxICogeTIgKSAqIHIsXG4gICAgICAgICggdDIgKiB6MSAtIHQxICogejIgKSAqIHJcbiAgICAgICk7XG5cbiAgICAgIHRkaXIuc2V0KFxuICAgICAgICAoIHMxICogeDIgLSBzMiAqIHgxICkgKiByLFxuICAgICAgICAoIHMxICogeTIgLSBzMiAqIHkxICkgKiByLFxuICAgICAgICAoIHMxICogejIgLSBzMiAqIHoxICkgKiByXG4gICAgICApO1xuXG4gICAgICB0YW4xWyBhIF0uYWRkKCBzZGlyICk7XG4gICAgICB0YW4xWyBiIF0uYWRkKCBzZGlyICk7XG4gICAgICB0YW4xWyBjIF0uYWRkKCBzZGlyICk7XG5cbiAgICAgIHRhbjJbIGEgXS5hZGQoIHRkaXIgKTtcbiAgICAgIHRhbjJbIGIgXS5hZGQoIHRkaXIgKTtcbiAgICAgIHRhbjJbIGMgXS5hZGQoIHRkaXIgKTtcblxuICAgIH1cblxuICAgIHZhciBpLCBpbDtcbiAgICB2YXIgaiwgamw7XG4gICAgdmFyIGlBLCBpQiwgaUM7XG5cbiAgICBpZiAoIHRoaXMuZHJhd2NhbGxzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgdGhpcy5hZGREcmF3Q2FsbCggMCwgaW5kaWNlcy5sZW5ndGgsIDAgKTtcblxuICAgIH1cblxuICAgIHZhciBkcmF3Y2FsbHMgPSB0aGlzLmRyYXdjYWxscztcblxuICAgIGZvciAoIGogPSAwLCBqbCA9IGRyYXdjYWxscy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcblxuICAgICAgdmFyIHN0YXJ0ID0gZHJhd2NhbGxzWyBqIF0uc3RhcnQ7XG4gICAgICB2YXIgY291bnQgPSBkcmF3Y2FsbHNbIGogXS5jb3VudDtcbiAgICAgIHZhciBpbmRleCA9IGRyYXdjYWxsc1sgaiBdLmluZGV4O1xuXG4gICAgICBmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XG5cbiAgICAgICAgaUEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcbiAgICAgICAgaUIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XG4gICAgICAgIGlDID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMiBdO1xuXG4gICAgICAgIGhhbmRsZVRyaWFuZ2xlKCBpQSwgaUIsIGlDICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciB0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0bXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIG4yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdywgdCwgdGVzdDtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVZlcnRleCggdiApIHtcblxuICAgICAgbi5mcm9tQXJyYXkoIG5vcm1hbHMsIHYgKiAzICk7XG4gICAgICBuMi5jb3B5KCBuICk7XG5cbiAgICAgIHQgPSB0YW4xWyB2IF07XG5cbiAgICAgIC8vIEdyYW0tU2NobWlkdCBvcnRob2dvbmFsaXplXG5cbiAgICAgIHRtcC5jb3B5KCB0ICk7XG4gICAgICB0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcblxuICAgICAgdG1wMi5jcm9zc1ZlY3RvcnMoIG4yLCB0ICk7XG4gICAgICB0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xuICAgICAgdyA9ICggdGVzdCA8IDAuMCApID8gLSAxLjAgOiAxLjA7XG5cbiAgICAgIHRhbmdlbnRzWyB2ICogNCAgICAgXSA9IHRtcC54O1xuICAgICAgdGFuZ2VudHNbIHYgKiA0ICsgMSBdID0gdG1wLnk7XG4gICAgICB0YW5nZW50c1sgdiAqIDQgKyAyIF0gPSB0bXAuejtcbiAgICAgIHRhbmdlbnRzWyB2ICogNCArIDMgXSA9IHc7XG5cbiAgICB9XG5cbiAgICBmb3IgKCBqID0gMCwgamwgPSBkcmF3Y2FsbHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XG5cbiAgICAgIHZhciBzdGFydCA9IGRyYXdjYWxsc1sgaiBdLnN0YXJ0O1xuICAgICAgdmFyIGNvdW50ID0gZHJhd2NhbGxzWyBqIF0uY291bnQ7XG4gICAgICB2YXIgaW5kZXggPSBkcmF3Y2FsbHNbIGogXS5pbmRleDtcblxuICAgICAgZm9yICggaSA9IHN0YXJ0LCBpbCA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbDsgaSArPSAzICkge1xuXG4gICAgICAgIGlBID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XG4gICAgICAgIGlCID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdO1xuICAgICAgICBpQyA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDIgXTtcblxuICAgICAgICBoYW5kbGVWZXJ0ZXgoIGlBICk7XG4gICAgICAgIGhhbmRsZVZlcnRleCggaUIgKTtcbiAgICAgICAgaGFuZGxlVmVydGV4KCBpQyApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICAvKlxuICBDb21wdXRlIHRoZSBkcmF3IG9mZnNldCBmb3IgbGFyZ2UgbW9kZWxzIGJ5IGNodW5raW5nIHRoZSBpbmRleCBidWZmZXIgaW50byBjaHVua3Mgb2YgNjVrIGFkZHJlc3NhYmxlIHZlcnRpY2VzLlxuICBUaGlzIG1ldGhvZCB3aWxsIGVmZmVjdGl2ZWx5IHJld3JpdGUgdGhlIGluZGV4IGJ1ZmZlciBhbmQgcmVtYXAgYWxsIGF0dHJpYnV0ZXMgdG8gbWF0Y2ggdGhlIG5ldyBpbmRpY2VzLlxuICBXQVJOSU5HOiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gZXhwYW5kIHRoZSB2ZXJ0ZXggY291bnQgdG8gcHJldmVudCBzcHJhd2xlZCB0cmlhbmdsZXMgYWNyb3NzIGRyYXcgb2Zmc2V0cy5cbiAgc2l6ZSAtIERlZmF1bHRzIHRvIDY1NTM1IG9yIDQyOTQ5NjcyOTYgaWYgZXh0ZW5zaW9uIE9FU19lbGVtZW50X2luZGV4X3VpbnQgc3VwcG9ydGVkLCBidXQgYWxsb3dzIGZvciBsYXJnZXIgb3Igc21hbGxlciBjaHVua3MuXG4gICovXG4gIGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoIHNpemUgKSB7XG5cbiAgICBpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSBUSFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleDtcblxuICAgIHZhciBpbmRpY2VzID0gdGhpcy5hdHRyaWJ1dGVzLmluZGV4LmFycmF5O1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICAgIHZhciBmYWNlc0NvdW50ID0gKCBpbmRpY2VzLmxlbmd0aCAvIDMgKTtcblxuICAgIHZhciBVaW50QXJyYXkgPSAoICggdmVydGljZXMubGVuZ3RoIC8gMyApID4gNjU1MzUgJiYgVEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPiA2NTUzNSApID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheTtcblxuICAgIC8qXG4gICAgY29uc29sZS5sb2coXCJDb21wdXRpbmcgYnVmZmVycyBpbiBvZmZzZXRzIG9mIFwiK3NpemUrXCIgLT4gaW5kaWNlczpcIitpbmRpY2VzLmxlbmd0aCtcIiB2ZXJ0aWNlczpcIit2ZXJ0aWNlcy5sZW5ndGgpO1xuICAgIGNvbnNvbGUubG9nKFwiRmFjZXMgdG8gcHJvY2VzczogXCIrKGluZGljZXMubGVuZ3RoLzMpKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlb3JkZXJpbmcgXCIrdmVydGljZXNDb3VudCtcIiB2ZXJ0aWNlcy5cIik7XG4gICAgKi9cblxuICAgIHZhciBzb3J0ZWRJbmRpY2VzID0gbmV3IFVpbnRBcnJheSggaW5kaWNlcy5sZW5ndGggKTtcblxuICAgIHZhciBpbmRleFB0ciA9IDA7XG4gICAgdmFyIHZlcnRleFB0ciA9IDA7XG5cbiAgICB2YXIgb2Zmc2V0cyA9IFsgeyBzdGFydDowLCBjb3VudDowLCBpbmRleDowIH0gXTtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0c1sgMCBdO1xuXG4gICAgdmFyIGR1cGxpY2F0ZWRWZXJ0aWNlcyA9IDA7XG4gICAgdmFyIG5ld1ZlcnRpY2VNYXBzID0gMDtcbiAgICB2YXIgZmFjZVZlcnRpY2VzID0gbmV3IEludDMyQXJyYXkoIDYgKTtcbiAgICB2YXIgdmVydGV4TWFwID0gbmV3IEludDMyQXJyYXkoIHZlcnRpY2VzLmxlbmd0aCApO1xuICAgIHZhciByZXZWZXJ0ZXhNYXAgPSBuZXcgSW50MzJBcnJheSggdmVydGljZXMubGVuZ3RoICk7XG4gICAgZm9yICggdmFyIGogPSAwOyBqIDwgdmVydGljZXMubGVuZ3RoOyBqICsrICkgeyB2ZXJ0ZXhNYXBbIGogXSA9IC0gMTsgcmV2VmVydGV4TWFwWyBqIF0gPSAtIDE7IH1cblxuICAgIC8qXG4gICAgICBUcmF2ZXJzZSBldmVyeSBmYWNlIGFuZCByZW9yZGVyIHZlcnRpY2VzIGluIHRoZSBwcm9wZXIgb2Zmc2V0cyBvZiA2NWsuXG4gICAgICBXZSBjYW4gaGF2ZSBtb3JlIHRoYW4gJ3NpemUnIGVudHJpZXMgaW4gdGhlIGluZGV4IGJ1ZmZlciBwZXIgb2Zmc2V0LCBidXQgb25seSByZWZlcmVuY2UgJ3NpemUnIHZhbHVlcy5cbiAgICAqL1xuICAgIGZvciAoIHZhciBmaW5kZXggPSAwOyBmaW5kZXggPCBmYWNlc0NvdW50OyBmaW5kZXggKysgKSB7XG4gICAgICBuZXdWZXJ0aWNlTWFwcyA9IDA7XG5cbiAgICAgIGZvciAoIHZhciB2byA9IDA7IHZvIDwgMzsgdm8gKysgKSB7XG4gICAgICAgIHZhciB2aWQgPSBpbmRpY2VzWyBmaW5kZXggKiAzICsgdm8gXTtcbiAgICAgICAgaWYgKCB2ZXJ0ZXhNYXBbIHZpZCBdID09PSAtIDEgKSB7XG4gICAgICAgICAgLy9Vbm1hcHBlZCB2ZXJ0aWNlXG4gICAgICAgICAgZmFjZVZlcnRpY2VzWyB2byAqIDIgXSA9IHZpZDtcbiAgICAgICAgICBmYWNlVmVydGljZXNbIHZvICogMiArIDEgXSA9IC0gMTtcbiAgICAgICAgICBuZXdWZXJ0aWNlTWFwcyArKztcbiAgICAgICAgfSBlbHNlIGlmICggdmVydGV4TWFwWyB2aWQgXSA8IG9mZnNldC5pbmRleCApIHtcbiAgICAgICAgICAvL1JldXNlZCB2ZXJ0aWNlcyBmcm9tIHByZXZpb3VzIGJsb2NrIChkdXBsaWNhdGUpXG4gICAgICAgICAgZmFjZVZlcnRpY2VzWyB2byAqIDIgXSA9IHZpZDtcbiAgICAgICAgICBmYWNlVmVydGljZXNbIHZvICogMiArIDEgXSA9IC0gMTtcbiAgICAgICAgICBkdXBsaWNhdGVkVmVydGljZXMgKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9SZXVzZWQgdmVydGljZSBpbiB0aGUgY3VycmVudCBibG9ja1xuICAgICAgICAgIGZhY2VWZXJ0aWNlc1sgdm8gKiAyIF0gPSB2aWQ7XG4gICAgICAgICAgZmFjZVZlcnRpY2VzWyB2byAqIDIgKyAxIF0gPSB2ZXJ0ZXhNYXBbIHZpZCBdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWNlTWF4ID0gdmVydGV4UHRyICsgbmV3VmVydGljZU1hcHM7XG4gICAgICBpZiAoIGZhY2VNYXggPiAoIG9mZnNldC5pbmRleCArIHNpemUgKSApIHtcbiAgICAgICAgdmFyIG5ld19vZmZzZXQgPSB7IHN0YXJ0OmluZGV4UHRyLCBjb3VudDowLCBpbmRleDp2ZXJ0ZXhQdHIgfTtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKCBuZXdfb2Zmc2V0ICk7XG4gICAgICAgIG9mZnNldCA9IG5ld19vZmZzZXQ7XG5cbiAgICAgICAgLy9SZS1ldmFsdWF0ZSByZXVzZWQgdmVydGljZXMgaW4gbGlnaHQgb2YgbmV3IG9mZnNldC5cbiAgICAgICAgZm9yICggdmFyIHYgPSAwOyB2IDwgNjsgdiArPSAyICkge1xuICAgICAgICAgIHZhciBuZXdfdmlkID0gZmFjZVZlcnRpY2VzWyB2ICsgMSBdO1xuICAgICAgICAgIGlmICggbmV3X3ZpZCA+IC0gMSAmJiBuZXdfdmlkIDwgb2Zmc2V0LmluZGV4IClcbiAgICAgICAgICAgIGZhY2VWZXJ0aWNlc1sgdiArIDEgXSA9IC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL1JlaW5kZXggdGhlIGZhY2UuXG4gICAgICBmb3IgKCB2YXIgdiA9IDA7IHYgPCA2OyB2ICs9IDIgKSB7XG4gICAgICAgIHZhciB2aWQgPSBmYWNlVmVydGljZXNbIHYgXTtcbiAgICAgICAgdmFyIG5ld192aWQgPSBmYWNlVmVydGljZXNbIHYgKyAxIF07XG5cbiAgICAgICAgaWYgKCBuZXdfdmlkID09PSAtIDEgKVxuICAgICAgICAgIG5ld192aWQgPSB2ZXJ0ZXhQdHIgKys7XG5cbiAgICAgICAgdmVydGV4TWFwWyB2aWQgXSA9IG5ld192aWQ7XG4gICAgICAgIHJldlZlcnRleE1hcFsgbmV3X3ZpZCBdID0gdmlkO1xuICAgICAgICBzb3J0ZWRJbmRpY2VzWyBpbmRleFB0ciArKyBdID0gbmV3X3ZpZCAtIG9mZnNldC5pbmRleDsgLy9YWFggb3ZlcmZsb3dzIGF0IDE2Yml0XG4gICAgICAgIG9mZnNldC5jb3VudCArKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBNb3ZlIGFsbCBhdHRyaWJ1dGUgdmFsdWVzIHRvIG1hcCB0byB0aGUgbmV3IGNvbXB1dGVkIGluZGljZXMgLCBhbHNvIGV4cGFuZCB0aGUgdmVydGljZSBzdGFjayB0byBtYXRjaCBvdXIgbmV3IHZlcnRleFB0ci4gKi9cbiAgICB0aGlzLnJlb3JkZXJCdWZmZXJzKCBzb3J0ZWRJbmRpY2VzLCByZXZWZXJ0ZXhNYXAsIHZlcnRleFB0ciApO1xuICAgIHRoaXMub2Zmc2V0cyA9IG9mZnNldHM7IC8vIFRPRE86IERlcHJlY2F0ZVxuICAgIHRoaXMuZHJhd2NhbGxzID0gb2Zmc2V0cztcblxuICAgIC8qXG4gICAgdmFyIG9yZGVyVGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc29sZS5sb2coXCJSZW9yZGVyIHRpbWU6IFwiKyhvcmRlclRpbWUtcykrXCJtc1wiKTtcbiAgICBjb25zb2xlLmxvZyhcIkR1cGxpY2F0ZWQgXCIrZHVwbGljYXRlZFZlcnRpY2VzK1wiIHZlcnRpY2VzLlwiKTtcbiAgICBjb25zb2xlLmxvZyhcIkNvbXB1dGUgQnVmZmVycyB0aW1lOiBcIisoRGF0ZS5ub3coKS1zKStcIm1zXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiRHJhdyBvZmZzZXRzOiBcIitvZmZzZXRzLmxlbmd0aCk7XG4gICAgKi9cblxuICAgIHJldHVybiBvZmZzZXRzO1xuXG4gIH0sXG5cbiAgbWVyZ2U6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG9mZnNldCApIHtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeS5tZXJnZSgpOiBnZW9tZXRyeSBub3QgYW4gaW5zdGFuY2Ugb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkuJywgZ2VvbWV0cnkgKTtcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xuXG4gICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICBmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIGlmICggZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgYXR0cmlidXRlMSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xuICAgICAgdmFyIGF0dHJpYnV0ZUFycmF5MSA9IGF0dHJpYnV0ZTEuYXJyYXk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUyID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sga2V5IF07XG4gICAgICB2YXIgYXR0cmlidXRlQXJyYXkyID0gYXR0cmlidXRlMi5hcnJheTtcblxuICAgICAgdmFyIGF0dHJpYnV0ZVNpemUgPSBhdHRyaWJ1dGUyLml0ZW1TaXplO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGogPSBhdHRyaWJ1dGVTaXplICogb2Zmc2V0OyBpIDwgYXR0cmlidXRlQXJyYXkyLmxlbmd0aDsgaSArKywgaiArKyApIHtcblxuICAgICAgICBhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxuICB9LFxuXG4gIG5vcm1hbGl6ZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheTtcblxuICAgIHZhciB4LCB5LCB6LCBuO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgeCA9IG5vcm1hbHNbIGkgXTtcbiAgICAgIHkgPSBub3JtYWxzWyBpICsgMSBdO1xuICAgICAgeiA9IG5vcm1hbHNbIGkgKyAyIF07XG5cbiAgICAgIG4gPSAxLjAgLyBNYXRoLnNxcnQoIHggKiB4ICsgeSAqIHkgKyB6ICogeiApO1xuXG4gICAgICBub3JtYWxzWyBpICAgICBdICo9IG47XG4gICAgICBub3JtYWxzWyBpICsgMSBdICo9IG47XG4gICAgICBub3JtYWxzWyBpICsgMiBdICo9IG47XG5cbiAgICB9XG5cbiAgfSxcblxuICAvKlxuICAgIHJlb2RlckJ1ZmZlcnM6XG4gICAgUmVvcmRlciBhdHRyaWJ1dGVzIGJhc2VkIG9uIGEgbmV3IGluZGV4QnVmZmVyIGFuZCBpbmRleE1hcC5cbiAgICBpbmRleEJ1ZmZlciAtIFVpbnQxNkFycmF5IG9mIHRoZSBuZXcgb3JkZXJlZCBpbmRpY2VzLlxuICAgIGluZGV4TWFwIC0gSW50MzJBcnJheSB3aGVyZSB0aGUgcG9zaXRpb24gaXMgdGhlIG5ldyB2ZXJ0ZXggSUQgYW5kIHRoZSB2YWx1ZSB0aGUgb2xkIHZlcnRleCBJRCBmb3IgZWFjaCB2ZXJ0ZXguXG4gICAgdmVydGV4Q291bnQgLSBBbW91bnQgb2YgdG90YWwgdmVydGljZXMgY29uc2lkZXJlZCBpbiB0aGlzIHJlb3JkZXJpbmcgKGluIGNhc2UgeW91IHdhbnQgdG8gZ3JvdyB0aGUgdmVydGljZSBzdGFjaykuXG4gICovXG4gIHJlb3JkZXJCdWZmZXJzOiBmdW5jdGlvbiAoIGluZGV4QnVmZmVyLCBpbmRleE1hcCwgdmVydGV4Q291bnQgKSB7XG5cbiAgICAvKiBDcmVhdGUgYSBjb3B5IG9mIGFsbCBhdHRyaWJ1dGVzIGZvciByZW9yZGVyaW5nLiAqL1xuICAgIHZhciBzb3J0ZWRBdHRyaWJ1dGVzID0ge307XG4gICAgZm9yICggdmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuICAgICAgaWYgKCBhdHRyID09PSAnaW5kZXgnIClcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgc291cmNlQXJyYXkgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5hcnJheTtcbiAgICAgIHNvcnRlZEF0dHJpYnV0ZXNbIGF0dHIgXSA9IG5ldyBzb3VyY2VBcnJheS5jb25zdHJ1Y3RvciggdGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0uaXRlbVNpemUgKiB2ZXJ0ZXhDb3VudCApO1xuICAgIH1cblxuICAgIC8qIE1vdmUgYXR0cmlidXRlIHBvc2l0aW9ucyBiYXNlZCBvbiB0aGUgbmV3IGluZGV4IG1hcCAqL1xuICAgIGZvciAoIHZhciBuZXdfdmlkID0gMDsgbmV3X3ZpZCA8IHZlcnRleENvdW50OyBuZXdfdmlkICsrICkge1xuICAgICAgdmFyIHZpZCA9IGluZGV4TWFwWyBuZXdfdmlkIF07XG4gICAgICBmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XG4gICAgICAgIGlmICggYXR0ciA9PT0gJ2luZGV4JyApXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBhdHRyQXJyYXkgPSB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5hcnJheTtcbiAgICAgICAgdmFyIGF0dHJTaXplID0gdGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0uaXRlbVNpemU7XG4gICAgICAgIHZhciBzb3J0ZWRBdHRyID0gc29ydGVkQXR0cmlidXRlc1sgYXR0ciBdO1xuICAgICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBhdHRyU2l6ZTsgayArKyApXG4gICAgICAgICAgc29ydGVkQXR0clsgbmV3X3ZpZCAqIGF0dHJTaXplICsgayBdID0gYXR0ckFycmF5WyB2aWQgKiBhdHRyU2l6ZSArIGsgXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBDYXJyeSB0aGUgbmV3IHNvcnRlZCBidWZmZXJzIGxvY2FsbHkgKi9cbiAgICB0aGlzLmF0dHJpYnV0ZXNbICdpbmRleCcgXS5hcnJheSA9IGluZGV4QnVmZmVyO1xuICAgIGZvciAoIHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcyApIHtcbiAgICAgIGlmICggYXR0ciA9PT0gJ2luZGV4JyApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzWyBhdHRyIF0uYXJyYXkgPSBzb3J0ZWRBdHRyaWJ1dGVzWyBhdHRyIF07XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbIGF0dHIgXS5udW1JdGVtcyA9IHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdLml0ZW1TaXplICogdmVydGV4Q291bnQ7XG4gICAgfVxuICB9LFxuXG4gIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgIHR5cGU6ICdCdWZmZXJHZW9tZXRyeScsXG4gICAgICAgIGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3RhbmRhcmQgQnVmZmVyR2VvbWV0cnkgc2VyaWFsaXphdGlvblxuXG4gICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICBpZiAoIHRoaXMucGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcblxuICAgICAgZm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xuXG4gICAgICAgIGlmICggcGFyYW1ldGVyc1sga2V5IF0gIT09IHVuZGVmaW5lZCApIGRhdGFbIGtleSBdID0gcGFyYW1ldGVyc1sga2V5IF07XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRhdGE7XG5cbiAgICB9XG5cbiAgICBkYXRhLmRhdGEgPSB7IGF0dHJpYnV0ZXM6IHt9IH07XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgICB2YXIgb2Zmc2V0cyA9IHRoaXMub2Zmc2V0cztcbiAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xuXG4gICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG5cbiAgICAgIHZhciBhcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhdHRyaWJ1dGUuYXJyYXkgKTtcblxuICAgICAgZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xuICAgICAgICBpdGVtU2l6ZTogYXR0cmlidXRlLml0ZW1TaXplLFxuICAgICAgICB0eXBlOiBhdHRyaWJ1dGUuYXJyYXkuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgYXJyYXk6IGFycmF5XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIG9mZnNldHMubGVuZ3RoID4gMCApIHtcblxuICAgICAgZGF0YS5kYXRhLm9mZnNldHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggb2Zmc2V0cyApICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xuXG4gICAgICBkYXRhLmRhdGEuYm91bmRpbmdTcGhlcmUgPSB7XG4gICAgICAgIGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcbiAgICAgICAgcmFkaXVzOiBib3VuZGluZ1NwaGVyZS5yYWRpdXNcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBkYXRhO1xuXG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuXG4gICAgZm9yICggdmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzICkge1xuXG4gICAgICB2YXIgc291cmNlQXR0ciA9IHRoaXMuYXR0cmlidXRlc1sgYXR0ciBdO1xuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCBhdHRyLCBzb3VyY2VBdHRyLmNsb25lKCkgKTtcblxuICAgIH1cblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLm9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldHNbIGkgXTtcblxuICAgICAgZ2VvbWV0cnkub2Zmc2V0cy5wdXNoKCB7XG5cbiAgICAgICAgc3RhcnQ6IG9mZnNldC5zdGFydCxcbiAgICAgICAgaW5kZXg6IG9mZnNldC5pbmRleCxcbiAgICAgICAgY291bnQ6IG9mZnNldC5jb3VudFxuXG4gICAgICB9ICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZ2VvbWV0cnk7XG5cbiAgfSxcblxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeS5NYXhJbmRleCA9IDY1NTM1O1xuXG4vLyBGaWxlOnNyYy9jb3JlL0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKi9cblxuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc7XG4gIHRoaXMubWF4SW5zdGFuY2VkQ291bnQgPSB1bmRlZmluZWQ7XG5cbn07XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnk7XG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5hZGREcmF3Q2FsbCA9IGZ1bmN0aW9uICggc3RhcnQsIGNvdW50LCBpbmRleE9mZnNldCwgaW5zdGFuY2VzICkge1xuXG4gIHRoaXMuZHJhd2NhbGxzLnB1c2goIHtcblxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBjb3VudDogY291bnQsXG4gICAgaW5kZXg6IGluZGV4T2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBpbmRleE9mZnNldCA6IDAsXG4gICAgaW5zdGFuY2VzOiBpbnN0YW5jZXNcblxuICB9ICk7XG5cbn0sXG5cblRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkoKTtcblxuICBmb3IgKCB2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMgKSB7XG5cbiAgICB2YXIgc291cmNlQXR0ciA9IHRoaXMuYXR0cmlidXRlc1thdHRyXTtcbiAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoIGF0dHIsIHNvdXJjZUF0dHIuY2xvbmUoKSApO1xuXG4gIH1cblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5vZmZzZXRzLmxlbmd0aDsgaSA8IGlsOyBpKysgKSB7XG5cbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXRzW2ldO1xuXG4gICAgZ2VvbWV0cnkub2Zmc2V0cy5wdXNoKCB7XG5cbiAgICAgIHN0YXJ0OiBvZmZzZXQuc3RhcnQsXG4gICAgICBpbmRleDogb2Zmc2V0LmluZGV4LFxuICAgICAgY291bnQ6IG9mZnNldC5jb3VudCxcbiAgICAgIGluc3RhbmNlczogb2Zmc2V0Lmluc3RhbmNlc1xuXG4gICAgfSApO1xuXG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL0NhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5DYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdDYW1lcmEnO1xuXG4gIHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcblxufTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNhbWVyYTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5nZXRXb3JsZERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgICByZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgLSAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XG5cbiAgfTtcblxufSgpO1xuXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmxvb2tBdCA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyBUaGlzIHJvdXRpbmUgZG9lcyBub3Qgc3VwcG9ydCBjYW1lcmFzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcblxuICB2YXIgbTEgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIHZlY3RvciApIHtcblxuICAgIG0xLmxvb2tBdCggdGhpcy5wb3NpdGlvbiwgdmVjdG9yLCB0aGlzLnVwICk7XG5cbiAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtMSApO1xuXG4gIH07XG5cbn0oKTtcblxuVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG4gIGlmICggY2FtZXJhID09PSB1bmRlZmluZWQgKSBjYW1lcmEgPSBuZXcgVEhSRUUuQ2FtZXJhKCk7XG5cbiAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGNhbWVyYSApO1xuXG4gIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuY29weSggdGhpcy5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5wcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgcmV0dXJuIGNhbWVyYTtcbn07XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvQ3ViZUNhbWVyYS5qc1xuXG4vKipcbiAqIENhbWVyYSBmb3IgcmVuZGVyaW5nIGN1YmUgbWFwc1xuICogIC0gcmVuZGVycyBzY2VuZSBpbnRvIGF4aXMtYWxpZ25lZCBjdWJlXG4gKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5DdWJlQ2FtZXJhID0gZnVuY3Rpb24gKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnQ3ViZUNhbWVyYSc7XG5cbiAgdmFyIGZvdiA9IDkwLCBhc3BlY3QgPSAxO1xuXG4gIHZhciBjYW1lcmFQWCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICBjYW1lcmFQWC51cC5zZXQoIDAsIC0gMSwgMCApO1xuICBjYW1lcmFQWC5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICkgKTtcbiAgdGhpcy5hZGQoIGNhbWVyYVBYICk7XG5cbiAgdmFyIGNhbWVyYU5YID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XG4gIGNhbWVyYU5YLnVwLnNldCggMCwgLSAxLCAwICk7XG4gIGNhbWVyYU5YLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIC0gMSwgMCwgMCApICk7XG4gIHRoaXMuYWRkKCBjYW1lcmFOWCApO1xuXG4gIHZhciBjYW1lcmFQWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICBjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcbiAgY2FtZXJhUFkubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XG4gIHRoaXMuYWRkKCBjYW1lcmFQWSApO1xuXG4gIHZhciBjYW1lcmFOWSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICBjYW1lcmFOWS51cC5zZXQoIDAsIDAsIC0gMSApO1xuICBjYW1lcmFOWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKSApO1xuICB0aGlzLmFkZCggY2FtZXJhTlkgKTtcblxuICB2YXIgY2FtZXJhUFogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcbiAgY2FtZXJhUFoudXAuc2V0KCAwLCAtIDEsIDAgKTtcbiAgY2FtZXJhUFoubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApICk7XG4gIHRoaXMuYWRkKCBjYW1lcmFQWiApO1xuXG4gIHZhciBjYW1lcmFOWiA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xuICBjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xuICBjYW1lcmFOWi5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEgKSApO1xuICB0aGlzLmFkZCggY2FtZXJhTlogKTtcblxuICB0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgeyBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyIH0gKTtcblxuICB0aGlzLnVwZGF0ZUN1YmVNYXAgPSBmdW5jdGlvbiAoIHJlbmRlcmVyLCBzY2VuZSApIHtcblxuICAgIGlmICggdGhpcy5wYXJlbnQgPT09IHVuZGVmaW5lZCApIHRoaXMudXBkYXRlTWF0cml4V29ybGQoKTtcblxuICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlclRhcmdldDtcbiAgICB2YXIgZ2VuZXJhdGVNaXBtYXBzID0gcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcztcblxuICAgIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDA7XG4gICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFgsIHJlbmRlclRhcmdldCApO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcbiAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAyO1xuICAgIHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBZLCByZW5kZXJUYXJnZXQgKTtcblxuICAgIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDM7XG4gICAgcmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlksIHJlbmRlclRhcmdldCApO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcbiAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICByZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xuXG4gICAgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNTtcbiAgICByZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICByZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcblxuICB9O1xuXG59O1xuXG5USFJFRS5DdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJlQ2FtZXJhO1xuXG4vLyBGaWxlOnNyYy9jYW1lcmFzL09ydGhvZ3JhcGhpY0NhbWVyYS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhID0gZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcblxuICBUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xuXG4gIHRoaXMuem9vbSA9IDE7XG5cbiAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICB0aGlzLnRvcCA9IHRvcDtcbiAgdGhpcy5ib3R0b20gPSBib3R0b207XG5cbiAgdGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAwLjE7XG4gIHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMjAwMDtcblxuICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmE7XG5cblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZHggPSAoIHRoaXMucmlnaHQgLSB0aGlzLmxlZnQgKSAvICggMiAqIHRoaXMuem9vbSApO1xuICB2YXIgZHkgPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvICggMiAqIHRoaXMuem9vbSApO1xuICB2YXIgY3ggPSAoIHRoaXMucmlnaHQgKyB0aGlzLmxlZnQgKSAvIDI7XG4gIHZhciBjeSA9ICggdGhpcy50b3AgKyB0aGlzLmJvdHRvbSApIC8gMjtcblxuICB0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZU9ydGhvZ3JhcGhpYyggY3ggLSBkeCwgY3ggKyBkeCwgY3kgKyBkeSwgY3kgLSBkeSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG59O1xuXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCk7XG5cbiAgVEhSRUUuQ2FtZXJhLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBjYW1lcmEgKTtcblxuICBjYW1lcmEuem9vbSA9IHRoaXMuem9vbTtcblxuICBjYW1lcmEubGVmdCA9IHRoaXMubGVmdDtcbiAgY2FtZXJhLnJpZ2h0ID0gdGhpcy5yaWdodDtcbiAgY2FtZXJhLnRvcCA9IHRoaXMudG9wO1xuICBjYW1lcmEuYm90dG9tID0gdGhpcy5ib3R0b207XG5cbiAgY2FtZXJhLm5lYXIgPSB0aGlzLm5lYXI7XG4gIGNhbWVyYS5mYXIgPSB0aGlzLmZhcjtcblxuICBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLnByb2plY3Rpb25NYXRyaXggKTtcblxuICByZXR1cm4gY2FtZXJhO1xufTtcblxuVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICBkYXRhLm9iamVjdC5sZWZ0ID0gdGhpcy5sZWZ0O1xuICBkYXRhLm9iamVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG4gIGRhdGEub2JqZWN0LnRvcCA9IHRoaXMudG9wO1xuICBkYXRhLm9iamVjdC5ib3R0b20gPSB0aGlzLmJvdHRvbTtcbiAgZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcbiAgZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2NhbWVyYXMvUGVyc3BlY3RpdmVDYW1lcmEuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBncmVnZ21hbiAvIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XG5cbiAgVEhSRUUuQ2FtZXJhLmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xuXG4gIHRoaXMuem9vbSA9IDE7XG5cbiAgdGhpcy5mb3YgPSBmb3YgIT09IHVuZGVmaW5lZCA/IGZvdiA6IDUwO1xuICB0aGlzLmFzcGVjdCA9IGFzcGVjdCAhPT0gdW5kZWZpbmVkID8gYXNwZWN0IDogMTtcbiAgdGhpcy5uZWFyID0gbmVhciAhPT0gdW5kZWZpbmVkID8gbmVhciA6IDAuMTtcbiAgdGhpcy5mYXIgPSBmYXIgIT09IHVuZGVmaW5lZCA/IGZhciA6IDIwMDA7XG5cbiAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhO1xuXG5cbi8qKlxuICogVXNlcyBGb2NhbCBMZW5ndGggKGluIG1tKSB0byBlc3RpbWF0ZSBhbmQgc2V0IEZPVlxuICogMzVtbSAoZnVsbGZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XG4gKiBGb3JtdWxhIGJhc2VkIG9uIGh0dHA6Ly93d3cuYm9iYXRraW5zLmNvbS9waG90b2dyYXBoeS90ZWNobmljYWwvZmllbGRfb2Zfdmlldy5odG1sXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoLCBmcmFtZUhlaWdodCApIHtcblxuICBpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xuXG4gIHRoaXMuZm92ID0gMiAqIFRIUkVFLk1hdGgucmFkVG9EZWcoIE1hdGguYXRhbiggZnJhbWVIZWlnaHQgLyAoIGZvY2FsTGVuZ3RoICogMiApICkgKTtcbiAgdGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG5cbn07XG5cblxuLyoqXG4gKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXG4gKiBtdWx0aS1tb25pdG9yL211bHRpLW1hY2hpbmUgc2V0dXBzLlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXG4gKiB0aGUgbW9uaXRvcnMgYXJlIGluIGdyaWQgbGlrZSB0aGlzXG4gKlxuICogICArLS0tKy0tLSstLS0rXG4gKiAgIHwgQSB8IEIgfCBDIHxcbiAqICAgKy0tLSstLS0rLS0tK1xuICogICB8IEQgfCBFIHwgRiB8XG4gKiAgICstLS0rLS0tKy0tLStcbiAqXG4gKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXG4gKlxuICogICB2YXIgdyA9IDE5MjA7XG4gKiAgIHZhciBoID0gMTA4MDtcbiAqICAgdmFyIGZ1bGxXaWR0aCA9IHcgKiAzO1xuICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xuICpcbiAqICAgLS1BLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1CLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1DLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcbiAqICAgLS1ELS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcbiAqICAgLS1FLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMSwgaCAqIDEsIHcsIGggKTtcbiAqICAgLS1GLS1cbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcbiAqXG4gKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXG4gKi9cblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldFZpZXdPZmZzZXQgPSBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcblxuICB0aGlzLmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcbiAgdGhpcy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICB0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxufTtcblxuXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUudXBkYXRlUHJvamVjdGlvbk1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZm92ID0gVEhSRUUuTWF0aC5yYWRUb0RlZyggMiAqIE1hdGguYXRhbiggTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRoaXMuZm92ICkgKiAwLjUgKSAvIHRoaXMuem9vbSApICk7XG5cbiAgaWYgKCB0aGlzLmZ1bGxXaWR0aCApIHtcblxuICAgIHZhciBhc3BlY3QgPSB0aGlzLmZ1bGxXaWR0aCAvIHRoaXMuZnVsbEhlaWdodDtcbiAgICB2YXIgdG9wID0gTWF0aC50YW4oIFRIUkVFLk1hdGguZGVnVG9SYWQoIGZvdiAqIDAuNSApICkgKiB0aGlzLm5lYXI7XG4gICAgdmFyIGJvdHRvbSA9IC0gdG9wO1xuICAgIHZhciBsZWZ0ID0gYXNwZWN0ICogYm90dG9tO1xuICAgIHZhciByaWdodCA9IGFzcGVjdCAqIHRvcDtcbiAgICB2YXIgd2lkdGggPSBNYXRoLmFicyggcmlnaHQgLSBsZWZ0ICk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKCB0b3AgLSBib3R0b20gKTtcblxuICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlRnJ1c3R1bShcbiAgICAgIGxlZnQgKyB0aGlzLnggKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxuICAgICAgbGVmdCArICggdGhpcy54ICsgdGhpcy53aWR0aCApICogd2lkdGggLyB0aGlzLmZ1bGxXaWR0aCxcbiAgICAgIHRvcCAtICggdGhpcy55ICsgdGhpcy5oZWlnaHQgKSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcbiAgICAgIHRvcCAtIHRoaXMueSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcbiAgICAgIHRoaXMubmVhcixcbiAgICAgIHRoaXMuZmFyXG4gICAgKTtcblxuICB9IGVsc2Uge1xuXG4gICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VQZXJzcGVjdGl2ZSggZm92LCB0aGlzLmFzcGVjdCwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoKTtcblxuICBUSFJFRS5DYW1lcmEucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGNhbWVyYSApO1xuXG4gIGNhbWVyYS56b29tID0gdGhpcy56b29tO1xuXG4gIGNhbWVyYS5mb3YgPSB0aGlzLmZvdjtcbiAgY2FtZXJhLmFzcGVjdCA9IHRoaXMuYXNwZWN0O1xuICBjYW1lcmEubmVhciA9IHRoaXMubmVhcjtcbiAgY2FtZXJhLmZhciA9IHRoaXMuZmFyO1xuXG4gIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmNvcHkoIHRoaXMucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gIHJldHVybiBjYW1lcmE7XG5cbn07XG5cblRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICBkYXRhLm9iamVjdC5mb3YgPSB0aGlzLmZvdjtcbiAgZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XG4gIGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XG4gIGRhdGEub2JqZWN0LmZhciA9IHRoaXMuZmFyO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9saWdodHMvTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5MaWdodCA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdMaWdodCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcblxufTtcblxuVEhSRUUuTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5MaWdodC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5MaWdodDtcblxuVEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBsaWdodCApIHtcblxuICBpZiAoIGxpZ2h0ID09PSB1bmRlZmluZWQgKSBsaWdodCA9IG5ldyBUSFJFRS5MaWdodCgpO1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBsaWdodCApO1xuXG4gIGxpZ2h0LmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblxuICByZXR1cm4gbGlnaHQ7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9BbWJpZW50TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkFtYmllbnRMaWdodCA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICB0aGlzLnR5cGUgPSAnQW1iaWVudExpZ2h0JztcblxufTtcblxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFtYmllbnRMaWdodDtcblxuVEhSRUUuQW1iaWVudExpZ2h0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCk7XG5cbiAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XG5cbiAgcmV0dXJuIGxpZ2h0O1xuXG59O1xuXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL0FyZWFMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgTVBhbmtuaW4gLyBodHRwOi8vd3d3LnJlZHBsYW50LmRlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5BcmVhTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICB0aGlzLnR5cGUgPSAnQXJlYUxpZ2h0JztcblxuICB0aGlzLm5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcbiAgdGhpcy5yaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XG5cbiAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXG4gIHRoaXMud2lkdGggPSAxLjA7XG4gIHRoaXMuaGVpZ2h0ID0gMS4wO1xuXG4gIHRoaXMuY29uc3RhbnRBdHRlbnVhdGlvbiA9IDEuNTtcbiAgdGhpcy5saW5lYXJBdHRlbnVhdGlvbiA9IDAuNTtcbiAgdGhpcy5xdWFkcmF0aWNBdHRlbnVhdGlvbiA9IDAuMTtcblxufTtcblxuVEhSRUUuQXJlYUxpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xuVEhSRUUuQXJlYUxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFyZWFMaWdodDtcblxuXG4vLyBGaWxlOnNyYy9saWdodHMvRGlyZWN0aW9uYWxMaWdodC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICB0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XG5cbiAgdGhpcy5wb3NpdGlvbi5zZXQoIDAsIDEsIDAgKTtcbiAgdGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG5cbiAgdGhpcy5jYXN0U2hhZG93ID0gZmFsc2U7XG4gIHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xuXG4gIC8vXG5cbiAgdGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XG4gIHRoaXMuc2hhZG93Q2FtZXJhRmFyID0gNTAwMDtcblxuICB0aGlzLnNoYWRvd0NhbWVyYUxlZnQgPSAtIDUwMDtcbiAgdGhpcy5zaGFkb3dDYW1lcmFSaWdodCA9IDUwMDtcbiAgdGhpcy5zaGFkb3dDYW1lcmFUb3AgPSA1MDA7XG4gIHRoaXMuc2hhZG93Q2FtZXJhQm90dG9tID0gLSA1MDA7XG5cbiAgdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5zaGFkb3dCaWFzID0gMDtcbiAgdGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcblxuICB0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xuICB0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcblxuICAvL1xuXG4gIHRoaXMuc2hhZG93Q2FzY2FkZSA9IGZhbHNlO1xuXG4gIHRoaXMuc2hhZG93Q2FzY2FkZU9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAtIDEwMDAgKTtcbiAgdGhpcy5zaGFkb3dDYXNjYWRlQ291bnQgPSAyO1xuXG4gIHRoaXMuc2hhZG93Q2FzY2FkZUJpYXMgPSBbIDAsIDAsIDAgXTtcbiAgdGhpcy5zaGFkb3dDYXNjYWRlV2lkdGggPSBbIDUxMiwgNTEyLCA1MTIgXTtcbiAgdGhpcy5zaGFkb3dDYXNjYWRlSGVpZ2h0ID0gWyA1MTIsIDUxMiwgNTEyIF07XG5cbiAgdGhpcy5zaGFkb3dDYXNjYWRlTmVhclogPSBbIC0gMS4wMDAsIDAuOTkwLCAwLjk5OCBdO1xuICB0aGlzLnNoYWRvd0Nhc2NhZGVGYXJaID0gWyAwLjk5MCwgMC45OTgsIDEuMDAwIF07XG5cbiAgdGhpcy5zaGFkb3dDYXNjYWRlQXJyYXkgPSBbXTtcblxuICAvL1xuXG4gIHRoaXMuc2hhZG93TWFwID0gbnVsbDtcbiAgdGhpcy5zaGFkb3dNYXBTaXplID0gbnVsbDtcbiAgdGhpcy5zaGFkb3dDYW1lcmEgPSBudWxsO1xuICB0aGlzLnNoYWRvd01hdHJpeCA9IG51bGw7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQ7XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCk7XG5cbiAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XG5cbiAgbGlnaHQudGFyZ2V0ID0gdGhpcy50YXJnZXQuY2xvbmUoKTtcblxuICBsaWdodC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcblxuICBsaWdodC5jYXN0U2hhZG93ID0gdGhpcy5jYXN0U2hhZG93O1xuICBsaWdodC5vbmx5U2hhZG93ID0gdGhpcy5vbmx5U2hhZG93O1xuXG4gIC8vXG5cbiAgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciA9IHRoaXMuc2hhZG93Q2FtZXJhTmVhcjtcbiAgbGlnaHQuc2hhZG93Q2FtZXJhRmFyID0gdGhpcy5zaGFkb3dDYW1lcmFGYXI7XG5cbiAgbGlnaHQuc2hhZG93Q2FtZXJhTGVmdCA9IHRoaXMuc2hhZG93Q2FtZXJhTGVmdDtcbiAgbGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQgPSB0aGlzLnNoYWRvd0NhbWVyYVJpZ2h0O1xuICBsaWdodC5zaGFkb3dDYW1lcmFUb3AgPSB0aGlzLnNoYWRvd0NhbWVyYVRvcDtcbiAgbGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tID0gdGhpcy5zaGFkb3dDYW1lcmFCb3R0b207XG5cbiAgbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZTtcblxuICBsaWdodC5zaGFkb3dCaWFzID0gdGhpcy5zaGFkb3dCaWFzO1xuICBsaWdodC5zaGFkb3dEYXJrbmVzcyA9IHRoaXMuc2hhZG93RGFya25lc3M7XG5cbiAgbGlnaHQuc2hhZG93TWFwV2lkdGggPSB0aGlzLnNoYWRvd01hcFdpZHRoO1xuICBsaWdodC5zaGFkb3dNYXBIZWlnaHQgPSB0aGlzLnNoYWRvd01hcEhlaWdodDtcblxuICAvL1xuXG4gIGxpZ2h0LnNoYWRvd0Nhc2NhZGUgPSB0aGlzLnNoYWRvd0Nhc2NhZGU7XG5cbiAgbGlnaHQuc2hhZG93Q2FzY2FkZU9mZnNldC5jb3B5KCB0aGlzLnNoYWRvd0Nhc2NhZGVPZmZzZXQgKTtcbiAgbGlnaHQuc2hhZG93Q2FzY2FkZUNvdW50ID0gdGhpcy5zaGFkb3dDYXNjYWRlQ291bnQ7XG5cbiAgbGlnaHQuc2hhZG93Q2FzY2FkZUJpYXMgPSB0aGlzLnNoYWRvd0Nhc2NhZGVCaWFzLnNsaWNlKCAwICk7XG4gIGxpZ2h0LnNoYWRvd0Nhc2NhZGVXaWR0aCA9IHRoaXMuc2hhZG93Q2FzY2FkZVdpZHRoLnNsaWNlKCAwICk7XG4gIGxpZ2h0LnNoYWRvd0Nhc2NhZGVIZWlnaHQgPSB0aGlzLnNoYWRvd0Nhc2NhZGVIZWlnaHQuc2xpY2UoIDAgKTtcblxuICBsaWdodC5zaGFkb3dDYXNjYWRlTmVhclogPSB0aGlzLnNoYWRvd0Nhc2NhZGVOZWFyWi5zbGljZSggMCApO1xuICBsaWdodC5zaGFkb3dDYXNjYWRlRmFyWiA9IHRoaXMuc2hhZG93Q2FzY2FkZUZhclouc2xpY2UoIDAgKTtcblxuICByZXR1cm4gbGlnaHQ7XG5cbn07XG5cblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcbiAgZGF0YS5vYmplY3QuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9IZW1pc3BoZXJlTGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodCA9IGZ1bmN0aW9uICggc2t5Q29sb3IsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKSB7XG5cbiAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3IgKTtcblxuICB0aGlzLnR5cGUgPSAnSGVtaXNwaGVyZUxpZ2h0JztcblxuICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMTAwLCAwICk7XG5cbiAgdGhpcy5ncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggZ3JvdW5kQ29sb3IgKTtcbiAgdGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBsaWdodCA9IG5ldyBUSFJFRS5IZW1pc3BoZXJlTGlnaHQoKTtcblxuICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuICBsaWdodC5ncm91bmRDb2xvci5jb3B5KCB0aGlzLmdyb3VuZENvbG9yICk7XG4gIGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuXG4gIHJldHVybiBsaWdodDtcblxufTtcblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcblxuICByZXR1cm4gZGF0YTtcblxufTtcblxuLy8gRmlsZTpzcmMvbGlnaHRzL1BvaW50TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlBvaW50TGlnaHQgPSBmdW5jdGlvbiAoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcblxuICBUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBjb2xvciApO1xuXG4gIHRoaXMudHlwZSA9ICdQb2ludExpZ2h0JztcblxuICB0aGlzLmludGVuc2l0eSA9ICggaW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGludGVuc2l0eSA6IDE7XG4gIHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcbiAgdGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxOyAvLyBmb3IgcGh5c2ljYWxseSBjb3JyZWN0IGxpZ2h0cywgc2hvdWxkIGJlIDIuXG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvaW50TGlnaHQ7XG5cblRIUkVFLlBvaW50TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBsaWdodCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCk7XG5cbiAgVEhSRUUuTGlnaHQucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIGxpZ2h0ICk7XG5cbiAgbGlnaHQuaW50ZW5zaXR5ID0gdGhpcy5pbnRlbnNpdHk7XG4gIGxpZ2h0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcbiAgbGlnaHQuZGVjYXkgPSB0aGlzLmRlY2F5O1xuXG4gIHJldHVybiBsaWdodDtcblxufTtcblxuVEhSRUUuUG9pbnRMaWdodC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgZGF0YS5vYmplY3QuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICBkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcbiAgZGF0YS5vYmplY3QuZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlO1xuICBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xpZ2h0cy9TcG90TGlnaHQuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwb3RMaWdodCA9IGZ1bmN0aW9uICggY29sb3IsIGludGVuc2l0eSwgZGlzdGFuY2UsIGFuZ2xlLCBleHBvbmVudCwgZGVjYXkgKSB7XG5cbiAgVEhSRUUuTGlnaHQuY2FsbCggdGhpcywgY29sb3IgKTtcblxuICB0aGlzLnR5cGUgPSAnU3BvdExpZ2h0JztcblxuICB0aGlzLnBvc2l0aW9uLnNldCggMCwgMSwgMCApO1xuICB0aGlzLnRhcmdldCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gIHRoaXMuaW50ZW5zaXR5ID0gKCBpbnRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gaW50ZW5zaXR5IDogMTtcbiAgdGhpcy5kaXN0YW5jZSA9ICggZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApID8gZGlzdGFuY2UgOiAwO1xuICB0aGlzLmFuZ2xlID0gKCBhbmdsZSAhPT0gdW5kZWZpbmVkICkgPyBhbmdsZSA6IE1hdGguUEkgLyAzO1xuICB0aGlzLmV4cG9uZW50ID0gKCBleHBvbmVudCAhPT0gdW5kZWZpbmVkICkgPyBleHBvbmVudCA6IDEwO1xuICB0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7IC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cblxuICB0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcbiAgdGhpcy5vbmx5U2hhZG93ID0gZmFsc2U7XG5cbiAgLy9cblxuICB0aGlzLnNoYWRvd0NhbWVyYU5lYXIgPSA1MDtcbiAgdGhpcy5zaGFkb3dDYW1lcmFGYXIgPSA1MDAwO1xuICB0aGlzLnNoYWRvd0NhbWVyYUZvdiA9IDUwO1xuXG4gIHRoaXMuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuc2hhZG93QmlhcyA9IDA7XG4gIHRoaXMuc2hhZG93RGFya25lc3MgPSAwLjU7XG5cbiAgdGhpcy5zaGFkb3dNYXBXaWR0aCA9IDUxMjtcbiAgdGhpcy5zaGFkb3dNYXBIZWlnaHQgPSA1MTI7XG5cbiAgLy9cblxuICB0aGlzLnNoYWRvd01hcCA9IG51bGw7XG4gIHRoaXMuc2hhZG93TWFwU2l6ZSA9IG51bGw7XG4gIHRoaXMuc2hhZG93Q2FtZXJhID0gbnVsbDtcbiAgdGhpcy5zaGFkb3dNYXRyaXggPSBudWxsO1xuXG59O1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BvdExpZ2h0O1xuXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBsaWdodCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoKTtcblxuICBUSFJFRS5MaWdodC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbGlnaHQgKTtcblxuICBsaWdodC50YXJnZXQgPSB0aGlzLnRhcmdldC5jbG9uZSgpO1xuXG4gIGxpZ2h0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuICBsaWdodC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG4gIGxpZ2h0LmFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgbGlnaHQuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50O1xuICBsaWdodC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cbiAgbGlnaHQuY2FzdFNoYWRvdyA9IHRoaXMuY2FzdFNoYWRvdztcbiAgbGlnaHQub25seVNoYWRvdyA9IHRoaXMub25seVNoYWRvdztcblxuICAvL1xuXG4gIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIgPSB0aGlzLnNoYWRvd0NhbWVyYU5lYXI7XG4gIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciA9IHRoaXMuc2hhZG93Q2FtZXJhRmFyO1xuICBsaWdodC5zaGFkb3dDYW1lcmFGb3YgPSB0aGlzLnNoYWRvd0NhbWVyYUZvdjtcblxuICBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlID0gdGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuXG4gIGxpZ2h0LnNoYWRvd0JpYXMgPSB0aGlzLnNoYWRvd0JpYXM7XG4gIGxpZ2h0LnNoYWRvd0RhcmtuZXNzID0gdGhpcy5zaGFkb3dEYXJrbmVzcztcblxuICBsaWdodC5zaGFkb3dNYXBXaWR0aCA9IHRoaXMuc2hhZG93TWFwV2lkdGg7XG4gIGxpZ2h0LnNoYWRvd01hcEhlaWdodCA9IHRoaXMuc2hhZG93TWFwSGVpZ2h0O1xuXG4gIHJldHVybiBsaWdodDtcblxufTtcblxuVEhSRUUuU3BvdExpZ2h0LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICBkYXRhLm9iamVjdC5jb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XG4gIGRhdGEub2JqZWN0LmludGVuc2l0eSA9IHRoaXMuaW50ZW5zaXR5O1xuICBkYXRhLm9iamVjdC5kaXN0YW5jZSA9IHRoaXMuZGlzdGFuY2U7XG4gIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgZGF0YS5vYmplY3QuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50O1xuICBkYXRhLm9iamVjdC5kZWNheSA9IHRoaXMuZGVjYXk7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvQ2FjaGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkNhY2hlID0ge1xuXG4gIGZpbGVzOiB7fSxcblxuICBhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xuXG4gICAgLy8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdBZGRpbmcga2V5OicsIGtleSApO1xuXG4gICAgdGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xuXG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiAoIGtleSApIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuQ2FjaGUnLCAnQ2hlY2tpbmcga2V5OicsIGtleSApO1xuXG4gICAgcmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xuXG4gIH0sXG5cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcblxuICAgIGRlbGV0ZSB0aGlzLmZpbGVzWyBrZXkgXTtcblxuICB9LFxuXG4gIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmZpbGVzID0ge31cblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Mb2FkZXIgPSBmdW5jdGlvbiAoIHNob3dTdGF0dXMgKSB7XG5cbiAgdGhpcy5zaG93U3RhdHVzID0gc2hvd1N0YXR1cztcbiAgdGhpcy5zdGF0dXNEb21FbGVtZW50ID0gc2hvd1N0YXR1cyA/IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuYWRkU3RhdHVzRWxlbWVudCgpIDogbnVsbDtcblxuICB0aGlzLmltYWdlTG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG5cbiAgdGhpcy5vbkxvYWRTdGFydCA9IGZ1bmN0aW9uICgpIHt9O1xuICB0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24gKCkge307XG4gIHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7fTtcblxufTtcblxuVEhSRUUuTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTG9hZGVyLFxuXG4gIGNyb3NzT3JpZ2luOiB1bmRlZmluZWQsXG5cbiAgYWRkU3RhdHVzRWxlbWVudDogZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXG4gICAgZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZS5zdHlsZS5yaWdodCA9ICcwcHgnO1xuICAgIGUuc3R5bGUudG9wID0gJzBweCc7XG4gICAgZS5zdHlsZS5mb250U2l6ZSA9ICcwLjhlbSc7XG4gICAgZS5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgZS5zdHlsZS5iYWNrZ3JvdW5kID0gJ3JnYmEoMCwwLDAsMC4yNSknO1xuICAgIGUuc3R5bGUuY29sb3IgPSAnI2ZmZic7XG4gICAgZS5zdHlsZS53aWR0aCA9ICcxMjBweCc7XG4gICAgZS5zdHlsZS5wYWRkaW5nID0gJzAuNWVtIDAuNWVtIDAuNWVtIDAuNWVtJztcbiAgICBlLnN0eWxlLnpJbmRleCA9IDEwMDA7XG5cbiAgICBlLmlubmVySFRNTCA9ICdMb2FkaW5nIC4uLic7XG5cbiAgICByZXR1cm4gZTtcblxuICB9LFxuXG4gIHVwZGF0ZVByb2dyZXNzOiBmdW5jdGlvbiAoIHByb2dyZXNzICkge1xuXG4gICAgdmFyIG1lc3NhZ2UgPSAnTG9hZGVkICc7XG5cbiAgICBpZiAoIHByb2dyZXNzLnRvdGFsICkge1xuXG4gICAgICBtZXNzYWdlICs9ICggMTAwICogcHJvZ3Jlc3MubG9hZGVkIC8gcHJvZ3Jlc3MudG90YWwgKS50b0ZpeGVkKCAwICkgKyAnJSc7XG5cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIG1lc3NhZ2UgKz0gKCBwcm9ncmVzcy5sb2FkZWQgLyAxMDI0ICkudG9GaXhlZCggMiApICsgJyBLQic7XG5cbiAgICB9XG5cbiAgICB0aGlzLnN0YXR1c0RvbUVsZW1lbnQuaW5uZXJIVE1MID0gbWVzc2FnZTtcblxuICB9LFxuXG4gIGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgIHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XG5cbiAgICBpZiAoIHBhcnRzLmxlbmd0aCA9PT0gMSApIHJldHVybiAnLi8nO1xuXG4gICAgcGFydHMucG9wKCk7XG5cbiAgICByZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XG5cbiAgfSxcblxuICBpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscywgdGV4dHVyZVBhdGggKSB7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XG5cbiAgICAgIGFycmF5WyBpIF0gPSB0aGlzLmNyZWF0ZU1hdGVyaWFsKCBtYXRlcmlhbHNbIGkgXSwgdGV4dHVyZVBhdGggKTtcblxuICAgIH1cblxuICAgIHJldHVybiBhcnJheTtcblxuICB9LFxuXG4gIG5lZWRzVGFuZ2VudHM6IGZ1bmN0aW9uICggbWF0ZXJpYWxzICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIG0gPSBtYXRlcmlhbHNbIGkgXTtcblxuICAgICAgaWYgKCBtIGluc3RhbmNlb2YgVEhSRUUuU2hhZGVyTWF0ZXJpYWwgKSByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9LFxuXG4gIGNyZWF0ZU1hdGVyaWFsOiBmdW5jdGlvbiAoIG0sIHRleHR1cmVQYXRoICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIG5lYXJlc3RfcG93MiggbiApIHtcblxuICAgICAgdmFyIGwgPSBNYXRoLmxvZyggbiApIC8gTWF0aC5MTjI7XG4gICAgICByZXR1cm4gTWF0aC5wb3coIDIsIE1hdGgucm91bmQoICBsICkgKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV90ZXh0dXJlKCB3aGVyZSwgbmFtZSwgc291cmNlRmlsZSwgcmVwZWF0LCBvZmZzZXQsIHdyYXAsIGFuaXNvdHJvcHkgKSB7XG5cbiAgICAgIHZhciBmdWxsUGF0aCA9IHRleHR1cmVQYXRoICsgc291cmNlRmlsZTtcblxuICAgICAgdmFyIHRleHR1cmU7XG5cbiAgICAgIHZhciBsb2FkZXIgPSBUSFJFRS5Mb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xuXG4gICAgICBpZiAoIGxvYWRlciAhPT0gbnVsbCApIHtcblxuICAgICAgICB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIGZ1bGxQYXRoICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCk7XG5cbiAgICAgICAgbG9hZGVyID0gc2NvcGUuaW1hZ2VMb2FkZXI7XG4gICAgICAgIGxvYWRlci5jcm9zc09yaWdpbiA9IHNjb3BlLmNyb3NzT3JpZ2luO1xuICAgICAgICBsb2FkZXIubG9hZCggZnVsbFBhdGgsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cbiAgICAgICAgICBpZiAoIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS53aWR0aCApID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgICAgIHZhciB3aWR0aCA9IG5lYXJlc3RfcG93MiggaW1hZ2Uud2lkdGggKTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBuZWFyZXN0X3BvdzIoIGltYWdlLmhlaWdodCApO1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xuICAgICAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG5cbiAgICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBjYW52YXM7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICB9ICk7XG5cbiAgICAgIH1cblxuICAgICAgdGV4dHVyZS5zb3VyY2VGaWxlID0gc291cmNlRmlsZTtcblxuICAgICAgaWYgKCByZXBlYXQgKSB7XG5cbiAgICAgICAgdGV4dHVyZS5yZXBlYXQuc2V0KCByZXBlYXRbIDAgXSwgcmVwZWF0WyAxIF0gKTtcblxuICAgICAgICBpZiAoIHJlcGVhdFsgMCBdICE9PSAxICkgdGV4dHVyZS53cmFwUyA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuICAgICAgICBpZiAoIHJlcGVhdFsgMSBdICE9PSAxICkgdGV4dHVyZS53cmFwVCA9IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggb2Zmc2V0ICkge1xuXG4gICAgICAgIHRleHR1cmUub2Zmc2V0LnNldCggb2Zmc2V0WyAwIF0sIG9mZnNldFsgMSBdICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCB3cmFwICkge1xuXG4gICAgICAgIHZhciB3cmFwTWFwID0ge1xuICAgICAgICAgICdyZXBlYXQnOiBUSFJFRS5SZXBlYXRXcmFwcGluZyxcbiAgICAgICAgICAnbWlycm9yJzogVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICggd3JhcE1hcFsgd3JhcFsgMCBdIF0gIT09IHVuZGVmaW5lZCApIHRleHR1cmUud3JhcFMgPSB3cmFwTWFwWyB3cmFwWyAwIF0gXTtcbiAgICAgICAgaWYgKCB3cmFwTWFwWyB3cmFwWyAxIF0gXSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS53cmFwVCA9IHdyYXBNYXBbIHdyYXBbIDEgXSBdO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggYW5pc290cm9weSApIHtcblxuICAgICAgICB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xuXG4gICAgICB9XG5cbiAgICAgIHdoZXJlWyBuYW1lIF0gPSB0ZXh0dXJlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmdiMmhleCggcmdiICkge1xuXG4gICAgICByZXR1cm4gKCByZ2JbIDAgXSAqIDI1NSA8PCAxNiApICsgKCByZ2JbIDEgXSAqIDI1NSA8PCA4ICkgKyByZ2JbIDIgXSAqIDI1NTtcblxuICAgIH1cblxuICAgIC8vIGRlZmF1bHRzXG5cbiAgICB2YXIgbXR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XG4gICAgdmFyIG1wYXJzID0geyBjb2xvcjogMHhlZWVlZWUsIG9wYWNpdHk6IDEuMCwgbWFwOiBudWxsLCBsaWdodE1hcDogbnVsbCwgbm9ybWFsTWFwOiBudWxsLCBidW1wTWFwOiBudWxsLCB3aXJlZnJhbWU6IGZhbHNlIH07XG5cbiAgICAvLyBwYXJhbWV0ZXJzIGZyb20gbW9kZWwgZmlsZVxuXG4gICAgaWYgKCBtLnNoYWRpbmcgKSB7XG5cbiAgICAgIHZhciBzaGFkaW5nID0gbS5zaGFkaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGlmICggc2hhZGluZyA9PT0gJ3Bob25nJyApIG10eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcbiAgICAgIGVsc2UgaWYgKCBzaGFkaW5nID09PSAnYmFzaWMnICkgbXR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgJiYgVEhSRUVbIG0uYmxlbmRpbmcgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtcGFycy5ibGVuZGluZyA9IFRIUkVFWyBtLmJsZW5kaW5nIF07XG5cbiAgICB9XG5cbiAgICBpZiAoIG0udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbXBhcnMudHJhbnNwYXJlbnQgPSBtLnRyYW5zcGFyZW50O1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLm9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBtLm9wYWNpdHkgPCAxLjAgKSB7XG5cbiAgICAgIG1wYXJzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIGlmICggbS5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbXBhcnMuZGVwdGhUZXN0ID0gbS5kZXB0aFRlc3Q7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtcGFycy5kZXB0aFdyaXRlID0gbS5kZXB0aFdyaXRlO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLnZpc2libGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbXBhcnMudmlzaWJsZSA9IG0udmlzaWJsZTtcblxuICAgIH1cblxuICAgIGlmICggbS5mbGlwU2lkZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbXBhcnMuc2lkZSA9IFRIUkVFLkJhY2tTaWRlO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLmRvdWJsZVNpZGVkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIG1wYXJzLnNpZGUgPSBUSFJFRS5Eb3VibGVTaWRlO1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBtcGFycy53aXJlZnJhbWUgPSBtLndpcmVmcmFtZTtcblxuICAgIH1cblxuICAgIGlmICggbS52ZXJ0ZXhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaWYgKCBtLnZlcnRleENvbG9ycyA9PT0gJ2ZhY2UnICkge1xuXG4gICAgICAgIG1wYXJzLnZlcnRleENvbG9ycyA9IFRIUkVFLkZhY2VDb2xvcnM7XG5cbiAgICAgIH0gZWxzZSBpZiAoIG0udmVydGV4Q29sb3JzICkge1xuXG4gICAgICAgIG1wYXJzLnZlcnRleENvbG9ycyA9IFRIUkVFLlZlcnRleENvbG9ycztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gY29sb3JzXG5cbiAgICBpZiAoIG0uY29sb3JEaWZmdXNlICkge1xuXG4gICAgICBtcGFycy5jb2xvciA9IHJnYjJoZXgoIG0uY29sb3JEaWZmdXNlICk7XG5cbiAgICB9IGVsc2UgaWYgKCBtLkRiZ0NvbG9yICkge1xuXG4gICAgICBtcGFycy5jb2xvciA9IG0uRGJnQ29sb3I7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0uY29sb3JTcGVjdWxhciApIHtcblxuICAgICAgbXBhcnMuc3BlY3VsYXIgPSByZ2IyaGV4KCBtLmNvbG9yU3BlY3VsYXIgKTtcblxuICAgIH1cblxuICAgIGlmICggbS5jb2xvckVtaXNzaXZlICkge1xuXG4gICAgICBtcGFycy5lbWlzc2l2ZSA9IHJnYjJoZXgoIG0uY29sb3JFbWlzc2l2ZSApO1xuXG4gICAgfVxuXG4gICAgLy8gbW9kaWZpZXJzXG5cbiAgICBpZiAoIG0udHJhbnNwYXJlbmN5ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlcjogdHJhbnNwYXJlbmN5IGhhcyBiZWVuIHJlbmFtZWQgdG8gb3BhY2l0eScgKTtcbiAgICAgIG0ub3BhY2l0eSA9IG0udHJhbnNwYXJlbmN5O1xuXG4gICAgfVxuXG4gICAgaWYgKCBtLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgbXBhcnMub3BhY2l0eSA9IG0ub3BhY2l0eTtcblxuICAgIH1cblxuICAgIGlmICggbS5zcGVjdWxhckNvZWYgKSB7XG5cbiAgICAgIG1wYXJzLnNoaW5pbmVzcyA9IG0uc3BlY3VsYXJDb2VmO1xuXG4gICAgfVxuXG4gICAgLy8gdGV4dHVyZXNcblxuICAgIGlmICggbS5tYXBEaWZmdXNlICYmIHRleHR1cmVQYXRoICkge1xuXG4gICAgICBjcmVhdGVfdGV4dHVyZSggbXBhcnMsICdtYXAnLCBtLm1hcERpZmZ1c2UsIG0ubWFwRGlmZnVzZVJlcGVhdCwgbS5tYXBEaWZmdXNlT2Zmc2V0LCBtLm1hcERpZmZ1c2VXcmFwLCBtLm1hcERpZmZ1c2VBbmlzb3Ryb3B5ICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ubWFwTGlnaHQgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ2xpZ2h0TWFwJywgbS5tYXBMaWdodCwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ubWFwQU8gJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ2FvTWFwJywgbS5tYXBBTywgbS5tYXBBT1JlcGVhdCwgbS5tYXBBT09mZnNldCwgbS5tYXBBT1dyYXAsIG0ubWFwQU9Bbmlzb3Ryb3B5ICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ubWFwQnVtcCAmJiB0ZXh0dXJlUGF0aCApIHtcblxuICAgICAgY3JlYXRlX3RleHR1cmUoIG1wYXJzLCAnYnVtcE1hcCcsIG0ubWFwQnVtcCwgbS5tYXBCdW1wUmVwZWF0LCBtLm1hcEJ1bXBPZmZzZXQsIG0ubWFwQnVtcFdyYXAsIG0ubWFwQnVtcEFuaXNvdHJvcHkgKTtcblxuICAgIH1cblxuICAgIGlmICggbS5tYXBOb3JtYWwgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ25vcm1hbE1hcCcsIG0ubWFwTm9ybWFsLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ubWFwU3BlY3VsYXIgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ3NwZWN1bGFyTWFwJywgbS5tYXBTcGVjdWxhciwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ubWFwQWxwaGEgJiYgdGV4dHVyZVBhdGggKSB7XG5cbiAgICAgIGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgJ2FscGhhTWFwJywgbS5tYXBBbHBoYSwgbS5tYXBBbHBoYVJlcGVhdCwgbS5tYXBBbHBoYU9mZnNldCwgbS5tYXBBbHBoYVdyYXAsIG0ubWFwQWxwaGFBbmlzb3Ryb3B5ICk7XG5cbiAgICB9XG5cbiAgICAvL1xuXG4gICAgaWYgKCBtLm1hcEJ1bXBTY2FsZSApIHtcblxuICAgICAgbXBhcnMuYnVtcFNjYWxlID0gbS5tYXBCdW1wU2NhbGU7XG5cbiAgICB9XG5cbiAgICBpZiAoIG0ubWFwTm9ybWFsRmFjdG9yICkge1xuXG4gICAgICBtcGFycy5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBtLm1hcE5vcm1hbEZhY3RvciwgbS5tYXBOb3JtYWxGYWN0b3IgKTtcblxuICAgIH1cblxuICAgIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsgbXR5cGUgXSggbXBhcnMgKTtcblxuICAgIGlmICggbS5EYmdOYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5uYW1lID0gbS5EYmdOYW1lO1xuXG4gICAgcmV0dXJuIG1hdGVyaWFsO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTG9hZGVyLkhhbmRsZXJzID0ge1xuXG4gIGhhbmRsZXJzOiBbXSxcblxuICBhZGQ6IGZ1bmN0aW9uICggcmVnZXgsIGxvYWRlciApIHtcblxuICAgIHRoaXMuaGFuZGxlcnMucHVzaCggcmVnZXgsIGxvYWRlciApO1xuXG4gIH0sXG5cbiAgZ2V0OiBmdW5jdGlvbiAoIGZpbGUgKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcblxuICAgICAgdmFyIHJlZ2V4ID0gdGhpcy5oYW5kbGVyc1sgaSBdO1xuICAgICAgdmFyIGxvYWRlciAgPSB0aGlzLmhhbmRsZXJzWyBpICsgMSBdO1xuXG4gICAgICBpZiAoIHJlZ2V4LnRlc3QoIGZpbGUgKSApIHtcblxuICAgICAgICByZXR1cm4gbG9hZGVyO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvWEhSTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5YSFJMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cbiAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlhIUkxvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLlhIUkxvYWRlcixcblxuICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBjYWNoZWQgPSBUSFJFRS5DYWNoZS5nZXQoIHVybCApO1xuXG4gICAgaWYgKCBjYWNoZWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIGNhY2hlZCApO1xuICAgICAgcmV0dXJuIGNhY2hlZDtcblxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XG5cbiAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgICAgVEhSRUUuQ2FjaGUuYWRkKCB1cmwsIHRoaXMucmVzcG9uc2UgKTtcblxuICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRoaXMucmVzcG9uc2UgKTtcblxuICAgICAgc2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcblxuICAgIH0sIGZhbHNlICk7XG5cbiAgICBpZiAoIG9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICAgIG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XG5cbiAgICAgIH0sIGZhbHNlICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICAgIG9uRXJyb3IoIGV2ZW50ICk7XG5cbiAgICAgIH0sIGZhbHNlICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMuY3Jvc3NPcmlnaW4gIT09IHVuZGVmaW5lZCApIHJlcXVlc3QuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgIGlmICggdGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCApIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XG5cbiAgICByZXF1ZXN0LnNlbmQoIG51bGwgKTtcblxuICAgIHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcblxuICAgIHJldHVybiByZXF1ZXN0O1xuXG4gIH0sXG5cbiAgc2V0UmVzcG9uc2VUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5yZXNwb25zZVR5cGUgPSB2YWx1ZTtcblxuICB9LFxuXG4gIHNldENyb3NzT3JpZ2luOiBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gICAgdGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9JbWFnZUxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuSW1hZ2VMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cbiAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLkltYWdlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuSW1hZ2VMb2FkZXIsXG5cbiAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgY2FjaGVkID0gVEhSRUUuQ2FjaGUuZ2V0KCB1cmwgKTtcblxuICAgIGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCBjYWNoZWQgKTtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG5cbiAgICB9XG5cbiAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW1nJyApO1xuXG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICBUSFJFRS5DYWNoZS5hZGQoIHVybCwgdGhpcyApO1xuXG4gICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGhpcyApO1xuXG4gICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgfSwgZmFsc2UgKTtcblxuICAgIGlmICggb25Qcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgICAgIG9uUHJvZ3Jlc3MoIGV2ZW50ICk7XG5cbiAgICAgIH0sIGZhbHNlICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9uRXJyb3IgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgICAgICBvbkVycm9yKCBldmVudCApO1xuXG4gICAgICB9LCBmYWxzZSApO1xuXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XG5cbiAgICBzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XG5cbiAgICBpbWFnZS5zcmMgPSB1cmw7XG5cbiAgICByZXR1cm4gaW1hZ2U7XG5cbiAgfSxcblxuICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvSlNPTkxvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkpTT05Mb2FkZXIgPSBmdW5jdGlvbiAoIHNob3dTdGF0dXMgKSB7XG5cbiAgVEhSRUUuTG9hZGVyLmNhbGwoIHRoaXMsIHNob3dTdGF0dXMgKTtcblxuICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxvYWRlci5wcm90b3R5cGUgKTtcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSlNPTkxvYWRlcjtcblxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uICggdXJsLCBjYWxsYmFjaywgdGV4dHVyZVBhdGggKSB7XG5cbiAgLy8gdG9kbzogdW5pZnkgbG9hZCBBUEkgdG8gZm9yIGVhc2llciBTY2VuZUxvYWRlciB1c2VcblxuICB0ZXh0dXJlUGF0aCA9IHRleHR1cmVQYXRoICYmICggdHlwZW9mIHRleHR1cmVQYXRoID09PSAnc3RyaW5nJyApID8gdGV4dHVyZVBhdGggOiB0aGlzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcblxuICB0aGlzLm9uTG9hZFN0YXJ0KCk7XG4gIHRoaXMubG9hZEFqYXhKU09OKCB0aGlzLCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCApO1xuXG59O1xuXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZS5sb2FkQWpheEpTT04gPSBmdW5jdGlvbiAoIGNvbnRleHQsIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoLCBjYWxsYmFja1Byb2dyZXNzICkge1xuXG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICB2YXIgbGVuZ3RoID0gMDtcblxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0geGhyLkRPTkUgKSB7XG5cbiAgICAgIGlmICggeGhyLnN0YXR1cyA9PT0gMjAwIHx8IHhoci5zdGF0dXMgPT09IDAgKSB7XG5cbiAgICAgICAgaWYgKCB4aHIucmVzcG9uc2VUZXh0ICkge1xuXG4gICAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKCB4aHIucmVzcG9uc2VUZXh0ICk7XG4gICAgICAgICAgdmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcblxuICAgICAgICAgIGlmICggbWV0YWRhdGEgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgaWYgKCBtZXRhZGF0YS50eXBlID09PSAnb2JqZWN0JyApIHtcblxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLk9iamVjdExvYWRlciBpbnN0ZWFkLicgKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbWV0YWRhdGEudHlwZSA9PT0gJ3NjZW5lJyApIHtcblxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2VlbXMgdG8gYmUgYSBTY2VuZS4gVXNlIFRIUkVFLlNjZW5lTG9hZGVyIGluc3RlYWQuJyApO1xuICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXN1bHQgPSBjb250ZXh0LnBhcnNlKCBqc29uLCB0ZXh0dXJlUGF0aCApO1xuICAgICAgICAgIGNhbGxiYWNrKCByZXN1bHQuZ2VvbWV0cnksIHJlc3VsdC5tYXRlcmlhbHMgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNlZW1zIHRvIGJlIHVucmVhY2hhYmxlIG9yIHRoZSBmaWxlIGlzIGVtcHR5LicgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW4gY29udGV4dCBvZiBtb3JlIGNvbXBsZXggYXNzZXQgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgLy8gZG8gbm90IGJsb2NrIG9uIHNpbmdsZSBmYWlsZWQgZmlsZVxuICAgICAgICAvLyBtYXliZSBzaG91bGQgZ28gZXZlbiBvbmUgbW9yZSBsZXZlbCB1cFxuXG4gICAgICAgIGNvbnRleHQub25Mb2FkQ29tcGxldGUoKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogQ291bGRuXFwndCBsb2FkICcgKyB1cmwgKyAnICgnICsgeGhyLnN0YXR1cyArICcpJyApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0geGhyLkxPQURJTkcgKSB7XG5cbiAgICAgIGlmICggY2FsbGJhY2tQcm9ncmVzcyApIHtcblxuICAgICAgICBpZiAoIGxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgIGxlbmd0aCA9IHhoci5nZXRSZXNwb25zZUhlYWRlciggJ0NvbnRlbnQtTGVuZ3RoJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFja1Byb2dyZXNzKCB7IHRvdGFsOiBsZW5ndGgsIGxvYWRlZDogeGhyLnJlc3BvbnNlVGV4dC5sZW5ndGggfSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0geGhyLkhFQURFUlNfUkVDRUlWRUQgKSB7XG5cbiAgICAgIGlmICggY2FsbGJhY2tQcm9ncmVzcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGxlbmd0aCA9IHhoci5nZXRSZXNwb25zZUhlYWRlciggJ0NvbnRlbnQtTGVuZ3RoJyApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICB4aHIub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xuICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG4gIHhoci5zZW5kKCBudWxsICk7XG5cbn07XG5cblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKCBqc29uLCB0ZXh0dXJlUGF0aCApIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKSxcbiAgc2NhbGUgPSAoIGpzb24uc2NhbGUgIT09IHVuZGVmaW5lZCApID8gMS4wIC8ganNvbi5zY2FsZSA6IDEuMDtcblxuICBwYXJzZU1vZGVsKCBzY2FsZSApO1xuXG4gIHBhcnNlU2tpbigpO1xuICBwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xuXG4gIGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICBmdW5jdGlvbiBwYXJzZU1vZGVsKCBzY2FsZSApIHtcblxuICAgIGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XG5cbiAgICAgIHJldHVybiB2YWx1ZSAmICggMSA8PCBwb3NpdGlvbiApO1xuXG4gICAgfVxuXG4gICAgdmFyIGksIGosIGZpLFxuXG4gICAgb2Zmc2V0LCB6TGVuZ3RoLFxuXG4gICAgY29sb3JJbmRleCwgbm9ybWFsSW5kZXgsIHV2SW5kZXgsXG5cbiAgICB0eXBlLFxuICAgIGlzUXVhZCxcbiAgICBoYXNNYXRlcmlhbCxcbiAgICBoYXNGYWNlVmVydGV4VXYsXG4gICAgaGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcbiAgICBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcblxuICAgIHZlcnRleCwgZmFjZSwgZmFjZUEsIGZhY2VCLCBoZXgsIG5vcm1hbCxcblxuICAgIHV2TGF5ZXIsIHV2LCB1LCB2LFxuXG4gICAgZmFjZXMgPSBqc29uLmZhY2VzLFxuICAgIHZlcnRpY2VzID0ganNvbi52ZXJ0aWNlcyxcbiAgICBub3JtYWxzID0ganNvbi5ub3JtYWxzLFxuICAgIGNvbG9ycyA9IGpzb24uY29sb3JzLFxuXG4gICAgblV2TGF5ZXJzID0gMDtcblxuICAgIGlmICgganNvbi51dnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgLy8gZGlzcmVnYXJkIGVtcHR5IGFycmF5c1xuXG4gICAgICBmb3IgKCBpID0gMDsgaSA8IGpzb24udXZzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgICBpZiAoIGpzb24udXZzWyBpIF0ubGVuZ3RoICkgblV2TGF5ZXJzICsrO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG4gICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBvZmZzZXQgPSAwO1xuICAgIHpMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XG5cbiAgICAgIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHZlcnRleC54ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XG4gICAgICB2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xuICAgICAgdmVydGV4LnogPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcblxuICAgICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICB9XG5cbiAgICBvZmZzZXQgPSAwO1xuICAgIHpMZW5ndGggPSBmYWNlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XG5cbiAgICAgIHR5cGUgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG5cblxuICAgICAgaXNRdWFkICAgICAgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAwICk7XG4gICAgICBoYXNNYXRlcmlhbCAgICAgICAgID0gaXNCaXRTZXQoIHR5cGUsIDEgKTtcbiAgICAgIGhhc0ZhY2VWZXJ0ZXhVdiAgICAgPSBpc0JpdFNldCggdHlwZSwgMyApO1xuICAgICAgaGFzRmFjZU5vcm1hbCAgICAgICA9IGlzQml0U2V0KCB0eXBlLCA0ICk7XG4gICAgICBoYXNGYWNlVmVydGV4Tm9ybWFsID0gaXNCaXRTZXQoIHR5cGUsIDUgKTtcbiAgICAgIGhhc0ZhY2VDb2xvciAgICAgICA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XG4gICAgICBoYXNGYWNlVmVydGV4Q29sb3IgID0gaXNCaXRTZXQoIHR5cGUsIDcgKTtcblxuICAgICAgLy8gY29uc29sZS5sb2coXCJ0eXBlXCIsIHR5cGUsIFwiYml0c1wiLCBpc1F1YWQsIGhhc01hdGVyaWFsLCBoYXNGYWNlVmVydGV4VXYsIGhhc0ZhY2VOb3JtYWwsIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwsIGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yKTtcblxuICAgICAgaWYgKCBpc1F1YWQgKSB7XG5cbiAgICAgICAgZmFjZUEgPSBuZXcgVEhSRUUuRmFjZTMoKTtcbiAgICAgICAgZmFjZUEuYSA9IGZhY2VzWyBvZmZzZXQgXTtcbiAgICAgICAgZmFjZUEuYiA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XG4gICAgICAgIGZhY2VBLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xuXG4gICAgICAgIGZhY2VCID0gbmV3IFRIUkVFLkZhY2UzKCk7XG4gICAgICAgIGZhY2VCLmEgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xuICAgICAgICBmYWNlQi5iID0gZmFjZXNbIG9mZnNldCArIDIgXTtcbiAgICAgICAgZmFjZUIuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XG5cbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG5cbiAgICAgICAgaWYgKCBoYXNNYXRlcmlhbCApIHtcblxuICAgICAgICAgIG9mZnNldCArKztcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXG5cbiAgICAgICAgZmkgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XG5cbiAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcblxuICAgICAgICAgICAgdXZMYXllciA9IGpzb24udXZzWyBpIF07XG5cbiAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXSA9IFtdO1xuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKCBqID0gMDsgaiA8IDQ7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgdXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuICAgICAgICAgICAgICB1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcbiAgICAgICAgICAgICAgdiA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xuXG4gICAgICAgICAgICAgIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcblxuICAgICAgICAgICAgICBpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcbiAgICAgICAgICAgICAgaWYgKCBqICE9PSAwICkgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSArIDEgXS5wdXNoKCB1diApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuICAgICAgICAgIGZhY2VBLm5vcm1hbC5zZXQoXG4gICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZmFjZUIubm9ybWFsLmNvcHkoIGZhY2VBLm5vcm1hbCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XG5cbiAgICAgICAgICBmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuICAgICAgICAgICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoXG4gICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cbiAgICAgICAgICAgICk7XG5cblxuICAgICAgICAgICAgaWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcbiAgICAgICAgICAgIGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKCBoYXNGYWNlQ29sb3IgKSB7XG5cbiAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICAgIGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xuXG4gICAgICAgICAgZmFjZUEuY29sb3Iuc2V0SGV4KCBoZXggKTtcbiAgICAgICAgICBmYWNlQi5jb2xvci5zZXRIZXgoIGhleCApO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xuXG4gICAgICAgICAgZm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG4gICAgICAgICAgICBjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICAgICAgaGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XG5cbiAgICAgICAgICAgIGlmICggaSAhPT0gMiApIGZhY2VBLnZlcnRleENvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XG4gICAgICAgICAgICBpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQSApO1xuICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoKTtcbiAgICAgICAgZmFjZS5hID0gZmFjZXNbIG9mZnNldCArKyBdO1xuICAgICAgICBmYWNlLmIgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XG4gICAgICAgIGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcblxuICAgICAgICBpZiAoIGhhc01hdGVyaWFsICkge1xuXG4gICAgICAgICAgb2Zmc2V0ICsrO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcblxuICAgICAgICBmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcblxuICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpICsrICkge1xuXG4gICAgICAgICAgICB1dkxheWVyID0ganNvbi51dnNbIGkgXTtcblxuICAgICAgICAgICAgZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gW107XG5cbiAgICAgICAgICAgIGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgICAgICAgICAgICB1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xuXG4gICAgICAgICAgICAgIHUgPSB1dkxheWVyWyB1dkluZGV4ICogMiBdO1xuICAgICAgICAgICAgICB2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XG5cbiAgICAgICAgICAgICAgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdSwgdiApO1xuXG4gICAgICAgICAgICAgIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaGFzRmFjZU5vcm1hbCApIHtcblxuICAgICAgICAgIG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcblxuICAgICAgICAgIGZhY2Uubm9ybWFsLnNldChcbiAgICAgICAgICAgIG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXG4gICAgICAgICAgICBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxuICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcblxuICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuICAgICAgICAgICAgbm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xuXG4gICAgICAgICAgICBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyhcbiAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcbiAgICAgICAgICAgICAgbm9ybWFsc1sgbm9ybWFsSW5kZXggXVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGlmICggaGFzRmFjZUNvbG9yICkge1xuXG4gICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICAgICAgICBmYWNlLmNvbG9yLnNldEhleCggY29sb3JzWyBjb2xvckluZGV4IF0gKTtcblxuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcblxuICAgICAgICAgIGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcblxuICAgICAgICAgICAgY29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcbiAgICAgICAgICAgIGZhY2UudmVydGV4Q29sb3JzLnB1c2goIG5ldyBUSFJFRS5Db2xvciggY29sb3JzWyBjb2xvckluZGV4IF0gKSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTa2luKCkge1xuICAgIHZhciBpbmZsdWVuY2VzUGVyVmVydGV4ID0gKCBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggIT09IHVuZGVmaW5lZCApID8ganNvbi5pbmZsdWVuY2VzUGVyVmVydGV4IDogMjtcblxuICAgIGlmICgganNvbi5za2luV2VpZ2h0cyApIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luV2VpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XG5cbiAgICAgICAgdmFyIHggPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uLnNraW5XZWlnaHRzWyBpICAgICBdO1xuICAgICAgICB2YXIgeSA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF0gOiAwO1xuICAgICAgICB2YXIgeiA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAyIF0gOiAwO1xuICAgICAgICB2YXIgdyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDMgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAzIF0gOiAwO1xuXG4gICAgICAgIGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcblxuICAgICAgICB2YXIgYSA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24uc2tpbkluZGljZXNbIGkgICAgIF07XG4gICAgICAgIHZhciBiID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMSApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDEgXSA6IDA7XG4gICAgICAgIHZhciBjID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDIgXSA6IDA7XG4gICAgICAgIHZhciBkID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDMgXSA6IDA7XG5cbiAgICAgICAgZ2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBnZW9tZXRyeS5ib25lcyA9IGpzb24uYm9uZXM7XG5cbiAgICBpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgJiYgKCBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggIT09IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCB8fCBnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggIT09IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aCApICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBXaGVuIHNraW5uaW5nLCBudW1iZXIgb2YgdmVydGljZXMgKCcgKyBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKyAnKSwgc2tpbkluZGljZXMgKCcgK1xuICAgICAgICAgIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCArICcpLCBhbmQgc2tpbldlaWdodHMgKCcgKyBnZW9tZXRyeS5za2luV2VpZ2h0cy5sZW5ndGggKyAnKSBzaG91bGQgbWF0Y2guJyApO1xuXG4gICAgfVxuXG5cbiAgICAvLyBjb3VsZCBjaGFuZ2UgdGhpcyB0byBqc29uLmFuaW1hdGlvbnNbMF0gb3IgcmVtb3ZlIGNvbXBsZXRlbHlcblxuICAgIGdlb21ldHJ5LmFuaW1hdGlvbiA9IGpzb24uYW5pbWF0aW9uO1xuICAgIGdlb21ldHJ5LmFuaW1hdGlvbnMgPSBqc29uLmFuaW1hdGlvbnM7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xuXG4gICAgaWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgaSwgbCwgdiwgdmwsIGRzdFZlcnRpY2VzLCBzcmNWZXJ0aWNlcztcblxuICAgICAgZm9yICggaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdID0ge307XG4gICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XG4gICAgICAgIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzID0gW107XG5cbiAgICAgICAgZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcbiAgICAgICAgc3JjVmVydGljZXMgPSBqc29uLm1vcnBoVGFyZ2V0cyBbIGkgXS52ZXJ0aWNlcztcblxuICAgICAgICBmb3IgKCB2ID0gMCwgdmwgPSBzcmNWZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArPSAzICkge1xuXG4gICAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgICAgdmVydGV4LnggPSBzcmNWZXJ0aWNlc1sgdiBdICogc2NhbGU7XG4gICAgICAgICAgdmVydGV4LnkgPSBzcmNWZXJ0aWNlc1sgdiArIDEgXSAqIHNjYWxlO1xuICAgICAgICAgIHZlcnRleC56ID0gc3JjVmVydGljZXNbIHYgKyAyIF0gKiBzY2FsZTtcblxuICAgICAgICAgIGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBqc29uLm1vcnBoQ29sb3JzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBpLCBsLCBjLCBjbCwgZHN0Q29sb3JzLCBzcmNDb2xvcnMsIGNvbG9yO1xuXG4gICAgICBmb3IgKCBpID0gMCwgbCA9IGpzb24ubW9ycGhDb2xvcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICBnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdID0ge307XG4gICAgICAgIGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhDb2xvcnNbIGkgXS5uYW1lO1xuICAgICAgICBnZW9tZXRyeS5tb3JwaENvbG9yc1sgaSBdLmNvbG9ycyA9IFtdO1xuXG4gICAgICAgIGRzdENvbG9ycyA9IGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzO1xuICAgICAgICBzcmNDb2xvcnMgPSBqc29uLm1vcnBoQ29sb3JzIFsgaSBdLmNvbG9ycztcblxuICAgICAgICBmb3IgKCBjID0gMCwgY2wgPSBzcmNDb2xvcnMubGVuZ3RoOyBjIDwgY2w7IGMgKz0gMyApIHtcblxuICAgICAgICAgIGNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmYWEwMCApO1xuICAgICAgICAgIGNvbG9yLnNldFJHQiggc3JjQ29sb3JzWyBjIF0sIHNyY0NvbG9yc1sgYyArIDEgXSwgc3JjQ29sb3JzWyBjICsgMiBdICk7XG4gICAgICAgICAgZHN0Q29sb3JzLnB1c2goIGNvbG9yICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIGlmICgganNvbi5tYXRlcmlhbHMgPT09IHVuZGVmaW5lZCB8fCBqc29uLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICByZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcblxuICB9IGVsc2Uge1xuXG4gICAgdmFyIG1hdGVyaWFscyA9IHRoaXMuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoICk7XG5cbiAgICBpZiAoIHRoaXMubmVlZHNUYW5nZW50cyggbWF0ZXJpYWxzICkgKSB7XG5cbiAgICAgIGdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgZ2VvbWV0cnk6IGdlb21ldHJ5LCBtYXRlcmlhbHM6IG1hdGVyaWFscyB9O1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbG9hZGVycy9Mb2FkaW5nTWFuYWdlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTG9hZGluZ01hbmFnZXIgPSBmdW5jdGlvbiAoIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcblxuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIHZhciBsb2FkZWQgPSAwLCB0b3RhbCA9IDA7XG5cbiAgdGhpcy5vbkxvYWQgPSBvbkxvYWQ7XG4gIHRoaXMub25Qcm9ncmVzcyA9IG9uUHJvZ3Jlc3M7XG4gIHRoaXMub25FcnJvciA9IG9uRXJyb3I7XG5cbiAgdGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAoIHVybCApIHtcblxuICAgIHRvdGFsICsrO1xuXG4gIH07XG5cbiAgdGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cbiAgICBsb2FkZWQgKys7XG5cbiAgICBpZiAoIHNjb3BlLm9uUHJvZ3Jlc3MgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgc2NvcGUub25Qcm9ncmVzcyggdXJsLCBsb2FkZWQsIHRvdGFsICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGxvYWRlZCA9PT0gdG90YWwgJiYgc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHNjb3BlLm9uTG9hZCgpO1xuXG4gICAgfVxuXG4gIH07XG5cbn07XG5cblRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlcigpO1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0J1ZmZlckdlb21ldHJ5TG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlciA9IGZ1bmN0aW9uICggbWFuYWdlciApIHtcblxuICB0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IFRIUkVFLkRlZmF1bHRMb2FkaW5nTWFuYWdlcjtcblxufTtcblxuVEhSRUUuQnVmZmVyR2VvbWV0cnlMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcixcblxuICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuWEhSTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XG4gICAgbG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XG4gICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xuXG4gICAgICBvbkxvYWQoIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICkgKSApO1xuXG4gICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gIH0sXG5cbiAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgfSxcblxuICBwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJ1ZmZlckdlb21ldHJ5KCk7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IGpzb24uZGF0YS5hdHRyaWJ1dGVzO1xuXG4gICAgZm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sga2V5IF07XG4gICAgICB2YXIgdHlwZWRBcnJheSA9IG5ldyBzZWxmWyBhdHRyaWJ1dGUudHlwZSBdKCBhdHRyaWJ1dGUuYXJyYXkgKTtcblxuICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCBrZXksIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSApICk7XG5cbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGpzb24uZGF0YS5vZmZzZXRzO1xuXG4gICAgaWYgKCBvZmZzZXRzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGdlb21ldHJ5Lm9mZnNldHMgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggb2Zmc2V0cyApICk7XG5cbiAgICB9XG5cbiAgICB2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XG5cbiAgICBpZiAoIGJvdW5kaW5nU3BoZXJlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBjZW50ZXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgICBpZiAoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNlbnRlci5mcm9tQXJyYXkoIGJvdW5kaW5nU3BoZXJlLmNlbnRlciApO1xuXG4gICAgICB9XG5cbiAgICAgIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBnZW9tZXRyeTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2xvYWRlcnMvTWF0ZXJpYWxMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1hdGVyaWFsTG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG4gIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuXG59O1xuXG5USFJFRS5NYXRlcmlhbExvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsTG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICAgIG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XG5cbiAgICB9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XG5cbiAgfSxcblxuICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XG5cbiAgICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUVbIGpzb24udHlwZSBdO1xuXG4gICAgaWYgKCBqc29uLmNvbG9yICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jb2xvci5zZXRIZXgoIGpzb24uY29sb3IgKTtcbiAgICBpZiAoIGpzb24uZW1pc3NpdmUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlLnNldEhleCgganNvbi5lbWlzc2l2ZSApO1xuICAgIGlmICgganNvbi5zcGVjdWxhciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXIuc2V0SGV4KCBqc29uLnNwZWN1bGFyICk7XG4gICAgaWYgKCBqc29uLnNoaW5pbmVzcyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2hpbmluZXNzID0ganNvbi5zaGluaW5lc3M7XG4gICAgaWYgKCBqc29uLnVuaWZvcm1zICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51bmlmb3JtcyA9IGpzb24udW5pZm9ybXM7XG4gICAgaWYgKCBqc29uLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmF0dHJpYnV0ZXMgPSBqc29uLmF0dHJpYnV0ZXM7XG4gICAgaWYgKCBqc29uLnZlcnRleFNoYWRlciAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0ganNvbi52ZXJ0ZXhTaGFkZXI7XG4gICAgaWYgKCBqc29uLmZyYWdtZW50U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IGpzb24uZnJhZ21lbnRTaGFkZXI7XG4gICAgaWYgKCBqc29uLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0ganNvbi52ZXJ0ZXhDb2xvcnM7XG4gICAgaWYgKCBqc29uLnNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNoYWRpbmcgPSBqc29uLnNoYWRpbmc7XG4gICAgaWYgKCBqc29uLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ibGVuZGluZyA9IGpzb24uYmxlbmRpbmc7XG4gICAgaWYgKCBqc29uLnNpZGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpZGUgPSBqc29uLnNpZGU7XG4gICAgaWYgKCBqc29uLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm9wYWNpdHkgPSBqc29uLm9wYWNpdHk7XG4gICAgaWYgKCBqc29uLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC50cmFuc3BhcmVudCA9IGpzb24udHJhbnNwYXJlbnQ7XG4gICAgaWYgKCBqc29uLndpcmVmcmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lID0ganNvbi53aXJlZnJhbWU7XG4gICAgaWYgKCBqc29uLmFscGhhVGVzdCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYWxwaGFUZXN0ID0ganNvbi5hbHBoYVRlc3Q7XG5cbiAgICAvLyBmb3IgUG9pbnRDbG91ZE1hdGVyaWFsXG4gICAgaWYgKCBqc29uLnNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnNpemUgPSBqc29uLnNpemU7XG4gICAgaWYgKCBqc29uLnNpemVBdHRlbnVhdGlvbiAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0ganNvbi5zaXplQXR0ZW51YXRpb247XG5cbiAgICBpZiAoIGpzb24ubWF0ZXJpYWxzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgbWF0ZXJpYWwubWF0ZXJpYWxzLnB1c2goIHRoaXMucGFyc2UoIGpzb24ubWF0ZXJpYWxzWyBpIF0gKSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0ZXJpYWw7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL09iamVjdExvYWRlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuT2JqZWN0TG9hZGVyID0gZnVuY3Rpb24gKCBtYW5hZ2VyICkge1xuXG4gIHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogVEhSRUUuRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xuICB0aGlzLnRleHR1cmVQYXRoID0gJyc7XG5cbn07XG5cblRIUkVFLk9iamVjdExvYWRlci5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLk9iamVjdExvYWRlcixcblxuICBsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xuXG4gICAgaWYgKCB0aGlzLnRleHR1cmVQYXRoID09PSAnJyApIHtcblxuICAgICAgdGhpcy50ZXh0dXJlUGF0aCA9IHVybC5zdWJzdHJpbmcoIDAsIHVybC5sYXN0SW5kZXhPZiggJy8nICkgKyAxICk7XG5cbiAgICB9XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5YSFJMb2FkZXIoIHNjb3BlLm1hbmFnZXIgKTtcbiAgICBsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcbiAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICAgIHNjb3BlLnBhcnNlKCBKU09OLnBhcnNlKCB0ZXh0ICksIG9uTG9hZCApO1xuXG4gICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gIH0sXG5cbiAgc2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XG5cbiAgfSxcblxuICBzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcblxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcblxuICAgIHZhciBnZW9tZXRyaWVzID0gdGhpcy5wYXJzZUdlb21ldHJpZXMoIGpzb24uZ2VvbWV0cmllcyApO1xuXG4gICAgdmFyIGltYWdlcyA9IHRoaXMucGFyc2VJbWFnZXMoIGpzb24uaW1hZ2VzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIGlmICggb25Mb2FkICE9PSB1bmRlZmluZWQgKSBvbkxvYWQoIG9iamVjdCApO1xuXG4gICAgfSApO1xuXG4gICAgdmFyIHRleHR1cmVzICA9IHRoaXMucGFyc2VUZXh0dXJlcygganNvbi50ZXh0dXJlcywgaW1hZ2VzICk7XG4gICAgdmFyIG1hdGVyaWFscyA9IHRoaXMucGFyc2VNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlcyApO1xuICAgIHZhciBvYmplY3QgPSB0aGlzLnBhcnNlT2JqZWN0KCBqc29uLm9iamVjdCwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICk7XG5cbiAgICBpZiAoIGpzb24uaW1hZ2VzID09PSB1bmRlZmluZWQgfHwganNvbi5pbWFnZXMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICBpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvYmplY3Q7XG5cbiAgfSxcblxuICBwYXJzZUdlb21ldHJpZXM6IGZ1bmN0aW9uICgganNvbiApIHtcblxuICAgIHZhciBnZW9tZXRyaWVzID0ge307XG5cbiAgICBpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIGdlb21ldHJ5TG9hZGVyID0gbmV3IFRIUkVFLkpTT05Mb2FkZXIoKTtcbiAgICAgIHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgdmFyIGdlb21ldHJ5O1xuICAgICAgICB2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuICAgICAgICBzd2l0Y2ggKCBkYXRhLnR5cGUgKSB7XG5cbiAgICAgICAgICBjYXNlICdQbGFuZUdlb21ldHJ5JzpcbiAgICAgICAgICBjYXNlICdQbGFuZUJ1ZmZlckdlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUVbIGRhdGEudHlwZSBdKFxuICAgICAgICAgICAgICBkYXRhLndpZHRoLFxuICAgICAgICAgICAgICBkYXRhLmhlaWdodCxcbiAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0JveEdlb21ldHJ5JzpcbiAgICAgICAgICBjYXNlICdDdWJlR2VvbWV0cnknOiAvLyBiYWNrd2FyZHMgY29tcGF0aWJsZVxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5Cb3hHZW9tZXRyeShcbiAgICAgICAgICAgICAgZGF0YS53aWR0aCxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHQsXG4gICAgICAgICAgICAgIGRhdGEuZGVwdGgsXG4gICAgICAgICAgICAgIGRhdGEud2lkdGhTZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS5oZWlnaHRTZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS5kZXB0aFNlZ21lbnRzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0NpcmNsZUdlb21ldHJ5JzpcblxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQ2lyY2xlR2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLnNlZ21lbnRzXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0N5bGluZGVyR2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1c1RvcCxcbiAgICAgICAgICAgICAgZGF0YS5yYWRpdXNCb3R0b20sXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICBkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLm9wZW5FbmRlZFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdTcGhlcmVHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgZGF0YS53aWR0aFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLmhlaWdodFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLnBoaVN0YXJ0LFxuICAgICAgICAgICAgICBkYXRhLnBoaUxlbmd0aCxcbiAgICAgICAgICAgICAgZGF0YS50aGV0YVN0YXJ0LFxuICAgICAgICAgICAgICBkYXRhLnRoZXRhTGVuZ3RoXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgZGF0YS5kZXRhaWxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnVG9ydXNHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEucmFkaXVzLFxuICAgICAgICAgICAgICBkYXRhLnR1YmUsXG4gICAgICAgICAgICAgIGRhdGEucmFkaWFsU2VnbWVudHMsXG4gICAgICAgICAgICAgIGRhdGEudHVidWxhclNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLmFyY1xuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUb3J1c0tub3RHZW9tZXRyeSc6XG5cbiAgICAgICAgICAgIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5KFxuICAgICAgICAgICAgICBkYXRhLnJhZGl1cyxcbiAgICAgICAgICAgICAgZGF0YS50dWJlLFxuICAgICAgICAgICAgICBkYXRhLnJhZGlhbFNlZ21lbnRzLFxuICAgICAgICAgICAgICBkYXRhLnR1YnVsYXJTZWdtZW50cyxcbiAgICAgICAgICAgICAgZGF0YS5wLFxuICAgICAgICAgICAgICBkYXRhLnEsXG4gICAgICAgICAgICAgIGRhdGEuaGVpZ2h0U2NhbGVcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnQnVmZmVyR2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGJ1ZmZlckdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhICk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnR2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJ5TG9hZGVyLnBhcnNlKCBkYXRhLmRhdGEgKS5nZW9tZXRyeTtcblxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdUZXh0R2VvbWV0cnknOlxuXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG5ldyBUSFJFRS5UZXh0R2VvbWV0cnkoXG4gICAgICAgICAgICAgIGRhdGEudGV4dCxcbiAgICAgICAgICAgICAgZGF0YS5kYXRhXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgICAgZ2VvbWV0cnkudXVpZCA9IGRhdGEudXVpZDtcblxuICAgICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgZ2VvbWV0cnkubmFtZSA9IGRhdGEubmFtZTtcblxuICAgICAgICBnZW9tZXRyaWVzWyBkYXRhLnV1aWQgXSA9IGdlb21ldHJ5O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZ2VvbWV0cmllcztcblxuICB9LFxuXG4gIHBhcnNlTWF0ZXJpYWxzOiBmdW5jdGlvbiAoIGpzb24sIHRleHR1cmVzICkge1xuXG4gICAgdmFyIG1hdGVyaWFscyA9IHt9O1xuXG4gICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHZhciBnZXRUZXh0dXJlID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gICAgICAgIGlmICggdGV4dHVyZXNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgdGV4dHVyZScsIG5hbWUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHR1cmVzWyBuYW1lIF07XG5cbiAgICAgIH07XG5cbiAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuTWF0ZXJpYWxMb2FkZXIoKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBkYXRhID0ganNvblsgaSBdO1xuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBsb2FkZXIucGFyc2UoIGRhdGEgKTtcblxuICAgICAgICBtYXRlcmlhbC51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICAgIGlmICggZGF0YS5kZXB0aFRlc3QgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmRlcHRoVGVzdCA9IGRhdGEuZGVwdGhUZXN0O1xuICAgICAgICBpZiAoIGRhdGEuZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGRhdGEuZGVwdGhXcml0ZTtcblxuICAgICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGRhdGEubmFtZTtcblxuICAgICAgICBpZiAoIGRhdGEubWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5tYXAgPSBnZXRUZXh0dXJlKCBkYXRhLm1hcCApO1xuXG4gICAgICAgIGlmICggZGF0YS5hbHBoYU1hcCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwuYWxwaGFNYXAgPSBnZXRUZXh0dXJlKCBkYXRhLmFscGhhTWFwICk7XG4gICAgICAgICAgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGRhdGEuYnVtcE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcE1hcCA9IGdldFRleHR1cmUoIGRhdGEuYnVtcE1hcCApO1xuICAgICAgICBpZiAoIGRhdGEuYnVtcFNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wU2NhbGUgPSBkYXRhLmJ1bXBTY2FsZTtcblxuICAgICAgICBpZiAoIGRhdGEubm9ybWFsTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ub3JtYWxNYXAgPSBnZXRUZXh0dXJlKCBkYXRhLm5vcm1hbE1hcCApO1xuICAgICAgICBpZiAoIGRhdGEubm9ybWFsU2NhbGUgKSBtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBkYXRhLm5vcm1hbFNjYWxlLCBkYXRhLm5vcm1hbFNjYWxlICk7XG5cbiAgICAgICAgaWYgKCBkYXRhLnNwZWN1bGFyTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IGdldFRleHR1cmUoIGRhdGEuc3BlY3VsYXJNYXAgKTtcblxuICAgICAgICBpZiAoIGRhdGEuZW52TWFwICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBtYXRlcmlhbC5lbnZNYXAgPSBnZXRUZXh0dXJlKCBkYXRhLmVudk1hcCApO1xuICAgICAgICAgIG1hdGVyaWFsLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBkYXRhLnJlZmxlY3Rpdml0eSApIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IGRhdGEucmVmbGVjdGl2aXR5O1xuXG4gICAgICAgIGlmICggZGF0YS5saWdodE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXAgPSBnZXRUZXh0dXJlKCBkYXRhLmxpZ2h0TWFwICk7XG4gICAgICAgIGlmICggZGF0YS5saWdodE1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBkYXRhLmxpZ2h0TWFwSW50ZW5zaXR5O1xuXG4gICAgICAgIGlmICggZGF0YS5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKCBkYXRhLmFvTWFwICk7XG4gICAgICAgIGlmICggZGF0YS5hb01hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXBJbnRlbnNpdHkgPSBkYXRhLmFvTWFwSW50ZW5zaXR5O1xuXG4gICAgICAgIG1hdGVyaWFsc1sgZGF0YS51dWlkIF0gPSBtYXRlcmlhbDtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGVyaWFscztcblxuICB9LFxuXG4gIHBhcnNlSW1hZ2VzOiBmdW5jdGlvbiAoIGpzb24sIG9uTG9hZCApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgdmFyIGltYWdlcyA9IHt9O1xuXG4gICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgJiYganNvbi5sZW5ndGggPiAwICkge1xuXG4gICAgICB2YXIgbWFuYWdlciA9IG5ldyBUSFJFRS5Mb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XG5cbiAgICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKTtcbiAgICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuXG4gICAgICB2YXIgbG9hZEltYWdlID0gZnVuY3Rpb24gKCB1cmwgKSB7XG5cbiAgICAgICAgc2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xuXG4gICAgICAgIHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICBzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xuXG4gICAgICAgIH0gKTtcblxuICAgICAgfTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBpbWFnZSA9IGpzb25bIGkgXTtcbiAgICAgICAgaW1hZ2VzWyBpbWFnZS51dWlkIF0gPSBsb2FkSW1hZ2UoIGltYWdlLnVybCApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gaW1hZ2VzO1xuXG4gIH0sXG5cbiAgcGFyc2VUZXh0dXJlczogZnVuY3Rpb24gKCBqc29uLCBpbWFnZXMgKSB7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUNvbnN0YW50KCB2YWx1ZSApIHtcblxuICAgICAgaWYgKCB0eXBlb2YoIHZhbHVlICkgPT09ICdudW1iZXInICkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlICk7XG5cbiAgICAgIHJldHVybiBUSFJFRVsgdmFsdWUgXTtcblxuICAgIH1cblxuICAgIHZhciB0ZXh0dXJlcyA9IHt9O1xuXG4gICAgaWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgICB2YXIgZGF0YSA9IGpzb25bIGkgXTtcblxuICAgICAgICBpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogTm8gXCJpbWFnZVwiIHNwZWZpY2llZCBmb3InLCBkYXRhLnV1aWQgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpbWFnZXNbIGRhdGEuaW1hZ2UgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XG4gICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIHRleHR1cmUudXVpZCA9IGRhdGEudXVpZDtcblxuICAgICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5uYW1lID0gZGF0YS5uYW1lO1xuICAgICAgICBpZiAoIGRhdGEubWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gcGFyc2VDb25zdGFudCggZGF0YS5tYXBwaW5nICk7XG4gICAgICAgIGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGRhdGEucmVwZWF0WyAwIF0sIGRhdGEucmVwZWF0WyAxIF0gKTtcbiAgICAgICAgaWYgKCBkYXRhLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5taW5GaWx0ZXIgPSBwYXJzZUNvbnN0YW50KCBkYXRhLm1pbkZpbHRlciApO1xuICAgICAgICBpZiAoIGRhdGEubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hZ0ZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFnRmlsdGVyICk7XG4gICAgICAgIGlmICggZGF0YS5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSBkYXRhLmFuaXNvdHJvcHk7XG4gICAgICAgIGlmICggQXJyYXkuaXNBcnJheSggZGF0YS53cmFwICkgKSB7XG5cbiAgICAgICAgICB0ZXh0dXJlLndyYXBTID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAwIF0gKTtcbiAgICAgICAgICB0ZXh0dXJlLndyYXBUID0gcGFyc2VDb25zdGFudCggZGF0YS53cmFwWyAxIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZXNbIGRhdGEudXVpZCBdID0gdGV4dHVyZTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmVzO1xuXG4gIH0sXG5cbiAgcGFyc2VPYmplY3Q6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICggZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkge1xuXG4gICAgICB2YXIgb2JqZWN0O1xuXG4gICAgICB2YXIgZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICAgICAgaWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIGdlb21ldHJ5JywgbmFtZSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2VvbWV0cmllc1sgbmFtZSBdO1xuXG4gICAgICB9O1xuXG4gICAgICB2YXIgZ2V0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCBuYW1lICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRlcmlhbHNbIG5hbWUgXTtcblxuICAgICAgfTtcblxuICAgICAgc3dpdGNoICggZGF0YS50eXBlICkge1xuXG4gICAgICAgIGNhc2UgJ1NjZW5lJzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUGVyc3BlY3RpdmVDYW1lcmEnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBkYXRhLmZvdiwgZGF0YS5hc3BlY3QsIGRhdGEubmVhciwgZGF0YS5mYXIgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ09ydGhvZ3JhcGhpY0NhbWVyYSc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCBkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQW1iaWVudExpZ2h0JzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoIGRhdGEuY29sb3IgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0RpcmVjdGlvbmFsTGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5ICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdQb2ludExpZ2h0JzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5Qb2ludExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5kZWNheSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnU3BvdExpZ2h0JzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TcG90TGlnaHQoIGRhdGEuY29sb3IsIGRhdGEuaW50ZW5zaXR5LCBkYXRhLmRpc3RhbmNlLCBkYXRhLmFuZ2xlLCBkYXRhLmV4cG9uZW50LCBkYXRhLmRlY2F5ICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIZW1pc3BoZXJlTGlnaHQnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ01lc2gnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0xpbmUnOlxuXG4gICAgICAgICAgb2JqZWN0ID0gbmV3IFRIUkVFLkxpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUG9pbnRDbG91ZCc6XG5cbiAgICAgICAgICBvYmplY3QgPSBuZXcgVEhSRUUuUG9pbnRDbG91ZCggZ2V0R2VvbWV0cnkoIGRhdGEuZ2VvbWV0cnkgKSwgZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnU3ByaXRlJzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5TcHJpdGUoIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0dyb3VwJzpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5Hcm91cCgpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblxuICAgICAgICAgIG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgICB9XG5cbiAgICAgIG9iamVjdC51dWlkID0gZGF0YS51dWlkO1xuXG4gICAgICBpZiAoIGRhdGEubmFtZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICBpZiAoIGRhdGEubWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgbWF0cml4LmZyb21BcnJheSggZGF0YS5tYXRyaXggKTtcbiAgICAgICAgbWF0cml4LmRlY29tcG9zZSggb2JqZWN0LnBvc2l0aW9uLCBvYmplY3QucXVhdGVybmlvbiwgb2JqZWN0LnNjYWxlICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XG4gICAgICAgIGlmICggZGF0YS5yb3RhdGlvbiAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJvdGF0aW9uLmZyb21BcnJheSggZGF0YS5yb3RhdGlvbiApO1xuICAgICAgICBpZiAoIGRhdGEuc2NhbGUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zY2FsZS5mcm9tQXJyYXkoIGRhdGEuc2NhbGUgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIGRhdGEuY2FzdFNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmNhc3RTaGFkb3cgPSBkYXRhLmNhc3RTaGFkb3c7XG4gICAgICBpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XG5cbiAgICAgIGlmICggZGF0YS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSBvYmplY3QudmlzaWJsZSA9IGRhdGEudmlzaWJsZTtcbiAgICAgIGlmICggZGF0YS51c2VyRGF0YSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnVzZXJEYXRhID0gZGF0YS51c2VyRGF0YTtcblxuICAgICAgaWYgKCBkYXRhLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGNoaWxkIGluIGRhdGEuY2hpbGRyZW4gKSB7XG5cbiAgICAgICAgICBvYmplY3QuYWRkKCB0aGlzLnBhcnNlT2JqZWN0KCBkYXRhLmNoaWxkcmVuWyBjaGlsZCBdLCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgfVxuXG4gIH0oKVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL1RleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlRleHR1cmVMb2FkZXIgPSBmdW5jdGlvbiAoIG1hbmFnZXIgKSB7XG5cbiAgdGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBUSFJFRS5EZWZhdWx0TG9hZGluZ01hbmFnZXI7XG5cbn07XG5cblRIUkVFLlRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlTG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5JbWFnZUxvYWRlciggc2NvcGUubWFuYWdlciApO1xuICAgIGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xuICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XG5cbiAgICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLlRleHR1cmUoIGltYWdlICk7XG4gICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgaWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgfVxuXG4gICAgfSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xuXG4gIH0sXG5cbiAgc2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgICB0aGlzLmNyb3NzT3JpZ2luID0gdmFsdWU7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0JpbmFyeVRleHR1cmVMb2FkZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIE5pa29zIE0uIC8gaHR0cHM6Ly9naXRodWIuY29tL2ZvbzEyMy9cbiAqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGxvYWQgZ2VuZXJpYyBiaW5hcnkgdGV4dHVyZXMgZm9ybWF0cyAocmdiZSwgaGRyLCAuLi4pXG4gKi9cblxuVEhSRUUuRGF0YVRleHR1cmVMb2FkZXIgPSBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gIC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXG4gIHRoaXMuX3BhcnNlciA9IG51bGw7XG5cbn07XG5cblRIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5CaW5hcnlUZXh0dXJlTG9hZGVyLFxuXG4gIGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoICk7XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlcigpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuICAgIGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xuXG4gICAgICB2YXIgdGV4RGF0YSA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciApO1xuXG4gICAgICBpZiAoICF0ZXhEYXRhICkgcmV0dXJuO1xuXG4gICAgICBpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcblxuICAgICAgICB0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcblxuICAgICAgfSBlbHNlIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLmRhdGEgKSB7XG5cbiAgICAgICAgdGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGEud2lkdGg7XG4gICAgICAgIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YS5oZWlnaHQ7XG4gICAgICAgIHRleHR1cmUuaW1hZ2UuZGF0YSA9IHRleERhdGEuZGF0YTtcblxuICAgICAgfVxuXG4gICAgICB0ZXh0dXJlLndyYXBTID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBTID8gdGV4RGF0YS53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gICAgICB0ZXh0dXJlLndyYXBUID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLndyYXBUID8gdGV4RGF0YS53cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG5cbiAgICAgIHRleHR1cmUubWFnRmlsdGVyID0gdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1hZ0ZpbHRlciA/IHRleERhdGEubWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xuICAgICAgdGV4dHVyZS5taW5GaWx0ZXIgPSB1bmRlZmluZWQgIT09IHRleERhdGEubWluRmlsdGVyID8gdGV4RGF0YS5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgICAgIHRleHR1cmUuYW5pc290cm9weSA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5hbmlzb3Ryb3B5ID8gdGV4RGF0YS5hbmlzb3Ryb3B5IDogMTtcblxuICAgICAgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZm9ybWF0ICkge1xuXG4gICAgICAgIHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XG5cbiAgICAgIH1cbiAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLnR5cGUgKSB7XG5cbiAgICAgICAgdGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLm1pcG1hcHMgKSB7XG5cbiAgICAgICAgdGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YS5taXBtYXBzO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggMSA9PT0gdGV4RGF0YS5taXBtYXBDb3VudCApIHtcblxuICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuICAgICAgfVxuXG4gICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUsIHRleERhdGEgKTtcblxuICAgIH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcblxuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9sb2FkZXJzL0NvbXByZXNzZWRUZXh0dXJlTG9hZGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqXG4gKiBBYnN0cmFjdCBCYXNlIGNsYXNzIHRvIGJsb2NrIGJhc2VkIHRleHR1cmVzIGxvYWRlciAoZGRzLCBwdnIsIC4uLilcbiAqL1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAvLyBvdmVycmlkZSBpbiBzdWIgY2xhc3Nlc1xuICB0aGlzLl9wYXJzZXIgPSBudWxsO1xuXG59O1xuXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIsXG5cbiAgbG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25FcnJvciApIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICB2YXIgaW1hZ2VzID0gW107XG5cbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xuICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZXM7XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLlhIUkxvYWRlcigpO1xuICAgIGxvYWRlci5zZXRSZXNwb25zZVR5cGUoICdhcnJheWJ1ZmZlcicgKTtcblxuICAgIGlmICggQXJyYXkuaXNBcnJheSggdXJsICkgKSB7XG5cbiAgICAgIHZhciBsb2FkZWQgPSAwO1xuXG4gICAgICB2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cbiAgICAgICAgbG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcblxuICAgICAgICAgIHZhciB0ZXhEYXRhcyA9IHNjb3BlLl9wYXJzZXIoIGJ1ZmZlciwgdHJ1ZSApO1xuXG4gICAgICAgICAgaW1hZ2VzWyBpIF0gPSB7XG4gICAgICAgICAgICB3aWR0aDogdGV4RGF0YXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRleERhdGFzLmhlaWdodCxcbiAgICAgICAgICAgIGZvcm1hdDogdGV4RGF0YXMuZm9ybWF0LFxuICAgICAgICAgICAgbWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsb2FkZWQgKz0gMTtcblxuICAgICAgICAgIGlmICggbG9hZGVkID09PSA2ICkge1xuXG4gICAgICAgICAgICBpZiAodGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEpXG4gICAgICAgICAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgICAgICB0ZXh0dXJlLmZvcm1hdCA9IHRleERhdGFzLmZvcm1hdDtcbiAgICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gKTtcblxuICAgICAgfTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHVybC5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuICAgICAgICBsb2FkVGV4dHVyZSggaSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZSBzdG9yZWQgaW4gYSBzaW5nbGUgRERTIGZpbGVcblxuICAgICAgbG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cbiAgICAgICAgdmFyIHRleERhdGFzID0gc2NvcGUuX3BhcnNlciggYnVmZmVyLCB0cnVlICk7XG5cbiAgICAgICAgaWYgKCB0ZXhEYXRhcy5pc0N1YmVtYXAgKSB7XG5cbiAgICAgICAgICB2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xuXG4gICAgICAgICAgZm9yICggdmFyIGYgPSAwOyBmIDwgZmFjZXM7IGYgKysgKSB7XG5cbiAgICAgICAgICAgIGltYWdlc1sgZiBdID0geyBtaXBtYXBzIDogW10gfTtcblxuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGV4RGF0YXMubWlwbWFwQ291bnQ7IGkgKysgKSB7XG5cbiAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0ubWlwbWFwcy5wdXNoKCB0ZXhEYXRhcy5taXBtYXBzWyBmICogdGV4RGF0YXMubWlwbWFwQ291bnQgKyBpIF0gKTtcbiAgICAgICAgICAgICAgaW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xuICAgICAgICAgICAgICBpbWFnZXNbIGYgXS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuICAgICAgICAgICAgICBpbWFnZXNbIGYgXS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleERhdGFzLndpZHRoO1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xuICAgICAgICAgIHRleHR1cmUubWlwbWFwcyA9IHRleERhdGFzLm1pcG1hcHM7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggdGV4RGF0YXMubWlwbWFwQ291bnQgPT09IDEgKSB7XG5cbiAgICAgICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLkxpbmVhckZpbHRlcjtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XG4gICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgIGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XG5cbiAgICAgIH0gKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTWF0ZXJpYWwgPSBmdW5jdGlvbiAoKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5NYXRlcmlhbElkQ291bnQgKysgfSApO1xuXG4gIHRoaXMudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7XG5cbiAgdGhpcy5uYW1lID0gJyc7XG4gIHRoaXMudHlwZSA9ICdNYXRlcmlhbCc7XG5cbiAgdGhpcy5zaWRlID0gVEhSRUUuRnJvbnRTaWRlO1xuXG4gIHRoaXMub3BhY2l0eSA9IDE7XG4gIHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcblxuICB0aGlzLmJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XG5cbiAgdGhpcy5ibGVuZFNyYyA9IFRIUkVFLlNyY0FscGhhRmFjdG9yO1xuICB0aGlzLmJsZW5kRHN0ID0gVEhSRUUuT25lTWludXNTcmNBbHBoYUZhY3RvcjtcbiAgdGhpcy5ibGVuZEVxdWF0aW9uID0gVEhSRUUuQWRkRXF1YXRpb247XG4gIHRoaXMuYmxlbmRTcmNBbHBoYSA9IG51bGw7XG4gIHRoaXMuYmxlbmREc3RBbHBoYSA9IG51bGw7XG4gIHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcblxuICB0aGlzLmRlcHRoRnVuYyA9IFRIUkVFLkxlc3NFcXVhbERlcHRoO1xuICB0aGlzLmRlcHRoVGVzdCA9IHRydWU7XG4gIHRoaXMuZGVwdGhXcml0ZSA9IHRydWU7XG5cbiAgdGhpcy5jb2xvcldyaXRlID0gdHJ1ZTtcblxuICB0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcbiAgdGhpcy5wb2x5Z29uT2Zmc2V0RmFjdG9yID0gMDtcbiAgdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHMgPSAwO1xuXG4gIHRoaXMuYWxwaGFUZXN0ID0gMDtcblxuICB0aGlzLm92ZXJkcmF3ID0gMDsgLy8gT3ZlcmRyYXduIHBpeGVscyAodHlwaWNhbGx5IGJldHdlZW4gMCBhbmQgMSkgZm9yIGZpeGluZyBhbnRpYWxpYXNpbmcgZ2FwcyBpbiBDYW52YXNSZW5kZXJlclxuXG4gIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgdGhpcy5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXG59O1xuXG5USFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLk1hdGVyaWFsLFxuXG4gIGdldCBuZWVkc1VwZGF0ZSAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fbmVlZHNVcGRhdGU7XG5cbiAgfSxcblxuICBzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcblxuICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICB9LFxuXG4gIHNldFZhbHVlczogZnVuY3Rpb24gKCB2YWx1ZXMgKSB7XG5cbiAgICBpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgZm9yICggdmFyIGtleSBpbiB2YWx1ZXMgKSB7XG5cbiAgICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlc1sga2V5IF07XG5cbiAgICAgIGlmICggbmV3VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuTWF0ZXJpYWw6ICdcIiArIGtleSArIFwiJyBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkLlwiICk7XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICgga2V5IGluIHRoaXMgKSB7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRoaXNbIGtleSBdO1xuXG4gICAgICAgIGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSB7XG5cbiAgICAgICAgICBjdXJyZW50VmFsdWUuc2V0KCBuZXdWYWx1ZSApO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgJiYgbmV3VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkge1xuXG4gICAgICAgICAgY3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICgga2V5ID09PSAnb3ZlcmRyYXcnICkge1xuXG4gICAgICAgICAgLy8gZW5zdXJlIG92ZXJkcmF3IGlzIGJhY2t3YXJkcy1jb21wYXRhYmxlIHdpdGggbGVnYWN5IGJvb2xlYW4gdHlwZVxuICAgICAgICAgIHRoaXNbIGtleSBdID0gTnVtYmVyKCBuZXdWYWx1ZSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB0aGlzWyBrZXkgXSA9IG5ld1ZhbHVlO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIHZlcnNpb246IDQuNCxcbiAgICAgICAgdHlwZTogJ01hdGVyaWFsJyxcbiAgICAgICAgZ2VuZXJhdG9yOiAnTWF0ZXJpYWwudG9KU09OJ1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGFuZGFyZCBNYXRlcmlhbCBzZXJpYWxpemF0aW9uXG4gICAgZGF0YS51dWlkID0gdGhpcy51dWlkO1xuICAgIGRhdGEudHlwZSA9IHRoaXMudHlwZTtcbiAgICBpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XG5cbiAgICBpZiAoIHRoaXMuY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xuICAgIGlmICggdGhpcy5lbWlzc2l2ZSBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XG4gICAgaWYgKCB0aGlzLnNwZWN1bGFyIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgKSBkYXRhLnNwZWN1bGFyID0gdGhpcy5zcGVjdWxhci5nZXRIZXgoKTtcbiAgICBpZiAoIHRoaXMuc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLnNoaW5pbmVzcyA9IHRoaXMuc2hpbmluZXNzO1xuXG4gICAgaWYgKCB0aGlzLm1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSBkYXRhLm1hcCA9IHRoaXMubWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgaWYgKCB0aGlzLmFscGhhTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgaWYgKCB0aGlzLmxpZ2h0TWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgaWYgKCB0aGlzLmJ1bXBNYXAgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xuICAgICAgZGF0YS5idW1wTWFwID0gdGhpcy5idW1wTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICBkYXRhLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xuICAgIH1cbiAgICBpZiAoIHRoaXMubm9ybWFsTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcbiAgICAgIGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcbiAgICAgIGRhdGEubm9ybWFsU2NhbGUgPSB0aGlzLm5vcm1hbFNjYWxlOyAvLyBSZW1vdmVkIGZvciBub3csIGNhdXNlcyBpc3N1ZSBpbiBlZGl0b3IgdWkuanNcbiAgICB9XG4gICAgaWYgKCB0aGlzLnNwZWN1bGFyTWFwIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIGRhdGEuc3BlY3VsYXJNYXAgPSB0aGlzLnNwZWN1bGFyTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgaWYgKCB0aGlzLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLlRleHR1cmUgKSB7XG4gICAgICBkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XG4gICAgICBkYXRhLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5OyAvLyBTY2FsZSBiZWhpbmQgZW52TWFwXG4gICAgfVxuXG4gICAgaWYgKCB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICBpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xuXG4gICAgaWYgKCB0aGlzLnZlcnRleENvbG9ycyAhPT0gdW5kZWZpbmVkICYmIHRoaXMudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIGRhdGEudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG4gICAgaWYgKCB0aGlzLnNoYWRpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNoYWRpbmcgIT09IFRIUkVFLlNtb290aFNoYWRpbmcgKSBkYXRhLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XG4gICAgaWYgKCB0aGlzLmJsZW5kaW5nICE9PSB1bmRlZmluZWQgJiYgdGhpcy5ibGVuZGluZyAhPT0gVEhSRUUuTm9ybWFsQmxlbmRpbmcgKSBkYXRhLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcbiAgICBpZiAoIHRoaXMuc2lkZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuc2lkZSAhPT0gVEhSRUUuRnJvbnRTaWRlICkgZGF0YS5zaWRlID0gdGhpcy5zaWRlO1xuXG4gICAgaWYgKCB0aGlzLm9wYWNpdHkgPCAxICkgZGF0YS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIGlmICggdGhpcy50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIGRhdGEudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xuICAgIGlmICggdGhpcy53aXJlZnJhbWUgPT09IHRydWUgKSBkYXRhLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuXG4gICAgcmV0dXJuIGRhdGE7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuICAgIGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1hdGVyaWFsKCk7XG5cbiAgICBtYXRlcmlhbC5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgbWF0ZXJpYWwuc2lkZSA9IHRoaXMuc2lkZTtcblxuICAgIG1hdGVyaWFsLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG4gICAgbWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0aGlzLnRyYW5zcGFyZW50O1xuXG4gICAgbWF0ZXJpYWwuYmxlbmRpbmcgPSB0aGlzLmJsZW5kaW5nO1xuXG4gICAgbWF0ZXJpYWwuYmxlbmRTcmMgPSB0aGlzLmJsZW5kU3JjO1xuICAgIG1hdGVyaWFsLmJsZW5kRHN0ID0gdGhpcy5ibGVuZERzdDtcbiAgICBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uID0gdGhpcy5ibGVuZEVxdWF0aW9uO1xuICAgIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEgPSB0aGlzLmJsZW5kU3JjQWxwaGE7XG4gICAgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSA9IHRoaXMuYmxlbmREc3RBbHBoYTtcbiAgICBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEgPSB0aGlzLmJsZW5kRXF1YXRpb25BbHBoYTtcblxuICAgIG1hdGVyaWFsLmRlcHRoRnVuYyA9IHRoaXMuZGVwdGhGdW5jO1xuICAgIG1hdGVyaWFsLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xuICAgIG1hdGVyaWFsLmRlcHRoV3JpdGUgPSB0aGlzLmRlcHRoV3JpdGU7XG5cbiAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gdGhpcy5wb2x5Z29uT2Zmc2V0O1xuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I7XG4gICAgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHM7XG5cbiAgICBtYXRlcmlhbC5hbHBoYVRlc3QgPSB0aGlzLmFscGhhVGVzdDtcblxuICAgIG1hdGVyaWFsLm92ZXJkcmF3ID0gdGhpcy5vdmVyZHJhdztcblxuICAgIG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG5cbiAgICByZXR1cm4gbWF0ZXJpYWw7XG5cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAndXBkYXRlJyB9ICk7XG5cbiAgfSxcblxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUuYXBwbHkoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuXG5USFJFRS5NYXRlcmlhbElkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTGluZUJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXG4gKiAgbGluZWNhcDogXCJyb3VuZFwiLFxuICogIGxpbmVqb2luOiBcInJvdW5kXCIsXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+XG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuICB0aGlzLmxpbmV3aWR0aCA9IDE7XG4gIHRoaXMubGluZWNhcCA9ICdyb3VuZCc7XG4gIHRoaXMubGluZWpvaW4gPSAncm91bmQnO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWw7XG5cblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcblxuICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XG5cbiAgbWF0ZXJpYWwubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XG4gIG1hdGVyaWFsLmxpbmVjYXAgPSB0aGlzLmxpbmVjYXA7XG4gIG1hdGVyaWFsLmxpbmVqb2luID0gdGhpcy5saW5lam9pbjtcblxuICBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuICBtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuICByZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9MaW5lRGFzaGVkTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIGxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgc2NhbGU6IDxmbG9hdD4sXG4gKiAgZGFzaFNpemU6IDxmbG9hdD4sXG4gKiAgZ2FwU2l6ZTogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdMaW5lRGFzaGVkTWF0ZXJpYWwnO1xuXG4gIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG5cbiAgdGhpcy5saW5ld2lkdGggPSAxO1xuXG4gIHRoaXMuc2NhbGUgPSAxO1xuICB0aGlzLmRhc2hTaXplID0gMztcbiAgdGhpcy5nYXBTaXplID0gMTtcblxuICB0aGlzLnZlcnRleENvbG9ycyA9IGZhbHNlO1xuXG4gIHRoaXMuZm9nID0gdHJ1ZTtcblxuICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsO1xuXG5USFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwoKTtcblxuICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XG5cbiAgbWF0ZXJpYWwubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XG5cbiAgbWF0ZXJpYWwuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICBtYXRlcmlhbC5kYXNoU2l6ZSA9IHRoaXMuZGFzaFNpemU7XG4gIG1hdGVyaWFsLmdhcFNpemUgPSB0aGlzLmdhcFNpemU7XG5cbiAgbWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XG5cbiAgbWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaEJhc2ljTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKiAgYW9NYXBJbnRlbnNpdHk6IDxmbG9hdD5cbiAqXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxuICpcbiAqICBza2lubmluZzogPGJvb2w+LFxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xuXG4gIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXG5cbiAgdGhpcy5tYXAgPSBudWxsO1xuXG4gIHRoaXMuYW9NYXAgPSBudWxsO1xuICB0aGlzLmFvTWFwSW50ZW5zaXR5ID0gMS4wO1xuXG4gIHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xuXG4gIHRoaXMuYWxwaGFNYXAgPSBudWxsO1xuXG4gIHRoaXMuZW52TWFwID0gbnVsbDtcbiAgdGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XG4gIHRoaXMucmVmbGVjdGl2aXR5ID0gMTtcbiAgdGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xuXG4gIHRoaXMuZm9nID0gdHJ1ZTtcblxuICB0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG4gIHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XG4gIHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcbiAgdGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcbiAgdGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XG5cbiAgdGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9ycztcblxuICB0aGlzLnNraW5uaW5nID0gZmFsc2U7XG4gIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbDtcblxuVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblxuICBtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcblxuICBtYXRlcmlhbC5hb01hcCA9IHRoaXMuYW9NYXA7XG4gIG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5ID0gdGhpcy5hb01hcEludGVuc2l0eTtcblxuICBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XG5cbiAgbWF0ZXJpYWwuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwO1xuXG4gIG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xuICBtYXRlcmlhbC5jb21iaW5lID0gdGhpcy5jb21iaW5lO1xuICBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcbiAgbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XG5cbiAgbWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cbiAgbWF0ZXJpYWwuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcblxuICBtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG4gIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG4gIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcblxuICBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuICBtYXRlcmlhbC5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XG4gIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xuXG4gIHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hMYW1iZXJ0TWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIGNvbG9yOiA8aGV4PixcbiAqICBlbWlzc2l2ZTogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxuICpcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcbiAqXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXG4gKlxuICogIHNraW5uaW5nOiA8Ym9vbD4sXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXG4gKiAgbW9ycGhOb3JtYWxzOiA8Ym9vbD4sXG4gKlxuICogIGZvZzogPGJvb2w+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ01lc2hMYW1iZXJ0TWF0ZXJpYWwnO1xuXG4gIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcbiAgdGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcblxuICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgdGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XG5cbiAgdGhpcy5hbHBoYU1hcCA9IG51bGw7XG5cbiAgdGhpcy5lbnZNYXAgPSBudWxsO1xuICB0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcbiAgdGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xuICB0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XG5cbiAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gIHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XG5cbiAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuICB0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xuICB0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcblxuICB0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xuXG4gIHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgdGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcblxuICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsO1xuXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcbiAgbWF0ZXJpYWwuZW1pc3NpdmUuY29weSggdGhpcy5lbWlzc2l2ZSApO1xuXG4gIG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xuXG4gIG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcblxuICBtYXRlcmlhbC5hbHBoYU1hcCA9IHRoaXMuYWxwaGFNYXA7XG5cbiAgbWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XG4gIG1hdGVyaWFsLmNvbWJpbmUgPSB0aGlzLmNvbWJpbmU7XG4gIG1hdGVyaWFsLnJlZmxlY3Rpdml0eSA9IHRoaXMucmVmbGVjdGl2aXR5O1xuICBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcblxuICBtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuICBtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXG4gIG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IHRoaXMud2lyZWZyYW1lTGluZWNhcDtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xuXG4gIG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xuXG4gIG1hdGVyaWFsLnNraW5uaW5nID0gdGhpcy5za2lubmluZztcbiAgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG4gIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xuXG4gIHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hQaG9uZ01hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxuICogIHNwZWN1bGFyOiA8aGV4PixcbiAqICBzaGluaW5lc3M6IDxmbG9hdD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBhb01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxuICpcbiAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIGJ1bXBTY2FsZTogPGZsb2F0PixcbiAqXG4gKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXG4gKlxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcbiAqXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ01lc2hQaG9uZ01hdGVyaWFsJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApOyAvLyBkaWZmdXNlXG4gIHRoaXMuZW1pc3NpdmUgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICk7XG4gIHRoaXMuc3BlY3VsYXIgPSBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICk7XG4gIHRoaXMuc2hpbmluZXNzID0gMzA7XG5cbiAgdGhpcy5tZXRhbCA9IGZhbHNlO1xuXG4gIHRoaXMubWFwID0gbnVsbDtcblxuICB0aGlzLmxpZ2h0TWFwID0gbnVsbDtcbiAgdGhpcy5saWdodE1hcEludGVuc2l0eSA9IDEuMDtcblxuICB0aGlzLmFvTWFwID0gbnVsbDtcbiAgdGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcblxuICB0aGlzLmJ1bXBNYXAgPSBudWxsO1xuICB0aGlzLmJ1bXBTY2FsZSA9IDE7XG5cbiAgdGhpcy5ub3JtYWxNYXAgPSBudWxsO1xuICB0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuICB0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcblxuICB0aGlzLmFscGhhTWFwID0gbnVsbDtcblxuICB0aGlzLmVudk1hcCA9IG51bGw7XG4gIHRoaXMuY29tYmluZSA9IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xuICB0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XG4gIHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcblxuICB0aGlzLmZvZyA9IHRydWU7XG5cbiAgdGhpcy5zaGFkaW5nID0gVEhSRUUuU21vb3RoU2hhZGluZztcblxuICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG4gIHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XG4gIHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgdGhpcy5za2lubmluZyA9IGZhbHNlO1xuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xuICB0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaFBob25nTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoKTtcblxuICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XG4gIG1hdGVyaWFsLmVtaXNzaXZlLmNvcHkoIHRoaXMuZW1pc3NpdmUgKTtcbiAgbWF0ZXJpYWwuc3BlY3VsYXIuY29weSggdGhpcy5zcGVjdWxhciApO1xuICBtYXRlcmlhbC5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcblxuICBtYXRlcmlhbC5tZXRhbCA9IHRoaXMubWV0YWw7XG5cbiAgbWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cbiAgbWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xuICBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eSA9IHRoaXMubGlnaHRNYXBJbnRlbnNpdHk7XG5cbiAgbWF0ZXJpYWwuYW9NYXAgPSB0aGlzLmFvTWFwO1xuICBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IHRoaXMuYW9NYXBJbnRlbnNpdHk7XG5cbiAgbWF0ZXJpYWwuYnVtcE1hcCA9IHRoaXMuYnVtcE1hcDtcbiAgbWF0ZXJpYWwuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XG5cbiAgbWF0ZXJpYWwubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXA7XG4gIG1hdGVyaWFsLm5vcm1hbFNjYWxlLmNvcHkoIHRoaXMubm9ybWFsU2NhbGUgKTtcblxuICBtYXRlcmlhbC5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXA7XG5cbiAgbWF0ZXJpYWwuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwO1xuXG4gIG1hdGVyaWFsLmVudk1hcCA9IHRoaXMuZW52TWFwO1xuICBtYXRlcmlhbC5jb21iaW5lID0gdGhpcy5jb21iaW5lO1xuICBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcbiAgbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvID0gdGhpcy5yZWZyYWN0aW9uUmF0aW87XG5cbiAgbWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XG5cbiAgbWF0ZXJpYWwuc2hhZGluZyA9IHRoaXMuc2hhZGluZztcblxuICBtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG4gIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XG4gIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0gdGhpcy53aXJlZnJhbWVMaW5lam9pbjtcblxuICBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuICBtYXRlcmlhbC5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XG4gIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xuICBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFscztcblxuICByZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIEZpbGU6c3JjL21hdGVyaWFscy9NZXNoRGVwdGhNYXRlcmlhbC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxuICogIGRlcHRoV3JpdGU6IDxib29sPixcbiAqXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XG4gKiB9XG4gKi9cblxuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgVEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdNZXNoRGVwdGhNYXRlcmlhbCc7XG5cbiAgdGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcbiAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWw7XG5cblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwoKTtcblxuICBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcblxuICBtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcbiAgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoID0gdGhpcy53aXJlZnJhbWVMaW5ld2lkdGg7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvTWVzaE5vcm1hbE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKlxuICogIHNoYWRpbmc6IFRIUkVFLkZsYXRTaGFkaW5nLFxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PlxuICogfVxuICovXG5cblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XG5cbiAgdGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XG5cbiAgdGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcbiAgdGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xuXG4gIHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbDtcblxuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsKCk7XG5cbiAgVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cbiAgbWF0ZXJpYWwud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XG4gIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xuXG4gIHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvbWF0ZXJpYWxzL01lc2hGYWNlTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFscyApIHtcblxuICBjb25zb2xlLmVycm9yKCAnVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLicgKTtcblxuICB2YXIgbWF0ZXJpYWwgPSBBcnJheS5pc0FycmF5KCBtYXRlcmlhbHMgKSA/IG1hdGVyaWFsc1sgMCBdIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCk7XG4gIG1hdGVyaWFsLm1hdGVyaWFscyA9IFtdOyAvLyB0ZW1wb3JhbCB3b3JrYXJvdW5kXG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvUG9pbnRDbG91ZE1hdGVyaWFsLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBjb2xvcjogPGhleD4sXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXG4gKlxuICogIHNpemU6IDxmbG9hdD4sXG4gKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD4sXG4gKlxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXG4gKlxuICogIHZlcnRleENvbG9yczogPGJvb2w+LFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BvaW50Q2xvdWRNYXRlcmlhbCc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcblxuICB0aGlzLm1hcCA9IG51bGw7XG5cbiAgdGhpcy5zaXplID0gMTtcbiAgdGhpcy5zaXplQXR0ZW51YXRpb24gPSB0cnVlO1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XG5cbiAgdGhpcy5mb2cgPSB0cnVlO1xuXG4gIHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XG5cbn07XG5cblRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWw7XG5cblRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcblxuICBtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcblxuICBtYXRlcmlhbC5zaXplID0gdGhpcy5zaXplO1xuICBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSB0aGlzLnNpemVBdHRlbnVhdGlvbjtcblxuICBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuICBtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuICByZXR1cm4gbWF0ZXJpYWw7XG5cbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwuJyApO1xuICByZXR1cm4gbmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG59O1xuXG5USFJFRS5QYXJ0aWNsZVN5c3RlbU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwuJyApO1xuICByZXR1cm4gbmV3IFRIUkVFLlBvaW50Q2xvdWRNYXRlcmlhbCggcGFyYW1ldGVycyApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU2hhZGVyTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgZGVmaW5lczogeyBcImxhYmVsXCIgOiBcInZhbHVlXCIgfSxcbiAqICB1bmlmb3JtczogeyBcInBhcmFtZXRlcjFcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LCBcInBhcmFtZXRlcjJcIjogeyB0eXBlOiBcImlcIiB2YWx1ZTI6IDIgfSB9LFxuICpcbiAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXG4gKiAgdmVydGV4U2hhZGVyOiA8c3RyaW5nPixcbiAqXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXG4gKlxuICogIGxpZ2h0czogPGJvb2w+LFxuICpcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcbiAqXG4gKiAgc2tpbm5pbmc6IDxib29sPixcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcbiAqXG4gKiAgZm9nOiA8Ym9vbD5cbiAqIH1cbiAqL1xuXG5USFJFRS5TaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1NoYWRlck1hdGVyaWFsJztcblxuICB0aGlzLmRlZmluZXMgPSB7fTtcbiAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBbXTtcblxuICB0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxuXFx0Z2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcbn0nO1xuICB0aGlzLmZyYWdtZW50U2hhZGVyID0gJ3ZvaWQgbWFpbigpIHtcXG5cXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXG59JztcblxuICB0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xuXG4gIHRoaXMubGluZXdpZHRoID0gMTtcblxuICB0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xuICB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XG5cbiAgdGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcblxuICB0aGlzLmxpZ2h0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGxpZ2h0c1xuXG4gIHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7IC8vIHNldCB0byB1c2UgXCJjb2xvclwiIGF0dHJpYnV0ZSBzdHJlYW1cblxuICB0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcblxuICB0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcbiAgdGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXG5cbiAgdGhpcy5kZXJpdmF0aXZlcyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIGRlcml2YXRpdmVzXG5cbiAgLy8gV2hlbiByZW5kZXJlZCBnZW9tZXRyeSBkb2Vzbid0IGluY2x1ZGUgdGhlc2UgYXR0cmlidXRlcyBidXQgdGhlIG1hdGVyaWFsIGRvZXMsXG4gIC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cbiAgdGhpcy5kZWZhdWx0QXR0cmlidXRlVmFsdWVzID0ge1xuICAgICdjb2xvcic6IFsgMSwgMSwgMSBdLFxuICAgICd1dic6IFsgMCwgMCBdLFxuICAgICd1djInOiBbIDAsIDAgXVxuICB9O1xuXG4gIHRoaXMuaW5kZXgwQXR0cmlidXRlTmFtZSA9IHVuZGVmaW5lZDtcblxuICBpZiAoIHBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIGlmICggcGFyYW1ldGVycy5hdHRyaWJ1dGVzICE9PSB1bmRlZmluZWQgJiYgQXJyYXkuaXNBcnJheSggcGFyYW1ldGVycy5hdHRyaWJ1dGVzICkgPT09IGZhbHNlICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5TaGFkZXJNYXRlcmlhbDogYXR0cmlidXRlcyBzaG91bGQgbm93IGJlIGFuIGFycmF5IG9mIGF0dHJpYnV0ZSBuYW1lcy4nICk7XG4gICAgICBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyggcGFyYW1ldGVycy5hdHRyaWJ1dGVzICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFkZXJNYXRlcmlhbDtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuICBpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0gdGhpcy5mcmFnbWVudFNoYWRlcjtcbiAgbWF0ZXJpYWwudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG5cbiAgbWF0ZXJpYWwudW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCB0aGlzLnVuaWZvcm1zICk7XG5cbiAgbWF0ZXJpYWwuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcbiAgbWF0ZXJpYWwuZGVmaW5lcyA9IHRoaXMuZGVmaW5lcztcblxuICBtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xuXG4gIG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xuICBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcblxuICBtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcblxuICBtYXRlcmlhbC5saWdodHMgPSB0aGlzLmxpZ2h0cztcblxuICBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcblxuICBtYXRlcmlhbC5za2lubmluZyA9IHRoaXMuc2tpbm5pbmc7XG5cbiAgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0gdGhpcy5tb3JwaFRhcmdldHM7XG4gIG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xuXG4gIHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIGRhdGEudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xuICBkYXRhLmF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XG4gIGRhdGEudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XG4gIGRhdGEuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvUmF3U2hhZGVyTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLlNoYWRlck1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcblxuICB0aGlzLnR5cGUgPSAnUmF3U2hhZGVyTWF0ZXJpYWwnO1xuXG59O1xuXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUgKTtcblRIUkVFLlJhd1NoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsO1xuXG5USFJFRS5SYXdTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsKCk7XG5cbiAgVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XG5cbiAgcmV0dXJuIG1hdGVyaWFsO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9tYXRlcmlhbHMvU3ByaXRlTWF0ZXJpYWwuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKiAgY29sb3I6IDxoZXg+LFxuICogIG9wYWNpdHk6IDxmbG9hdD4sXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxuICpcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxuICpcbiAqICB1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcbiAqICB1dlNjYWxlOiBuZXcgVEhSRUUuVmVjdG9yMigpLFxuICpcbiAqICBmb2c6IDxib29sPlxuICogfVxuICovXG5cblRIUkVFLlNwcml0ZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xuXG4gIFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnU3ByaXRlTWF0ZXJpYWwnO1xuXG4gIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG4gIHRoaXMubWFwID0gbnVsbDtcblxuICB0aGlzLnJvdGF0aW9uID0gMDtcblxuICB0aGlzLmZvZyA9IGZhbHNlO1xuXG4gIC8vIHNldCBwYXJhbWV0ZXJzXG5cbiAgdGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcblxufTtcblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XG5USFJFRS5TcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcHJpdGVNYXRlcmlhbDtcblxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TcHJpdGVNYXRlcmlhbCgpO1xuXG4gIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xuXG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcbiAgbWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XG5cbiAgbWF0ZXJpYWwucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuXG4gIG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xuXG4gIHJldHVybiBtYXRlcmlhbDtcblxufTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xuICovXG5cblRIUkVFLlRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBUSFJFRS5UZXh0dXJlSWRDb3VudCArKyB9ICk7XG5cbiAgdGhpcy51dWlkID0gVEhSRUUuTWF0aC5nZW5lcmF0ZVVVSUQoKTtcblxuICB0aGlzLm5hbWUgPSAnJztcbiAgdGhpcy5zb3VyY2VGaWxlID0gJyc7XG5cbiAgdGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9JTUFHRTtcbiAgdGhpcy5taXBtYXBzID0gW107XG5cbiAgdGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IFRIUkVFLlRleHR1cmUuREVGQVVMVF9NQVBQSU5HO1xuXG4gIHRoaXMud3JhcFMgPSB3cmFwUyAhPT0gdW5kZWZpbmVkID8gd3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xuICB0aGlzLndyYXBUID0gd3JhcFQgIT09IHVuZGVmaW5lZCA/IHdyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICB0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogVEhSRUUuTGluZWFyRmlsdGVyO1xuICB0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuXG4gIHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IGFuaXNvdHJvcHkgOiAxO1xuXG4gIHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xuICB0aGlzLnR5cGUgPSB0eXBlICE9PSB1bmRlZmluZWQgPyB0eXBlIDogVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcblxuICB0aGlzLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XG4gIHRoaXMucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcblxuICB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XG4gIHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IGZhbHNlO1xuICB0aGlzLmZsaXBZID0gdHJ1ZTtcbiAgdGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0OyAvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcblxuICB0aGlzLl9uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICB0aGlzLm9uVXBkYXRlID0gbnVsbDtcblxufTtcblxuVEhSRUUuVGV4dHVyZS5ERUZBVUxUX0lNQUdFID0gdW5kZWZpbmVkO1xuVEhSRUUuVGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBUSFJFRS5VVk1hcHBpbmc7XG5cblRIUkVFLlRleHR1cmUucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBUSFJFRS5UZXh0dXJlLFxuXG4gIGdldCBuZWVkc1VwZGF0ZSAoKSB7XG5cbiAgICByZXR1cm4gdGhpcy5fbmVlZHNVcGRhdGU7XG5cbiAgfSxcblxuICBzZXQgbmVlZHNVcGRhdGUgKCB2YWx1ZSApIHtcblxuICAgIGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdGhpcy5fbmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICB9LFxuXG4gIGNsb25lOiBmdW5jdGlvbiAoIHRleHR1cmUgKSB7XG5cbiAgICBpZiAoIHRleHR1cmUgPT09IHVuZGVmaW5lZCApIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSgpO1xuXG4gICAgdGV4dHVyZS5pbWFnZSA9IHRoaXMuaW1hZ2U7XG4gICAgdGV4dHVyZS5taXBtYXBzID0gdGhpcy5taXBtYXBzLnNsaWNlKCAwICk7XG5cbiAgICB0ZXh0dXJlLm1hcHBpbmcgPSB0aGlzLm1hcHBpbmc7XG5cbiAgICB0ZXh0dXJlLndyYXBTID0gdGhpcy53cmFwUztcbiAgICB0ZXh0dXJlLndyYXBUID0gdGhpcy53cmFwVDtcblxuICAgIHRleHR1cmUubWFnRmlsdGVyID0gdGhpcy5tYWdGaWx0ZXI7XG4gICAgdGV4dHVyZS5taW5GaWx0ZXIgPSB0aGlzLm1pbkZpbHRlcjtcblxuICAgIHRleHR1cmUuYW5pc290cm9weSA9IHRoaXMuYW5pc290cm9weTtcblxuICAgIHRleHR1cmUuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgdGV4dHVyZS50eXBlID0gdGhpcy50eXBlO1xuXG4gICAgdGV4dHVyZS5vZmZzZXQuY29weSggdGhpcy5vZmZzZXQgKTtcbiAgICB0ZXh0dXJlLnJlcGVhdC5jb3B5KCB0aGlzLnJlcGVhdCApO1xuXG4gICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSB0aGlzLmdlbmVyYXRlTWlwbWFwcztcbiAgICB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSB0aGlzLnByZW11bHRpcGx5QWxwaGE7XG4gICAgdGV4dHVyZS5mbGlwWSA9IHRoaXMuZmxpcFk7XG4gICAgdGV4dHVyZS51bnBhY2tBbGlnbm1lbnQgPSB0aGlzLnVucGFja0FsaWdubWVudDtcblxuICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgICBpZiAoIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHJldHVybiBtZXRhLnRleHR1cmVzWyB0aGlzLnV1aWQgXTtcblxuICAgIH1cblxuICAgIHZhciBvdXRwdXQgPSB7XG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICB2ZXJzaW9uOiA0LjQsXG4gICAgICAgIHR5cGU6ICdUZXh0dXJlJyxcbiAgICAgICAgZ2VuZXJhdG9yOiAnVGV4dHVyZS50b0pTT04nXG4gICAgICB9LFxuXG4gICAgICB1dWlkOiB0aGlzLnV1aWQsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG5cbiAgICAgIG1hcHBpbmc6IHRoaXMubWFwcGluZyxcblxuICAgICAgcmVwZWF0OiBbIHRoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnkgXSxcbiAgICAgIG9mZnNldDogWyB0aGlzLm9mZnNldC54LCB0aGlzLm9mZnNldC55IF0sXG4gICAgICB3cmFwOiBbIHRoaXMud3JhcFMsIHRoaXMud3JhcFQgXSxcblxuICAgICAgbWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlcixcbiAgICAgIG1hZ0ZpbHRlcjogdGhpcy5tYWdGaWx0ZXIsXG4gICAgICBhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHlcbiAgICB9O1xuXG4gICAgaWYgKCB0aGlzLmltYWdlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIC8vIFRPRE86IE1vdmUgdG8gVEhSRUUuSW1hZ2VcblxuICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuICAgICAgaWYgKCBpbWFnZS51dWlkID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgaW1hZ2UudXVpZCA9IFRIUkVFLk1hdGguZ2VuZXJhdGVVVUlEKCk7IC8vIFVHSFxuXG4gICAgICB9XG5cbiAgICAgIGlmICggbWV0YS5pbWFnZXNbIHRoaXMuaW1hZ2UudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XG5cbiAgICAgICAgdmFyIHNyYztcblxuICAgICAgICBpZiAoIGltYWdlLndpZHRoID4gMjA0OCB8fCBpbWFnZS5oZWlnaHQgPiAyMDQ4ICkge1xuXG4gICAgICAgICAgc3JjID0gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL2pwZWcnLCAwLjYgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc3JjID0gY2FudmFzLnRvRGF0YVVSTCggJ2ltYWdlL3BuZycgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgbWV0YS5pbWFnZXNbIHRoaXMuaW1hZ2UudXVpZCBdID0geyB1dWlkOiB0aGlzLmltYWdlLnV1aWQsIHVybDogc3JjIH07XG5cbiAgICAgIH1cblxuICAgICAgb3V0cHV0LmltYWdlID0gaW1hZ2UudXVpZDtcblxuICAgIH1cblxuICAgIG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdID0gb3V0cHV0O1xuXG4gICAgcmV0dXJuIG91dHB1dDtcblxuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICd1cGRhdGUnIH0gKTtcblxuICB9LFxuXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZS5hcHBseSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblxuVEhSRUUuVGV4dHVyZUlkQ291bnQgPSAwO1xuXG4vLyBGaWxlOnNyYy90ZXh0dXJlcy9DdWJlVGV4dHVyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuQ3ViZVRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICkge1xuXG4gIG1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xuXG4gIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICB0aGlzLmltYWdlcyA9IGltYWdlcztcblxufTtcblxuVEhSRUUuQ3ViZVRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1YmVUZXh0dXJlO1xuXG5USFJFRS5DdWJlVGV4dHVyZS5jbG9uZSA9IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuICBpZiAoIHRleHR1cmUgPT09IHVuZGVmaW5lZCApIHRleHR1cmUgPSBuZXcgVEhSRUUuQ3ViZVRleHR1cmUoKTtcblxuICBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XG5cbiAgdGV4dHVyZS5pbWFnZXMgPSB0aGlzLmltYWdlcztcblxuICByZXR1cm4gdGV4dHVyZTtcblxufTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvQ29tcHJlc3NlZFRleHR1cmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlID0gZnVuY3Rpb24gKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHkgKSB7XG5cbiAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcblxuICB0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XG4gIHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XG5cbiAgLy8gbm8gZmxpcHBpbmcgZm9yIGN1YmUgdGV4dHVyZXNcbiAgLy8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcblxuICB0aGlzLmZsaXBZID0gZmFsc2U7XG5cbiAgLy8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xuICAvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXG5cbiAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuVGV4dHVyZS5wcm90b3R5cGUgKTtcblRIUkVFLkNvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlO1xuXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUoKTtcblxuICBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XG5cbiAgcmV0dXJuIHRleHR1cmU7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3RleHR1cmVzL0RhdGFUZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5EYXRhVGV4dHVyZSA9IGZ1bmN0aW9uICggZGF0YSwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBhbmlzb3Ryb3B5ICkge1xuXG4gIFRIUkVFLlRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgdGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xuXG59O1xuXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xuVEhSRUUuRGF0YVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRGF0YVRleHR1cmU7XG5cblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSgpO1xuXG4gIFRIUkVFLlRleHR1cmUucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIHRleHR1cmUgKTtcblxuICByZXR1cm4gdGV4dHVyZTtcblxufTtcblxuLy8gRmlsZTpzcmMvdGV4dHVyZXMvVmlkZW9UZXh0dXJlLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5WaWRlb1RleHR1cmUgPSBmdW5jdGlvbiAoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XG5cbiAgVEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XG5cbiAgdGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xuXG4gICAgaWYgKCB2aWRlby5yZWFkeVN0YXRlID09PSB2aWRlby5IQVZFX0VOT1VHSF9EQVRBICkge1xuXG4gICAgICBzY29wZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgfTtcblxuICB1cGRhdGUoKTtcblxufTtcblxuVEhSRUUuVmlkZW9UZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XG5USFJFRS5WaWRlb1RleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmlkZW9UZXh0dXJlO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0dyb3VwLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Hcm91cCA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0dyb3VwJztcblxufTtcblxuVEhSRUUuR3JvdXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5Hcm91cC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Hcm91cDtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Qb2ludENsb3VkLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5Qb2ludENsb3VkID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdQb2ludENsb3VkJztcblxuICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgIT09IHVuZGVmaW5lZCA/IGdlb21ldHJ5IDogbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG59O1xuXG5USFJFRS5Qb2ludENsb3VkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Qb2ludENsb3VkO1xuXG5USFJFRS5Qb2ludENsb3VkLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICB2YXIgcmF5ID0gbmV3IFRIUkVFLlJheSgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgIHZhciBvYmplY3QgPSB0aGlzO1xuICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcbiAgICB2YXIgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5Qb2ludENsb3VkLnRocmVzaG9sZDtcblxuICAgIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xuXG4gICAgICBpZiAoIHJheS5pc0ludGVyc2VjdGlvbkJveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XG4gICAgdmFyIHBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIHZhciB0ZXN0UG9pbnQgPSBmdW5jdGlvbiAoIHBvaW50LCBpbmRleCApIHtcblxuICAgICAgdmFyIHJheVBvaW50RGlzdGFuY2UgPSByYXkuZGlzdGFuY2VUb1BvaW50KCBwb2ludCApO1xuXG4gICAgICBpZiAoIHJheVBvaW50RGlzdGFuY2UgPCBsb2NhbFRocmVzaG9sZCApIHtcblxuICAgICAgICB2YXIgaW50ZXJzZWN0UG9pbnQgPSByYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQgKTtcbiAgICAgICAgaW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3RQb2ludCApO1xuXG4gICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSByZXR1cm47XG5cbiAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgZGlzdGFuY2VUb1JheTogcmF5UG9pbnREaXN0YW5jZSxcbiAgICAgICAgICBwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcbiAgICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdFxuXG4gICAgICAgIH0gKTtcblxuICAgICAgfVxuXG4gICAgfTtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgIGlmICggYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZhciBpbmRpY2VzID0gYXR0cmlidXRlcy5pbmRleC5hcnJheTtcbiAgICAgICAgdmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xuXG4gICAgICAgIGlmICggb2Zmc2V0cy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0ge1xuICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICBjb3VudDogaW5kaWNlcy5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBvZmZzZXRzID0gWyBvZmZzZXQgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIG9pID0gMCwgb2wgPSBvZmZzZXRzLmxlbmd0aDsgb2kgPCBvbDsgKysgb2kgKSB7XG5cbiAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXRzWyBvaSBdLnN0YXJ0O1xuICAgICAgICAgIHZhciBjb3VudCA9IG9mZnNldHNbIG9pIF0uY291bnQ7XG4gICAgICAgICAgdmFyIGluZGV4ID0gb2Zmc2V0c1sgb2kgXS5pbmRleDtcblxuICAgICAgICAgIGZvciAoIHZhciBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YXIgYSA9IGluZGV4ICsgaW5kaWNlc1sgaSBdO1xuXG4gICAgICAgICAgICBwb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYSAqIDMgKTtcblxuICAgICAgICAgICAgdGVzdFBvaW50KCBwb3NpdGlvbiwgYSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB2YXIgcG9pbnRDb3VudCA9IHBvc2l0aW9ucy5sZW5ndGggLyAzO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHBvaW50Q291bnQ7IGkgKysgKSB7XG5cbiAgICAgICAgICBwb3NpdGlvbi5zZXQoXG4gICAgICAgICAgICBwb3NpdGlvbnNbIDMgKiBpIF0sXG4gICAgICAgICAgICBwb3NpdGlvbnNbIDMgKiBpICsgMSBdLFxuICAgICAgICAgICAgcG9zaXRpb25zWyAzICogaSArIDIgXVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB0ZXN0UG9pbnQoIHBvc2l0aW9uLCBpICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgdmVydGljZXMgPSB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgdGVzdFBvaW50KCB2ZXJ0aWNlc1sgaSBdLCBpICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG59KCkgKTtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICBpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlBvaW50Q2xvdWQoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKTtcblxuICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cbiAgcmV0dXJuIG9iamVjdDtcblxufTtcblxuVEhSRUUuUG9pbnRDbG91ZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgZ2VvbWV0cmllcyBjYWNoZVxuICBpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oKTtcbiAgfVxuXG4gIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCk7XG4gIH1cblxuICBkYXRhLm9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcbiAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBhcnRpY2xlU3lzdGVtID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgY29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW0gaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludENsb3VkLicgKTtcbiAgcmV0dXJuIG5ldyBUSFJFRS5Qb2ludENsb3VkKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MaW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5MaW5lID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG1vZGUgKSB7XG5cbiAgaWYgKCBtb2RlID09PSAxICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkxpbmU6IFRIUkVFLkxpbmVQaWVjZXMgbW9kZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuTGluZVNlZ21lbnRzIGluc3RlYWQuJyApO1xuXG4gIH1cblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xpbmUnO1xuXG4gIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgdGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbCA6IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmIH0gKTtcblxufTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkxpbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgdmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcbiAgdmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICB2YXIgcHJlY2lzaW9uID0gcmF5Y2FzdGVyLmxpbmVQcmVjaXNpb247XG4gICAgdmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxuXG4gICAgc3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XG4gICAgc3BoZXJlLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgaWYgKCByYXljYXN0ZXIucmF5LmlzSW50ZXJzZWN0aW9uU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIGludmVyc2VNYXRyaXguZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApO1xuICAgIHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XG5cbiAgICB2YXIgdlN0YXJ0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgdkVuZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGludGVyU2VnbWVudCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgdmFyIGludGVyUmF5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgc3RlcCA9IHRoaXMgaW5zdGFuY2VvZiBUSFJFRS5MaW5lU2VnbWVudHMgPyAyIDogMTtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZXMuaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IGF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cbiAgICAgICAgaWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgIG9mZnNldHMgPSBbIHsgc3RhcnQ6IDAsIGNvdW50OiBpbmRpY2VzLmxlbmd0aCwgaW5kZXg6IDAgfSBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgb2kgPSAwOyBvaSA8IG9mZnNldHMubGVuZ3RoOyBvaSArKykge1xuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gb2Zmc2V0c1sgb2kgXS5zdGFydDtcbiAgICAgICAgICB2YXIgY291bnQgPSBvZmZzZXRzWyBvaSBdLmNvdW50O1xuICAgICAgICAgIHZhciBpbmRleCA9IG9mZnNldHNbIG9pIF0uaW5kZXg7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudCAtIDE7IGkgKz0gc3RlcCApIHtcblxuICAgICAgICAgICAgdmFyIGEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcbiAgICAgICAgICAgIHZhciBiID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdO1xuXG4gICAgICAgICAgICB2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XG4gICAgICAgICAgICB2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCBiICogMyApO1xuXG4gICAgICAgICAgICB2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xuXG4gICAgICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAgIC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xuICAgICAgICAgICAgICAvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgb2Zmc2V0SW5kZXg6IG9pLFxuICAgICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgICB9ICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGggLyAzIC0gMTsgaSArPSBzdGVwICkge1xuXG4gICAgICAgICAgdlN0YXJ0LmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSApO1xuICAgICAgICAgIHZFbmQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIDMgKiBpICsgMyApO1xuXG4gICAgICAgICAgdmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2U3RhcnQsIHZFbmQsIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuICAgICAgICAgIGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcblxuICAgICAgICAgIHZhciBkaXN0YW5jZSA9IHJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcblxuICAgICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsXG4gICAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICAgICAgICAgIC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxuICAgICAgICAgICAgcG9pbnQ6IGludGVyU2VnbWVudC5jbG9uZSgpLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApLFxuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBmYWNlOiBudWxsLFxuICAgICAgICAgICAgZmFjZUluZGV4OiBudWxsLFxuICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICB9ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xuXG4gICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcbiAgICAgIHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuYlZlcnRpY2VzIC0gMTsgaSArPSBzdGVwICkge1xuXG4gICAgICAgIHZhciBkaXN0U3EgPSByYXkuZGlzdGFuY2VTcVRvU2VnbWVudCggdmVydGljZXNbIGkgXSwgdmVydGljZXNbIGkgKyAxIF0sIGludGVyUmF5LCBpbnRlclNlZ21lbnQgKTtcblxuICAgICAgICBpZiAoIGRpc3RTcSA+IHByZWNpc2lvblNxICkgY29udGludWU7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlclJheSApO1xuXG4gICAgICAgIGlmICggZGlzdGFuY2UgPCByYXljYXN0ZXIubmVhciB8fCBkaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcblxuICAgICAgICBpbnRlcnNlY3RzLnB1c2goIHtcblxuICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAvLyBXaGF0IGRvIHdlIHdhbnQ/IGludGVyc2VjdGlvbiBwb2ludCBvbiB0aGUgcmF5IG9yIG9uIHRoZSBzZWdtZW50Pz9cbiAgICAgICAgICAvLyBwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggZGlzdGFuY2UgKSxcbiAgICAgICAgICBwb2ludDogaW50ZXJTZWdtZW50LmNsb25lKCkuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmFjZTogbnVsbCxcbiAgICAgICAgICBmYWNlSW5kZXg6IG51bGwsXG4gICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgfSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxufSgpICk7XG5cblRIUkVFLkxpbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgaWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRVsgdGhpcy50eXBlIF0oIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKTtcblxuICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cbiAgcmV0dXJuIG9iamVjdDtcblxufTtcblxuVEhSRUUuTGluZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCBtZXRhICkge1xuXG4gIHZhciBkYXRhID0gVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XG5cbiAgLy8gb25seSBzZXJpYWxpemUgaWYgbm90IGluIG1ldGEgZ2VvbWV0cmllcyBjYWNoZVxuICBpZiAoIG1ldGEuZ2VvbWV0cmllc1sgdGhpcy5nZW9tZXRyeS51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID0gdGhpcy5nZW9tZXRyeS50b0pTT04oKTtcbiAgfVxuXG4gIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIG1hdGVyaWFscyBjYWNoZVxuICBpZiAoIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgIG1ldGEubWF0ZXJpYWxzWyB0aGlzLm1hdGVyaWFsLnV1aWQgXSA9IHRoaXMubWF0ZXJpYWwudG9KU09OKCk7XG4gIH1cblxuICBkYXRhLm9iamVjdC5nZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkudXVpZDtcbiAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIERFUFJFQ0FURURcblxuVEhSRUUuTGluZVN0cmlwID0gMDtcblRIUkVFLkxpbmVQaWVjZXMgPSAxO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xpbmVTZWdtZW50cy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTGluZVNlZ21lbnRzID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XG5cbiAgVEhSRUUuTGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICB0aGlzLnR5cGUgPSAnTGluZVNlZ21lbnRzJztcblxufTtcblxuVEhSRUUuTGluZVNlZ21lbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmUucHJvdG90eXBlICk7XG5USFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTGluZVNlZ21lbnRzO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL01lc2guanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXG4gKi9cblxuVEhSRUUuTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnTWVzaCc7XG5cbiAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xuXG4gIHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5NZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1lc2g7XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLnVwZGF0ZU1vcnBoVGFyZ2V0cyA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcblxuICAgIHRoaXMubW9ycGhUYXJnZXRCYXNlID0gLSAxO1xuICAgIHRoaXMubW9ycGhUYXJnZXRGb3JjZWRPcmRlciA9IFtdO1xuICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XG4gICAgdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcblxuICAgIGZvciAoIHZhciBtID0gMCwgbWwgPSB0aGlzLmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcblxuICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xuICAgICAgdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBtIF0ubmFtZSBdID0gbTtcblxuICAgIH1cblxuICB9XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgaWYgKCB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXTtcblxuICB9XG5cbiAgY29uc29sZS53YXJuKCAnVEhSRUUuTWVzaC5nZXRNb3JwaFRhcmdldEluZGV4QnlOYW1lOiBtb3JwaCB0YXJnZXQgJyArIG5hbWUgKyAnIGRvZXMgbm90IGV4aXN0LiBSZXR1cm5pbmcgMC4nICk7XG5cbiAgcmV0dXJuIDA7XG5cbn07XG5cblxuVEhSRUUuTWVzaC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgdmFyIHJheSA9IG5ldyBUSFJFRS5SYXkoKTtcbiAgdmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcblxuICB2YXIgdkEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdkIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgdkMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cbiAgICAvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcblxuICAgIHNwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApO1xuICAgIHNwaGVyZS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIGlmICggcmF5Y2FzdGVyLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkge1xuXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICAvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xuXG4gICAgaW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XG4gICAgcmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcblxuICAgIGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XG5cbiAgICAgIGlmICggcmF5LmlzSW50ZXJzZWN0aW9uQm94KCBnZW9tZXRyeS5ib3VuZGluZ0JveCApID09PSBmYWxzZSApIHtcblxuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgdmFyIG1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbDtcblxuICAgICAgaWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG5cbiAgICAgIHZhciBhLCBiLCBjO1xuXG4gICAgICBpZiAoIGF0dHJpYnV0ZXMuaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICB2YXIgaW5kaWNlcyA9IGF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBhdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5O1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cbiAgICAgICAgaWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICAgIG9mZnNldHMgPSBbIHsgc3RhcnQ6IDAsIGNvdW50OiBpbmRpY2VzLmxlbmd0aCwgaW5kZXg6IDAgfSBdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKCB2YXIgb2kgPSAwLCBvbCA9IG9mZnNldHMubGVuZ3RoOyBvaSA8IG9sOyArKyBvaSApIHtcblxuICAgICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbIG9pIF0uc3RhcnQ7XG4gICAgICAgICAgdmFyIGNvdW50ID0gb2Zmc2V0c1sgb2kgXS5jb3VudDtcbiAgICAgICAgICB2YXIgaW5kZXggPSBvZmZzZXRzWyBvaSBdLmluZGV4O1xuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgICAgYSA9IGluZGV4ICsgaW5kaWNlc1sgaSBdO1xuICAgICAgICAgICAgYiA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDEgXTtcbiAgICAgICAgICAgIGMgPSBpbmRleCArIGluZGljZXNbIGkgKyAyIF07XG5cbiAgICAgICAgICAgIHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xuICAgICAgICAgICAgdkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGIgKiAzICk7XG4gICAgICAgICAgICB2Qy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYyAqIDMgKTtcblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZDLCB2QiwgdkEsIHRydWUgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZBLCB2QiwgdkMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIGludGVyc2VjdGlvblBvaW50ID09PSBudWxsICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuXG4gICAgICAgICAgICBpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XG5cbiAgICAgICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgICAgcG9pbnQ6IGludGVyc2VjdGlvblBvaW50LFxuICAgICAgICAgICAgICBmYWNlOiBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIFRIUkVFLlRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICksXG4gICAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcbiAgICAgICAgICAgICAgb2JqZWN0OiB0aGlzXG5cbiAgICAgICAgICAgIH0gKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBqID0gMCwgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMywgaiArPSA5ICkge1xuXG4gICAgICAgICAgYSA9IGk7XG4gICAgICAgICAgYiA9IGkgKyAxO1xuICAgICAgICAgIGMgPSBpICsgMjtcblxuICAgICAgICAgIHZBLmZyb21BcnJheSggcG9zaXRpb25zLCBqICk7XG4gICAgICAgICAgdkIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGogKyAzICk7XG4gICAgICAgICAgdkMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGogKyA2ICk7XG5cbiAgICAgICAgICBpZiAoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICkge1xuXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHZDLCB2QiwgdkEsIHRydWUgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggdkEsIHZCLCB2QywgbWF0ZXJpYWwuc2lkZSAhPT0gVEhSRUUuRG91YmxlU2lkZSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb25Qb2ludCA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludCApO1xuXG4gICAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludCxcbiAgICAgICAgICAgIGZhY2U6IG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYywgVEhSRUUuVHJpYW5nbGUubm9ybWFsKCB2QSwgdkIsIHZDICkgKSxcbiAgICAgICAgICAgIGZhY2VJbmRleDogbnVsbCxcbiAgICAgICAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgICAgICAgfSApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgICAgdmFyIGlzRmFjZU1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWw7XG4gICAgICB2YXIgb2JqZWN0TWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyB0aGlzLm1hdGVyaWFsLm1hdGVyaWFscyA6IG51bGw7XG5cbiAgICAgIHZhciBhLCBiLCBjO1xuXG4gICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgICAgZm9yICggdmFyIGYgPSAwLCBmbCA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgICAgIHZhciBmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGYgXTtcblxuICAgICAgICB2YXIgbWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG9iamVjdE1hdGVyaWFsc1sgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiB0aGlzLm1hdGVyaWFsO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xuXG4gICAgICAgIGEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XG4gICAgICAgIGIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XG4gICAgICAgIGMgPSB2ZXJ0aWNlc1sgZmFjZS5jIF07XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XG5cbiAgICAgICAgICB2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzO1xuICAgICAgICAgIHZhciBtb3JwaEluZmx1ZW5jZXMgPSB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcblxuICAgICAgICAgIHZBLnNldCggMCwgMCwgMCApO1xuICAgICAgICAgIHZCLnNldCggMCwgMCwgMCApO1xuICAgICAgICAgIHZDLnNldCggMCwgMCwgMCApO1xuXG4gICAgICAgICAgZm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcblxuICAgICAgICAgICAgdmFyIGluZmx1ZW5jZSA9IG1vcnBoSW5mbHVlbmNlc1sgdCBdO1xuXG4gICAgICAgICAgICBpZiAoIGluZmx1ZW5jZSA9PT0gMCApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xuXG4gICAgICAgICAgICB2QS54ICs9ICggdGFyZ2V0c1sgZmFjZS5hIF0ueCAtIGEueCApICogaW5mbHVlbmNlO1xuICAgICAgICAgICAgdkEueSArPSAoIHRhcmdldHNbIGZhY2UuYSBdLnkgLSBhLnkgKSAqIGluZmx1ZW5jZTtcbiAgICAgICAgICAgIHZBLnogKz0gKCB0YXJnZXRzWyBmYWNlLmEgXS56IC0gYS56ICkgKiBpbmZsdWVuY2U7XG5cbiAgICAgICAgICAgIHZCLnggKz0gKCB0YXJnZXRzWyBmYWNlLmIgXS54IC0gYi54ICkgKiBpbmZsdWVuY2U7XG4gICAgICAgICAgICB2Qi55ICs9ICggdGFyZ2V0c1sgZmFjZS5iIF0ueSAtIGIueSApICogaW5mbHVlbmNlO1xuICAgICAgICAgICAgdkIueiArPSAoIHRhcmdldHNbIGZhY2UuYiBdLnogLSBiLnogKSAqIGluZmx1ZW5jZTtcblxuICAgICAgICAgICAgdkMueCArPSAoIHRhcmdldHNbIGZhY2UuYyBdLnggLSBjLnggKSAqIGluZmx1ZW5jZTtcbiAgICAgICAgICAgIHZDLnkgKz0gKCB0YXJnZXRzWyBmYWNlLmMgXS55IC0gYy55ICkgKiBpbmZsdWVuY2U7XG4gICAgICAgICAgICB2Qy56ICs9ICggdGFyZ2V0c1sgZmFjZS5jIF0ueiAtIGMueiApICogaW5mbHVlbmNlO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdkEuYWRkKCBhICk7XG4gICAgICAgICAgdkIuYWRkKCBiICk7XG4gICAgICAgICAgdkMuYWRkKCBjICk7XG5cbiAgICAgICAgICBhID0gdkE7XG4gICAgICAgICAgYiA9IHZCO1xuICAgICAgICAgIGMgPSB2QztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZSApIHtcblxuICAgICAgICAgIHZhciBpbnRlcnNlY3Rpb25Qb2ludCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggYywgYiwgYSwgdHJ1ZSApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIGEsIGIsIGMsIG1hdGVyaWFsLnNpZGUgIT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBpbnRlcnNlY3Rpb25Qb2ludCA9PT0gbnVsbCApIGNvbnRpbnVlO1xuXG4gICAgICAgIGludGVyc2VjdGlvblBvaW50LmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdGlvblBvaW50ICk7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIGNvbnRpbnVlO1xuXG4gICAgICAgIGludGVyc2VjdHMucHVzaCgge1xuXG4gICAgICAgICAgZGlzdGFuY2U6IGRpc3RhbmNlLFxuICAgICAgICAgIHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludCxcbiAgICAgICAgICBmYWNlOiBmYWNlLFxuICAgICAgICAgIGZhY2VJbmRleDogZixcbiAgICAgICAgICBvYmplY3Q6IHRoaXNcblxuICAgICAgICB9ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG59KCkgKTtcblxuVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcmVjdXJzaXZlICkge1xuXG4gIGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QsIHJlY3Vyc2l2ZSApO1xuXG4gIHJldHVybiBvYmplY3Q7XG5cbn07XG5cblRIUkVFLk1lc2gucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcblxuICB2YXIgZGF0YSA9IFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xuXG4gIC8vIG9ubHkgc2VyaWFsaXplIGlmIG5vdCBpbiBtZXRhIGdlb21ldHJpZXMgY2FjaGVcbiAgaWYgKCBtZXRhLmdlb21ldHJpZXNbIHRoaXMuZ2VvbWV0cnkudXVpZCBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgbWV0YS5nZW9tZXRyaWVzWyB0aGlzLmdlb21ldHJ5LnV1aWQgXSA9IHRoaXMuZ2VvbWV0cnkudG9KU09OKCBtZXRhICk7XG4gIH1cblxuICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBtYXRlcmlhbHMgY2FjaGVcbiAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTiggbWV0YSApO1xuICB9XG5cbiAgZGF0YS5vYmplY3QuZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5LnV1aWQ7XG4gIGRhdGEub2JqZWN0Lm1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbC51dWlkO1xuXG4gIHJldHVybiBkYXRhO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0JvbmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxuICovXG5cblRIUkVFLkJvbmUgPSBmdW5jdGlvbiAoIHNraW4gKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdCb25lJztcblxuICB0aGlzLnNraW4gPSBza2luO1xuXG59O1xuXG5USFJFRS5Cb25lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQm9uZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb25lO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL1NrZWxldG9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1pY2hhZWwgZ3VlcnJlcm8gLyBodHRwOi8vcmVhbGl0eW1lbHRkb3duLmNvbVxuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tlbGV0b24gPSBmdW5jdGlvbiAoIGJvbmVzLCBib25lSW52ZXJzZXMsIHVzZVZlcnRleFRleHR1cmUgKSB7XG5cbiAgdGhpcy51c2VWZXJ0ZXhUZXh0dXJlID0gdXNlVmVydGV4VGV4dHVyZSAhPT0gdW5kZWZpbmVkID8gdXNlVmVydGV4VGV4dHVyZSA6IHRydWU7XG5cbiAgdGhpcy5pZGVudGl0eU1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgLy8gY29weSB0aGUgYm9uZSBhcnJheVxuXG4gIGJvbmVzID0gYm9uZXMgfHwgW107XG5cbiAgdGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XG5cbiAgLy8gY3JlYXRlIGEgYm9uZSB0ZXh0dXJlIG9yIGFuIGFycmF5IG9mIGZsb2F0c1xuXG4gIGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgLy8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxuICAgIC8vICAgICAgUkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcbiAgICAvLyAgd2l0aCAgOHg4ICBwaXhlbCB0ZXh0dXJlIG1heCAgIDE2IGJvbmVzICAoOCAqIDggIC8gNClcbiAgICAvLyAgICAgICAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICgxNiAqIDE2IC8gNClcbiAgICAvLyAgICAgICAzMngzMiBwaXhlbCB0ZXh0dXJlIG1heCAgMjU2IGJvbmVzICgzMiAqIDMyIC8gNClcbiAgICAvLyAgICAgICA2NHg2NCBwaXhlbCB0ZXh0dXJlIG1heCAxMDI0IGJvbmVzICg2NCAqIDY0IC8gNClcblxuICAgIHZhciBzaXplO1xuXG4gICAgaWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA+IDI1NiApXG4gICAgICBzaXplID0gNjQ7XG4gICAgZWxzZSBpZiAoIHRoaXMuYm9uZXMubGVuZ3RoID4gNjQgKVxuICAgICAgc2l6ZSA9IDMyO1xuICAgIGVsc2UgaWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA+IDE2IClcbiAgICAgIHNpemUgPSAxNjtcbiAgICBlbHNlXG4gICAgICBzaXplID0gODtcblxuICAgIHRoaXMuYm9uZVRleHR1cmVXaWR0aCA9IHNpemU7XG4gICAgdGhpcy5ib25lVGV4dHVyZUhlaWdodCA9IHNpemU7XG5cbiAgICB0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXG4gICAgdGhpcy5ib25lVGV4dHVyZSA9IG5ldyBUSFJFRS5EYXRhVGV4dHVyZSggdGhpcy5ib25lTWF0cmljZXMsIHRoaXMuYm9uZVRleHR1cmVXaWR0aCwgdGhpcy5ib25lVGV4dHVyZUhlaWdodCwgVEhSRUUuUkdCQUZvcm1hdCwgVEhSRUUuRmxvYXRUeXBlICk7XG4gICAgdGhpcy5ib25lVGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgIHRoaXMuYm9uZVRleHR1cmUubWFnRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcbiAgICB0aGlzLmJvbmVUZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xuICAgIHRoaXMuYm9uZVRleHR1cmUuZmxpcFkgPSBmYWxzZTtcblxuICB9IGVsc2Uge1xuXG4gICAgdGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiAqIHRoaXMuYm9uZXMubGVuZ3RoICk7XG5cbiAgfVxuXG4gIC8vIHVzZSB0aGUgc3VwcGxpZWQgYm9uZSBpbnZlcnNlcyBvciBjYWxjdWxhdGUgdGhlIGludmVyc2VzXG5cbiAgaWYgKCBib25lSW52ZXJzZXMgPT09IHVuZGVmaW5lZCApIHtcblxuICAgIHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcblxuICB9IGVsc2Uge1xuXG4gICAgaWYgKCB0aGlzLmJvbmVzLmxlbmd0aCA9PT0gYm9uZUludmVyc2VzLmxlbmd0aCApIHtcblxuICAgICAgdGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uIGJvbkludmVyc2VzIGlzIHRoZSB3cm9uZyBsZW5ndGguJyApO1xuXG4gICAgICB0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG4gICAgICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuICAgICAgICB0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBuZXcgVEhSRUUuTWF0cml4NCgpICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbn07XG5cblRIUkVFLlNrZWxldG9uLnByb3RvdHlwZS5jYWxjdWxhdGVJbnZlcnNlcyA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xuXG4gIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgdmFyIGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgaWYgKCB0aGlzLmJvbmVzWyBiIF0gKSB7XG5cbiAgICAgIGludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Ta2VsZXRvbi5wcm90b3R5cGUucG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgYm9uZTtcblxuICAvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcblxuICBmb3IgKCB2YXIgYiA9IDAsIGJsID0gdGhpcy5ib25lcy5sZW5ndGg7IGIgPCBibDsgYiArKyApIHtcblxuICAgIGJvbmUgPSB0aGlzLmJvbmVzWyBiIF07XG5cbiAgICBpZiAoIGJvbmUgKSB7XG5cbiAgICAgIGJvbmUubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xuXG4gICAgfVxuXG4gIH1cblxuICAvLyBjb21wdXRlIHRoZSBsb2NhbCBtYXRyaWNlcywgcG9zaXRpb25zLCByb3RhdGlvbnMgYW5kIHNjYWxlc1xuXG4gIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgYm9uZSA9IHRoaXMuYm9uZXNbIGIgXTtcblxuICAgIGlmICggYm9uZSApIHtcblxuICAgICAgaWYgKCBib25lLnBhcmVudCApIHtcblxuICAgICAgICBib25lLm1hdHJpeC5nZXRJbnZlcnNlKCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgICAgICBib25lLm1hdHJpeC5tdWx0aXBseSggYm9uZS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcblxuICAgICAgfVxuXG4gICAgICBib25lLm1hdHJpeC5kZWNvbXBvc2UoIGJvbmUucG9zaXRpb24sIGJvbmUucXVhdGVybmlvbiwgYm9uZS5zY2FsZSApO1xuXG4gICAgfVxuXG4gIH1cblxufTtcblxuVEhSRUUuU2tlbGV0b24ucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBvZmZzZXRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcblxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xuXG4gICAgICAvLyBjb21wdXRlIHRoZSBvZmZzZXQgYmV0d2VlbiB0aGUgY3VycmVudCBhbmQgdGhlIG9yaWdpbmFsIHRyYW5zZm9ybVxuXG4gICAgICB2YXIgbWF0cml4ID0gdGhpcy5ib25lc1sgYiBdID8gdGhpcy5ib25lc1sgYiBdLm1hdHJpeFdvcmxkIDogdGhpcy5pZGVudGl0eU1hdHJpeDtcblxuICAgICAgb2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xuICAgICAgb2Zmc2V0TWF0cml4LmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB0aGlzLmJvbmVNYXRyaWNlcywgYiAqIDE2ICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIHRoaXMudXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgdGhpcy5ib25lVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgfTtcblxufSApKCk7XG5cblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9Ta2lubmVkTWVzaC5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tpbm5lZE1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdXNlVmVydGV4VGV4dHVyZSApIHtcblxuICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMudHlwZSA9ICdTa2lubmVkTWVzaCc7XG5cbiAgdGhpcy5iaW5kTW9kZSA9IFwiYXR0YWNoZWRcIjtcbiAgdGhpcy5iaW5kTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgdGhpcy5iaW5kTWF0cml4SW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG5cbiAgLy8gaW5pdCBib25lc1xuXG4gIC8vIFRPRE86IHJlbW92ZSBib25lIGNyZWF0aW9uIGFzIHRoZXJlIGlzIG5vIHJlYXNvbiAob3RoZXIgdGhhblxuICAvLyBjb252ZW5pZW5jZSkgZm9yIFRIUkVFLlNraW5uZWRNZXNoIHRvIGRvIHRoaXMuXG5cbiAgdmFyIGJvbmVzID0gW107XG5cbiAgaWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIHZhciBib25lLCBnYm9uZSwgcCwgcSwgcztcblxuICAgIGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgYiA8IGJsOyArKyBiICkge1xuXG4gICAgICBnYm9uZSA9IHRoaXMuZ2VvbWV0cnkuYm9uZXNbIGIgXTtcblxuICAgICAgcCA9IGdib25lLnBvcztcbiAgICAgIHEgPSBnYm9uZS5yb3RxO1xuICAgICAgcyA9IGdib25lLnNjbDtcblxuICAgICAgYm9uZSA9IG5ldyBUSFJFRS5Cb25lKCB0aGlzICk7XG4gICAgICBib25lcy5wdXNoKCBib25lICk7XG5cbiAgICAgIGJvbmUubmFtZSA9IGdib25lLm5hbWU7XG4gICAgICBib25lLnBvc2l0aW9uLnNldCggcFsgMCBdLCBwWyAxIF0sIHBbIDIgXSApO1xuICAgICAgYm9uZS5xdWF0ZXJuaW9uLnNldCggcVsgMCBdLCBxWyAxIF0sIHFbIDIgXSwgcVsgMyBdICk7XG5cbiAgICAgIGlmICggcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGJvbmUuc2NhbGUuc2V0KCBzWyAwIF0sIHNbIDEgXSwgc1sgMiBdICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYm9uZS5zY2FsZS5zZXQoIDEsIDEsIDEgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiIDwgYmw7ICsrIGIgKSB7XG5cbiAgICAgIGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xuXG4gICAgICBpZiAoIGdib25lLnBhcmVudCAhPT0gLSAxICkge1xuXG4gICAgICAgIGJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmVzWyBiIF0gKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0aGlzLmFkZCggYm9uZXNbIGIgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMubm9ybWFsaXplU2tpbldlaWdodHMoKTtcblxuICB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XG4gIHRoaXMuYmluZCggbmV3IFRIUkVFLlNrZWxldG9uKCBib25lcywgdW5kZWZpbmVkLCB1c2VWZXJ0ZXhUZXh0dXJlICkgKTtcblxufTtcblxuXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2tpbm5lZE1lc2g7XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24oIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xuXG4gIHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuICBpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcblxuICAgIHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xuXG4gIH1cblxuICB0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xuICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGJpbmRNYXRyaXggKTtcblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5za2VsZXRvbi5wb3NlKCk7XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5ub3JtYWxpemVTa2luV2VpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAoIHRoaXMuZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XG5cbiAgICAgIHZhciBzY2FsZSA9IDEuMCAvIHN3Lmxlbmd0aE1hbmhhdHRhbigpO1xuXG4gICAgICBpZiAoIHNjYWxlICE9PSBJbmZpbml0eSApIHtcblxuICAgICAgICBzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdy5zZXQoIDEgKTsgLy8gdGhpcyB3aWxsIGJlIG5vcm1hbGl6ZWQgYnkgdGhlIHNoYWRlciBhbnl3YXlcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICAvLyBza2lubmluZyB3ZWlnaHRzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCBmb3IgVEhSRUUuQnVmZmVyR2VvbWV0cnlcblxuICB9XG5cbn07XG5cblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uKCBmb3JjZSApIHtcblxuICBUSFJFRS5NZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cbiAgaWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImF0dGFjaGVkXCIgKSB7XG5cbiAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcblxuICB9IGVsc2UgaWYgKCB0aGlzLmJpbmRNb2RlID09PSBcImRldGFjaGVkXCIgKSB7XG5cbiAgICB0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYmluZE1hdHJpeCApO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Ta2lubmVkTWVzaCB1bnJlY2tvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICBpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgb2JqZWN0ID0gbmV3IFRIUkVFLlNraW5uZWRNZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLnVzZVZlcnRleFRleHR1cmUgKTtcblxuICB9XG5cbiAgVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cbiAgcmV0dXJuIG9iamVjdDtcblxufTtcblxuXG4vLyBGaWxlOnNyYy9vYmplY3RzL01vcnBoQW5pbU1lc2guanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1vcnBoQW5pbU1lc2ggPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMudHlwZSA9ICdNb3JwaEFuaW1NZXNoJztcblxuICAvLyBBUElcblxuICB0aGlzLmR1cmF0aW9uID0gMTAwMDsgLy8gbWlsbGlzZWNvbmRzXG4gIHRoaXMubWlycm9yZWRMb29wID0gZmFsc2U7XG4gIHRoaXMudGltZSA9IDA7XG5cbiAgLy8gaW50ZXJuYWxzXG5cbiAgdGhpcy5sYXN0S2V5ZnJhbWUgPSAwO1xuICB0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IDA7XG5cbiAgdGhpcy5kaXJlY3Rpb24gPSAxO1xuICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IGZhbHNlO1xuXG4gIHRoaXMuc2V0RnJhbWVSYW5nZSggMCwgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoIC0gMSApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLk1vcnBoQW5pbU1lc2g7XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEZyYW1lUmFuZ2UgPSBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XG5cbiAgdGhpcy5zdGFydEtleWZyYW1lID0gc3RhcnQ7XG4gIHRoaXMuZW5kS2V5ZnJhbWUgPSBlbmQ7XG5cbiAgdGhpcy5sZW5ndGggPSB0aGlzLmVuZEtleWZyYW1lIC0gdGhpcy5zdGFydEtleWZyYW1lICsgMTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uRm9yd2FyZCA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmRpcmVjdGlvbiA9IDE7XG4gIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldERpcmVjdGlvbkJhY2t3YXJkID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuZGlyZWN0aW9uID0gLSAxO1xuICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnBhcnNlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gIGlmICggISBnZW9tZXRyeS5hbmltYXRpb25zICkgZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IHt9O1xuXG4gIHZhciBmaXJzdEFuaW1hdGlvbiwgYW5pbWF0aW9ucyA9IGdlb21ldHJ5LmFuaW1hdGlvbnM7XG5cbiAgdmFyIHBhdHRlcm4gPSAvKFthLXpdKylfPyhcXGQrKS87XG5cbiAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIHZhciBtb3JwaCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdO1xuICAgIHZhciBwYXJ0cyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuICAgIGlmICggcGFydHMgJiYgcGFydHMubGVuZ3RoID4gMSApIHtcblxuICAgICAgdmFyIGxhYmVsID0gcGFydHNbIDEgXTtcblxuICAgICAgaWYgKCAhIGFuaW1hdGlvbnNbIGxhYmVsIF0gKSBhbmltYXRpb25zWyBsYWJlbCBdID0geyBzdGFydDogSW5maW5pdHksIGVuZDogLSBJbmZpbml0eSB9O1xuXG4gICAgICB2YXIgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1sgbGFiZWwgXTtcblxuICAgICAgaWYgKCBpIDwgYW5pbWF0aW9uLnN0YXJ0ICkgYW5pbWF0aW9uLnN0YXJ0ID0gaTtcbiAgICAgIGlmICggaSA+IGFuaW1hdGlvbi5lbmQgKSBhbmltYXRpb24uZW5kID0gaTtcblxuICAgICAgaWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBsYWJlbDtcblxuICAgIH1cblxuICB9XG5cbiAgZ2VvbWV0cnkuZmlyc3RBbmltYXRpb24gPSBmaXJzdEFuaW1hdGlvbjtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uTGFiZWwgPSBmdW5jdGlvbiAoIGxhYmVsLCBzdGFydCwgZW5kICkge1xuXG4gIGlmICggISB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnMgKSB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnMgPSB7fTtcblxuICB0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnNbIGxhYmVsIF0gPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUucGxheUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbGFiZWwsIGZwcyApIHtcblxuICB2YXIgYW5pbWF0aW9uID0gdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zWyBsYWJlbCBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgdGhpcy5zZXRGcmFtZVJhbmdlKCBhbmltYXRpb24uc3RhcnQsIGFuaW1hdGlvbi5lbmQgKTtcbiAgICB0aGlzLmR1cmF0aW9uID0gMTAwMCAqICggKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBmcHMgKTtcbiAgICB0aGlzLnRpbWUgPSAwO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5Nb3JwaEFuaW1NZXNoOiBhbmltYXRpb25bJyArIGxhYmVsICsgJ10gdW5kZWZpbmVkIGluIC5wbGF5QW5pbWF0aW9uKCknICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS51cGRhdGVBbmltYXRpb24gPSBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG4gIHZhciBmcmFtZVRpbWUgPSB0aGlzLmR1cmF0aW9uIC8gdGhpcy5sZW5ndGg7XG5cbiAgdGhpcy50aW1lICs9IHRoaXMuZGlyZWN0aW9uICogZGVsdGE7XG5cbiAgaWYgKCB0aGlzLm1pcnJvcmVkTG9vcCApIHtcblxuICAgIGlmICggdGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbiB8fCB0aGlzLnRpbWUgPCAwICkge1xuXG4gICAgICB0aGlzLmRpcmVjdGlvbiAqPSAtIDE7XG5cbiAgICAgIGlmICggdGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbiApIHtcblxuICAgICAgICB0aGlzLnRpbWUgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCB0aGlzLnRpbWUgPCAwICkge1xuXG4gICAgICAgIHRoaXMudGltZSA9IDA7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9IGVsc2Uge1xuXG4gICAgdGhpcy50aW1lID0gdGhpcy50aW1lICUgdGhpcy5kdXJhdGlvbjtcblxuICAgIGlmICggdGhpcy50aW1lIDwgMCApIHRoaXMudGltZSArPSB0aGlzLmR1cmF0aW9uO1xuXG4gIH1cblxuICB2YXIga2V5ZnJhbWUgPSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyBUSFJFRS5NYXRoLmNsYW1wKCBNYXRoLmZsb29yKCB0aGlzLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgdGhpcy5sZW5ndGggLSAxICk7XG5cbiAgaWYgKCBrZXlmcmFtZSAhPT0gdGhpcy5jdXJyZW50S2V5ZnJhbWUgKSB7XG5cbiAgICB0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5sYXN0S2V5ZnJhbWUgXSA9IDA7XG4gICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEtleWZyYW1lIF0gPSAxO1xuXG4gICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGtleWZyYW1lIF0gPSAwO1xuXG4gICAgdGhpcy5sYXN0S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcbiAgICB0aGlzLmN1cnJlbnRLZXlmcmFtZSA9IGtleWZyYW1lO1xuXG4gIH1cblxuICB2YXIgbWl4ID0gKCB0aGlzLnRpbWUgJSBmcmFtZVRpbWUgKSAvIGZyYW1lVGltZTtcblxuICBpZiAoIHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzICkge1xuXG4gICAgbWl4ID0gMSAtIG1peDtcblxuICB9XG5cbiAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIHRoaXMuY3VycmVudEtleWZyYW1lIF0gPSBtaXg7XG4gIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMSAtIG1peDtcblxufTtcblxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuaW50ZXJwb2xhdGVUYXJnZXRzID0gZnVuY3Rpb24gKCBhLCBiLCB0ICkge1xuXG4gIHZhciBpbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gaW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgaW5mbHVlbmNlc1sgaSBdID0gMDtcblxuICB9XG5cbiAgaWYgKCBhID4gLTEgKSBpbmZsdWVuY2VzWyBhIF0gPSAxIC0gdDtcbiAgaWYgKCBiID4gLTEgKSBpbmZsdWVuY2VzWyBiIF0gPSB0O1xuXG59O1xuXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuTW9ycGhBbmltTWVzaCggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xuXG4gIG9iamVjdC5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XG4gIG9iamVjdC5taXJyb3JlZExvb3AgPSB0aGlzLm1pcnJvcmVkTG9vcDtcbiAgb2JqZWN0LnRpbWUgPSB0aGlzLnRpbWU7XG5cbiAgb2JqZWN0Lmxhc3RLZXlmcmFtZSA9IHRoaXMubGFzdEtleWZyYW1lO1xuICBvYmplY3QuY3VycmVudEtleWZyYW1lID0gdGhpcy5jdXJyZW50S2V5ZnJhbWU7XG5cbiAgb2JqZWN0LmRpcmVjdGlvbiA9IHRoaXMuZGlyZWN0aW9uO1xuICBvYmplY3QuZGlyZWN0aW9uQmFja3dhcmRzID0gdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHM7XG5cbiAgVEhSRUUuTWVzaC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cbiAgcmV0dXJuIG9iamVjdDtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9MT0QuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuTE9EID0gZnVuY3Rpb24gKCkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLm9iamVjdHMgPSBbXTtcblxufTtcblxuXG5USFJFRS5MT0QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5MT0QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuTE9EO1xuXG5USFJFRS5MT0QucHJvdG90eXBlLmFkZExldmVsID0gZnVuY3Rpb24gKCBvYmplY3QsIGRpc3RhbmNlICkge1xuXG4gIGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcblxuICBkaXN0YW5jZSA9IE1hdGguYWJzKCBkaXN0YW5jZSApO1xuXG4gIGZvciAoIHZhciBsID0gMDsgbCA8IHRoaXMub2JqZWN0cy5sZW5ndGg7IGwgKysgKSB7XG5cbiAgICBpZiAoIGRpc3RhbmNlIDwgdGhpcy5vYmplY3RzWyBsIF0uZGlzdGFuY2UgKSB7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLm9iamVjdHMuc3BsaWNlKCBsLCAwLCB7IGRpc3RhbmNlOiBkaXN0YW5jZSwgb2JqZWN0OiBvYmplY3QgfSApO1xuICB0aGlzLmFkZCggb2JqZWN0ICk7XG5cbn07XG5cblRIUkVFLkxPRC5wcm90b3R5cGUuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UgPSBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xuXG4gIGZvciAoIHZhciBpID0gMSwgbCA9IHRoaXMub2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgaWYgKCBkaXN0YW5jZSA8IHRoaXMub2JqZWN0c1sgaSBdLmRpc3RhbmNlICkge1xuXG4gICAgICBicmVhaztcblxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIHRoaXMub2JqZWN0c1sgaSAtIDEgXS5vYmplY3Q7XG5cbn07XG5cblRIUkVFLkxPRC5wcm90b3R5cGUucmF5Y2FzdCA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG4gICAgbWF0cml4UG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xuXG4gICAgdGhpcy5nZXRPYmplY3RGb3JEaXN0YW5jZSggZGlzdGFuY2UgKS5yYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuICB9O1xuXG59KCkgKTtcblxuVEhSRUUuTE9ELnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBjYW1lcmEgKSB7XG5cbiAgICBpZiAoIHRoaXMub2JqZWN0cy5sZW5ndGggPiAxICkge1xuXG4gICAgICB2MS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xuICAgICAgdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XG5cbiAgICAgIHZhciBkaXN0YW5jZSA9IHYxLmRpc3RhbmNlVG8oIHYyICk7XG5cbiAgICAgIHRoaXMub2JqZWN0c1sgMCBdLm9iamVjdC52aXNpYmxlID0gdHJ1ZTtcblxuICAgICAgZm9yICggdmFyIGkgPSAxLCBsID0gdGhpcy5vYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgaWYgKCBkaXN0YW5jZSA+PSB0aGlzLm9iamVjdHNbIGkgXS5kaXN0YW5jZSApIHtcblxuICAgICAgICAgIHRoaXMub2JqZWN0c1sgaSAtIDEgXS5vYmplY3QudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMub2JqZWN0c1sgaSAgICAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBmb3IgKCA7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHRoaXMub2JqZWN0c1sgaSBdLm9iamVjdC52aXNpYmxlID0gZmFsc2U7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG59KCk7XG5cblRIUkVFLkxPRC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICBpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLkxPRCgpO1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLm9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcbiAgICB2YXIgeCA9IHRoaXMub2JqZWN0c1sgaSBdLm9iamVjdC5jbG9uZSgpO1xuICAgIHgudmlzaWJsZSA9IGkgPT09IDA7XG4gICAgb2JqZWN0LmFkZExldmVsKCB4LCB0aGlzLm9iamVjdHNbIGkgXS5kaXN0YW5jZSApO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcblxufTtcblxuLy8gRmlsZTpzcmMvb2JqZWN0cy9TcHJpdGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5TcHJpdGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWyAwLCAxLCAyLCAgMCwgMiwgMyBdICk7XG4gIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFsgLSAwLjUsIC0gMC41LCAwLCAgIDAuNSwgLSAwLjUsIDAsICAgMC41LCAwLjUsIDAsICAgLSAwLjUsIDAuNSwgMCBdICk7XG4gIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbIDAsIDAsICAgMSwgMCwgICAxLCAxLCAgIDAsIDEgXSApO1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdpbmRleCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcbiAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gICAgdGhpcy50eXBlID0gJ1Nwcml0ZSc7XG5cbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XG4gICAgdGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoKTtcblxuICB9O1xuXG59ICkoKTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwcml0ZTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS5yYXljYXN0ID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XG5cbiAgICBtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcblxuICAgIHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkuZGlzdGFuY2VUb1BvaW50KCBtYXRyaXhQb3NpdGlvbiApO1xuXG4gICAgaWYgKCBkaXN0YW5jZSA+IHRoaXMuc2NhbGUueCApIHtcblxuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgaW50ZXJzZWN0cy5wdXNoKCB7XG5cbiAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgIHBvaW50OiB0aGlzLnBvc2l0aW9uLFxuICAgICAgZmFjZTogbnVsbCxcbiAgICAgIG9iamVjdDogdGhpc1xuXG4gICAgfSApO1xuXG4gIH07XG5cbn0oKSApO1xuXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgaWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5TcHJpdGUoIHRoaXMubWF0ZXJpYWwgKTtcblxuICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XG5cbiAgcmV0dXJuIG9iamVjdDtcblxufTtcblxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIG1ldGEgKSB7XG5cbiAgdmFyIGRhdGEgPSBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcblxuICAvLyBvbmx5IHNlcmlhbGl6ZSBpZiBub3QgaW4gbWV0YSBtYXRlcmlhbHMgY2FjaGVcbiAgaWYgKCBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICBtZXRhLm1hdGVyaWFsc1sgdGhpcy5tYXRlcmlhbC51dWlkIF0gPSB0aGlzLm1hdGVyaWFsLnRvSlNPTigpO1xuICB9XG5cbiAgZGF0YS5vYmplY3QubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsLnV1aWQ7XG5cbiAgcmV0dXJuIGRhdGE7XG5cbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cblRIUkVFLlBhcnRpY2xlID0gVEhSRUUuU3ByaXRlO1xuXG4vLyBGaWxlOnNyYy9vYmplY3RzL0xlbnNGbGFyZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkxlbnNGbGFyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy5sZW5zRmxhcmVzID0gW107XG5cbiAgdGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCB0ZXh0dXJlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICB0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxlbnNGbGFyZTtcblxuXG4vKlxuICogQWRkOiBhZGRzIGFub3RoZXIgZmxhcmVcbiAqL1xuXG5USFJFRS5MZW5zRmxhcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciwgb3BhY2l0eSApIHtcblxuICBpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAtIDE7XG4gIGlmICggZGlzdGFuY2UgPT09IHVuZGVmaW5lZCApIGRpc3RhbmNlID0gMDtcbiAgaWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcbiAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XG4gIGlmICggYmxlbmRpbmcgPT09IHVuZGVmaW5lZCApIGJsZW5kaW5nID0gVEhSRUUuTm9ybWFsQmxlbmRpbmc7XG5cbiAgZGlzdGFuY2UgPSBNYXRoLm1pbiggZGlzdGFuY2UsIE1hdGgubWF4KCAwLCBkaXN0YW5jZSApICk7XG5cbiAgdGhpcy5sZW5zRmxhcmVzLnB1c2goIHtcbiAgICB0ZXh0dXJlOiB0ZXh0dXJlLCAgICAgICAvLyBUSFJFRS5UZXh0dXJlXG4gICAgc2l6ZTogc2l6ZSwgICAgICAgICAvLyBzaXplIGluIHBpeGVscyAoLTEgPSB1c2UgdGV4dHVyZS53aWR0aClcbiAgICBkaXN0YW5jZTogZGlzdGFuY2UsICAgICAvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXG4gICAgeDogMCwgeTogMCwgejogMCwgICAgIC8vIHNjcmVlbiBwb3NpdGlvbiAoLTEgPT4gMSkgeiA9IDAgaXMgb250b3AgeiA9IDEgaXMgYmFja1xuICAgIHNjYWxlOiAxLCAgICAgICAgICAgLy8gc2NhbGVcbiAgICByb3RhdGlvbjogMSwgICAgICAgIC8vIHJvdGF0aW9uXG4gICAgb3BhY2l0eTogb3BhY2l0eSwgICAgIC8vIG9wYWNpdHlcbiAgICBjb2xvcjogY29sb3IsICAgICAgIC8vIGNvbG9yXG4gICAgYmxlbmRpbmc6IGJsZW5kaW5nICAgICAgLy8gYmxlbmRpbmdcbiAgfSApO1xuXG59O1xuXG4vKlxuICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXG4gKiBTZXQgbXlMZW5zRmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgdG8gYWx0ZXIgdGhlIGZsYXJlcyBpbiB5b3VyIHByb2plY3Qgc3BlY2lmaWMgd2F5LlxuICovXG5cblRIUkVFLkxlbnNGbGFyZS5wcm90b3R5cGUudXBkYXRlTGVuc0ZsYXJlcyA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xuICB2YXIgZmxhcmU7XG4gIHZhciB2ZWNYID0gLSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKiAyO1xuICB2YXIgdmVjWSA9IC0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICogMjtcblxuICBmb3IgKCBmID0gMDsgZiA8IGZsOyBmICsrICkge1xuXG4gICAgZmxhcmUgPSB0aGlzLmxlbnNGbGFyZXNbIGYgXTtcblxuICAgIGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XG4gICAgZmxhcmUueSA9IHRoaXMucG9zaXRpb25TY3JlZW4ueSArIHZlY1kgKiBmbGFyZS5kaXN0YW5jZTtcblxuICAgIGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xuICAgIGZsYXJlLnJvdGF0aW9uICs9ICggZmxhcmUud2FudGVkUm90YXRpb24gLSBmbGFyZS5yb3RhdGlvbiApICogMC4yNTtcblxuICB9XG5cbn07XG5cblxuLy8gRmlsZTpzcmMvc2NlbmVzL1NjZW5lLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5TY2VuZSA9IGZ1bmN0aW9uICgpIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1NjZW5lJztcblxuICB0aGlzLmZvZyA9IG51bGw7XG4gIHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XG5cbiAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcblxufTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TY2VuZTtcblxuVEhSRUUuU2NlbmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XG5cbiAgaWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuXG4gIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcblxuICBpZiAoIHRoaXMuZm9nICE9PSBudWxsICkgb2JqZWN0LmZvZyA9IHRoaXMuZm9nLmNsb25lKCk7XG4gIGlmICggdGhpcy5vdmVycmlkZU1hdGVyaWFsICE9PSBudWxsICkgb2JqZWN0Lm92ZXJyaWRlTWF0ZXJpYWwgPSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwuY2xvbmUoKTtcblxuICBvYmplY3QuYXV0b1VwZGF0ZSA9IHRoaXMuYXV0b1VwZGF0ZTtcbiAgb2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSB0aGlzLm1hdHJpeEF1dG9VcGRhdGU7XG5cbiAgcmV0dXJuIG9iamVjdDtcblxufTtcblxuLy8gRmlsZTpzcmMvc2NlbmVzL0ZvZy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLkZvZyA9IGZ1bmN0aW9uICggY29sb3IsIG5lYXIsIGZhciApIHtcblxuICB0aGlzLm5hbWUgPSAnJztcblxuICB0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBjb2xvciApO1xuXG4gIHRoaXMubmVhciA9ICggbmVhciAhPT0gdW5kZWZpbmVkICkgPyBuZWFyIDogMTtcbiAgdGhpcy5mYXIgPSAoIGZhciAhPT0gdW5kZWZpbmVkICkgPyBmYXIgOiAxMDAwO1xuXG59O1xuXG5USFJFRS5Gb2cucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuXG4gIHJldHVybiBuZXcgVEhSRUUuRm9nKCB0aGlzLmNvbG9yLmdldEhleCgpLCB0aGlzLm5lYXIsIHRoaXMuZmFyICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3NjZW5lcy9Gb2dFeHAyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuRm9nRXhwMiA9IGZ1bmN0aW9uICggY29sb3IsIGRlbnNpdHkgKSB7XG5cbiAgdGhpcy5uYW1lID0gJyc7XG5cbiAgdGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggY29sb3IgKTtcbiAgdGhpcy5kZW5zaXR5ID0gKCBkZW5zaXR5ICE9PSB1bmRlZmluZWQgKSA/IGRlbnNpdHkgOiAwLjAwMDI1O1xuXG59O1xuXG5USFJFRS5Gb2dFeHAyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblxuICByZXR1cm4gbmV3IFRIUkVFLkZvZ0V4cDIoIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMuZGVuc2l0eSApO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay5qc1xuXG5USFJFRS5TaGFkZXJDaHVuayA9IHt9O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYW1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcblxcbiAgZGlmZnVzZUNvbG9yLmEgKj0gdGV4dHVyZTJEKCBhbHBoYU1hcCwgdlV2ICkuZztcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYWxwaGFtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnYWxwaGFtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxuXFxuIHVuaWZvcm0gc2FtcGxlcjJEIGFscGhhTWFwO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hbHBoYXRlc3RfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FscGhhdGVzdF9mcmFnbWVudCddID0gXCIjaWZkZWYgQUxQSEFURVNUXFxuXFxuICBpZiAoIGRpZmZ1c2VDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvYW9tYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2FvbWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXG4gIHRvdGFsQW1iaWVudExpZ2h0ICo9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9hb21hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdhb21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfQU9NQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgYW9NYXA7XFxuICB1bmlmb3JtIGZsb2F0IGFvTWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9idW1wbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2J1bXBtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0JVTVBNQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgYnVtcE1hcDtcXG4gIHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcblxcbiAgLy8gRGVyaXZhdGl2ZSBtYXBzIC0gYnVtcCBtYXBwaW5nIHVucGFyYW1ldHJpemVkIHN1cmZhY2VzIGJ5IE1vcnRlbiBNaWtrZWxzZW5cXG4gLy8gaHR0cDovL21taWtrZWxzZW4zZC5ibG9nc3BvdC5zay8yMDExLzA3L2Rlcml2YXRpdmUtbWFwcy5odG1sXFxuXFxuIC8vIEV2YWx1YXRlIHRoZSBkZXJpdmF0aXZlIG9mIHRoZSBoZWlnaHQgdy5yLnQuIHNjcmVlbi1zcGFjZSB1c2luZyBmb3J3YXJkIGRpZmZlcmVuY2luZyAobGlzdGluZyAyKVxcblxcbiB2ZWMyIGRIZHh5X2Z3ZCgpIHtcXG5cXG4gICAgdmVjMiBkU1RkeCA9IGRGZHgoIHZVdiApO1xcbiAgIHZlYzIgZFNUZHkgPSBkRmR5KCB2VXYgKTtcXG5cXG4gICBmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XFxuICAgIGZsb2F0IGRCeCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHggKS54IC0gSGxsO1xcbiAgICBmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXG5cXG4gICAgcmV0dXJuIHZlYzIoIGRCeCwgZEJ5ICk7XFxuXFxuICB9XFxuXFxuIHZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XFxuXFxuICAgIHZlYzMgdlNpZ21hWCA9IGRGZHgoIHN1cmZfcG9zICk7XFxuICAgIHZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XFxuICAgIHZlYzMgdk4gPSBzdXJmX25vcm07ICAgIC8vIG5vcm1hbGl6ZWRcXG5cXG4gICB2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxuICAgdmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcblxcbiAgIGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxuXFxuICAgIHZlYzMgdkdyYWQgPSBzaWduKCBmRGV0ICkgKiAoIGRIZHh5LnggKiBSMSArIGRIZHh5LnkgKiBSMiApO1xcbiAgICByZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XFxuXFxuICB9XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuICBkaWZmdXNlQ29sb3IucmdiICo9IHZDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29sb3JfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuIHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb2xvcl9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0NPTE9SXFxuXFxuIHZhcnlpbmcgdmVjMyB2Q29sb3I7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2NvbG9yX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnY29sb3JfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfQ09MT1JcXG5cXG4gIHZDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCBjb2xvci54eXogKTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvY29tbW9uLmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdjb21tb24nXSA9IFwiI2RlZmluZSBQSSAzLjE0MTU5XFxuI2RlZmluZSBQSTIgNi4yODMxOFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSTIgMC4xNTkxNTQ5NFxcbiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVxcbiNkZWZpbmUgRVBTSUxPTiAxZS02XFxuXFxuI2RlZmluZSBzYXR1cmF0ZShhKSBjbGFtcCggYSwgMC4wLCAxLjAgKVxcbiNkZWZpbmUgd2hpdGVDb21wbGltZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxuXFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgbm9ybWFsLCBpbiBtYXQ0IG1hdHJpeCApIHtcXG5cXG4gIHJldHVybiBub3JtYWxpemUoICggbWF0cml4ICogdmVjNCggbm9ybWFsLCAwLjAgKSApLnh5eiApO1xcblxcbn1cXG5cXG4vLyBodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0dMU0xfUHJvZ3JhbW1pbmcvQXBwbHlpbmdfTWF0cml4X1RyYW5zZm9ybWF0aW9uc1xcbnZlYzMgaW52ZXJzZVRyYW5zZm9ybURpcmVjdGlvbiggaW4gdmVjMyBub3JtYWwsIGluIG1hdDQgbWF0cml4ICkge1xcblxcbiAgcmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBub3JtYWwsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxuXFxufVxcblxcbnZlYzMgcHJvamVjdE9uUGxhbmUoaW4gdmVjMyBwb2ludCwgaW4gdmVjMyBwb2ludE9uUGxhbmUsIGluIHZlYzMgcGxhbmVOb3JtYWwgKSB7XFxuXFxuICBmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50IC0gcG9pbnRPblBsYW5lICk7XFxuXFxuICByZXR1cm4gLSBkaXN0YW5jZSAqIHBsYW5lTm9ybWFsICsgcG9pbnQ7XFxuXFxufVxcblxcbmZsb2F0IHNpZGVPZlBsYW5lKCBpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXG5cXG4gIHJldHVybiBzaWduKCBkb3QoIHBvaW50IC0gcG9pbnRPblBsYW5lLCBwbGFuZU5vcm1hbCApICk7XFxuXFxufVxcblxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcblxcbiByZXR1cm4gbGluZURpcmVjdGlvbiAqICggZG90KCBwbGFuZU5vcm1hbCwgcG9pbnRPblBsYW5lIC0gcG9pbnRPbkxpbmUgKSAvIGRvdCggcGxhbmVOb3JtYWwsIGxpbmVEaXJlY3Rpb24gKSApICsgcG9pbnRPbkxpbmU7XFxuXFxufVxcblxcbmZsb2F0IGNhbGNMaWdodEF0dGVudWF0aW9uKCBmbG9hdCBsaWdodERpc3RhbmNlLCBmbG9hdCBjdXRvZmZEaXN0YW5jZSwgZmxvYXQgZGVjYXlFeHBvbmVudCApIHtcXG5cXG4gaWYgKCBkZWNheUV4cG9uZW50ID4gMC4wICkge1xcblxcbiAgICByZXR1cm4gcG93KCBzYXR1cmF0ZSggLWxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSArIDEuMCApLCBkZWNheUV4cG9uZW50ICk7XFxuXFxuIH1cXG5cXG4gcmV0dXJuIDEuMDtcXG5cXG59XFxuXFxudmVjMyBGX1NjaGxpY2soIGluIHZlYzMgc3BlY3VsYXJDb2xvciwgaW4gZmxvYXQgZG90TEggKSB7XFxuXFxuIHJldHVybiAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIHBvdyggMS4wIC0gZG90TEgsIDUuMCApICsgc3BlY3VsYXJDb2xvcjtcXG5cXG59XFxuXFxuZmxvYXQgR19CbGlublBob25nX0ltcGxpY2l0KCAvKiBpbiBmbG9hdCBkb3ROTCwgaW4gZmxvYXQgZG90TlYgKi8gKSB7XFxuXFxuIC8vIGdlb21ldHJ5IHRlcm0gaXMgKG7ii4VsKShu4ouFdikgLyA0KG7ii4VsKShu4ouFdilcXG5cXG4gIHJldHVybiAwLjI1O1xcblxcbn1cXG5cXG5mbG9hdCBEX0JsaW5uUGhvbmcoIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gZmxvYXQgZG90TkggKSB7XFxuXFxuIC8vIGZhY3RvciBvZiAxL1BJIGluIGRpc3RyaWJ1dGlvbiB0ZXJtIG9taXR0ZWRcXG5cXG4gIHJldHVybiAoIHNoaW5pbmVzcyAqIDAuNSArIDEuMCApICogcG93KCBkb3ROSCwgc2hpbmluZXNzICk7XFxuXFxufVxcblxcbnZlYzMgQlJERl9CbGlublBob25nKCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGluIGZsb2F0IHNoaW5pbmVzcywgaW4gdmVjMyBub3JtYWwsIGluIHZlYzMgbGlnaHREaXIsIGluIHZlYzMgdmlld0RpciApIHtcXG5cXG4gIHZlYzMgaGFsZkRpciA9IG5vcm1hbGl6ZSggbGlnaHREaXIgKyB2aWV3RGlyICk7XFxuXFxuIC8vZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG4gIC8vZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIHZpZXdEaXIgKSApO1xcbiBmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIG5vcm1hbCwgaGFsZkRpciApICk7XFxuIGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggbGlnaHREaXIsIGhhbGZEaXIgKSApO1xcblxcbiB2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxuXFxuIGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoIC8qIGRvdE5MLCBkb3ROViAqLyApO1xcblxcbiAgZmxvYXQgRCA9IERfQmxpbm5QaG9uZyggc2hpbmluZXNzLCBkb3ROSCApO1xcblxcbiByZXR1cm4gRiAqIEcgKiBEO1xcblxcbn1cXG5cXG52ZWMzIGlucHV0VG9MaW5lYXIoIGluIHZlYzMgYSApIHtcXG5cXG4gI2lmZGVmIEdBTU1BX0lOUFVUXFxuXFxuICAgIHJldHVybiBwb3coIGEsIHZlYzMoIGZsb2F0KCBHQU1NQV9GQUNUT1IgKSApICk7XFxuXFxuICNlbHNlXFxuXFxuICAgcmV0dXJuIGE7XFxuXFxuICNlbmRpZlxcblxcbn1cXG5cXG52ZWMzIGxpbmVhclRvT3V0cHV0KCBpbiB2ZWMzIGEgKSB7XFxuXFxuICNpZmRlZiBHQU1NQV9PVVRQVVRcXG5cXG4gICByZXR1cm4gcG93KCBhLCB2ZWMzKCAxLjAgLyBmbG9hdCggR0FNTUFfRkFDVE9SICkgKSApO1xcblxcbiAjZWxzZVxcblxcbiAgIHJldHVybiBhO1xcblxcbiAjZW5kaWZcXG5cXG59XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2RlZmF1bHRfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdkZWZhdWx0X3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHNraW5uZWQ7XFxuXFxuI2VsaWYgZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApXFxuXFxuIHZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1xcblxcbiNlbHNlXFxuXFxuICB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxuXFxuI2VuZGlmXFxuXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZGVmYXVsdG5vcm1hbF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2RlZmF1bHRub3JtYWxfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gdmVjMyBvYmplY3ROb3JtYWwgPSBza2lubmVkTm9ybWFsLnh5ejtcXG5cXG4jZWxpZiBkZWZpbmVkKCBVU0VfTU9SUEhOT1JNQUxTIClcXG5cXG4gdmVjMyBvYmplY3ROb3JtYWwgPSBtb3JwaGVkTm9ybWFsO1xcblxcbiNlbHNlXFxuXFxuIHZlYzMgb2JqZWN0Tm9ybWFsID0gbm9ybWFsO1xcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBGTElQX1NJREVEXFxuXFxuICBvYmplY3ROb3JtYWwgPSAtb2JqZWN0Tm9ybWFsO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiBvYmplY3ROb3JtYWw7XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRU5WTUFQXFxuXFxuICAjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcblxcbiAgICB2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxuXFxuICAgLy8gVHJhbnNmb3JtaW5nIE5vcm1hbCBWZWN0b3JzIHdpdGggdGhlIEludmVyc2UgVHJhbnNmb3JtYXRpb25cXG4gICAgdmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcblxcbiAgICNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuICAgICB2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXG4gICAjZWxzZVxcblxcbiAgICAgdmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXG5cXG4gICAgI2VuZGlmXFxuXFxuICAjZWxzZVxcblxcbiAgIHZlYzMgcmVmbGVjdFZlYyA9IHZSZWZsZWN0O1xcblxcbiAjZW5kaWZcXG5cXG4gICNpZmRlZiBET1VCTEVfU0lERURcXG4gICBmbG9hdCBmbGlwTm9ybWFsID0gKCBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKSAqIDIuMCAtIDEuMCApO1xcbiAjZWxzZVxcbiAgIGZsb2F0IGZsaXBOb3JtYWwgPSAxLjA7XFxuICNlbmRpZlxcblxcbiAgI2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXG4gICB2ZWM0IGVudkNvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgZmxpcE5vcm1hbCAqIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xcblxcbiAjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXG4gICAgdmVjMiBzYW1wbGVVVjtcXG4gICAgc2FtcGxlVVYueSA9IHNhdHVyYXRlKCBmbGlwTm9ybWFsICogcmVmbGVjdFZlYy55ICogMC41ICsgMC41ICk7XFxuICAgc2FtcGxlVVYueCA9IGF0YW4oIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnosIGZsaXBOb3JtYWwgKiByZWZsZWN0VmVjLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcbiAgIHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYgKTtcXG5cXG4gICNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX1NQSEVSRSApXFxuICAgdmVjMyByZWZsZWN0VmlldyA9IGZsaXBOb3JtYWwgKiBub3JtYWxpemUoKHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSkueHl6ICsgdmVjMygwLjAsMC4wLDEuMCkpO1xcbiAgICB2ZWM0IGVudkNvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41ICk7XFxuICAjZW5kaWZcXG5cXG4gIGVudkNvbG9yLnh5eiA9IGlucHV0VG9MaW5lYXIoIGVudkNvbG9yLnh5eiApO1xcblxcbiAjaWZkZWYgRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZXFxuXFxuICAgb3V0Z29pbmdMaWdodCA9IG1peCggb3V0Z29pbmdMaWdodCwgb3V0Z29pbmdMaWdodCAqIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcbiAgI2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX01JWCApXFxuXFxuICAgIG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcblxcbiAgI2VsaWYgZGVmaW5lZCggRU5WTUFQX0JMRU5ESU5HX0FERCApXFxuXFxuICAgIG91dGdvaW5nTGlnaHQgKz0gZW52Q29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcXG5cXG4gICNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnZW52bWFwX3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9FTlZNQVBcXG5cXG4gdW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxuICNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxuICAgdW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XFxuICNlbHNlXFxuICAgdW5pZm9ybSBzYW1wbGVyMkQgZW52TWFwO1xcbiAjZW5kaWZcXG4gIHVuaWZvcm0gZmxvYXQgZmxpcEVudk1hcDtcXG5cXG4gI2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXG5cXG4gICAgdW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFxuICAjZWxzZVxcblxcbiAgIHZhcnlpbmcgdmVjMyB2UmVmbGVjdDtcXG5cXG4gICNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9lbnZtYXBfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF9wYXJzX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXG5cXG4gdmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcblxcbiAgdW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2Vudm1hcF92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2Vudm1hcF92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgJiYgISBkZWZpbmVkKCBQSE9ORyApXFxuXFxuICB2ZWMzIHdvcmxkTm9ybWFsID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBvYmplY3ROb3JtYWwsIG1vZGVsTWF0cml4ICk7XFxuXFxuIHZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHdvcmxkUG9zaXRpb24ueHl6IC0gY2FtZXJhUG9zaXRpb24gKTtcXG5cXG4gICNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxuXFxuICAgdlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXG5cXG4gICNlbHNlXFxuXFxuICAgdlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcblxcbiAjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdmb2dfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9GT0dcXG5cXG4gICNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuICAgIGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XFxuXFxuICNlbHNlXFxuXFxuICAgZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1xcblxcbiAgI2VuZGlmXFxuXFxuICAjaWZkZWYgRk9HX0VYUDJcXG5cXG4gICBmbG9hdCBmb2dGYWN0b3IgPSB3aGl0ZUNvbXBsaW1lbnQoIGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApICk7XFxuXFxuICAjZWxzZVxcblxcbiAgIGZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTtcXG5cXG4gI2VuZGlmXFxuICBcXG4gIG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvZm9nX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2ZvZ19wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfRk9HXFxuXFxuIHVuaWZvcm0gdmVjMyBmb2dDb2xvcjtcXG5cXG4gICNpZmRlZiBGT0dfRVhQMlxcblxcbiAgIHVuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTtcXG5cXG4gI2Vsc2VcXG5cXG4gICB1bmlmb3JtIGZsb2F0IGZvZ05lYXI7XFxuICAgIHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcbiAjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTElHSFRNQVBcXG5cXG4gIHRvdGFsQW1iaWVudExpZ2h0ICs9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbGlnaHRtYXBfcGFyc19mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX0xJR0hUTUFQXFxuXFxuIHVuaWZvcm0gc2FtcGxlcjJEIGxpZ2h0TWFwO1xcbiB1bmlmb3JtIGZsb2F0IGxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXgnXSA9IFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG4gdW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgTUFYX0RJUl9MSUdIVFMgXTtcXG4gdW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcXG5cXG4gIHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuICB1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1xcbiB1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG4gdW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRDb2xvclsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuICB1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREaXN0YW5jZVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHBvaW50TGlnaHREZWNheVsgTUFYX1BPSU5UX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuIHVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XFxuICB1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0QW5nbGVDb3NbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBzcG90TGlnaHREZWNheVsgTUFYX1NQT1RfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19sYW1iZXJ0X3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGlnaHRzX2xhbWJlcnRfdmVydGV4J10gPSBcInZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcbiAgdkxpZ2h0QmFjayA9IHZlYzMoIDAuMCApO1xcblxcbiNlbmRpZlxcblxcbnZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcbiAgZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcXG5cXG4gICB2ZWMzIGxpZ2h0Q29sb3IgPSBwb2ludExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICB2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XFxuICAgdmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1xcbiAgICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuICAgLy8gYXR0ZW51YXRpb25cXG5cXG4gICAgZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdLCBwb2ludExpZ2h0RGVjYXlbIGkgXSApO1xcblxcbiAgIC8vIGRpZmZ1c2VcXG5cXG4gICAgZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcbiAgIHZMaWdodEZyb250ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuICAgI2lmZGVmIERPVUJMRV9TSURFRFxcblxcbiAgICAgdkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuICAgICNlbmRpZlxcblxcbiAgfVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgIHZlYzMgbGlnaHRDb2xvciA9IHNwb3RMaWdodENvbG9yWyBpIF07XFxuXFxuICAgIHZlYzMgbGlnaHRQb3NpdGlvbiA9IHNwb3RMaWdodFBvc2l0aW9uWyBpIF07XFxuICAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGxpZ2h0UG9zaXRpb24sIDEuMCApO1xcbiAgIHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcXG4gICAgdmVjMyBsaWdodERpciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1xcblxcbiAgIGZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIGxpZ2h0UG9zaXRpb24gLSB3b3JsZFBvc2l0aW9uLnh5eiApICk7XFxuXFxuICAgIGlmICggc3BvdEVmZmVjdCA+IHNwb3RMaWdodEFuZ2xlQ29zWyBpIF0gKSB7XFxuXFxuICAgICAgc3BvdEVmZmVjdCA9IHNhdHVyYXRlKCBwb3coIHNhdHVyYXRlKCBzcG90RWZmZWN0ICksIHNwb3RMaWdodEV4cG9uZW50WyBpIF0gKSApO1xcblxcbiAgICAgLy8gYXR0ZW51YXRpb25cXG5cXG4gICAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSwgc3BvdExpZ2h0RGVjYXlbIGkgXSApO1xcblxcbiAgICAgYXR0ZW51YXRpb24gKj0gc3BvdEVmZmVjdDtcXG5cXG4gICAgICAvLyBkaWZmdXNlXFxuXFxuICAgICAgZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsaWdodERpciApO1xcblxcbiAgICAgdkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogc2F0dXJhdGUoIGRvdFByb2R1Y3QgKTtcXG5cXG4gICAgICNpZmRlZiBET1VCTEVfU0lERURcXG5cXG4gICAgICAgdkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBzYXR1cmF0ZSggLSBkb3RQcm9kdWN0ICk7XFxuXFxuICAgICAgI2VuZGlmXFxuXFxuICAgIH1cXG5cXG4gfVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcXG5cXG4gZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgdmVjMyBsaWdodENvbG9yID0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF07XFxuXFxuICAgdmVjMyBsaWdodERpciA9IHRyYW5zZm9ybURpcmVjdGlvbiggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCB2aWV3TWF0cml4ICk7XFxuXFxuICAgLy8gZGlmZnVzZVxcblxcbiAgICBmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuICAgdkxpZ2h0RnJvbnQgKz0gbGlnaHRDb2xvciAqIHNhdHVyYXRlKCBkb3RQcm9kdWN0ICk7XFxuXFxuICAgI2lmZGVmIERPVUJMRV9TSURFRFxcblxcbiAgICAgdkxpZ2h0QmFjayArPSBsaWdodENvbG9yICogc2F0dXJhdGUoIC0gZG90UHJvZHVjdCApO1xcblxcbiAgICAjZW5kaWZcXG5cXG4gIH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcbiAgZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1xcblxcbiAgICB2ZWMzIGxpZ2h0RGlyID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIGkgXSwgdmlld01hdHJpeCApO1xcblxcbiAgICAvLyBkaWZmdXNlXFxuXFxuICAgIGZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbGlnaHREaXIgKTtcXG5cXG4gICBmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XFxuXFxuICAgdkxpZ2h0RnJvbnQgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcblxcbiAgICNpZmRlZiBET1VCTEVfU0lERURcXG5cXG4gICAgIGZsb2F0IGhlbWlEaWZmdXNlV2VpZ2h0QmFjayA9IC0gMC41ICogZG90UHJvZHVjdCArIDAuNTtcXG5cXG4gICAgIHZMaWdodEJhY2sgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgKTtcXG5cXG4gICAgI2VuZGlmXFxuXFxuICB9XFxuXFxuI2VuZGlmXFxuXFxudkxpZ2h0RnJvbnQgKz0gYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcblxcbiB2TGlnaHRCYWNrICs9IGFtYmllbnRMaWdodENvbG9yO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19mcmFnbWVudCddID0gXCIjaWZuZGVmIEZMQVRfU0hBREVEXFxuXFxuICB2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggdk5vcm1hbCApO1xcblxcbiAjaWZkZWYgRE9VQkxFX1NJREVEXFxuXFxuICAgbm9ybWFsID0gbm9ybWFsICogKCAtMS4wICsgMi4wICogZmxvYXQoIGdsX0Zyb250RmFjaW5nICkgKTtcXG5cXG4gI2VuZGlmXFxuXFxuI2Vsc2VcXG5cXG4gdmVjMyBmZHggPSBkRmR4KCB2Vmlld1Bvc2l0aW9uICk7XFxuIHZlYzMgZmR5ID0gZEZkeSggdlZpZXdQb3NpdGlvbiApO1xcbiB2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXG5cXG4jZW5kaWZcXG5cXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcbiBub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCApO1xcblxcbiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcXG5cXG4gbm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcXG5cXG4jZW5kaWZcXG5cXG52ZWMzIHZpZXdEaXIgPSBub3JtYWxpemUoIHZWaWV3UG9zaXRpb24gKTtcXG5cXG52ZWMzIHRvdGFsRGlmZnVzZUxpZ2h0ID0gdmVjMyggMC4wICk7XFxudmVjMyB0b3RhbFNwZWN1bGFyTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXG5cXG4jaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcXG5cXG4gIGZvciAoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgdmVjMyBsaWdodENvbG9yID0gcG9pbnRMaWdodENvbG9yWyBpIF07XFxuXFxuICAgdmVjMyBsaWdodFBvc2l0aW9uID0gcG9pbnRMaWdodFBvc2l0aW9uWyBpIF07XFxuICAgdmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggbGlnaHRQb3NpdGlvbiwgMS4wICk7XFxuICAgdmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1xcbiAgIHZlYzMgbGlnaHREaXIgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXG5cXG4gICAvLyBhdHRlbnVhdGlvblxcblxcbiAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IGNhbGNMaWdodEF0dGVudWF0aW9uKCBsZW5ndGgoIGxWZWN0b3IgKSwgcG9pbnRMaWdodERpc3RhbmNlWyBpIF0sIHBvaW50TGlnaHREZWNheVsgaSBdICk7XFxuXFxuICAgLy8gZGlmZnVzZVxcblxcbiAgICBmbG9hdCBjb3NpbmVUZXJtID0gc2F0dXJhdGUoIGRvdCggbm9ybWFsLCBsaWdodERpciApICk7XFxuXFxuICAgdG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG4gICAvLyBzcGVjdWxhclxcblxcbiAgIHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcbiAgICB0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogYXR0ZW51YXRpb24gKiBjb3NpbmVUZXJtO1xcblxcblxcbiAgfVxcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXFxuXFxuICBmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgIHZlYzMgbGlnaHRDb2xvciA9IHNwb3RMaWdodENvbG9yWyBpIF07XFxuXFxuICAgIHZlYzMgbGlnaHRQb3NpdGlvbiA9IHNwb3RMaWdodFBvc2l0aW9uWyBpIF07XFxuICAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGxpZ2h0UG9zaXRpb24sIDEuMCApO1xcbiAgIHZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcXG4gICB2ZWMzIGxpZ2h0RGlyID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxuXFxuICAgZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIG5vcm1hbGl6ZSggbGlnaHRQb3NpdGlvbiAtIHZXb3JsZFBvc2l0aW9uICkgKTtcXG5cXG4gICBpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1xcblxcbiAgICAgIHNwb3RFZmZlY3QgPSBzYXR1cmF0ZSggcG93KCBzYXR1cmF0ZSggc3BvdEVmZmVjdCApLCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICkgKTtcXG5cXG4gICAgIC8vIGF0dGVudWF0aW9uXFxuXFxuICAgICAgZmxvYXQgYXR0ZW51YXRpb24gPSBjYWxjTGlnaHRBdHRlbnVhdGlvbiggbGVuZ3RoKCBsVmVjdG9yICksIHNwb3RMaWdodERpc3RhbmNlWyBpIF0sIHNwb3RMaWdodERlY2F5WyBpIF0gKTtcXG5cXG4gICAgIGF0dGVudWF0aW9uICo9IHNwb3RFZmZlY3Q7XFxuXFxuICAgICAgLy8gZGlmZnVzZVxcblxcbiAgICAgIGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG4gICAgIHRvdGFsRGlmZnVzZUxpZ2h0ICs9IGxpZ2h0Q29sb3IgKiBhdHRlbnVhdGlvbiAqIGNvc2luZVRlcm07XFxuXFxuICAgICAvLyBzcGVjdWxhclxcblxcbiAgICAgdmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuICAgICAgdG90YWxTcGVjdWxhckxpZ2h0ICs9IGJyZGYgKiBzcGVjdWxhclN0cmVuZ3RoICogbGlnaHRDb2xvciAqIGF0dGVudWF0aW9uICogY29zaW5lVGVybTtcXG5cXG4gICAgfVxcblxcbiB9XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcbiBmb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1xcblxcbiAgICB2ZWMzIGxpZ2h0Q29sb3IgPSBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXTtcXG5cXG4gICB2ZWMzIGxpZ2h0RGlyID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF0sIHZpZXdNYXRyaXggKTtcXG5cXG4gICAvLyBkaWZmdXNlXFxuXFxuICAgIGZsb2F0IGNvc2luZVRlcm0gPSBzYXR1cmF0ZSggZG90KCBub3JtYWwsIGxpZ2h0RGlyICkgKTtcXG5cXG4gICB0b3RhbERpZmZ1c2VMaWdodCArPSBsaWdodENvbG9yICogY29zaW5lVGVybTtcXG5cXG4gICAvLyBzcGVjdWxhclxcblxcbiAgIHZlYzMgYnJkZiA9IEJSREZfQmxpbm5QaG9uZyggc3BlY3VsYXIsIHNoaW5pbmVzcywgbm9ybWFsLCBsaWdodERpciwgdmlld0RpciApO1xcblxcbiAgICB0b3RhbFNwZWN1bGFyTGlnaHQgKz0gYnJkZiAqIHNwZWN1bGFyU3RyZW5ndGggKiBsaWdodENvbG9yICogY29zaW5lVGVybTtcXG5cXG4gIH1cXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcbiAgZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfSEVNSV9MSUdIVFM7IGkgKysgKSB7XFxuXFxuICAgdmVjMyBsaWdodERpciA9IHRyYW5zZm9ybURpcmVjdGlvbiggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIHZpZXdNYXRyaXggKTtcXG5cXG4gICAgLy8gZGlmZnVzZVxcblxcbiAgICBmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyICk7XFxuXFxuICAgZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1xcblxcbiAgIHZlYzMgbGlnaHRDb2xvciA9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcXG5cXG4gICAgdG90YWxEaWZmdXNlTGlnaHQgKz0gbGlnaHRDb2xvcjtcXG5cXG4gICAgLy8gc3BlY3VsYXIgKHNreSB0ZXJtIG9ubHkpXFxuXFxuICAgdmVjMyBicmRmID0gQlJERl9CbGlublBob25nKCBzcGVjdWxhciwgc2hpbmluZXNzLCBub3JtYWwsIGxpZ2h0RGlyLCB2aWV3RGlyICk7XFxuXFxuICAgIHRvdGFsU3BlY3VsYXJMaWdodCArPSBicmRmICogc3BlY3VsYXJTdHJlbmd0aCAqIGxpZ2h0Q29sb3IgKiBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1xcblxcbiAgfVxcblxcbiNlbmRpZlxcblxcbiNpZmRlZiBNRVRBTFxcblxcbiBvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiAoIHRvdGFsRGlmZnVzZUxpZ2h0ICsgdG90YWxBbWJpZW50TGlnaHQgKSAqIHNwZWN1bGFyICsgdG90YWxTcGVjdWxhckxpZ2h0ICsgZW1pc3NpdmU7XFxuXFxuI2Vsc2VcXG5cXG4gIG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqICggdG90YWxEaWZmdXNlTGlnaHQgKyB0b3RhbEFtYmllbnRMaWdodCApICsgdG90YWxTcGVjdWxhckxpZ2h0ICsgZW1pc3NpdmU7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudCddID0gXCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XFxuXFxuI2lmIE1BWF9ESVJfTElHSFRTID4gMFxcblxcbiB1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1xcbiB1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0hFTUlfTElHSFRTID4gMFxcblxcbiAgdW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XFxuIHVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHREaXJlY3Rpb25bIE1BWF9IRU1JX0xJR0hUUyBdO1xcblxcbiNlbmRpZlxcblxcbiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFxcblxcbiB1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuIHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERlY2F5WyBNQVhfUE9JTlRfTElHSFRTIF07XFxuXFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXG4gdW5pZm9ybSB2ZWMzIHNwb3RMaWdodENvbG9yWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gIHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcXG4gdW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XFxuIHVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RGlzdGFuY2VbIE1BWF9TUE9UX0xJR0hUUyBdO1xcbiB1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERlY2F5WyBNQVhfU1BPVF9MSUdIVFMgXTtcXG5cXG4jZW5kaWZcXG5cXG4jaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcbiAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcblxcbiNpZm5kZWYgRkxBVF9TSEFERURcXG5cXG4gIHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ2xpZ2h0c19waG9uZ19wYXJzX3ZlcnRleCddID0gXCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9FTlZNQVAgKVxcblxcbiAgdmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9saWdodHNfcGhvbmdfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsaWdodHNfcGhvbmdfdmVydGV4J10gPSBcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX0VOVk1BUCApXFxuXFxuIHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xpbmVhcl90b19nYW1tYV9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50J10gPSBcIlxcbiAgb3V0Z29pbmdMaWdodCA9IGxpbmVhclRvT3V0cHV0KCBvdXRnb2luZ0xpZ2h0ICk7XFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9mcmFnbWVudCddID0gXCIjaWYgZGVmaW5lZChVU0VfTE9HREVQVEhCVUYpICYmIGRlZmluZWQoVVNFX0xPR0RFUFRIQlVGX0VYVClcXG5cXG4gIGdsX0ZyYWdEZXB0aEVYVCA9IGxvZzIodkZyYWdEZXB0aCkgKiBsb2dEZXB0aEJ1ZkZDICogMC41O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9sb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG4gdW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcblxcbiAgI2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXG5cXG4gICAgI2V4dGVuc2lvbiBHTF9FWFRfZnJhZ19kZXB0aCA6IGVuYWJsZVxcbiAgIHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG4gI2VuZGlmXFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX0xPR0RFUFRIQlVGXFxuXFxuICNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXFxuXFxuICAgIHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXG5cXG4gI2VuZGlmXFxuXFxuICB1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL2xvZ2RlcHRoYnVmX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnbG9nZGVwdGhidWZfdmVydGV4J10gPSBcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXG5cXG4gIGdsX1Bvc2l0aW9uLnogPSBsb2cyKG1heCggRVBTSUxPTiwgZ2xfUG9zaXRpb24udyArIDEuMCApKSAqIGxvZ0RlcHRoQnVmRkM7XFxuXFxuICAjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcblxcbiAgICB2RnJhZ0RlcHRoID0gMS4wICsgZ2xfUG9zaXRpb24udztcXG5cXG4jZWxzZVxcblxcbiAgICBnbF9Qb3NpdGlvbi56ID0gKGdsX1Bvc2l0aW9uLnogLSAxLjApICogZ2xfUG9zaXRpb24udztcXG5cXG4gICNlbmRpZlxcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9tYXBfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcbiAgdmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcblxcbiAgdGV4ZWxDb2xvci54eXogPSBpbnB1dFRvTGluZWFyKCB0ZXhlbENvbG9yLnh5eiApO1xcblxcbiBkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfTUFQXFxuXFxuIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbWFwX3BhcnRpY2xlX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfZnJhZ21lbnQnXSA9IFwiI2lmZGVmIFVTRV9NQVBcXG5cXG4gZGlmZnVzZUNvbG9yICo9IHRleHR1cmUyRCggbWFwLCB2ZWMyKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSApICogb2Zmc2V0UmVwZWF0Lnp3ICsgb2Zmc2V0UmVwZWF0Lnh5ICk7XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX01BUFxcblxcbiAgdW5pZm9ybSB2ZWM0IG9mZnNldFJlcGVhdDtcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGhub3JtYWxfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaG5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG4gdmVjMyBtb3JwaGVkTm9ybWFsID0gdmVjMyggMC4wICk7XFxuXFxuIG1vcnBoZWROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcbiAgbW9ycGhlZE5vcm1hbCArPSAoIG1vcnBoTm9ybWFsMSAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAxIF07XFxuICBtb3JwaGVkTm9ybWFsICs9ICggbW9ycGhOb3JtYWwyIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG4gIG1vcnBoZWROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcblxcbiAgbW9ycGhlZE5vcm1hbCArPSBub3JtYWw7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL21vcnBodGFyZ2V0X3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcbiAgI2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXFxuXFxuICB1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgOCBdO1xcblxcbiAjZWxzZVxcblxcbiB1bmlmb3JtIGZsb2F0IG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNCBdO1xcblxcbiAjZW5kaWZcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvbW9ycGh0YXJnZXRfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdtb3JwaHRhcmdldF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXG5cXG4gdmVjMyBtb3JwaGVkID0gdmVjMyggMC4wICk7XFxuIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxuICBtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcbiAgbW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXG4gIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxuXFxuICAjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG4gIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XFxuICBtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ1IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNSBdO1xcbiAgbW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDYgXTtcXG4gIG1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XFxuXFxuICAjZW5kaWZcXG5cXG4gIG1vcnBoZWQgKz0gcG9zaXRpb247XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL25vcm1hbG1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdub3JtYWxtYXBfcGFyc19mcmFnbWVudCddID0gXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcblxcbiB1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxuICB1bmlmb3JtIHZlYzIgbm9ybWFsU2NhbGU7XFxuXFxuIC8vIFBlci1QaXhlbCBUYW5nZW50IFNwYWNlIE5vcm1hbCBNYXBwaW5nXFxuIC8vIGh0dHA6Ly9oYWNrc29mbGlmZS5ibG9nc3BvdC5jaC8yMDA5LzExL3Blci1waXhlbC10YW5nZW50LXNwYWNlLW5vcm1hbC1tYXBwaW5nLmh0bWxcXG5cXG4gdmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcXG5cXG4gICAgdmVjMyBxMCA9IGRGZHgoIGV5ZV9wb3MueHl6ICk7XFxuICAgIHZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1xcbiAgICB2ZWMyIHN0MCA9IGRGZHgoIHZVdi5zdCApO1xcbiAgICB2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcblxcbiAgICB2ZWMzIFMgPSBub3JtYWxpemUoIHEwICogc3QxLnQgLSBxMSAqIHN0MC50ICk7XFxuICAgIHZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XFxuICAgdmVjMyBOID0gbm9ybWFsaXplKCBzdXJmX25vcm0gKTtcXG5cXG4gICAgdmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXG4gICAgbWFwTi54eSA9IG5vcm1hbFNjYWxlICogbWFwTi54eTtcXG4gICAgbWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XFxuICAgcmV0dXJuIG5vcm1hbGl6ZSggdHNuICogbWFwTiApO1xcblxcbiB9XFxuXFxuI2VuZGlmXFxuXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NoYWRvd21hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuICAjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuICAgIHZlYzMgZnJ1c3R1bUNvbG9yc1szXTtcXG4gICAgZnJ1c3R1bUNvbG9yc1swXSA9IHZlYzMoIDEuMCwgMC41LCAwLjAgKTtcXG4gICBmcnVzdHVtQ29sb3JzWzFdID0gdmVjMyggMC4wLCAxLjAsIDAuOCApO1xcbiAgIGZydXN0dW1Db2xvcnNbMl0gPSB2ZWMzKCAwLjAsIDAuNSwgMS4wICk7XFxuXFxuICNlbmRpZlxcblxcbiAgI2lmZGVmIFNIQURPV01BUF9DQVNDQURFXFxuXFxuICAgIGludCBpbkZydXN0dW1Db3VudCA9IDA7XFxuXFxuICNlbmRpZlxcblxcbiAgZmxvYXQgZkRlcHRoO1xcbiB2ZWMzIHNoYWRvd0NvbG9yID0gdmVjMyggMS4wICk7XFxuXFxuIGZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XFxuXFxuICAgdmVjMyBzaGFkb3dDb29yZCA9IHZTaGFkb3dDb29yZFsgaSBdLnh5eiAvIHZTaGFkb3dDb29yZFsgaSBdLnc7XFxuXFxuICAgICAgIC8vIGlmICggc29tZXRoaW5nICYmIHNvbWV0aGluZyApIGJyZWFrcyBBVEkgT3BlbkdMIHNoYWRlciBjb21waWxlclxcbiAgICAgICAgLy8gaWYgKCBhbGwoIHNvbWV0aGluZywgc29tZXRoaW5nICkgKSB1c2luZyB0aGlzIGluc3RlYWRcXG5cXG4gICAgYnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcbiAgICBib29sIGluRnJ1c3R1bSA9IGFsbCggaW5GcnVzdHVtVmVjICk7XFxuXFxuICAgICAgIC8vIGRvbid0IHNoYWRvdyBwaXhlbHMgb3V0c2lkZSBvZiBsaWdodCBmcnVzdHVtXFxuICAgICAgIC8vIHVzZSBqdXN0IGZpcnN0IGZydXN0dW0gKGZvciBjYXNjYWRlcylcXG4gICAgICAgIC8vIGRvbid0IHNoYWRvdyBwaXhlbHMgYmVoaW5kIGZhciBwbGFuZSBvZiBsaWdodCBmcnVzdHVtXFxuXFxuICAgICNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVxcblxcbiAgICAgIGluRnJ1c3R1bUNvdW50ICs9IGludCggaW5GcnVzdHVtICk7XFxuICAgICBidmVjMyBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMzKCBpbkZydXN0dW0sIGluRnJ1c3R1bUNvdW50ID09IDEsIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxuXFxuICAgI2Vsc2VcXG5cXG4gICAgIGJ2ZWMyIGZydXN0dW1UZXN0VmVjID0gYnZlYzIoIGluRnJ1c3R1bSwgc2hhZG93Q29vcmQueiA8PSAxLjAgKTtcXG5cXG4gICAgI2VuZGlmXFxuXFxuICAgIGJvb2wgZnJ1c3R1bVRlc3QgPSBhbGwoIGZydXN0dW1UZXN0VmVjICk7XFxuXFxuICAgaWYgKCBmcnVzdHVtVGVzdCApIHtcXG5cXG4gICAgICBzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXNbIGkgXTtcXG5cXG4gICAgICNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcblxcbiAgICAgICAgICAgLy8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcXG4gICAgICAgICAgIC8vICg5IHBpeGVsIGtlcm5lbClcXG4gICAgICAgICAgIC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cXG5cXG4gICAgICAgIGZsb2F0IHNoYWRvdyA9IDAuMDtcXG5cXG4gICAvKlxcbiAgICAgICAgICAgIC8vIG5lc3RlZCBsb29wcyBicmVha3Mgc2hhZGVyIGNvbXBpbGVyIC8gdmFsaWRhdG9yIG9uIHNvbWUgQVRJIGNhcmRzIHdoZW4gdXNpbmcgT3BlbkdMXFxuICAgICAgICAgICAgLy8gbXVzdCBlbnJvbGwgbG9vcCBtYW51YWxseVxcblxcbiAgICAgICAgZm9yICggZmxvYXQgeSA9IC0xLjI1OyB5IDw9IDEuMjU7IHkgKz0gMS4yNSApXFxuICAgICAgICAgZm9yICggZmxvYXQgeCA9IC0xLjI1OyB4IDw9IDEuMjU7IHggKz0gMS4yNSApIHtcXG5cXG4gICAgICAgICAgIHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKTtcXG5cXG4gICAgICAgICAgICAgICAgLy8gZG9lc24ndCBzZWVtIHRvIHByb2R1Y2UgYW55IG5vdGljZWFibGUgdmlzdWFsIGRpZmZlcmVuY2UgY29tcGFyZWQgdG8gc2ltcGxlIHRleHR1cmUyRCBsb29rdXBcXG4gICAgICAgICAgICAgICAvL3ZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEUHJvaiggc2hhZG93TWFwWyBpIF0sIHZlYzQoIHZTaGFkb3dDb29yZFsgaSBdLncgKiAoIHZlYzIoIHggKiB4UGl4ZWxPZmZzZXQsIHkgKiB5UGl4ZWxPZmZzZXQgKSArIHNoYWRvd0Nvb3JkLnh5ICksIDAuMDUsIHZTaGFkb3dDb29yZFsgaSBdLncgKSApO1xcblxcbiAgICAgICAgICAgZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblxcbiAgICAgICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXFxuICAgICAgICAgICAgIHNoYWRvdyArPSAxLjA7XFxuXFxuICAgICAgICB9XFxuXFxuICAgICAgIHNoYWRvdyAvPSA5LjA7XFxuXFxuICAgICovXFxuXFxuICAgICAgICBjb25zdCBmbG9hdCBzaGFkb3dEZWx0YSA9IDEuMCAvIDkuMDtcXG5cXG4gICAgICAgIGZsb2F0IHhQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS54O1xcbiAgICAgICAgZmxvYXQgeVBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLnk7XFxuXFxuICAgICAgICBmbG9hdCBkeDAgPSAtMS4yNSAqIHhQaXhlbE9mZnNldDtcXG4gICAgICAgZmxvYXQgZHkwID0gLTEuMjUgKiB5UGl4ZWxPZmZzZXQ7XFxuICAgICAgIGZsb2F0IGR4MSA9IDEuMjUgKiB4UGl4ZWxPZmZzZXQ7XFxuICAgICAgICBmbG9hdCBkeTEgPSAxLjI1ICogeVBpeGVsT2Zmc2V0O1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XFxuICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICkgKSApO1xcbiAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcXG4gICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSApICk7XFxuICAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcXG4gICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSApICk7XFxuICAgICAgIGlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcXG5cXG4gICAgICAgIGZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkxICkgKSApO1xcbiAgICAgICBpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XFxuXFxuICAgICAgICBmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcXG4gICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1xcblxcbiAgICAgICAgc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XFxuXFxuICAgICAjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxuXFxuICAgICAgICAgICAgLy8gUGVyY2VudGFnZS1jbG9zZSBmaWx0ZXJpbmdcXG4gICAgICAgICAgIC8vICg5IHBpeGVsIGtlcm5lbClcXG4gICAgICAgICAgIC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cXG5cXG4gICAgICAgIGZsb2F0IHNoYWRvdyA9IDAuMDtcXG5cXG4gICAgICAgZmxvYXQgeFBpeGVsT2Zmc2V0ID0gMS4wIC8gc2hhZG93TWFwU2l6ZVsgaSBdLng7XFxuICAgICAgICBmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcXG5cXG4gICAgICAgIGZsb2F0IGR4MCA9IC0xLjAgKiB4UGl4ZWxPZmZzZXQ7XFxuICAgICAgICBmbG9hdCBkeTAgPSAtMS4wICogeVBpeGVsT2Zmc2V0O1xcbiAgICAgICAgZmxvYXQgZHgxID0gMS4wICogeFBpeGVsT2Zmc2V0O1xcbiAgICAgICBmbG9hdCBkeTEgPSAxLjAgKiB5UGl4ZWxPZmZzZXQ7XFxuXFxuICAgICAgIG1hdDMgc2hhZG93S2VybmVsO1xcbiAgICAgICAgbWF0MyBkZXB0aEtlcm5lbDtcXG5cXG4gICAgICAgZGVwdGhLZXJuZWxbMF1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MCApICkgKTtcXG4gICAgICAgIGRlcHRoS2VybmVsWzBdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSApICk7XFxuICAgICAgICBkZXB0aEtlcm5lbFswXVsyXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1xcbiAgICAgICAgZGVwdGhLZXJuZWxbMV1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcXG4gICAgICAgIGRlcHRoS2VybmVsWzFdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcXG4gICAgICAgZGVwdGhLZXJuZWxbMV1bMl0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApICkgKTtcXG4gICAgICAgIGRlcHRoS2VybmVsWzJdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTAgKSApICk7XFxuICAgICAgICBkZXB0aEtlcm5lbFsyXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1xcbiAgICAgICAgZGVwdGhLZXJuZWxbMl1bMl0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MSApICkgKTtcXG5cXG4gICAgICAgIHZlYzMgc2hhZG93WiA9IHZlYzMoIHNoYWRvd0Nvb3JkLnogKTtcXG4gICAgICAgc2hhZG93S2VybmVsWzBdID0gdmVjMyhsZXNzVGhhbihkZXB0aEtlcm5lbFswXSwgc2hhZG93WiApKTtcXG4gICAgICAgc2hhZG93S2VybmVsWzBdICo9IHZlYzMoMC4yNSk7XFxuXFxuICAgICAgICBzaGFkb3dLZXJuZWxbMV0gPSB2ZWMzKGxlc3NUaGFuKGRlcHRoS2VybmVsWzFdLCBzaGFkb3daICkpO1xcbiAgICAgICBzaGFkb3dLZXJuZWxbMV0gKj0gdmVjMygwLjI1KTtcXG5cXG4gICAgICAgIHNoYWRvd0tlcm5lbFsyXSA9IHZlYzMobGVzc1RoYW4oZGVwdGhLZXJuZWxbMl0sIHNoYWRvd1ogKSk7XFxuICAgICAgIHNoYWRvd0tlcm5lbFsyXSAqPSB2ZWMzKDAuMjUpO1xcblxcbiAgICAgICAgdmVjMiBmcmFjdGlvbmFsQ29vcmQgPSAxLjAgLSBmcmFjdCggc2hhZG93Q29vcmQueHkgKiBzaGFkb3dNYXBTaXplW2ldLnh5ICk7XFxuXFxuICAgICAgIHNoYWRvd0tlcm5lbFswXSA9IG1peCggc2hhZG93S2VybmVsWzFdLCBzaGFkb3dLZXJuZWxbMF0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuICAgICAgIHNoYWRvd0tlcm5lbFsxXSA9IG1peCggc2hhZG93S2VybmVsWzJdLCBzaGFkb3dLZXJuZWxbMV0sIGZyYWN0aW9uYWxDb29yZC54ICk7XFxuXFxuICAgICAgIHZlYzQgc2hhZG93VmFsdWVzO1xcbiAgICAgICAgc2hhZG93VmFsdWVzLnggPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsxXSwgc2hhZG93S2VybmVsWzBdWzBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcbiAgICAgICAgc2hhZG93VmFsdWVzLnkgPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsyXSwgc2hhZG93S2VybmVsWzBdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcbiAgICAgICAgc2hhZG93VmFsdWVzLnogPSBtaXgoIHNoYWRvd0tlcm5lbFsxXVsxXSwgc2hhZG93S2VybmVsWzFdWzBdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcbiAgICAgICAgc2hhZG93VmFsdWVzLncgPSBtaXgoIHNoYWRvd0tlcm5lbFsxXVsyXSwgc2hhZG93S2VybmVsWzFdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1xcblxcbiAgICAgICAgc2hhZG93ID0gZG90KCBzaGFkb3dWYWx1ZXMsIHZlYzQoIDEuMCApICk7XFxuXFxuICAgICAgICBzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcXG5cXG4gICAgICNlbHNlXFxuXFxuICAgICAgIHZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKTtcXG4gICAgICAgZmxvYXQgZkRlcHRoID0gdW5wYWNrRGVwdGgoIHJnYmFEZXB0aCApO1xcblxcbiAgICAgICAgaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56IClcXG5cXG4gICAvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBpcyBkYXJrZXJcXG5cXG4gICAgICAgICBzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSApO1xcblxcbiAgICAvLyBzcG90IHdpdGggbXVsdGlwbGUgc2hhZG93cyBoYXMgdGhlIHNhbWUgY29sb3IgYXMgc2luZ2xlIHNoYWRvdyBzcG90XFxuXFxuICAgIC8vICAgICAgICAgIHNoYWRvd0NvbG9yID0gbWluKCBzaGFkb3dDb2xvciwgdmVjMyggc2hhZG93RGFya25lc3NbIGkgXSApICk7XFxuXFxuICAgICAgI2VuZGlmXFxuXFxuICAgIH1cXG5cXG5cXG4gICAjaWZkZWYgU0hBRE9XTUFQX0RFQlVHXFxuXFxuICAgICAgI2lmZGVmIFNIQURPV01BUF9DQVNDQURFXFxuXFxuICAgICAgICBpZiAoIGluRnJ1c3R1bSAmJiBpbkZydXN0dW1Db3VudCA9PSAxICkgb3V0Z29pbmdMaWdodCAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XFxuXFxuICAgICAgI2Vsc2VcXG5cXG4gICAgICAgaWYgKCBpbkZydXN0dW0gKSBvdXRnb2luZ0xpZ2h0ICo9IGZydXN0dW1Db2xvcnNbIGkgXTtcXG5cXG4gICAgICNlbmRpZlxcblxcbiAgICAjZW5kaWZcXG5cXG4gIH1cXG5cXG4gLy8gTk9URTogSSBhbSB1bnN1cmUgaWYgdGhpcyBpcyBjb3JyZWN0IGluIGxpbmVhciBzcGFjZS4gIC1iaG91c3RvbiwgRGVjIDI5LCAyMDE0XFxuIHNoYWRvd0NvbG9yID0gaW5wdXRUb0xpbmVhciggc2hhZG93Q29sb3IgKTtcXG5cXG4gb3V0Z29pbmdMaWdodCA9IG91dGdvaW5nTGlnaHQgKiBzaGFkb3dDb2xvcjtcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NoYWRvd21hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXFxuXFxuIHVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd01hcFsgTUFYX1NIQURPV1MgXTtcXG4gdW5pZm9ybSB2ZWMyIHNoYWRvd01hcFNpemVbIE1BWF9TSEFET1dTIF07XFxuXFxuICB1bmlmb3JtIGZsb2F0IHNoYWRvd0RhcmtuZXNzWyBNQVhfU0hBRE9XUyBdO1xcbiAgdW5pZm9ybSBmbG9hdCBzaGFkb3dCaWFzWyBNQVhfU0hBRE9XUyBdO1xcblxcbiAgdmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG5cXG4gZmxvYXQgdW5wYWNrRGVwdGgoIGNvbnN0IGluIHZlYzQgcmdiYV9kZXB0aCApIHtcXG5cXG4gICBjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDEuMCAvICggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wICksIDEuMCAvICggMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAyNTYuMCwgMS4wICk7XFxuICAgIGZsb2F0IGRlcHRoID0gZG90KCByZ2JhX2RlcHRoLCBiaXRfc2hpZnQgKTtcXG4gICByZXR1cm4gZGVwdGg7XFxuXFxuIH1cXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzaGFkb3dtYXBfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXG5cXG4gdmFyeWluZyB2ZWM0IHZTaGFkb3dDb29yZFsgTUFYX1NIQURPV1MgXTtcXG4gdW5pZm9ybSBtYXQ0IHNoYWRvd01hdHJpeFsgTUFYX1NIQURPV1MgXTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2hhZG93bWFwX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2hhZG93bWFwX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcblxcbiAgZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcXG5cXG4gICB2U2hhZG93Q29vcmRbIGkgXSA9IHNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXG5cXG4gIH1cXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvc2tpbmJhc2VfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2luYmFzZV92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgbWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxuIG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcbiBtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcXG4gbWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3NraW5uaW5nX3BhcnNfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdza2lubmluZ19wYXJzX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuIHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcbiAgdW5pZm9ybSBtYXQ0IGJpbmRNYXRyaXhJbnZlcnNlO1xcblxcbiAjaWZkZWYgQk9ORV9URVhUVVJFXFxuXFxuICAgdW5pZm9ybSBzYW1wbGVyMkQgYm9uZVRleHR1cmU7XFxuICAgIHVuaWZvcm0gaW50IGJvbmVUZXh0dXJlV2lkdGg7XFxuICAgdW5pZm9ybSBpbnQgYm9uZVRleHR1cmVIZWlnaHQ7XFxuXFxuICAgIG1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcXG5cXG4gICAgICBmbG9hdCBqID0gaSAqIDQuMDtcXG4gICAgICBmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApICk7XFxuICAgICAgZmxvYXQgeSA9IGZsb29yKCBqIC8gZmxvYXQoIGJvbmVUZXh0dXJlV2lkdGggKSApO1xcblxcbiAgICAgZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVXaWR0aCApO1xcbiAgICAgZmxvYXQgZHkgPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVIZWlnaHQgKTtcXG5cXG4gICAgICB5ID0gZHkgKiAoIHkgKyAwLjUgKTtcXG5cXG4gICAgIHZlYzQgdjEgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDAuNSApLCB5ICkgKTtcXG4gICAgICB2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XFxuICAgICAgdmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcbiAgICAgIHZlYzQgdjQgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDMuNSApLCB5ICkgKTtcXG5cXG4gICAgICBtYXQ0IGJvbmUgPSBtYXQ0KCB2MSwgdjIsIHYzLCB2NCApO1xcblxcbiAgICAgcmV0dXJuIGJvbmU7XFxuXFxuICAgIH1cXG5cXG4gI2Vsc2VcXG5cXG4gICB1bmlmb3JtIG1hdDQgYm9uZUdsb2JhbE1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXG5cXG4gICBtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxuXFxuICAgICAgbWF0NCBib25lID0gYm9uZUdsb2JhbE1hdHJpY2VzWyBpbnQoaSkgXTtcXG4gICAgIHJldHVybiBib25lO1xcblxcbiAgICB9XFxuXFxuICNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubmluZ192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3NraW5uaW5nX3ZlcnRleCddID0gXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxuXFxuICAjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcblxcbiB2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggbW9ycGhlZCwgMS4wICk7XFxuXFxuICAjZWxzZVxcblxcbiB2ZWM0IHNraW5WZXJ0ZXggPSBiaW5kTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcbiAjZW5kaWZcXG5cXG4gIHZlYzQgc2tpbm5lZCA9IHZlYzQoIDAuMCApO1xcbiBza2lubmVkICs9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcXG4gIHNraW5uZWQgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1xcbiAgc2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxuICBza2lubmVkICs9IGJvbmVNYXRXICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQudztcXG4gIHNraW5uZWQgID0gYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkO1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9za2lubm9ybWFsX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc2tpbm5vcm1hbF92ZXJ0ZXgnXSA9IFwiI2lmZGVmIFVTRV9TS0lOTklOR1xcblxcbiAgbWF0NCBza2luTWF0cml4ID0gbWF0NCggMC4wICk7XFxuICBza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcbiAgc2tpbk1hdHJpeCArPSBza2luV2VpZ2h0LnkgKiBib25lTWF0WTtcXG4gIHNraW5NYXRyaXggKz0gc2tpbldlaWdodC56ICogYm9uZU1hdFo7XFxuICBza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcbiAgc2tpbk1hdHJpeCAgPSBiaW5kTWF0cml4SW52ZXJzZSAqIHNraW5NYXRyaXggKiBiaW5kTWF0cml4O1xcblxcbiAgI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcXG5cXG4gdmVjNCBza2lubmVkTm9ybWFsID0gc2tpbk1hdHJpeCAqIHZlYzQoIG1vcnBoZWROb3JtYWwsIDAuMCApO1xcblxcbiAjZWxzZVxcblxcbiB2ZWM0IHNraW5uZWROb3JtYWwgPSBza2luTWF0cml4ICogdmVjNCggbm9ybWFsLCAwLjAgKTtcXG5cXG4gICNlbmRpZlxcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9mcmFnbWVudC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAnc3BlY3VsYXJtYXBfZnJhZ21lbnQnXSA9IFwiZmxvYXQgc3BlY3VsYXJTdHJlbmd0aDtcXG5cXG4jaWZkZWYgVVNFX1NQRUNVTEFSTUFQXFxuXFxuIHZlYzQgdGV4ZWxTcGVjdWxhciA9IHRleHR1cmUyRCggc3BlY3VsYXJNYXAsIHZVdiApO1xcbiBzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1xcblxcbiNlbHNlXFxuXFxuICBzcGVjdWxhclN0cmVuZ3RoID0gMS4wO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay9zcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICdzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50J10gPSBcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXG5cXG4gdW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml9wYXJzX2ZyYWdtZW50Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd1djJfcGFyc19mcmFnbWVudCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG4gIHZhcnlpbmcgdmVjMiB2VXYyO1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91djJfcGFyc192ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml9wYXJzX3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXG5cXG4gIGF0dHJpYnV0ZSB2ZWMyIHV2MjtcXG4gdmFyeWluZyB2ZWMyIHZVdjI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2Ml92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2Ml92ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxuXFxuIHZVdjIgPSB1djI7XFxuXFxuI2VuZGlmXCI7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckNodW5rL3V2X3BhcnNfZnJhZ21lbnQuZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3BhcnNfZnJhZ21lbnQnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKVxcblxcbiB2YXJ5aW5nIHZlYzIgdlV2O1xcblxcbiNlbmRpZlwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl9wYXJzX3ZlcnRleC5nbHNsXG5cblRIUkVFLlNoYWRlckNodW5rWyAndXZfcGFyc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKVxcblxcbiB2YXJ5aW5nIHZlYzIgdlV2O1xcbiB1bmlmb3JtIHZlYzQgb2Zmc2V0UmVwZWF0O1xcblxcbiNlbmRpZlxcblwiO1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvc2hhZGVycy9TaGFkZXJDaHVuay91dl92ZXJ0ZXguZ2xzbFxuXG5USFJFRS5TaGFkZXJDaHVua1sgJ3V2X3ZlcnRleCddID0gXCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApIHx8IGRlZmluZWQoIFVTRV9BTFBIQU1BUCApXFxuXFxuICB2VXYgPSB1diAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eTtcXG5cXG4jZW5kaWZcIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvU2hhZGVyQ2h1bmsvd29ybGRwb3NfdmVydGV4Lmdsc2xcblxuVEhSRUUuU2hhZGVyQ2h1bmtbICd3b3JsZHBvc192ZXJ0ZXgnXSA9IFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXFxuXFxuICNpZmRlZiBVU0VfU0tJTk5JTkdcXG5cXG4gICB2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHNraW5uZWQ7XFxuXFxuICNlbGlmIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKVxcblxcbiAgIHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggbW9ycGhlZCwgMS4wICk7XFxuXFxuICAjZWxzZVxcblxcbiAgIHZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1xcblxcbiAjZW5kaWZcXG5cXG4jZW5kaWZcXG5cIjtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNVdGlscy5qc1xuXG4vKipcbiAqIFVuaWZvcm0gVXRpbGl0aWVzXG4gKi9cblxuVEhSRUUuVW5pZm9ybXNVdGlscyA9IHtcblxuICBtZXJnZTogZnVuY3Rpb24gKCB1bmlmb3JtcyApIHtcblxuICAgIHZhciBtZXJnZWQgPSB7fTtcblxuICAgIGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcblxuICAgICAgdmFyIHRtcCA9IHRoaXMuY2xvbmUoIHVuaWZvcm1zWyB1IF0gKTtcblxuICAgICAgZm9yICggdmFyIHAgaW4gdG1wICkge1xuXG4gICAgICAgIG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZWQ7XG5cbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24gKCB1bmlmb3Jtc19zcmMgKSB7XG5cbiAgICB2YXIgdW5pZm9ybXNfZHN0ID0ge307XG5cbiAgICBmb3IgKCB2YXIgdSBpbiB1bmlmb3Jtc19zcmMgKSB7XG5cbiAgICAgIHVuaWZvcm1zX2RzdFsgdSBdID0ge307XG5cbiAgICAgIGZvciAoIHZhciBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xuXG4gICAgICAgIHZhciBwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcblxuICAgICAgICBpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciB8fFxuICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxuICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyB8fFxuICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yNCB8fFxuICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4MyB8fFxuICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCB8fFxuICAgICAgICAgICBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSApIHtcblxuICAgICAgICAgIHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xuXG4gICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmMuc2xpY2UoKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdW5pZm9ybXNfZHN0WyB1IF1bIHAgXSA9IHBhcmFtZXRlcl9zcmM7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdW5pZm9ybXNfZHN0O1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3NoYWRlcnMvVW5pZm9ybXNMaWIuanNcblxuLyoqXG4gKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xuICovXG5cblRIUkVFLlVuaWZvcm1zTGliID0ge1xuXG4gIGNvbW1vbjoge1xuXG4gICAgXCJkaWZmdXNlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXG4gICAgXCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG5cbiAgICBcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXG5cbiAgICBcInNwZWN1bGFyTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxuICAgIFwiYWxwaGFNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG5cbiAgICBcImVudk1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcImZsaXBFbnZNYXBcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSxcbiAgICBcInJlZmxlY3Rpdml0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuICAgIFwicmVmcmFjdGlvblJhdGlvXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC45OCB9XG5cbiAgfSxcblxuICBhb21hcDoge1xuXG4gICAgXCJhb01hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcImFvTWFwSW50ZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuXG4gIH0sXG5cbiAgbGlnaHRtYXA6IHtcblxuICAgIFwibGlnaHRNYXBcIiA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgXCJsaWdodE1hcEludGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcblxuICB9LFxuXG4gIGJ1bXA6IHtcblxuICAgIFwiYnVtcE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcImJ1bXBTY2FsZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfVxuXG4gIH0sXG5cbiAgbm9ybWFsbWFwOiB7XG5cbiAgICBcIm5vcm1hbE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcIm5vcm1hbFNjYWxlXCIgOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfVxuICB9LFxuXG4gIGZvZyA6IHtcblxuICAgIFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcbiAgICBcImZvZ05lYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXG4gICAgXCJmb2dGYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwIH0sXG4gICAgXCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XG5cbiAgfSxcblxuICBsaWdodHM6IHtcblxuICAgIFwiYW1iaWVudExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcblxuICAgIFwiZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwiZGlyZWN0aW9uYWxMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcImhlbWlzcGhlcmVMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwiaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcbiAgICBcImhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcInBvaW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwicG9pbnRMaWdodFBvc2l0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJwb2ludExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJwb2ludExpZ2h0RGVjYXlcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcInNwb3RMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzcG90TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxuICAgIFwic3BvdExpZ2h0RGlyZWN0aW9uXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzcG90TGlnaHREaXN0YW5jZVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcbiAgICBcInNwb3RMaWdodEFuZ2xlQ29zXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuICAgIFwic3BvdExpZ2h0RXhwb25lbnRcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzcG90TGlnaHREZWNheVwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfVxuXG4gIH0sXG5cbiAgcGFydGljbGU6IHtcblxuICAgIFwicHNDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxuICAgIFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuICAgIFwic2l6ZVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxuICAgIFwic2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcbiAgICBcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICBcIm9mZnNldFJlcGVhdFwiIDogeyB0eXBlOiBcInY0XCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yNCggMCwgMCwgMSwgMSApIH0sXG5cbiAgICBcImZvZ0RlbnNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjAwMDI1IH0sXG4gICAgXCJmb2dOZWFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgIFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxuICAgIFwiZm9nQ29sb3JcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfVxuXG4gIH0sXG5cbiAgc2hhZG93bWFwOiB7XG5cbiAgICBcInNoYWRvd01hcFwiOiB7IHR5cGU6IFwidHZcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzaGFkb3dNYXBTaXplXCI6IHsgdHlwZTogXCJ2MnZcIiwgdmFsdWU6IFtdIH0sXG5cbiAgICBcInNoYWRvd0JpYXNcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXG4gICAgXCJzaGFkb3dEYXJrbmVzc1wiOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxuXG4gICAgXCJzaGFkb3dNYXRyaXhcIiA6IHsgdHlwZTogXCJtNHZcIiwgdmFsdWU6IFtdIH1cblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9zaGFkZXJzL1NoYWRlckxpYi5qc1xuXG4vKipcbiAqIFdlYmdsIFNoYWRlciBMaWJyYXJ5IGZvciB0aHJlZS5qc1xuICpcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqL1xuXG5cblRIUkVFLlNoYWRlckxpYiA9IHtcblxuICAnYmFzaWMnOiB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cblxuICAgIF0gKSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbmJhc2VfdmVydGV4XCIgXSxcblxuICAgICAgXCIgI2lmZGVmIFVTRV9FTlZNQVBcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuICAgICAgXCIgI2VuZGlmXCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLFxuICAgICAgXCIgdmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXG4gICAgICBcIiB2ZWMzIHRvdGFsQW1iaWVudExpZ2h0ID0gdmVjMyggMS4wICk7XCIsIC8vIGhhcmR3aXJlZFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiBvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYiAqIHRvdGFsQW1iaWVudExpZ2h0O1wiLCAvLyBzaW1wbGUgc2hhZGVyXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSwgICAgLy8gVE9ETzogU2hhZG93cyBvbiBhbiBvdGhlcndpc2UgdW5saXQgc3VyZmFjZSBkb2Vzbid0IG1ha2Ugc2Vuc2UuXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLCAvLyBUT0RPLCB0aGlzIHNob3VsZCBiZSBwcmUtbXVsdGlwbGllZCB0byBhbGxvdyBmb3IgYnJpZ2h0IGhpZ2hsaWdodHMgb24gdmVyeSB0cmFuc3BhcmVudCBvYmplY3RzXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIilcblxuICB9LFxuXG4gICdsYW1iZXJ0Jzoge1xuXG4gICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcblxuICAgICAge1xuICAgICAgICBcImVtaXNzaXZlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApIH1cbiAgICAgIH1cblxuICAgIF0gKSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBcIiNkZWZpbmUgTEFNQkVSVFwiLFxuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcIixcblxuICAgICAgXCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXG5cbiAgICAgIFwiIHZhcnlpbmcgdmVjMyB2TGlnaHRCYWNrO1wiLFxuXG4gICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19sYW1iZXJ0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcbiAgICAgIFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxuXG4gICAgICBcIiNpZmRlZiBET1VCTEVfU0lERURcIixcblxuICAgICAgXCIgdmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXG5cbiAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInV2X3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXYyX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsIC8vIG91dGdvaW5nIGxpZ2h0IGRvZXMgbm90IGhhdmUgYW4gYWxwaGEsIHRoZSBzdXJmYWNlIGRvZXNcbiAgICAgIFwiIHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgI2lmZGVmIERPVUJMRV9TSURFRFwiLFxuXG4gICAgICAgICAgLy9cImZsb2F0IGlzRnJvbnQgPSBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKTtcIixcbiAgICAgICAgICAvL1wiZ2xfRnJhZ0NvbG9yLnh5eiAqPSBpc0Zyb250ICogdkxpZ2h0RnJvbnQgKyAoIDEuMCAtIGlzRnJvbnQgKSAqIHZMaWdodEJhY2s7XCIsXG5cbiAgICAgIFwiICAgaWYgKCBnbF9Gcm9udEZhY2luZyApXCIsXG4gICAgICBcIiAgICAgb3V0Z29pbmdMaWdodCArPSBkaWZmdXNlQ29sb3IucmdiICogdkxpZ2h0RnJvbnQgKyBlbWlzc2l2ZTtcIixcbiAgICAgIFwiICAgZWxzZVwiLFxuICAgICAgXCIgICAgIG91dGdvaW5nTGlnaHQgKz0gZGlmZnVzZUNvbG9yLnJnYiAqIHZMaWdodEJhY2sgKyBlbWlzc2l2ZTtcIixcblxuICAgICAgXCIgI2Vsc2VcIixcblxuICAgICAgXCIgICBvdXRnb2luZ0xpZ2h0ICs9IGRpZmZ1c2VDb2xvci5yZ2IgKiB2TGlnaHRGcm9udCArIGVtaXNzaXZlO1wiLFxuXG4gICAgICBcIiAjZW5kaWZcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpbmVhcl90b19nYW1tYV9mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgZ2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcIiwgLy8gVE9ETywgdGhpcyBzaG91bGQgYmUgcHJlLW11bHRpcGxpZWQgdG8gYWxsb3cgZm9yIGJyaWdodCBoaWdobGlnaHRzIG9uIHZlcnkgdHJhbnNwYXJlbnQgb2JqZWN0c1xuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpXG5cbiAgfSxcblxuICAncGhvbmcnOiB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiYW9tYXBcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRtYXBcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiYnVtcFwiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJub3JtYWxtYXBcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcbiAgICAgIFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxuXG4gICAgICB7XG4gICAgICAgIFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcbiAgICAgICAgXCJzcGVjdWxhclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgxMTExMTEgKSB9LFxuICAgICAgICBcInNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfVxuICAgICAgfVxuXG4gICAgXSApLFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFwiI2RlZmluZSBQSE9OR1wiLFxuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxuXG4gICAgICBcIiNpZm5kZWYgRkxBVF9TSEFERURcIixcblxuICAgICAgXCIgdmFyeWluZyB2ZWMzIHZOb3JtYWw7XCIsXG5cbiAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1dl92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcblxuICAgICAgXCIjaWZuZGVmIEZMQVRfU0hBREVEXCIsIC8vIE5vcm1hbCBjb21wdXRlZCB3aXRoIGRlcml2YXRpdmVzIHdoZW4gRkxBVF9TSEFERURcblxuICAgICAgXCIgdk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcblxuICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwiIHZWaWV3UG9zaXRpb24gPSAtbXZQb3NpdGlvbi54eXo7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwiI2RlZmluZSBQSE9OR1wiLFxuXG4gICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuICAgICAgXCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXG4gICAgICBcInVuaWZvcm0gdmVjMyBzcGVjdWxhcjtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBzaGluaW5lc3M7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwidXZfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJ1djJfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYW1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImFvbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJidW1wbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibm9ybWFsbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLCAvLyBvdXRnb2luZyBsaWdodCBkb2VzIG5vdCBoYXZlIGFuIGFscGhhLCB0aGUgc3VyZmFjZSBkb2VzXG4gICAgICBcIiB2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcIixcbiAgICAgIFwiIHZlYzMgdG90YWxBbWJpZW50TGlnaHQgPSBhbWJpZW50TGlnaHRDb2xvcjtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGFtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYW9tYXBfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsIC8vIFRPRE8sIHRoaXMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIHRvIGFsbG93IGZvciBicmlnaHQgaGlnaGxpZ2h0cyBvbiB2ZXJ5IHRyYW5zcGFyZW50IG9iamVjdHNcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH0sXG5cbiAgJ3BhcnRpY2xlX2Jhc2ljJzoge1xuXG4gICAgdW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcblxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwicGFydGljbGVcIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXVxuXG4gICAgXSApLFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSBmbG9hdCBzaXplO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuICAgICAgXCIgdmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICBcIiAjaWZkZWYgVVNFX1NJWkVBVFRFTlVBVElPTlwiLFxuICAgICAgXCIgICBnbF9Qb2ludFNpemUgPSBzaXplICogKCBzY2FsZSAvIGxlbmd0aCggbXZQb3NpdGlvbi54eXogKSApO1wiLFxuICAgICAgXCIgI2Vsc2VcIixcbiAgICAgIFwiICAgZ2xfUG9pbnRTaXplID0gc2l6ZTtcIixcbiAgICAgIFwiICNlbmRpZlwiLFxuXG4gICAgICBcIiBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIndvcmxkcG9zX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIHZlYzMgcHNDb2xvcjtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIHZlYzMgb3V0Z29pbmdMaWdodCA9IHZlYzMoIDAuMCApO1wiLCAvLyBvdXRnb2luZyBsaWdodCBkb2VzIG5vdCBoYXZlIGFuIGFscGhhLCB0aGUgc3VyZmFjZSBkb2VzXG4gICAgICBcIiB2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIHBzQ29sb3IsIG9wYWNpdHkgKTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9mcmFnbWVudFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCIgb3V0Z29pbmdMaWdodCA9IGRpZmZ1c2VDb2xvci5yZ2I7XCIsIC8vIHNpbXBsZSBzaGFkZXJcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1wiLCAvLyBUT0RPLCB0aGlzIHNob3VsZCBiZSBwcmUtbXVsdGlwbGllZCB0byBhbGxvdyBmb3IgYnJpZ2h0IGhpZ2hsaWdodHMgb24gdmVyeSB0cmFuc3BhcmVudCBvYmplY3RzXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIilcblxuICB9LFxuXG4gICdkYXNoZWQnOiB7XG5cbiAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xuXG4gICAgICBUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcblxuICAgICAge1xuICAgICAgICBcInNjYWxlXCIgICAgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICBcImRhc2hTaXplXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxuICAgICAgICBcInRvdGFsU2l6ZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMiB9XG4gICAgICB9XG5cbiAgICBdICksXG5cbiAgICB2ZXJ0ZXhTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxuICAgICAgXCJhdHRyaWJ1dGUgZmxvYXQgbGluZURpc3RhbmNlO1wiLFxuXG4gICAgICBcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcblxuICAgICAgXCIgdkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1wiLFxuXG4gICAgICBcIiB2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG4gICAgICBcIiBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICBcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgIFwidW5pZm9ybSBmbG9hdCBkYXNoU2l6ZTtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XCIsXG5cbiAgICAgIFwidmFyeWluZyBmbG9hdCB2TGluZURpc3RhbmNlO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIGlmICggbW9kKCB2TGluZURpc3RhbmNlLCB0b3RhbFNpemUgKSA+IGRhc2hTaXplICkge1wiLFxuXG4gICAgICBcIiAgIGRpc2NhcmQ7XCIsXG5cbiAgICAgIFwiIH1cIixcblxuICAgICAgXCIgdmVjMyBvdXRnb2luZ0xpZ2h0ID0gdmVjMyggMC4wICk7XCIsIC8vIG91dGdvaW5nIGxpZ2h0IGRvZXMgbm90IGhhdmUgYW4gYWxwaGEsIHRoZSBzdXJmYWNlIGRvZXNcbiAgICAgIFwiIHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiBvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcIiwgLy8gc2ltcGxlIHNoYWRlclxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImZvZ19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XCIsIC8vIFRPRE8sIHRoaXMgc2hvdWxkIGJlIHByZS1tdWx0aXBsaWVkIHRvIGFsbG93IGZvciBicmlnaHQgaGlnaGxpZ2h0cyBvbiB2ZXJ5IHRyYW5zcGFyZW50IG9iamVjdHNcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH0sXG5cbiAgJ2RlcHRoJzoge1xuXG4gICAgdW5pZm9ybXM6IHtcblxuICAgICAgXCJtTmVhclwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXG4gICAgICBcIm1GYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwLjAgfSxcbiAgICAgIFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XG5cbiAgICB9LFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSBmbG9hdCBtTmVhcjtcIixcbiAgICAgIFwidW5pZm9ybSBmbG9hdCBtRmFyO1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcIiAjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFwiLFxuXG4gICAgICBcIiAgIGZsb2F0IGRlcHRoID0gZ2xfRnJhZ0RlcHRoRVhUIC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXG5cbiAgICAgIFwiICNlbHNlXCIsXG5cbiAgICAgIFwiICAgZmxvYXQgZGVwdGggPSBnbF9GcmFnQ29vcmQueiAvIGdsX0ZyYWdDb29yZC53O1wiLFxuXG4gICAgICBcIiAjZW5kaWZcIixcblxuICAgICAgXCIgZmxvYXQgY29sb3IgPSAxLjAgLSBzbW9vdGhzdGVwKCBtTmVhciwgbUZhciwgZGVwdGggKTtcIixcbiAgICAgIFwiIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMoIGNvbG9yICksIG9wYWNpdHkgKTtcIiwgICAvLyBUT0RPLCB0aGlzIHNob3VsZCBiZSBwcmUtbXVsdGlwbGllZCB0byBhbGxvdyBmb3IgYnJpZ2h0IGhpZ2hsaWdodHMgb24gdmVyeSB0cmFuc3BhcmVudCBvYmplY3RzXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIilcblxuICB9LFxuXG4gICdub3JtYWwnOiB7XG5cbiAgICB1bmlmb3Jtczoge1xuXG4gICAgICBcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxuXG4gICAgfSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgdk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl92ZXJ0ZXhcIiBdLFxuXG4gICAgICBcIn1cIlxuXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnRTaGFkZXI6IFtcblxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG4gICAgICBcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiBnbF9GcmFnQ29sb3IgPSB2ZWM0KCAwLjUgKiBub3JtYWxpemUoIHZOb3JtYWwgKSArIDAuNSwgb3BhY2l0eSApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH0sXG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAgQ3ViZSBtYXAgc2hhZGVyXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgJ2N1YmUnOiB7XG5cbiAgICB1bmlmb3JtczogeyBcInRDdWJlXCI6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXG4gICAgICAgICAgXCJ0RmxpcFwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogLSAxIH0gfSxcblxuICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4XCIgXSxcblxuICAgICAgXCJ2b2lkIG1haW4oKSB7XCIsXG5cbiAgICAgIFwiIHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcIixcblxuICAgICAgXCIgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICBcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XCIsXG4gICAgICBcInVuaWZvcm0gZmxvYXQgdEZsaXA7XCIsXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc19mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICBcIiBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH0sXG5cbiAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAgQ3ViZSBtYXAgc2hhZGVyXG4gICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgJ2VxdWlyZWN0Jzoge1xuXG4gICAgdW5pZm9ybXM6IHsgXCJ0RXF1aXJlY3RcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcbiAgICAgICAgICBcInRGbGlwXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAtIDEgfSB9LFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxuXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJjb21tb25cIiBdLFxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfcGFyc192ZXJ0ZXhcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgXCIgdldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1wiLFxuXG4gICAgICBcIiBnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXG5cbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgdEVxdWlyZWN0O1wiLFxuICAgICAgXCJ1bmlmb3JtIGZsb2F0IHRGbGlwO1wiLFxuXG4gICAgICBcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcblxuICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29tbW9uXCIgXSxcbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnRcIiBdLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAvLyBcIiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcbiAgICAgICAgXCJ2ZWMzIGRpcmVjdGlvbiA9IG5vcm1hbGl6ZSggdldvcmxkUG9zaXRpb24gKTtcIixcbiAgICAgICAgXCJ2ZWMyIHNhbXBsZVVWO1wiLFxuICAgICAgICBcInNhbXBsZVVWLnkgPSBzYXR1cmF0ZSggdEZsaXAgKiBkaXJlY3Rpb24ueSAqIC0wLjUgKyAwLjUgKTtcIixcbiAgICAgICAgXCJzYW1wbGVVVi54ID0gYXRhbiggZGlyZWN0aW9uLnosIGRpcmVjdGlvbi54ICkgKiBSRUNJUFJPQ0FMX1BJMiArIDAuNTtcIixcbiAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwifVwiXG5cbiAgICBdLmpvaW4oXCJcXG5cIilcblxuICB9LFxuXG4gIC8qIERlcHRoIGVuY29kaW5nIGludG8gUkdCQSB0ZXh0dXJlXG4gICAqXG4gICAqIGJhc2VkIG9uIFNwaWRlckdMIHNoYWRvdyBtYXAgZXhhbXBsZVxuICAgKiBodHRwOi8vc3BpZGVyZ2wub3JnL2V4YW1wbGUucGhwP2lkPTZcbiAgICpcbiAgICogb3JpZ2luYWxseSBmcm9tXG4gICAqIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvdG9waWMvNDQyMTM4LXBhY2tpbmctYS1mbG9hdC1pbnRvLWEtYThyOGc4YjgtdGV4dHVyZS1zaGFkZXIvcGFnZV9fd2hpY2hwYWdlX18xJTI1RUYlMjVCRiUyNUJEXG4gICAqXG4gICAqIHNlZSBhbHNvXG4gICAqIGh0dHA6Ly9hcmFzLXAuaW5mby9ibG9nLzIwMDkvMDcvMzAvZW5jb2RpbmctZmxvYXRzLXRvLXJnYmEtdGhlLWZpbmFsL1xuICAgKi9cblxuICAnZGVwdGhSR0JBJzoge1xuXG4gICAgdW5pZm9ybXM6IHt9LFxuXG4gICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleFwiIF0sXG5cbiAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXG4gICAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcbiAgICAgICAgVEhSRUUuU2hhZGVyQ2h1bmtbIFwibG9nZGVwdGhidWZfdmVydGV4XCIgXSxcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgIFRIUkVFLlNoYWRlckNodW5rWyBcImNvbW1vblwiIF0sXG4gICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50XCIgXSxcblxuICAgICAgXCJ2ZWM0IHBhY2tfZGVwdGgoIGNvbnN0IGluIGZsb2F0IGRlcHRoICkge1wiLFxuXG4gICAgICBcIiBjb25zdCB2ZWM0IGJpdF9zaGlmdCA9IHZlYzQoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCwgMjU2LjAgKiAyNTYuMCwgMjU2LjAsIDEuMCApO1wiLFxuICAgICAgXCIgY29uc3QgdmVjNCBiaXRfbWFzayA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxuICAgICAgXCIgdmVjNCByZXMgPSBtb2QoIGRlcHRoICogYml0X3NoaWZ0ICogdmVjNCggMjU1ICksIHZlYzQoIDI1NiApICkgLyB2ZWM0KCAyNTUgKTtcIiwgLy8gXCIgIHZlYzQgcmVzID0gZnJhY3QoIGRlcHRoICogYml0X3NoaWZ0ICk7XCIsXG4gICAgICBcIiByZXMgLT0gcmVzLnh4eXogKiBiaXRfbWFzaztcIixcbiAgICAgIFwiIHJldHVybiByZXM7XCIsXG5cbiAgICAgIFwifVwiLFxuXG4gICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICBUSFJFRS5TaGFkZXJDaHVua1sgXCJsb2dkZXB0aGJ1Zl9mcmFnbWVudFwiIF0sXG5cbiAgICAgIFwiICNpZmRlZiBVU0VfTE9HREVQVEhCVUZfRVhUXCIsXG5cbiAgICAgIFwiICAgZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdEZXB0aEVYVCApO1wiLFxuXG4gICAgICBcIiAjZWxzZVwiLFxuXG4gICAgICBcIiAgIGdsX0ZyYWdEYXRhWyAwIF0gPSBwYWNrX2RlcHRoKCBnbF9GcmFnQ29vcmQueiApO1wiLFxuXG4gICAgICBcIiAjZW5kaWZcIixcblxuICAgICAgICAvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKTtcIixcbiAgICAgICAgLy9cImZsb2F0IHogPSAoICggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApIC0gMy4wICkgLyAoIDQwMDAuMCAtIDMuMCApO1wiLFxuICAgICAgICAvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIHogKTtcIixcbiAgICAgICAgLy9cImdsX0ZyYWdEYXRhWyAwIF0gPSB2ZWM0KCB6LCB6LCB6LCAxLjAgKTtcIixcblxuICAgICAgXCJ9XCJcblxuICAgIF0uam9pbihcIlxcblwiKVxuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcblxuICBjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xuXG4gIHBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzIHx8IHt9O1xuXG4gIHZhciBfY2FudmFzID0gcGFyYW1ldGVycy5jYW52YXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2FudmFzIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKSxcbiAgX2NvbnRleHQgPSBwYXJhbWV0ZXJzLmNvbnRleHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY29udGV4dCA6IG51bGwsXG5cbiAgX3dpZHRoID0gX2NhbnZhcy53aWR0aCxcbiAgX2hlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxuXG4gIHBpeGVsUmF0aW8gPSAxLFxuXG4gIF9wcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnLFxuXG4gIF9hbHBoYSA9IHBhcmFtZXRlcnMuYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYWxwaGEgOiBmYWxzZSxcbiAgX2RlcHRoID0gcGFyYW1ldGVycy5kZXB0aCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5kZXB0aCA6IHRydWUsXG4gIF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxuICBfYW50aWFsaWFzID0gcGFyYW1ldGVycy5hbnRpYWxpYXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYW50aWFsaWFzIDogZmFsc2UsXG4gIF9wcmVtdWx0aXBsaWVkQWxwaGEgPSBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVtdWx0aXBsaWVkQWxwaGEgOiB0cnVlLFxuICBfcHJlc2VydmVEcmF3aW5nQnVmZmVyID0gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyIDogZmFsc2UsXG4gIF9sb2dhcml0aG1pY0RlcHRoQnVmZmVyID0gcGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgOiBmYWxzZSxcblxuICBfY2xlYXJDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSxcbiAgX2NsZWFyQWxwaGEgPSAwO1xuXG4gIHZhciBsaWdodHMgPSBbXTtcblxuICB2YXIgb3BhcXVlT2JqZWN0cyA9IFtdO1xuICB2YXIgdHJhbnNwYXJlbnRPYmplY3RzID0gW107XG5cbiAgdmFyIHNwcml0ZXMgPSBbXTtcbiAgdmFyIGxlbnNGbGFyZXMgPSBbXTtcblxuICAvLyBwdWJsaWMgcHJvcGVydGllc1xuXG4gIHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgLy8gY2xlYXJpbmdcblxuICB0aGlzLmF1dG9DbGVhciA9IHRydWU7XG4gIHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xuICB0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcbiAgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsID0gdHJ1ZTtcblxuICAvLyBzY2VuZSBncmFwaFxuXG4gIHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xuXG4gIC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xuXG4gIHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7IC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICB0aGlzLmdhbW1hSW5wdXQgPSBmYWxzZTtcbiAgdGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xuXG4gIC8vIG1vcnBoc1xuXG4gIHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcbiAgdGhpcy5tYXhNb3JwaE5vcm1hbHMgPSA0O1xuXG4gIC8vIGZsYWdzXG5cbiAgdGhpcy5hdXRvU2NhbGVDdWJlbWFwcyA9IHRydWU7XG5cbiAgLy8gaW5mb1xuXG4gIHRoaXMuaW5mbyA9IHtcblxuICAgIG1lbW9yeToge1xuXG4gICAgICBwcm9ncmFtczogMCxcbiAgICAgIGdlb21ldHJpZXM6IDAsXG4gICAgICB0ZXh0dXJlczogMFxuXG4gICAgfSxcblxuICAgIHJlbmRlcjoge1xuXG4gICAgICBjYWxsczogMCxcbiAgICAgIHZlcnRpY2VzOiAwLFxuICAgICAgZmFjZXM6IDAsXG4gICAgICBwb2ludHM6IDBcblxuICAgIH1cblxuICB9O1xuXG4gIC8vIGludGVybmFsIHByb3BlcnRpZXNcblxuICB2YXIgX3RoaXMgPSB0aGlzLFxuXG4gIF9wcm9ncmFtcyA9IFtdLFxuXG4gIC8vIGludGVybmFsIHN0YXRlIGNhY2hlXG5cbiAgX2N1cnJlbnRQcm9ncmFtID0gbnVsbCxcbiAgX2N1cnJlbnRGcmFtZWJ1ZmZlciA9IG51bGwsXG4gIF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMSxcbiAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJyxcbiAgX2N1cnJlbnRDYW1lcmEgPSBudWxsLFxuXG4gIF91c2VkVGV4dHVyZVVuaXRzID0gMCxcblxuICBfdmlld3BvcnRYID0gMCxcbiAgX3ZpZXdwb3J0WSA9IDAsXG4gIF92aWV3cG9ydFdpZHRoID0gX2NhbnZhcy53aWR0aCxcbiAgX3ZpZXdwb3J0SGVpZ2h0ID0gX2NhbnZhcy5oZWlnaHQsXG4gIF9jdXJyZW50V2lkdGggPSAwLFxuICBfY3VycmVudEhlaWdodCA9IDAsXG5cbiAgLy8gZnJ1c3R1bVxuXG4gIF9mcnVzdHVtID0gbmV3IFRIUkVFLkZydXN0dW0oKSxcblxuICAgLy8gY2FtZXJhIG1hdHJpY2VzIGNhY2hlXG5cbiAgX3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxuXG4gIF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICAvLyBsaWdodCBhcnJheXMgY2FjaGVcblxuICBfZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcblxuICBfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWUsXG5cbiAgX2xpZ2h0cyA9IHtcblxuICAgIGFtYmllbnQ6IFsgMCwgMCwgMCBdLFxuICAgIGRpcmVjdGlvbmFsOiB7IGxlbmd0aDogMCwgY29sb3JzOltdLCBwb3NpdGlvbnM6IFtdIH0sXG4gICAgcG9pbnQ6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IFtdLCBwb3NpdGlvbnM6IFtdLCBkaXN0YW5jZXM6IFtdLCBkZWNheXM6IFtdIH0sXG4gICAgc3BvdDogeyBsZW5ndGg6IDAsIGNvbG9yczogW10sIHBvc2l0aW9uczogW10sIGRpc3RhbmNlczogW10sIGRpcmVjdGlvbnM6IFtdLCBhbmdsZXNDb3M6IFtdLCBleHBvbmVudHM6IFtdLCBkZWNheXM6IFtdIH0sXG4gICAgaGVtaTogeyBsZW5ndGg6IDAsIHNreUNvbG9yczogW10sIGdyb3VuZENvbG9yczogW10sIHBvc2l0aW9uczogW10gfVxuXG4gIH07XG5cbiAgLy8gaW5pdGlhbGl6ZVxuXG4gIHZhciBfZ2w7XG5cbiAgdHJ5IHtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICAgYWxwaGE6IF9hbHBoYSxcbiAgICAgIGRlcHRoOiBfZGVwdGgsXG4gICAgICBzdGVuY2lsOiBfc3RlbmNpbCxcbiAgICAgIGFudGlhbGlhczogX2FudGlhbGlhcyxcbiAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogX3ByZW11bHRpcGxpZWRBbHBoYSxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlclxuICAgIH07XG5cbiAgICBfZ2wgPSBfY29udGV4dCB8fCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcsIGF0dHJpYnV0ZXMgKSB8fCBfY2FudmFzLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzICk7XG5cbiAgICBpZiAoIF9nbCA9PT0gbnVsbCApIHtcblxuICAgICAgaWYgKCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcpICE9PSBudWxsICkge1xuXG4gICAgICAgIHRocm93ICdFcnJvciBjcmVhdGluZyBXZWJHTCBjb250ZXh0IHdpdGggeW91ciBzZWxlY3RlZCBhdHRyaWJ1dGVzLic7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuJztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHJlc2V0R0xTdGF0ZSgpO1xuICAgICAgc2V0RGVmYXVsdEdMU3RhdGUoKTtcblxuICAgICAgb2JqZWN0cy5vYmplY3RzID0ge307XG5cbiAgICB9LCBmYWxzZSk7XG5cbiAgfSBjYXRjaCAoIGVycm9yICkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBlcnJvciApO1xuXG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgVEhSRUUuV2ViR0xTdGF0ZSggX2dsLCBwYXJhbVRocmVlVG9HTCApO1xuXG4gIGlmICggX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ3JhbmdlTWluJzogMSxcbiAgICAgICAgJ3JhbmdlTWF4JzogMSxcbiAgICAgICAgJ3ByZWNpc2lvbic6IDFcbiAgICAgIH07XG5cbiAgICB9XG5cbiAgfVxuXG4gIHZhciBleHRlbnNpb25zID0gbmV3IFRIUkVFLldlYkdMRXh0ZW5zaW9ucyggX2dsICk7XG4gIHZhciBvYmplY3RzID0gbmV3IFRIUkVFLldlYkdMT2JqZWN0cyggX2dsLCB0aGlzLmluZm8gKTtcblxuICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xuICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKTtcbiAgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuICBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApO1xuICBleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcbiAgZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gIGlmICggZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xuXG4gICAgVEhSRUUuQnVmZmVyR2VvbWV0cnkuTWF4SW5kZXggPSA0Mjk0OTY3Mjk2O1xuXG4gIH1cblxuICBpZiAoIF9sb2dhcml0aG1pY0RlcHRoQnVmZmVyICkge1xuXG4gICAgZXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKTtcblxuICB9XG5cbiAgLy9cblxuICB2YXIgZ2xDbGVhckNvbG9yID0gZnVuY3Rpb24gKCByLCBnLCBiLCBhICkge1xuXG4gICAgaWYgKCBfcHJlbXVsdGlwbGllZEFscGhhID09PSB0cnVlICkge1xuXG4gICAgICByICo9IGE7IGcgKj0gYTsgYiAqPSBhO1xuXG4gICAgfVxuXG4gICAgX2dsLmNsZWFyQ29sb3IoIHIsIGcsIGIsIGEgKTtcblxuICB9O1xuXG4gIHZhciBzZXREZWZhdWx0R0xTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIF9nbC5jbGVhckNvbG9yKCAwLCAwLCAwLCAxICk7XG4gICAgX2dsLmNsZWFyRGVwdGgoIDEgKTtcbiAgICBfZ2wuY2xlYXJTdGVuY2lsKCAwICk7XG5cbiAgICBfZ2wuZW5hYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xuICAgIF9nbC5kZXB0aEZ1bmMoIF9nbC5MRVFVQUwgKTtcblxuICAgIF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcbiAgICBfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG4gICAgX2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuXG4gICAgX2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XG4gICAgX2dsLmJsZW5kRXF1YXRpb24oIF9nbC5GVU5DX0FERCApO1xuICAgIF9nbC5ibGVuZEZ1bmMoIF9nbC5TUkNfQUxQSEEsIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XG5cbiAgICBfZ2wudmlld3BvcnQoIF92aWV3cG9ydFgsIF92aWV3cG9ydFksIF92aWV3cG9ydFdpZHRoLCBfdmlld3BvcnRIZWlnaHQgKTtcblxuICAgIGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICB9O1xuXG4gIHZhciByZXNldEdMU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBfY3VycmVudFByb2dyYW0gPSBudWxsO1xuICAgIF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcblxuICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG4gICAgX2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xuXG4gICAgX2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgc3RhdGUucmVzZXQoKTtcblxuICB9O1xuXG4gIHNldERlZmF1bHRHTFN0YXRlKCk7XG5cbiAgdGhpcy5jb250ZXh0ID0gX2dsO1xuICB0aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICB0aGlzLnN0YXRlID0gc3RhdGU7XG5cbiAgLy8gc2hhZG93IG1hcFxuXG4gIHZhciBzaGFkb3dNYXAgPSBuZXcgVEhSRUUuV2ViR0xTaGFkb3dNYXAoIHRoaXMsIGxpZ2h0cywgb2JqZWN0cyApO1xuXG4gIHRoaXMuc2hhZG93TWFwID0gc2hhZG93TWFwO1xuXG4gIC8vIEdQVSBjYXBhYmlsaXRpZXNcblxuICB2YXIgX21heFRleHR1cmVzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG4gIHZhciBfbWF4VmVydGV4VGV4dHVyZXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG4gIHZhciBfbWF4VGV4dHVyZVNpemUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1RFWFRVUkVfU0laRSApO1xuICB2YXIgX21heEN1YmVtYXBTaXplID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9DVUJFX01BUF9URVhUVVJFX1NJWkUgKTtcblxuICB2YXIgX3N1cHBvcnRzVmVydGV4VGV4dHVyZXMgPSBfbWF4VmVydGV4VGV4dHVyZXMgPiAwO1xuICB2YXIgX3N1cHBvcnRzQm9uZVRleHR1cmVzID0gX3N1cHBvcnRzVmVydGV4VGV4dHVyZXMgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcbiAgdmFyIF9zdXBwb3J0c0luc3RhbmNlZEFycmF5cyA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAvL1xuXG4gIHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuSElHSF9GTE9BVCApO1xuICB2YXIgX3ZlcnRleFNoYWRlclByZWNpc2lvbk1lZGl1bXBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuTUVESVVNX0ZMT0FUICk7XG5cbiAgdmFyIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuRlJBR01FTlRfU0hBREVSLCBfZ2wuSElHSF9GTE9BVCApO1xuICB2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLkZSQUdNRU5UX1NIQURFUiwgX2dsLk1FRElVTV9GTE9BVCApO1xuXG4gIHZhciBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSAoIGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBhcnJheTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgIGlmICggYXJyYXkgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICByZXR1cm4gYXJyYXk7XG5cbiAgICAgIH1cblxuICAgICAgYXJyYXkgPSBbXTtcblxuICAgICAgaWYgKCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fCBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApICkge1xuXG4gICAgICAgIHZhciBmb3JtYXRzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICAgICAgICBhcnJheS5wdXNoKCBmb3JtYXRzWyBpIF0gKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5O1xuXG4gICAgfTtcblxuICB9ICkoKTtcblxuICAvLyBjbGFtcCBwcmVjaXNpb24gdG8gbWF4aW11bSBhdmFpbGFibGVcblxuICB2YXIgaGlnaHBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdC5wcmVjaXNpb24gPiAwICYmIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQucHJlY2lzaW9uID4gMDtcbiAgdmFyIG1lZGl1bXBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDAgJiYgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0LnByZWNpc2lvbiA+IDA7XG5cbiAgaWYgKCBfcHJlY2lzaW9uID09PSAnaGlnaHAnICYmICEgaGlnaHBBdmFpbGFibGUgKSB7XG5cbiAgICBpZiAoIG1lZGl1bXBBdmFpbGFibGUgKSB7XG5cbiAgICAgIF9wcmVjaXNpb24gPSAnbWVkaXVtcCc7XG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBoaWdocCBub3Qgc3VwcG9ydGVkLCB1c2luZyBtZWRpdW1wLicgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIF9wcmVjaXNpb24gPSAnbG93cCc7XG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBoaWdocCBhbmQgbWVkaXVtcCBub3Qgc3VwcG9ydGVkLCB1c2luZyBsb3dwLicgKTtcblxuICAgIH1cblxuICB9XG5cbiAgaWYgKCBfcHJlY2lzaW9uID09PSAnbWVkaXVtcCcgJiYgISBtZWRpdW1wQXZhaWxhYmxlICkge1xuXG4gICAgX3ByZWNpc2lvbiA9ICdsb3dwJztcbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBtZWRpdW1wIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIGxvd3AuJyApO1xuXG4gIH1cblxuICAvLyBQbHVnaW5zXG5cbiAgdmFyIHNwcml0ZVBsdWdpbiA9IG5ldyBUSFJFRS5TcHJpdGVQbHVnaW4oIHRoaXMsIHNwcml0ZXMgKTtcbiAgdmFyIGxlbnNGbGFyZVBsdWdpbiA9IG5ldyBUSFJFRS5MZW5zRmxhcmVQbHVnaW4oIHRoaXMsIGxlbnNGbGFyZXMgKTtcblxuICAvLyBBUElcblxuICB0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gX2dsO1xuXG4gIH07XG5cbiAgdGhpcy5mb3JjZUNvbnRleHRMb3NzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9sb3NlX2NvbnRleHQnICkubG9zZUNvbnRleHQoKTtcblxuICB9O1xuXG4gIHRoaXMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcztcblxuICB9O1xuXG4gIHRoaXMuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gX3N1cHBvcnRzSW5zdGFuY2VkQXJyYXlzO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcblxuICB9O1xuXG4gIHRoaXMuc3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXQnICk7XG5cbiAgfTtcblxuICB0aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBleHRlbnNpb25zLmdldCggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcblxuICB9O1xuXG4gIHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVMzVEMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcblxuICB9O1xuXG4gIHRoaXMuc3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xuXG4gIH07XG5cbiAgdGhpcy5zdXBwb3J0c0JsZW5kTWluTWF4ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuICB9O1xuXG4gIHRoaXMuZ2V0TWF4QW5pc290cm9weSA9ICggZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHZhbHVlO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgICAgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG5cbiAgICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICAgIHZhbHVlID0gX2dsLmdldFBhcmFtZXRlciggZXh0ZW5zaW9uLk1BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsdWU7XG5cbiAgICB9XG5cbiAgfSApKCk7XG5cbiAgdGhpcy5nZXRQcmVjaXNpb24gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gX3ByZWNpc2lvbjtcblxuICB9O1xuXG4gIHRoaXMuZ2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBwaXhlbFJhdGlvO1xuXG4gIH07XG5cbiAgdGhpcy5zZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICAgIGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHBpeGVsUmF0aW8gPSB2YWx1ZTtcblxuICB9O1xuXG4gIHRoaXMuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogX3dpZHRoLFxuICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgfTtcblxuICB9O1xuXG4gIHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgdXBkYXRlU3R5bGUgKSB7XG5cbiAgICBfd2lkdGggPSB3aWR0aDtcbiAgICBfaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgX2NhbnZhcy53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICBfY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cbiAgICBpZiAoIHVwZGF0ZVN0eWxlICE9PSBmYWxzZSApIHtcblxuICAgICAgX2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgIH1cblxuICAgIHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICB9O1xuXG4gIHRoaXMuc2V0Vmlld3BvcnQgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XG5cbiAgICBfdmlld3BvcnRYID0geCAqIHBpeGVsUmF0aW87XG4gICAgX3ZpZXdwb3J0WSA9IHkgKiBwaXhlbFJhdGlvO1xuXG4gICAgX3ZpZXdwb3J0V2lkdGggPSB3aWR0aCAqIHBpeGVsUmF0aW87XG4gICAgX3ZpZXdwb3J0SGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblxuICAgIF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xuXG4gIH07XG5cbiAgdGhpcy5zZXRTY2lzc29yID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgX2dsLnNjaXNzb3IoXG4gICAgICB4ICogcGl4ZWxSYXRpbyxcbiAgICAgIHkgKiBwaXhlbFJhdGlvLFxuICAgICAgd2lkdGggKiBwaXhlbFJhdGlvLFxuICAgICAgaGVpZ2h0ICogcGl4ZWxSYXRpb1xuICAgICk7XG5cbiAgfTtcblxuICB0aGlzLmVuYWJsZVNjaXNzb3JUZXN0ID0gZnVuY3Rpb24gKCBlbmFibGUgKSB7XG5cbiAgICBlbmFibGUgPyBfZ2wuZW5hYmxlKCBfZ2wuU0NJU1NPUl9URVNUICkgOiBfZ2wuZGlzYWJsZSggX2dsLlNDSVNTT1JfVEVTVCApO1xuXG4gIH07XG5cbiAgLy8gQ2xlYXJpbmdcblxuICB0aGlzLmdldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gX2NsZWFyQ29sb3I7XG5cbiAgfTtcblxuICB0aGlzLnNldENsZWFyQ29sb3IgPSBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcblxuICAgIF9jbGVhckNvbG9yLnNldCggY29sb3IgKTtcblxuICAgIF9jbGVhckFscGhhID0gYWxwaGEgIT09IHVuZGVmaW5lZCA/IGFscGhhIDogMTtcblxuICAgIGdsQ2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcblxuICB9O1xuXG4gIHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHJldHVybiBfY2xlYXJBbHBoYTtcblxuICB9O1xuXG4gIHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICggYWxwaGEgKSB7XG5cbiAgICBfY2xlYXJBbHBoYSA9IGFscGhhO1xuXG4gICAgZ2xDbGVhckNvbG9yKCBfY2xlYXJDb2xvci5yLCBfY2xlYXJDb2xvci5nLCBfY2xlYXJDb2xvci5iLCBfY2xlYXJBbHBoYSApO1xuXG4gIH07XG5cbiAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uICggY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xuXG4gICAgdmFyIGJpdHMgPSAwO1xuXG4gICAgaWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkIHx8IGNvbG9yICkgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcbiAgICBpZiAoIGRlcHRoID09PSB1bmRlZmluZWQgfHwgZGVwdGggKSBiaXRzIHw9IF9nbC5ERVBUSF9CVUZGRVJfQklUO1xuICAgIGlmICggc3RlbmNpbCA9PT0gdW5kZWZpbmVkIHx8IHN0ZW5jaWwgKSBiaXRzIHw9IF9nbC5TVEVOQ0lMX0JVRkZFUl9CSVQ7XG5cbiAgICBfZ2wuY2xlYXIoIGJpdHMgKTtcblxuICB9O1xuXG4gIHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIF9nbC5jbGVhciggX2dsLkNPTE9SX0JVRkZFUl9CSVQgKTtcblxuICB9O1xuXG4gIHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIF9nbC5jbGVhciggX2dsLkRFUFRIX0JVRkZFUl9CSVQgKTtcblxuICB9O1xuXG4gIHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xuXG4gICAgX2dsLmNsZWFyKCBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUICk7XG5cbiAgfTtcblxuICB0aGlzLmNsZWFyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcblxuICAgIHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcbiAgICB0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcblxuICB9O1xuXG4gIC8vIFJlc2V0XG5cbiAgdGhpcy5yZXNldEdMU3RhdGUgPSByZXNldEdMU3RhdGU7XG5cbiAgLy8gRXZlbnRzXG5cbiAgdmFyIG9uVGV4dHVyZURpc3Bvc2UgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgdmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XG5cbiAgICB0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKTtcblxuICAgIF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xuXG5cbiAgfTtcblxuICB2YXIgb25SZW5kZXJUYXJnZXREaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgIHZhciByZW5kZXJUYXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICByZW5kZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcblxuICAgIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xuXG4gICAgX3RoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgLS07XG5cbiAgfTtcblxuICB2YXIgb25NYXRlcmlhbERpc3Bvc2UgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xuXG4gICAgdmFyIG1hdGVyaWFsID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgbWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xuXG4gICAgZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gIH07XG5cbiAgLy8gQnVmZmVyIGRlYWxsb2NhdGlvblxuXG4gIHZhciBkZWFsbG9jYXRlVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcblxuICAgIGlmICggdGV4dHVyZS5pbWFnZSAmJiB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuICAgICAgLy8gY3ViZSB0ZXh0dXJlXG5cbiAgICAgIF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xuXG4gICAgICBkZWxldGUgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmU7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyAyRCB0ZXh0dXJlXG5cbiAgICAgIGlmICggdGV4dHVyZS5fX3dlYmdsSW5pdCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xuXG4gICAgICBfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgICBkZWxldGUgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZTtcbiAgICAgIGRlbGV0ZSB0ZXh0dXJlLl9fd2ViZ2xJbml0O1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdmFyIGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcblxuICAgIGlmICggISByZW5kZXJUYXJnZXQgfHwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBfZ2wuZGVsZXRlVGV4dHVyZSggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICBkZWxldGUgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlO1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgICAgX2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcbiAgICAgICAgX2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSApO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgKTtcbiAgICAgIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cbiAgICB9XG5cbiAgICBkZWxldGUgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlcjtcbiAgICBkZWxldGUgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXI7XG5cbiAgfTtcblxuICB2YXIgZGVhbGxvY2F0ZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcblxuICAgIHZhciBwcm9ncmFtID0gbWF0ZXJpYWwucHJvZ3JhbS5wcm9ncmFtO1xuXG4gICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cbiAgICBtYXRlcmlhbC5wcm9ncmFtID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gb25seSBkZWFsbG9jYXRlIEdMIHByb2dyYW0gaWYgdGhpcyB3YXMgdGhlIGxhc3QgdXNlIG9mIHNoYXJlZCBwcm9ncmFtXG4gICAgLy8gYXNzdW1lZCB0aGVyZSBpcyBvbmx5IHNpbmdsZSBjb3B5IG9mIGFueSBwcm9ncmFtIGluIHRoZSBfcHJvZ3JhbXMgbGlzdFxuICAgIC8vICh0aGF0J3MgaG93IGl0J3MgY29uc3RydWN0ZWQpXG5cbiAgICB2YXIgaSwgaWwsIHByb2dyYW1JbmZvO1xuICAgIHZhciBkZWxldGVQcm9ncmFtID0gZmFsc2U7XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHByb2dyYW1JbmZvID0gX3Byb2dyYW1zWyBpIF07XG5cbiAgICAgIGlmICggcHJvZ3JhbUluZm8ucHJvZ3JhbSA9PT0gcHJvZ3JhbSApIHtcblxuICAgICAgICBwcm9ncmFtSW5mby51c2VkVGltZXMgLS07XG5cbiAgICAgICAgaWYgKCBwcm9ncmFtSW5mby51c2VkVGltZXMgPT09IDAgKSB7XG5cbiAgICAgICAgICBkZWxldGVQcm9ncmFtID0gdHJ1ZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggZGVsZXRlUHJvZ3JhbSA9PT0gdHJ1ZSApIHtcblxuICAgICAgLy8gYXZvaWQgdXNpbmcgYXJyYXkuc3BsaWNlLCB0aGlzIGlzIGNvc3RsaWVyIHRoYW4gY3JlYXRpbmcgbmV3IGFycmF5IGZyb20gc2NyYXRjaFxuXG4gICAgICB2YXIgbmV3UHJvZ3JhbXMgPSBbXTtcblxuICAgICAgZm9yICggaSA9IDAsIGlsID0gX3Byb2dyYW1zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIHByb2dyYW1JbmZvID0gX3Byb2dyYW1zWyBpIF07XG5cbiAgICAgICAgaWYgKCBwcm9ncmFtSW5mby5wcm9ncmFtICE9PSBwcm9ncmFtICkge1xuXG4gICAgICAgICAgbmV3UHJvZ3JhbXMucHVzaCggcHJvZ3JhbUluZm8gKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgX3Byb2dyYW1zID0gbmV3UHJvZ3JhbXM7XG5cbiAgICAgIF9nbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICAgIF90aGlzLmluZm8ubWVtb3J5LnByb2dyYW1zIC0tO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgLy8gQnVmZmVyIHJlbmRlcmluZ1xuXG4gIHRoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlID0gZnVuY3Rpb24gKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xuXG4gICAgc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcblxuICAgIGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyAmJiAhIG9iamVjdC5fX3dlYmdsVmVydGV4QnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgaWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgaWYgKCBvYmplY3QuaGFzVXZzICYmICEgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciApIG9iamVjdC5fX3dlYmdsVXZCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgaWYgKCBvYmplY3QuaGFzQ29sb3JzICYmICEgb2JqZWN0Ll9fd2ViZ2xDb2xvckJ1ZmZlciApIG9iamVjdC5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG4gICAgaWYgKCBvYmplY3QuaGFzUG9zaXRpb25zICkge1xuXG4gICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcbiAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QucG9zaXRpb25BcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcbiAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdC5oYXNOb3JtYWxzICkge1xuXG4gICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcblxuICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsID09PSBmYWxzZSAmJiBtYXRlcmlhbC5zaGFkaW5nID09PSBUSFJFRS5GbGF0U2hhZGluZyApIHtcblxuICAgICAgICB2YXIgbngsIG55LCBueixcbiAgICAgICAgICBuYXgsIG5ieCwgbmN4LCBuYXksIG5ieSwgbmN5LCBuYXosIG5ieiwgbmN6LFxuICAgICAgICAgIG5vcm1hbEFycmF5LFxuICAgICAgICAgIGksIGlsID0gb2JqZWN0LmNvdW50ICogMztcblxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpICs9IDkgKSB7XG5cbiAgICAgICAgICBub3JtYWxBcnJheSA9IG9iamVjdC5ub3JtYWxBcnJheTtcblxuICAgICAgICAgIG5heCA9IG5vcm1hbEFycmF5WyBpIF07XG4gICAgICAgICAgbmF5ID0gbm9ybWFsQXJyYXlbIGkgKyAxIF07XG4gICAgICAgICAgbmF6ID0gbm9ybWFsQXJyYXlbIGkgKyAyIF07XG5cbiAgICAgICAgICBuYnggPSBub3JtYWxBcnJheVsgaSArIDMgXTtcbiAgICAgICAgICBuYnkgPSBub3JtYWxBcnJheVsgaSArIDQgXTtcbiAgICAgICAgICBuYnogPSBub3JtYWxBcnJheVsgaSArIDUgXTtcblxuICAgICAgICAgIG5jeCA9IG5vcm1hbEFycmF5WyBpICsgNiBdO1xuICAgICAgICAgIG5jeSA9IG5vcm1hbEFycmF5WyBpICsgNyBdO1xuICAgICAgICAgIG5jeiA9IG5vcm1hbEFycmF5WyBpICsgOCBdO1xuXG4gICAgICAgICAgbnggPSAoIG5heCArIG5ieCArIG5jeCApIC8gMztcbiAgICAgICAgICBueSA9ICggbmF5ICsgbmJ5ICsgbmN5ICkgLyAzO1xuICAgICAgICAgIG56ID0gKCBuYXogKyBuYnogKyBuY3ogKSAvIDM7XG5cbiAgICAgICAgICBub3JtYWxBcnJheVsgaSAgICAgXSA9IG54O1xuICAgICAgICAgIG5vcm1hbEFycmF5WyBpICsgMSBdID0gbnk7XG4gICAgICAgICAgbm9ybWFsQXJyYXlbIGkgKyAyIF0gPSBuejtcblxuICAgICAgICAgIG5vcm1hbEFycmF5WyBpICsgMyBdID0gbng7XG4gICAgICAgICAgbm9ybWFsQXJyYXlbIGkgKyA0IF0gPSBueTtcbiAgICAgICAgICBub3JtYWxBcnJheVsgaSArIDUgXSA9IG56O1xuXG4gICAgICAgICAgbm9ybWFsQXJyYXlbIGkgKyA2IF0gPSBueDtcbiAgICAgICAgICBub3JtYWxBcnJheVsgaSArIDcgXSA9IG55O1xuICAgICAgICAgIG5vcm1hbEFycmF5WyBpICsgOCBdID0gbno7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3Qubm9ybWFsQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xuXG4gICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5ub3JtYWwsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgIH1cblxuICAgIGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XG5cbiAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbFV2QnVmZmVyICk7XG4gICAgICBfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcblxuICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XG5cbiAgICAgIF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgbWF0ZXJpYWwudmVydGV4Q29sb3JzICE9PSBUSFJFRS5Ob0NvbG9ycyApIHtcblxuICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcbiAgICAgIF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuY29sb3JBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xuXG4gICAgICBzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcblxuICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuICAgIH1cblxuICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICBfZ2wuZHJhd0FycmF5cyggX2dsLlRSSUFOR0xFUywgMCwgb2JqZWN0LmNvdW50ICk7XG5cbiAgICBvYmplY3QuY291bnQgPSAwO1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XG5cbiAgICB2YXIgZXh0ZW5zaW9uO1xuXG4gICAgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xuXG4gICAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XG5cbiAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xuXG4gICAgdmFyIHByb2dyYW1BdHRyaWJ1dGVzID0gcHJvZ3JhbS5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICB2YXIgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcblxuICAgIGZvciAoIHZhciBuYW1lIGluIHByb2dyYW1BdHRyaWJ1dGVzICkge1xuXG4gICAgICB2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICAgIGlmICggcHJvZ3JhbUF0dHJpYnV0ZSA+PSAwICkge1xuXG4gICAgICAgIHZhciBnZW9tZXRyeUF0dHJpYnV0ZSA9IGdlb21ldHJ5QXR0cmlidXRlc1sgbmFtZSBdO1xuXG4gICAgICAgIGlmICggZ2VvbWV0cnlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIHZhciBzaXplID0gZ2VvbWV0cnlBdHRyaWJ1dGUuaXRlbVNpemU7XG4gICAgICAgICAgc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XG5cbiAgICAgICAgICBpZiAoIGdlb21ldHJ5QXR0cmlidXRlIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gZ2VvbWV0cnlBdHRyaWJ1dGUuZGF0YTtcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5vZmZzZXQ7XG5cbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhLmJ1ZmZlciApO1xuICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGUsIHNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIHN0cmlkZSAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsICggc3RhcnRJbmRleCAqIHN0cmlkZSArIG9mZnNldCApICogZGF0YS5hcnJheS5CWVRFU19QRVJfRUxFTUVOVCApO1xuXG4gICAgICAgICAgICBpZiAoIGRhdGEgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRJbnRlcmxlYXZlZEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIHByb2dyYW1BdHRyaWJ1dGUsIGRhdGEubWVzaFBlckF0dHJpYnV0ZSApO1xuXG4gICAgICAgICAgICAgIGlmICggZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICAgIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZGF0YS5tZXNoUGVyQXR0cmlidXRlICogKCBkYXRhLmFycmF5Lmxlbmd0aCAvIGRhdGEuc3RyaWRlICk7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlBdHRyaWJ1dGUuYnVmZmVyICk7XG4gICAgICAgICAgICBfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiA0ICk7IC8vIDQgYnl0ZXMgcGVyIEZsb2F0MzJcblxuICAgICAgICAgICAgaWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlIGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKTtcblxuICAgICAgICAgICAgICBpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgICAgICBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9IGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKiAoIGdlb21ldHJ5QXR0cmlidXRlLmFycmF5Lmxlbmd0aCAvIGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplICk7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBtYXRlcmlhbERlZmF1bHRBdHRyaWJ1dGVWYWx1ZXNbIG5hbWUgXTtcbiAgICAgICAgICBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjNmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgX2dsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgfVxuXG4gIHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xuXG4gICAgaWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdHMuZ2VvbWV0cmllcy5nZXQoIG9iamVjdCApO1xuICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgdmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZSxcbiAgICAgIHdpcmVmcmFtZUJpdCA9IG1hdGVyaWFsLndpcmVmcmFtZSA/IDEgOiAwLFxuICAgICAgZ2VvbWV0cnlQcm9ncmFtID0gZ2VvbWV0cnkuaWQgKyAnXycgKyBwcm9ncmFtLmlkICsgJ18nICsgd2lyZWZyYW1lQml0O1xuXG4gICAgaWYgKCBnZW9tZXRyeVByb2dyYW0gIT09IF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtICkge1xuXG4gICAgICBfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5UHJvZ3JhbTtcbiAgICAgIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICBzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xuXG4gICAgfVxuXG4gICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG4gICAgICByZW5kZXJNZXNoKCBtYXRlcmlhbCwgZ2VvbWV0cnksIG9iamVjdCwgcHJvZ3JhbSwgdXBkYXRlQnVmZmVycyApO1xuXG4gICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuICAgICAgcmVuZGVyTGluZSggbWF0ZXJpYWwsIGdlb21ldHJ5LCBvYmplY3QsIHByb2dyYW0sIHVwZGF0ZUJ1ZmZlcnMgKTtcblxuICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50Q2xvdWQgKSB7XG5cbiAgICAgIHJlbmRlclBvaW50Q2xvdWQoIG1hdGVyaWFsLCBnZW9tZXRyeSwgb2JqZWN0LCBwcm9ncmFtLCB1cGRhdGVCdWZmZXJzICk7XG5cbiAgICB9XG5cbiAgfTtcblxuICBmdW5jdGlvbiByZW5kZXJNZXNoKCBtYXRlcmlhbCwgZ2VvbWV0cnksIG9iamVjdCwgcHJvZ3JhbSwgdXBkYXRlQnVmZmVycyApIHtcblxuICAgIHZhciBtb2RlID0gbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlID8gX2dsLkxJTkVTIDogX2dsLlRSSUFOR0xFUztcblxuICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5kZXg7XG5cbiAgICBpZiAoIGluZGV4ICkge1xuXG4gICAgICAvLyBpbmRleGVkIHRyaWFuZ2xlc1xuXG4gICAgICB2YXIgdHlwZSwgc2l6ZTtcblxuICAgICAgaWYgKCBpbmRleC5hcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICYmIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKSApIHtcblxuICAgICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX0lOVDtcbiAgICAgICAgc2l6ZSA9IDQ7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdHlwZSA9IF9nbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgc2l6ZSA9IDI7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xuXG4gICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgIGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuICAgICAgICAgIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCAwICk7XG4gICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSAmJiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA+IDAgKSB7XG5cbiAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgICAgICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlck1lc2g6IHVzaW5nIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckdlb21ldHJ5IGJ1dCBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IGV4dGVuc2lvbiBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzLicgKTtcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGV4dGVuc2lvbi5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRSggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwLCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApOyAvLyBEcmF3IHRoZSBpbnN0YW5jZWQgbWVzaGVzXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIF9nbC5kcmF3RWxlbWVudHMoIG1vZGUsIGluZGV4LmFycmF5Lmxlbmd0aCwgdHlwZSwgMCApO1xuXG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG4gICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IGluZGV4LmFycmF5Lmxlbmd0aDsgLy8gbm90IHJlYWxseSB0cnVlLCBoZXJlIHZlcnRpY2VzIGNhbiBiZSBzaGFyZWRcbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gaW5kZXguYXJyYXkubGVuZ3RoIC8gMztcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gMSBjaHVua1xuICAgICAgICAvLyBtdXN0IHNldCBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gdXNlIG5ldyBvZmZzZXRzIGZvciBlYWNoIGNodW5rXG4gICAgICAgIC8vIGV2ZW4gaWYgZ2VvbWV0cnkgYW5kIG1hdGVyaWFscyBkaWRuJ3QgY2hhbmdlXG5cbiAgICAgICAgdXBkYXRlQnVmZmVycyA9IHRydWU7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICB2YXIgc3RhcnRJbmRleCA9IG9mZnNldHNbIGkgXS5pbmRleDtcblxuICAgICAgICAgIGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuICAgICAgICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKTtcbiAgICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gcmVuZGVyIGluZGV4ZWQgdHJpYW5nbGVzXG5cbiAgICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgJiYgb2Zmc2V0c1tpXS5pbnN0YW5jZXMgPiAwICkge1xuXG4gICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xuXG4gICAgICAgICAgICBpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcblxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXJNZXNoOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleHRlbnNpb24uZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIG9mZnNldHNbaV0uY291bnQsIHR5cGUsIG9mZnNldHNbaV0uc3RhcnQgKiBzaXplLCBvZmZzZXRzW2ldLmNvdW50LCB0eXBlLCBvZmZzZXRzW2ldLmluc3RhbmNlcyApOyAvLyBEcmF3IHRoZSBpbnN0YW5jZWQgbWVzaGVzXG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfZ2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBvZmZzZXRzWyBpIF0uY291bnQsIHR5cGUsIG9mZnNldHNbIGkgXS5zdGFydCAqIHNpemUgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudDsgLy8gbm90IHJlYWxseSB0cnVlLCBoZXJlIHZlcnRpY2VzIGNhbiBiZSBzaGFyZWRcbiAgICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5mYWNlcyArPSBvZmZzZXRzWyBpIF0uY291bnQgLyAzO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gbm9uLWluZGV4ZWQgdHJpYW5nbGVzXG5cbiAgICAgIHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuICAgICAgaWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgMCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG4gICAgICAgIC8vIHJlbmRlciBub24taW5kZXhlZCB0cmlhbmdsZXNcblxuICAgICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgJiYgZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPiAwICkge1xuXG4gICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcblxuICAgICAgICAgIGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xuXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZW5kZXJNZXNoOiB1c2luZyBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSBidXQgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBleHRlbnNpb24gQU5HTEVfaW5zdGFuY2VkX2FycmF5cy4nICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIHBvc2l0aW9uIGluc3RhbmNlb2YgVEhSRUUuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XG5cbiAgICAgICAgICAgIGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIHBvc2l0aW9uLmRhdGEuYXJyYXkubGVuZ3RoIC8gcG9zaXRpb24uZGF0YS5zdHJpZGUsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7IC8vIERyYXcgdGhlIGluc3RhbmNlZCBtZXNoZXNcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIHBvc2l0aW9uLml0ZW1TaXplLCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApOyAvLyBEcmF3IHRoZSBpbnN0YW5jZWQgbWVzaGVzXG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmICggcG9zaXRpb24gaW5zdGFuY2VvZiBUSFJFRS5JbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuICAgICAgICAgICAgX2dsLmRyYXdBcnJheXMoIG1vZGUsIDAsIHBvc2l0aW9uLmRhdGEuYXJyYXkubGVuZ3RoIC8gcG9zaXRpb24uZGF0YS5zdHJpZGUgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIF9nbC5kcmF3QXJyYXlzKCBtb2RlLCAwLCBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyBwb3NpdGlvbi5pdGVtU2l6ZSApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5jYWxscysrO1xuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyBwb3NpdGlvbi5pdGVtU2l6ZTtcbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gcG9zaXRpb24uYXJyYXkubGVuZ3RoIC8gKCAzICogcG9zaXRpb24uaXRlbVNpemUgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gMSBjaHVua1xuICAgICAgICAvLyBtdXN0IHNldCBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gdXNlIG5ldyBvZmZzZXRzIGZvciBlYWNoIGNodW5rXG4gICAgICAgIC8vIGV2ZW4gaWYgZ2VvbWV0cnkgYW5kIG1hdGVyaWFscyBkaWRuJ3QgY2hhbmdlXG5cbiAgICAgICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcblxuICAgICAgICAgIC8vIHJlbmRlciBub24taW5kZXhlZCB0cmlhbmdsZXNcblxuICAgICAgICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyTWVzaDogY2Fubm90IHVzZSBkcmF3Q2FsbHMgd2l0aCBUSFJFRS5JbnN0YW5jZWRCdWZmZXJHZW9tZXRyeS4nICk7XG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfZ2wuZHJhd0FycmF5cyggbW9kZSwgb2Zmc2V0c1sgaSBdLnN0YXJ0LCBvZmZzZXRzWyBpIF0uY291bnQgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzKys7XG4gICAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gb2Zmc2V0c1sgaSBdLmNvdW50O1xuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICs9ICggb2Zmc2V0c1sgaSBdLmNvdW50ICApIC8gMztcblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJMaW5lKCBtYXRlcmlhbCwgZ2VvbWV0cnksIG9iamVjdCwgcHJvZ3JhbSwgdXBkYXRlQnVmZmVycyApIHtcblxuICAgIHZhciBtb2RlID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZVNlZ21lbnRzID8gX2dsLkxJTkVTIDogX2dsLkxJTkVfU1RSSVA7XG5cbiAgICAvLyBJbiBjYXNlIHVzZXIgaXMgbm90IHVzaW5nIExpbmUqTWF0ZXJpYWwgYnkgbWlzdGFrZVxuICAgIHZhciBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsLmxpbmV3aWR0aCA6IDE7XG5cbiAgICBzdGF0ZS5zZXRMaW5lV2lkdGgoIGxpbmVXaWR0aCAqIHBpeGVsUmF0aW8gKTtcblxuICAgIHZhciBpbmRleCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5kZXg7XG5cbiAgICBpZiAoIGluZGV4ICkge1xuXG4gICAgICAvLyBpbmRleGVkIGxpbmVzXG5cbiAgICAgIHZhciB0eXBlLCBzaXplO1xuXG4gICAgICBpZiAoIGluZGV4LmFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgJiYgZXh0ZW5zaW9ucy5nZXQoICdPRVNfZWxlbWVudF9pbmRleF91aW50JyApICkge1xuXG4gICAgICAgIHR5cGUgPSBfZ2wuVU5TSUdORURfSU5UO1xuICAgICAgICBzaXplID0gNDtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICB0eXBlID0gX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICBzaXplID0gMjtcblxuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cbiAgICAgIGlmICggb2Zmc2V0cy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcbiAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleC5idWZmZXIgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgX2dsLmRyYXdFbGVtZW50cyggbW9kZSwgaW5kZXguYXJyYXkubGVuZ3RoLCB0eXBlLCAwICk7IC8vIDIgYnl0ZXMgcGVyIFVpbnQxNkFycmF5XG5cbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG4gICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IGluZGV4LmFycmF5Lmxlbmd0aDsgLy8gbm90IHJlYWxseSB0cnVlLCBoZXJlIHZlcnRpY2VzIGNhbiBiZSBzaGFyZWRcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gMSBjaHVua1xuICAgICAgICAvLyBtdXN0IHNldCBhdHRyaWJ1dGUgcG9pbnRlcnMgdG8gdXNlIG5ldyBvZmZzZXRzIGZvciBlYWNoIGNodW5rXG4gICAgICAgIC8vIGV2ZW4gaWYgZ2VvbWV0cnkgYW5kIG1hdGVyaWFscyBkaWRuJ3QgY2hhbmdlXG5cbiAgICAgICAgaWYgKCBvZmZzZXRzLmxlbmd0aCA+IDEgKSB1cGRhdGVCdWZmZXJzID0gdHJ1ZTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2Zmc2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gb2Zmc2V0c1sgaSBdLmluZGV4O1xuXG4gICAgICAgICAgaWYgKCB1cGRhdGVCdWZmZXJzICkge1xuXG4gICAgICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgc3RhcnRJbmRleCApO1xuICAgICAgICAgICAgX2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kZXguYnVmZmVyICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyByZW5kZXIgaW5kZXhlZCBsaW5lc1xuXG4gICAgICAgICAgX2dsLmRyYXdFbGVtZW50cyggbW9kZSwgb2Zmc2V0c1sgaSBdLmNvdW50LCB0eXBlLCBvZmZzZXRzWyBpIF0uc3RhcnQgKiBzaXplICk7IC8vIDIgYnl0ZXMgcGVyIFVpbnQxNkFycmF5XG5cbiAgICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcbiAgICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBvZmZzZXRzWyBpIF0uY291bnQ7IC8vIG5vdCByZWFsbHkgdHJ1ZSwgaGVyZSB2ZXJ0aWNlcyBjYW4gYmUgc2hhcmVkXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBub24taW5kZXhlZCBsaW5lc1xuXG4gICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgICAgc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIDAgKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuICAgICAgdmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xuXG4gICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgIF9nbC5kcmF3QXJyYXlzKCBtb2RlLCAwLCBwb3NpdGlvbi5hcnJheS5sZW5ndGggLyAzICk7XG5cbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XG4gICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICBfZ2wuZHJhd0FycmF5cyggbW9kZSwgb2Zmc2V0c1sgaSBdLmluZGV4LCBvZmZzZXRzWyBpIF0uY291bnQgKTtcblxuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudDtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUG9pbnRDbG91ZCggbWF0ZXJpYWwsIGdlb21ldHJ5LCBvYmplY3QsIHByb2dyYW0sIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICB2YXIgbW9kZSA9IF9nbC5QT0lOVFM7XG5cbiAgICB2YXIgaW5kZXggPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLmluZGV4O1xuXG4gICAgaWYgKCBpbmRleCApIHtcblxuICAgICAgLy8gaW5kZXhlZCBwb2ludHNcblxuICAgICAgdmFyIHR5cGUsIHNpemU7XG5cbiAgICAgIGlmICggaW5kZXguYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSAmJiBleHRlbnNpb25zLmdldCggJ09FU19lbGVtZW50X2luZGV4X3VpbnQnICkgKSB7XG5cbiAgICAgICAgdHlwZSA9IF9nbC5VTlNJR05FRF9JTlQ7XG4gICAgICAgIHNpemUgPSA0O1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHR5cGUgPSBfZ2wuVU5TSUdORURfU0hPUlQ7XG4gICAgICAgIHNpemUgPSAyO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXRzID0gZ2VvbWV0cnkub2Zmc2V0cztcblxuICAgICAgaWYgKCBvZmZzZXRzLmxlbmd0aCA9PT0gMCApIHtcblxuICAgICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgMCApO1xuICAgICAgICAgIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfZ2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBpbmRleC5hcnJheS5sZW5ndGgsIHR5cGUsIDApO1xuXG4gICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5wb2ludHMgKz0gaW5kZXguYXJyYXkubGVuZ3RoO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiAxIGNodW5rXG4gICAgICAgIC8vIG11c3Qgc2V0IGF0dHJpYnV0ZSBwb2ludGVycyB0byB1c2UgbmV3IG9mZnNldHMgZm9yIGVhY2ggY2h1bmtcbiAgICAgICAgLy8gZXZlbiBpZiBnZW9tZXRyeSBhbmQgbWF0ZXJpYWxzIGRpZG4ndCBjaGFuZ2VcblxuICAgICAgICBpZiAoIG9mZnNldHMubGVuZ3RoID4gMSApIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBvZmZzZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgdmFyIHN0YXJ0SW5kZXggPSBvZmZzZXRzWyBpIF0uaW5kZXg7XG5cbiAgICAgICAgICBpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XG5cbiAgICAgICAgICAgIHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5LCBzdGFydEluZGV4ICk7XG4gICAgICAgICAgICBfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleC5idWZmZXIgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlbmRlciBpbmRleGVkIHBvaW50c1xuXG4gICAgICAgICAgX2dsLmRyYXdFbGVtZW50cyggbW9kZSwgb2Zmc2V0c1sgaSBdLmNvdW50LCB0eXBlLCBvZmZzZXRzWyBpIF0uc3RhcnQgKiBzaXplICk7XG5cbiAgICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcbiAgICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5wb2ludHMgKz0gb2Zmc2V0c1sgaSBdLmNvdW50O1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gbm9uLWluZGV4ZWQgcG9pbnRzXG5cbiAgICAgIGlmICggdXBkYXRlQnVmZmVycyApIHtcblxuICAgICAgICBzZXR1cFZlcnRleEF0dHJpYnV0ZXMoIG1hdGVyaWFsLCBwcm9ncmFtLCBnZW9tZXRyeSwgMCApO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICB2YXIgb2Zmc2V0cyA9IGdlb21ldHJ5Lm9mZnNldHM7XG5cbiAgICAgIGlmICggb2Zmc2V0cy5sZW5ndGggPT09IDAgKSB7XG5cbiAgICAgICAgX2dsLmRyYXdBcnJheXMoIG1vZGUsIDAsIHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDMgKTtcblxuICAgICAgICBfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcbiAgICAgICAgX3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IHBvc2l0aW9uLmFycmF5Lmxlbmd0aCAvIDM7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG9mZnNldHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICBfZ2wuZHJhd0FycmF5cyggbW9kZSwgb2Zmc2V0c1sgaSBdLmluZGV4LCBvZmZzZXRzWyBpIF0uY291bnQgKTtcblxuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xuICAgICAgICAgIF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyArPSBvZmZzZXRzWyBpIF0uY291bnQ7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIFNvcnRpbmdcblxuICBmdW5jdGlvbiBwYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XG5cbiAgICBpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcblxuICAgICAgcmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XG5cbiAgICB9IGVsc2UgaWYgKCBhLm9iamVjdC5tYXRlcmlhbC5pZCAhPT0gYi5vYmplY3QubWF0ZXJpYWwuaWQgKSB7XG5cbiAgICAgIHJldHVybiBhLm9iamVjdC5tYXRlcmlhbC5pZCAtIGIub2JqZWN0Lm1hdGVyaWFsLmlkO1xuXG4gICAgfSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XG5cbiAgICAgIHJldHVybiBhLnogLSBiLno7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSAoIGEsIGIgKSB7XG5cbiAgICBpZiAoIGEub2JqZWN0LnJlbmRlck9yZGVyICE9PSBiLm9iamVjdC5yZW5kZXJPcmRlciApIHtcblxuICAgICAgcmV0dXJuIGEub2JqZWN0LnJlbmRlck9yZGVyIC0gYi5vYmplY3QucmVuZGVyT3JkZXI7XG5cbiAgICB9IGlmICggYS56ICE9PSBiLnogKSB7XG5cbiAgICAgIHJldHVybiBiLnogLSBhLno7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIFJlbmRlcmluZ1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCByZW5kZXJUYXJnZXQsIGZvcmNlQ2xlYXIgKSB7XG5cbiAgICBpZiAoIGNhbWVyYSBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuXG4gICAgdmFyIGZvZyA9IHNjZW5lLmZvZztcblxuICAgIC8vIHJlc2V0IGNhY2hpbmcgZm9yIHRoaXMgZnJhbWVcblxuICAgIF9jdXJyZW50R2VvbWV0cnlQcm9ncmFtID0gJyc7XG4gICAgX2N1cnJlbnRNYXRlcmlhbElkID0gLSAxO1xuICAgIF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcbiAgICBfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgICAvLyB1cGRhdGUgc2NlbmUgZ3JhcGhcblxuICAgIGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXG5cbiAgICBpZiAoIGNhbWVyYS5wYXJlbnQgPT09IHVuZGVmaW5lZCApIGNhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcblxuICAgIF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgX2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcblxuICAgIGxpZ2h0cy5sZW5ndGggPSAwO1xuICAgIG9wYXF1ZU9iamVjdHMubGVuZ3RoID0gMDtcbiAgICB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoID0gMDtcblxuICAgIHNwcml0ZXMubGVuZ3RoID0gMDtcbiAgICBsZW5zRmxhcmVzLmxlbmd0aCA9IDA7XG5cbiAgICBwcm9qZWN0T2JqZWN0KCBzY2VuZSApO1xuXG4gICAgaWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgb3BhcXVlT2JqZWN0cy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuICAgICAgdHJhbnNwYXJlbnRPYmplY3RzLnNvcnQoIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSApO1xuXG4gICAgfVxuXG4gICAgb2JqZWN0cy51cGRhdGUoIG9wYXF1ZU9iamVjdHMgKTtcbiAgICBvYmplY3RzLnVwZGF0ZSggdHJhbnNwYXJlbnRPYmplY3RzICk7XG5cbiAgICAvL1xuXG4gICAgc2hhZG93TWFwLnJlbmRlciggc2NlbmUsIGNhbWVyYSApO1xuXG4gICAgLy9cblxuICAgIF90aGlzLmluZm8ucmVuZGVyLmNhbGxzID0gMDtcbiAgICBfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyA9IDA7XG4gICAgX3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgPSAwO1xuICAgIF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyA9IDA7XG5cbiAgICB0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICBpZiAoIHRoaXMuYXV0b0NsZWFyIHx8IGZvcmNlQ2xlYXIgKSB7XG5cbiAgICAgIHRoaXMuY2xlYXIoIHRoaXMuYXV0b0NsZWFyQ29sb3IsIHRoaXMuYXV0b0NsZWFyRGVwdGgsIHRoaXMuYXV0b0NsZWFyU3RlbmNpbCApO1xuXG4gICAgfVxuXG4gICAgLy8gc2V0IG1hdHJpY2VzIGZvciBpbW1lZGlhdGUgb2JqZWN0c1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG9iamVjdHMub2JqZWN0c0ltbWVkaWF0ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmFyIHdlYmdsT2JqZWN0ID0gb2JqZWN0cy5vYmplY3RzSW1tZWRpYXRlWyBpIF07XG4gICAgICB2YXIgb2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXG4gICAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgICAgIHNldHVwTWF0cmljZXMoIG9iamVjdCwgY2FtZXJhICk7XG5cbiAgICAgICAgdmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XG5cbiAgICAgICAgICB3ZWJnbE9iamVjdC50cmFuc3BhcmVudCA9IG1hdGVyaWFsO1xuICAgICAgICAgIHdlYmdsT2JqZWN0Lm9wYXF1ZSA9IG51bGw7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHdlYmdsT2JqZWN0Lm9wYXF1ZSA9IG1hdGVyaWFsO1xuICAgICAgICAgIHdlYmdsT2JqZWN0LnRyYW5zcGFyZW50ID0gbnVsbDtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuICAgICAgdmFyIG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xuXG4gICAgICBzZXRNYXRlcmlhbCggb3ZlcnJpZGVNYXRlcmlhbCApO1xuXG4gICAgICByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICk7XG4gICAgICByZW5kZXJPYmplY3RzKCB0cmFuc3BhcmVudE9iamVjdHMsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcbiAgICAgIHJlbmRlck9iamVjdHNJbW1lZGlhdGUoIG9iamVjdHMub2JqZWN0c0ltbWVkaWF0ZSwgJycsIGNhbWVyYSwgbGlnaHRzLCBmb2csIG92ZXJyaWRlTWF0ZXJpYWwgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIG9wYXF1ZSBwYXNzIChmcm9udC10by1iYWNrIG9yZGVyKVxuXG4gICAgICBzdGF0ZS5zZXRCbGVuZGluZyggVEhSRUUuTm9CbGVuZGluZyApO1xuXG4gICAgICByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBudWxsICk7XG4gICAgICByZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBvYmplY3RzLm9iamVjdHNJbW1lZGlhdGUsICdvcGFxdWUnLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBudWxsICk7XG5cbiAgICAgIC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXG5cbiAgICAgIHJlbmRlck9iamVjdHMoIHRyYW5zcGFyZW50T2JqZWN0cywgY2FtZXJhLCBsaWdodHMsIGZvZywgbnVsbCApO1xuICAgICAgcmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggb2JqZWN0cy5vYmplY3RzSW1tZWRpYXRlLCAndHJhbnNwYXJlbnQnLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBudWxsICk7XG5cbiAgICB9XG5cbiAgICAvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnMgKHBvc3QgcGFzcylcblxuICAgIHNwcml0ZVBsdWdpbi5yZW5kZXIoIHNjZW5lLCBjYW1lcmEgKTtcbiAgICBsZW5zRmxhcmVQbHVnaW4ucmVuZGVyKCBzY2VuZSwgY2FtZXJhLCBfY3VycmVudFdpZHRoLCBfY3VycmVudEhlaWdodCApO1xuXG4gICAgLy8gR2VuZXJhdGUgbWlwbWFwIGlmIHdlJ3JlIHVzaW5nIGFueSBraW5kIG9mIG1pcG1hcCBmaWx0ZXJpbmdcblxuICAgIGlmICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHMgJiYgcmVuZGVyVGFyZ2V0Lm1pbkZpbHRlciAhPT0gVEhSRUUuTmVhcmVzdEZpbHRlciAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICAgIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgZGVwdGggYnVmZmVyIHdyaXRpbmcgaXMgZW5hYmxlZCBzbyBpdCBjYW4gYmUgY2xlYXJlZCBvbiBuZXh0IHJlbmRlclxuXG4gICAgc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG4gICAgc3RhdGUuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xuICAgIHN0YXRlLnNldENvbG9yV3JpdGUoIHRydWUgKTtcblxuICAgIC8vIF9nbC5maW5pc2goKTtcblxuICB9O1xuXG4gIGZ1bmN0aW9uIHByb2plY3RPYmplY3QoIG9iamVjdCApIHtcblxuICAgIGlmICggb2JqZWN0LnZpc2libGUgPT09IHRydWUgKSB7XG5cbiAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2NlbmUgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuR3JvdXAgKSB7XG5cbiAgICAgICAgLy8gc2tpcFxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIHVwZGF0ZSBTa2VsZXRvbiBvYmplY3RzXG4gICAgICAgIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cbiAgICAgICAgICBvYmplY3Quc2tlbGV0b24udXBkYXRlKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdHMuaW5pdCggb2JqZWN0ICk7XG5cbiAgICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcblxuICAgICAgICAgIGxpZ2h0cy5wdXNoKCBvYmplY3QgKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5TcHJpdGUgKSB7XG5cbiAgICAgICAgICBzcHJpdGVzLnB1c2goIG9iamVjdCApO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSApIHtcblxuICAgICAgICAgIGxlbnNGbGFyZXMucHVzaCggb2JqZWN0ICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHZhciB3ZWJnbE9iamVjdCA9IG9iamVjdHMub2JqZWN0c1sgb2JqZWN0LmlkIF07XG5cbiAgICAgICAgICBpZiAoIHdlYmdsT2JqZWN0ICYmICggb2JqZWN0LmZydXN0dW1DdWxsZWQgPT09IGZhbHNlIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApID09PSB0cnVlICkgKSB7XG5cbiAgICAgICAgICAgIHZhciBtYXRlcmlhbCA9IG9iamVjdC5tYXRlcmlhbDtcblxuICAgICAgICAgICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcblxuICAgICAgICAgICAgICB0cmFuc3BhcmVudE9iamVjdHMucHVzaCggd2ViZ2xPYmplY3QgKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICBvcGFxdWVPYmplY3RzLnB1c2goIHdlYmdsT2JqZWN0ICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCBfdGhpcy5zb3J0T2JqZWN0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgICAgICAgICBfdmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgICAgICAgICAgICBfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICAgICAgICAgICAgd2ViZ2xPYmplY3QueiA9IF92ZWN0b3IzLno7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgcHJvamVjdE9iamVjdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJPYmplY3RzKCByZW5kZXJMaXN0LCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgdmFyIG1hdGVyaWFsO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgd2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBpIF07XG5cbiAgICAgIHZhciBvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cbiAgICAgIHNldHVwTWF0cmljZXMoIG9iamVjdCwgY2FtZXJhICk7XG5cbiAgICAgIGlmICggb3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuICAgICAgICBtYXRlcmlhbCA9IG92ZXJyaWRlTWF0ZXJpYWw7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgICAgaWYgKCAhIG1hdGVyaWFsICkgY29udGludWU7XG5cbiAgICAgICAgc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICk7XG5cbiAgICAgIH1cblxuICAgICAgX3RoaXMuc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcbiAgICAgIF90aGlzLnJlbmRlckJ1ZmZlckRpcmVjdCggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJPYmplY3RzSW1tZWRpYXRlICggcmVuZGVyTGlzdCwgbWF0ZXJpYWxUeXBlLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBvdmVycmlkZU1hdGVyaWFsICkge1xuXG4gICAgdmFyIG1hdGVyaWFsO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICB2YXIgd2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBpIF07XG4gICAgICB2YXIgb2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXG4gICAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgICAgIGlmICggb3ZlcnJpZGVNYXRlcmlhbCApIHtcblxuICAgICAgICAgIG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgbWF0ZXJpYWwgPSB3ZWJnbE9iamVjdFsgbWF0ZXJpYWxUeXBlIF07XG5cbiAgICAgICAgICBpZiAoICEgbWF0ZXJpYWwgKSBjb250aW51ZTtcblxuICAgICAgICAgIHNldE1hdGVyaWFsKCBtYXRlcmlhbCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICB0aGlzLnJlbmRlckltbWVkaWF0ZU9iamVjdCA9IGZ1bmN0aW9uICggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApIHtcblxuICAgIHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xuXG4gICAgX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJztcblxuICAgIF90aGlzLnNldE1hdGVyaWFsRmFjZXMoIG1hdGVyaWFsICk7XG5cbiAgICBpZiAoIG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayApIHtcblxuICAgICAgb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrKCBwcm9ncmFtLCBfZ2wsIF9mcnVzdHVtICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBvYmplY3QucmVuZGVyKCBmdW5jdGlvbiAoIG9iamVjdCApIHsgX3RoaXMucmVuZGVyQnVmZmVySW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICk7IH0gKTtcblxuICAgIH1cblxuICB9O1xuXG4gIC8vIE1hdGVyaWFsc1xuXG4gIHZhciBzaGFkZXJJRHMgPSB7XG4gICAgTWVzaERlcHRoTWF0ZXJpYWw6ICdkZXB0aCcsXG4gICAgTWVzaE5vcm1hbE1hdGVyaWFsOiAnbm9ybWFsJyxcbiAgICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgICBNZXNoTGFtYmVydE1hdGVyaWFsOiAnbGFtYmVydCcsXG4gICAgTWVzaFBob25nTWF0ZXJpYWw6ICdwaG9uZycsXG4gICAgTGluZUJhc2ljTWF0ZXJpYWw6ICdiYXNpYycsXG4gICAgTGluZURhc2hlZE1hdGVyaWFsOiAnZGFzaGVkJyxcbiAgICBQb2ludENsb3VkTWF0ZXJpYWw6ICdwYXJ0aWNsZV9iYXNpYydcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xuXG4gICAgdmFyIHNoYWRlcklEID0gc2hhZGVySURzWyBtYXRlcmlhbC50eXBlIF07XG5cbiAgICAvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxuICAgIC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXG5cbiAgICB2YXIgbWF4TGlnaHRDb3VudCA9IGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKTtcbiAgICB2YXIgbWF4U2hhZG93cyA9IGFsbG9jYXRlU2hhZG93cyggbGlnaHRzICk7XG4gICAgdmFyIG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XG5cbiAgICB2YXIgcGFyYW1ldGVycyA9IHtcblxuICAgICAgcHJlY2lzaW9uOiBfcHJlY2lzaW9uLFxuICAgICAgc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogX3N1cHBvcnRzVmVydGV4VGV4dHVyZXMsXG5cbiAgICAgIG1hcDogISEgbWF0ZXJpYWwubWFwLFxuICAgICAgZW52TWFwOiAhISBtYXRlcmlhbC5lbnZNYXAsXG4gICAgICBlbnZNYXBNb2RlOiBtYXRlcmlhbC5lbnZNYXAgJiYgbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcsXG4gICAgICBsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXG4gICAgICBhb01hcDogISEgbWF0ZXJpYWwuYW9NYXAsXG4gICAgICBidW1wTWFwOiAhISBtYXRlcmlhbC5idW1wTWFwLFxuICAgICAgbm9ybWFsTWFwOiAhISBtYXRlcmlhbC5ub3JtYWxNYXAsXG4gICAgICBzcGVjdWxhck1hcDogISEgbWF0ZXJpYWwuc3BlY3VsYXJNYXAsXG4gICAgICBhbHBoYU1hcDogISEgbWF0ZXJpYWwuYWxwaGFNYXAsXG5cbiAgICAgIGNvbWJpbmU6IG1hdGVyaWFsLmNvbWJpbmUsXG5cbiAgICAgIHZlcnRleENvbG9yczogbWF0ZXJpYWwudmVydGV4Q29sb3JzLFxuXG4gICAgICBmb2c6IGZvZyxcbiAgICAgIHVzZUZvZzogbWF0ZXJpYWwuZm9nLFxuICAgICAgZm9nRXhwOiBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyLFxuXG4gICAgICBmbGF0U2hhZGluZzogbWF0ZXJpYWwuc2hhZGluZyA9PT0gVEhSRUUuRmxhdFNoYWRpbmcsXG5cbiAgICAgIHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxuICAgICAgbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogX2xvZ2FyaXRobWljRGVwdGhCdWZmZXIsXG5cbiAgICAgIHNraW5uaW5nOiBtYXRlcmlhbC5za2lubmluZyxcbiAgICAgIG1heEJvbmVzOiBtYXhCb25lcyxcbiAgICAgIHVzZVZlcnRleFRleHR1cmU6IF9zdXBwb3J0c0JvbmVUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlLFxuXG4gICAgICBtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcbiAgICAgIG1vcnBoTm9ybWFsczogbWF0ZXJpYWwubW9ycGhOb3JtYWxzLFxuICAgICAgbWF4TW9ycGhUYXJnZXRzOiBfdGhpcy5tYXhNb3JwaFRhcmdldHMsXG4gICAgICBtYXhNb3JwaE5vcm1hbHM6IF90aGlzLm1heE1vcnBoTm9ybWFscyxcblxuICAgICAgbWF4RGlyTGlnaHRzOiBtYXhMaWdodENvdW50LmRpcmVjdGlvbmFsLFxuICAgICAgbWF4UG9pbnRMaWdodHM6IG1heExpZ2h0Q291bnQucG9pbnQsXG4gICAgICBtYXhTcG90TGlnaHRzOiBtYXhMaWdodENvdW50LnNwb3QsXG4gICAgICBtYXhIZW1pTGlnaHRzOiBtYXhMaWdodENvdW50LmhlbWksXG5cbiAgICAgIG1heFNoYWRvd3M6IG1heFNoYWRvd3MsXG4gICAgICBzaGFkb3dNYXBFbmFibGVkOiBzaGFkb3dNYXAuZW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiBtYXhTaGFkb3dzID4gMCxcbiAgICAgIHNoYWRvd01hcFR5cGU6IHNoYWRvd01hcC50eXBlLFxuICAgICAgc2hhZG93TWFwRGVidWc6IHNoYWRvd01hcC5kZWJ1ZyxcbiAgICAgIHNoYWRvd01hcENhc2NhZGU6IHNoYWRvd01hcC5jYXNjYWRlLFxuXG4gICAgICBhbHBoYVRlc3Q6IG1hdGVyaWFsLmFscGhhVGVzdCxcbiAgICAgIG1ldGFsOiBtYXRlcmlhbC5tZXRhbCxcbiAgICAgIGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5Eb3VibGVTaWRlLFxuICAgICAgZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZVxuXG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlIGNvZGVcblxuICAgIHZhciBjaHVua3MgPSBbXTtcblxuICAgIGlmICggc2hhZGVySUQgKSB7XG5cbiAgICAgIGNodW5rcy5wdXNoKCBzaGFkZXJJRCApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgY2h1bmtzLnB1c2goIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyICk7XG4gICAgICBjaHVua3MucHVzaCggbWF0ZXJpYWwudmVydGV4U2hhZGVyICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG1hdGVyaWFsLmRlZmluZXMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgZm9yICggdmFyIG5hbWUgaW4gbWF0ZXJpYWwuZGVmaW5lcyApIHtcblxuICAgICAgICBjaHVua3MucHVzaCggbmFtZSApO1xuICAgICAgICBjaHVua3MucHVzaCggbWF0ZXJpYWwuZGVmaW5lc1sgbmFtZSBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGZvciAoIHZhciBuYW1lIGluIHBhcmFtZXRlcnMgKSB7XG5cbiAgICAgIGNodW5rcy5wdXNoKCBuYW1lICk7XG4gICAgICBjaHVua3MucHVzaCggcGFyYW1ldGVyc1sgbmFtZSBdICk7XG5cbiAgICB9XG5cbiAgICB2YXIgY29kZSA9IGNodW5rcy5qb2luKCk7XG5cbiAgICBpZiAoICFtYXRlcmlhbC5wcm9ncmFtICkge1xuXG4gICAgICAvLyBuZXcgbWF0ZXJpYWxcbiAgICAgIG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcblxuICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLnByb2dyYW0uY29kZSAhPT0gY29kZSApIHtcblxuICAgICAgLy8gY2hhbmdlZCBnbHNsIG9yIHBhcmFtZXRlcnNcbiAgICAgIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcblxuICAgIH0gZWxzZSBpZiAoIHNoYWRlcklEICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIC8vIHNhbWUgZ2xzbFxuICAgICAgcmV0dXJuO1xuXG4gICAgfSBlbHNlIGlmICggbWF0ZXJpYWwuX193ZWJnbFNoYWRlci51bmlmb3JtcyA9PT0gbWF0ZXJpYWwudW5pZm9ybXMgKSB7XG5cbiAgICAgIC8vIHNhbWUgdW5pZm9ybXMgKGNvbnRhaW5lciBvYmplY3QpXG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICBpZiAoIHNoYWRlcklEICkge1xuXG4gICAgICB2YXIgc2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBzaGFkZXJJRCBdO1xuXG4gICAgICBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyID0ge1xuICAgICAgICB1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICksXG4gICAgICAgIHZlcnRleFNoYWRlcjogc2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgbWF0ZXJpYWwuX193ZWJnbFNoYWRlciA9IHtcbiAgICAgICAgdW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXI6IG1hdGVyaWFsLnZlcnRleFNoYWRlcixcbiAgICAgICAgZnJhZ21lbnRTaGFkZXI6IG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgcHJvZ3JhbTtcblxuICAgIC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxuXG4gICAgZm9yICggdmFyIHAgPSAwLCBwbCA9IF9wcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcblxuICAgICAgdmFyIHByb2dyYW1JbmZvID0gX3Byb2dyYW1zWyBwIF07XG5cbiAgICAgIGlmICggcHJvZ3JhbUluZm8uY29kZSA9PT0gY29kZSApIHtcblxuICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbUluZm87XG4gICAgICAgIHByb2dyYW0udXNlZFRpbWVzICsrO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgcHJvZ3JhbSA9IG5ldyBUSFJFRS5XZWJHTFByb2dyYW0oIF90aGlzLCBjb2RlLCBtYXRlcmlhbCwgcGFyYW1ldGVycyApO1xuICAgICAgX3Byb2dyYW1zLnB1c2goIHByb2dyYW0gKTtcblxuICAgICAgX3RoaXMuaW5mby5tZW1vcnkucHJvZ3JhbXMgPSBfcHJvZ3JhbXMubGVuZ3RoO1xuXG4gICAgfVxuXG4gICAgbWF0ZXJpYWwucHJvZ3JhbSA9IHByb2dyYW07XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IHByb2dyYW0uZ2V0QXR0cmlidXRlcygpO1xuXG4gICAgaWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XG5cbiAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyA9IDA7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcblxuICAgICAgICBpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaFRhcmdldCcgKyBpIF0gPj0gMCApIHtcblxuICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyArKztcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xuXG4gICAgICBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgPSAwO1xuXG4gICAgICBmb3IgKCBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoTm9ybWFsczsgaSArKyApIHtcblxuICAgICAgICBpZiAoIGF0dHJpYnV0ZXNbICdtb3JwaE5vcm1hbCcgKyBpIF0gPj0gMCApIHtcblxuICAgICAgICAgIG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIG1hdGVyaWFsLnVuaWZvcm1zTGlzdCA9IFtdO1xuXG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSBtYXRlcmlhbC5wcm9ncmFtLmdldFVuaWZvcm1zKCk7XG4gICAgZm9yICggdmFyIHUgaW4gbWF0ZXJpYWwuX193ZWJnbFNoYWRlci51bmlmb3JtcyApIHtcblxuICAgICAgdmFyIGxvY2F0aW9uID0gdW5pZm9ybUxvY2F0aW9uc1sgdSBdO1xuXG4gICAgICBpZiAoIGxvY2F0aW9uICkge1xuICAgICAgICBtYXRlcmlhbC51bmlmb3Jtc0xpc3QucHVzaCggWyBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zWyB1IF0sIGxvY2F0aW9uIF0gKTtcbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TWF0ZXJpYWwoIG1hdGVyaWFsICkge1xuXG4gICAgaWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCA9PT0gdHJ1ZSApIHtcblxuICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb25BbHBoYSwgbWF0ZXJpYWwuYmxlbmRTcmNBbHBoYSwgbWF0ZXJpYWwuYmxlbmREc3RBbHBoYSApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc3RhdGUuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcblxuICAgIH1cblxuICAgIHN0YXRlLnNldERlcHRoRnVuYyggbWF0ZXJpYWwuZGVwdGhGdW5jICk7XG4gICAgc3RhdGUuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcbiAgICBzdGF0ZS5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG4gICAgc3RhdGUuc2V0Q29sb3JXcml0ZSggbWF0ZXJpYWwuY29sb3JXcml0ZSApO1xuICAgIHN0YXRlLnNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xuXG4gICAgX3VzZWRUZXh0dXJlVW5pdHMgPSAwO1xuXG4gICAgaWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSApIHtcblxuICAgICAgaW5pdE1hdGVyaWFsKCBtYXRlcmlhbCwgbGlnaHRzLCBmb2csIG9iamVjdCApO1xuICAgICAgbWF0ZXJpYWwubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIH1cblxuICAgIHZhciByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xuICAgIHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcbiAgICB2YXIgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xuXG4gICAgdmFyIHByb2dyYW0gPSBtYXRlcmlhbC5wcm9ncmFtLFxuICAgICAgcF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcbiAgICAgIG1fdW5pZm9ybXMgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xuXG4gICAgaWYgKCBwcm9ncmFtLmlkICE9PSBfY3VycmVudFByb2dyYW0gKSB7XG5cbiAgICAgIF9nbC51c2VQcm9ncmFtKCBwcm9ncmFtLnByb2dyYW0gKTtcbiAgICAgIF9jdXJyZW50UHJvZ3JhbSA9IHByb2dyYW0uaWQ7XG5cbiAgICAgIHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcbiAgICAgIHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XG4gICAgICByZWZyZXNoTGlnaHRzID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcblxuICAgICAgaWYgKCBfY3VycmVudE1hdGVyaWFsSWQgPT09IC0xICkgcmVmcmVzaExpZ2h0cyA9IHRydWU7XG4gICAgICBfY3VycmVudE1hdGVyaWFsSWQgPSBtYXRlcmlhbC5pZDtcblxuICAgICAgcmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcblxuICAgIH1cblxuICAgIGlmICggcmVmcmVzaFByb2dyYW0gfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcblxuICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICAgIGlmICggX2xvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XG5cbiAgICAgICAgX2dsLnVuaWZvcm0xZiggcF91bmlmb3Jtcy5sb2dEZXB0aEJ1ZkZDLCAyLjAgLyAoIE1hdGgubG9nKCBjYW1lcmEuZmFyICsgMS4wICkgLyBNYXRoLkxOMiApICk7XG5cbiAgICAgIH1cblxuXG4gICAgICBpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSBfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcblxuICAgICAgLy8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuICAgICAgLy8gKHNoYWRlciBtYXRlcmlhbCBhbHNvIGdldHMgdGhlbSBmb3IgdGhlIHNha2Ugb2YgZ2VuZXJpY2l0eSlcblxuICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbC5lbnZNYXAgKSB7XG5cbiAgICAgICAgaWYgKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uICE9PSBudWxsICkge1xuXG4gICAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcbiAgICAgICAgICBfZ2wudW5pZm9ybTNmKCBwX3VuaWZvcm1zLmNhbWVyYVBvc2l0aW9uLCBfdmVjdG9yMy54LCBfdmVjdG9yMy55LCBfdmVjdG9yMy56ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCB8fFxuICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbC5za2lubmluZyApIHtcblxuICAgICAgICBpZiAoIHBfdW5pZm9ybXMudmlld01hdHJpeCAhPT0gbnVsbCApIHtcblxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLnZpZXdNYXRyaXgsIGZhbHNlLCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmVsZW1lbnRzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBza2lubmluZyB1bmlmb3JtcyBtdXN0IGJlIHNldCBldmVuIGlmIG1hdGVyaWFsIGRpZG4ndCBjaGFuZ2VcbiAgICAvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcbiAgICAvLyBub3Qgc3VyZSB3aHksIGJ1dCBvdGhlcndpc2Ugd2VpcmQgdGhpbmdzIGhhcHBlblxuXG4gICAgaWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcblxuICAgICAgaWYgKCBvYmplY3QuYmluZE1hdHJpeCAmJiBwX3VuaWZvcm1zLmJpbmRNYXRyaXggIT09IG51bGwgKSB7XG5cbiAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMuYmluZE1hdHJpeCwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4LmVsZW1lbnRzICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBvYmplY3QuYmluZE1hdHJpeEludmVyc2UgJiYgcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSAhPT0gbnVsbCApIHtcblxuICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5iaW5kTWF0cml4SW52ZXJzZSwgZmFsc2UsIG9iamVjdC5iaW5kTWF0cml4SW52ZXJzZS5lbGVtZW50cyApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24udXNlVmVydGV4VGV4dHVyZSApIHtcblxuICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICB2YXIgdGV4dHVyZVVuaXQgPSBnZXRUZXh0dXJlVW5pdCgpO1xuXG4gICAgICAgICAgX2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcbiAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoICE9PSBudWxsICkge1xuXG4gICAgICAgICAgX2dsLnVuaWZvcm0xaSggcF91bmlmb3Jtcy5ib25lVGV4dHVyZVdpZHRoLCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVXaWR0aCApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmVIZWlnaHQgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICBfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlSGVpZ2h0LCBvYmplY3Quc2tlbGV0b24uYm9uZVRleHR1cmVIZWlnaHQgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoIG9iamVjdC5za2VsZXRvbiAmJiBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICkge1xuXG4gICAgICAgIGlmICggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5ib25lR2xvYmFsTWF0cmljZXMsIGZhbHNlLCBvYmplY3Quc2tlbGV0b24uYm9uZU1hdHJpY2VzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcblxuICAgICAgLy8gcmVmcmVzaCB1bmlmb3JtcyBjb21tb24gdG8gc2V2ZXJhbCBtYXRlcmlhbHNcblxuICAgICAgaWYgKCBmb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xuXG4gICAgICAgIHJlZnJlc2hVbmlmb3Jtc0ZvZyggbV91bmlmb3JtcywgZm9nICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHxcbiAgICAgICAgIG1hdGVyaWFsLmxpZ2h0cyApIHtcblxuICAgICAgICBpZiAoIF9saWdodHNOZWVkVXBkYXRlICkge1xuXG4gICAgICAgICAgcmVmcmVzaExpZ2h0cyA9IHRydWU7XG4gICAgICAgICAgc2V0dXBMaWdodHMoIGxpZ2h0cyApO1xuICAgICAgICAgIF9saWdodHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIHJlZnJlc2hMaWdodHMgKSB7XG4gICAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGlnaHRzKCBtX3VuaWZvcm1zLCBfbGlnaHRzICk7XG4gICAgICAgICAgbWFya1VuaWZvcm1zTGlnaHRzTmVlZHNVcGRhdGUoIG1fdW5pZm9ybXMsIHRydWUgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgZmFsc2UgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fFxuICAgICAgICAgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XG4gICAgICAgICBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xuXG4gICAgICAgIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xuXG4gICAgICBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zUGFydGljbGUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcblxuICAgICAgICByZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xuXG4gICAgICAgIHJlZnJlc2hVbmlmb3Jtc0Jhc2ljKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xuXG4gICAgICAgIG1fdW5pZm9ybXMubU5lYXIudmFsdWUgPSBjYW1lcmEubmVhcjtcbiAgICAgICAgbV91bmlmb3Jtcy5tRmFyLnZhbHVlID0gY2FtZXJhLmZhcjtcbiAgICAgICAgbV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgICAgfSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XG5cbiAgICAgICAgbV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmICEgbWF0ZXJpYWwuX3NoYWRvd1Bhc3MgKSB7XG5cbiAgICAgICAgcmVmcmVzaFVuaWZvcm1zU2hhZG93KCBtX3VuaWZvcm1zLCBsaWdodHMgKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBsb2FkIGNvbW1vbiB1bmlmb3Jtc1xuXG4gICAgICBsb2FkVW5pZm9ybXNHZW5lcmljKCBtYXRlcmlhbC51bmlmb3Jtc0xpc3QgKTtcblxuICAgIH1cblxuICAgIGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcblxuICAgIGlmICggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCAhPT0gbnVsbCApIHtcblxuICAgICAgX2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXgsIGZhbHNlLCBvYmplY3QubWF0cml4V29ybGQuZWxlbWVudHMgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBwcm9ncmFtO1xuXG4gIH1cblxuICAvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xuXG4gICAgdW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xuXG4gICAgdW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuICAgIHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG4gICAgdW5pZm9ybXMuYWxwaGFNYXAudmFsdWUgPSBtYXRlcmlhbC5hbHBoYU1hcDtcblxuICAgIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcblxuICAgICAgdW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XG4gICAgICB1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XG5cbiAgICB9XG5cbiAgICBpZiAoIG1hdGVyaWFsLm5vcm1hbE1hcCApIHtcblxuICAgICAgdW5pZm9ybXMubm9ybWFsTWFwLnZhbHVlID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xuICAgICAgdW5pZm9ybXMubm9ybWFsU2NhbGUudmFsdWUuY29weSggbWF0ZXJpYWwubm9ybWFsU2NhbGUgKTtcblxuICAgIH1cblxuICAgIC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xuICAgIC8vIDEuIGNvbG9yIG1hcFxuICAgIC8vIDIuIHNwZWN1bGFyIG1hcFxuICAgIC8vIDMuIG5vcm1hbCBtYXBcbiAgICAvLyA0LiBidW1wIG1hcFxuICAgIC8vIDUuIGFscGhhIG1hcFxuXG4gICAgdmFyIHV2U2NhbGVNYXA7XG5cbiAgICBpZiAoIG1hdGVyaWFsLm1hcCApIHtcblxuICAgICAgdXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcblxuICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xuXG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XG5cbiAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XG5cbiAgICAgIHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XG5cbiAgICB9IGVsc2UgaWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xuXG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcblxuICAgIH0gZWxzZSBpZiAoIG1hdGVyaWFsLmFscGhhTWFwICkge1xuXG4gICAgICB1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XG5cbiAgICB9XG5cbiAgICBpZiAoIHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgdmFyIG9mZnNldCA9IHV2U2NhbGVNYXAub2Zmc2V0O1xuICAgICAgdmFyIHJlcGVhdCA9IHV2U2NhbGVNYXAucmVwZWF0O1xuXG4gICAgICB1bmlmb3Jtcy5vZmZzZXRSZXBlYXQudmFsdWUuc2V0KCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSApO1xuXG4gICAgfVxuXG4gICAgdW5pZm9ybXMuZW52TWFwLnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwO1xuICAgIHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIG1hdGVyaWFsLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApID8gMSA6IC0gMTtcblxuICAgIHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcbiAgICB1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0xpbmUgKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICB1bmlmb3Jtcy5kaWZmdXNlLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XG4gICAgdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rhc2ggKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XG5cbiAgICB1bmlmb3Jtcy5kYXNoU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplO1xuICAgIHVuaWZvcm1zLnRvdGFsU2l6ZS52YWx1ZSA9IG1hdGVyaWFsLmRhc2hTaXplICsgbWF0ZXJpYWwuZ2FwU2l6ZTtcbiAgICB1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIHVuaWZvcm1zLnBzQ29sb3IudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcbiAgICB1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcbiAgICB1bmlmb3Jtcy5zaXplLnZhbHVlID0gbWF0ZXJpYWwuc2l6ZTtcbiAgICB1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IF9jYW52YXMuaGVpZ2h0IC8gMi4wOyAvLyBUT0RPOiBDYWNoZSB0aGlzLlxuXG4gICAgdW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xuXG4gICAgaWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBtYXRlcmlhbC5tYXAub2Zmc2V0O1xuICAgICAgdmFyIHJlcGVhdCA9IG1hdGVyaWFsLm1hcC5yZXBlYXQ7XG5cbiAgICAgIHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyAoIHVuaWZvcm1zLCBmb2cgKSB7XG5cbiAgICB1bmlmb3Jtcy5mb2dDb2xvci52YWx1ZSA9IGZvZy5jb2xvcjtcblxuICAgIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nICkge1xuXG4gICAgICB1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XG4gICAgICB1bmlmb3Jtcy5mb2dGYXIudmFsdWUgPSBmb2cuZmFyO1xuXG4gICAgfSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcblxuICAgICAgdW5pZm9ybXMuZm9nRGVuc2l0eS52YWx1ZSA9IGZvZy5kZW5zaXR5O1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQaG9uZyAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIHVuaWZvcm1zLnNoaW5pbmVzcy52YWx1ZSA9IG1hdGVyaWFsLnNoaW5pbmVzcztcblxuICAgIHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XG4gICAgdW5pZm9ybXMuc3BlY3VsYXIudmFsdWUgPSBtYXRlcmlhbC5zcGVjdWxhcjtcblxuICAgIHVuaWZvcm1zLmxpZ2h0TWFwLnZhbHVlID0gbWF0ZXJpYWwubGlnaHRNYXA7XG4gICAgdW5pZm9ybXMubGlnaHRNYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcEludGVuc2l0eTtcblxuICAgIHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XG4gICAgdW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcblxuICAgIHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Jhc2ljICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xuXG4gICAgdW5pZm9ybXMuYW9NYXAudmFsdWUgPSBtYXRlcmlhbC5hb01hcDtcbiAgICB1bmlmb3Jtcy5hb01hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmFvTWFwSW50ZW5zaXR5O1xuXG4gIH1cblxuICBmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaWdodHMgKCB1bmlmb3JtcywgbGlnaHRzICkge1xuXG4gICAgdW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuYW1iaWVudDtcblxuICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5jb2xvcnM7XG4gICAgdW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5kaXJlY3Rpb25hbC5wb3NpdGlvbnM7XG5cbiAgICB1bmlmb3Jtcy5wb2ludExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMucG9pbnQuY29sb3JzO1xuICAgIHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi52YWx1ZSA9IGxpZ2h0cy5wb2ludC5wb3NpdGlvbnM7XG4gICAgdW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnBvaW50LmRpc3RhbmNlcztcbiAgICB1bmlmb3Jtcy5wb2ludExpZ2h0RGVjYXkudmFsdWUgPSBsaWdodHMucG9pbnQuZGVjYXlzO1xuXG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IudmFsdWUgPSBsaWdodHMuc3BvdC5jb2xvcnM7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0UG9zaXRpb24udmFsdWUgPSBsaWdodHMuc3BvdC5wb3NpdGlvbnM7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMuc3BvdC5kaXN0YW5jZXM7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QuZGlyZWN0aW9ucztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRBbmdsZUNvcy52YWx1ZSA9IGxpZ2h0cy5zcG90LmFuZ2xlc0NvcztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRFeHBvbmVudC52YWx1ZSA9IGxpZ2h0cy5zcG90LmV4cG9uZW50cztcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHREZWNheS52YWx1ZSA9IGxpZ2h0cy5zcG90LmRlY2F5cztcblxuICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodFNreUNvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuc2t5Q29sb3JzO1xuICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzO1xuICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodERpcmVjdGlvbi52YWx1ZSA9IGxpZ2h0cy5oZW1pLnBvc2l0aW9ucztcblxuICB9XG5cbiAgLy8gSWYgdW5pZm9ybXMgYXJlIG1hcmtlZCBhcyBjbGVhbiwgdGhleSBkb24ndCBuZWVkIHRvIGJlIGxvYWRlZCB0byB0aGUgR1BVLlxuXG4gIGZ1bmN0aW9uIG1hcmtVbmlmb3Jtc0xpZ2h0c05lZWRzVXBkYXRlICggdW5pZm9ybXMsIHZhbHVlICkge1xuXG4gICAgdW5pZm9ybXMuYW1iaWVudExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24ubmVlZHNVcGRhdGUgPSB2YWx1ZTtcblxuICAgIHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnBvaW50TGlnaHRQb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnBvaW50TGlnaHREaXN0YW5jZS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnBvaW50TGlnaHREZWNheS5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuXG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0Q29sb3IubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRQb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodERpc3RhbmNlLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MubmVlZHNVcGRhdGUgPSB2YWx1ZTtcbiAgICB1bmlmb3Jtcy5zcG90TGlnaHRFeHBvbmVudC5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLnNwb3RMaWdodERlY2F5Lm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgICB1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xuICAgIHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XG4gICAgdW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLm5lZWRzVXBkYXRlID0gdmFsdWU7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1NoYWRvdyAoIHVuaWZvcm1zLCBsaWdodHMgKSB7XG5cbiAgICBpZiAoIHVuaWZvcm1zLnNoYWRvd01hdHJpeCApIHtcblxuICAgICAgdmFyIGogPSAwO1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xuXG4gICAgICAgIGlmICggISBsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XG5cbiAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCB8fCAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCAmJiAhIGxpZ2h0LnNoYWRvd0Nhc2NhZGUgKSApIHtcblxuICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd01hcC52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWFwO1xuICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd01hcFNpemUudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hcFNpemU7XG5cbiAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dNYXRyaXgudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd01hdHJpeDtcblxuICAgICAgICAgIHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcbiAgICAgICAgICB1bmlmb3Jtcy5zaGFkb3dCaWFzLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dCaWFzO1xuXG4gICAgICAgICAgaiArKztcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgLy8gVW5pZm9ybXMgKGxvYWQgdG8gR1BVKVxuXG4gIGZ1bmN0aW9uIGxvYWRVbmlmb3Jtc01hdHJpY2VzICggdW5pZm9ybXMsIG9iamVjdCApIHtcblxuICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCB1bmlmb3Jtcy5tb2RlbFZpZXdNYXRyaXgsIGZhbHNlLCBvYmplY3QuX21vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgaWYgKCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXggKSB7XG5cbiAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXgsIGZhbHNlLCBvYmplY3QuX25vcm1hbE1hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRUZXh0dXJlVW5pdCgpIHtcblxuICAgIHZhciB0ZXh0dXJlVW5pdCA9IF91c2VkVGV4dHVyZVVuaXRzO1xuXG4gICAgaWYgKCB0ZXh0dXJlVW5pdCA+PSBfbWF4VGV4dHVyZXMgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1dlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgJyArIHRleHR1cmVVbml0ICsgJyB0ZXh0dXJlIHVuaXRzIHdoaWxlIHRoaXMgR1BVIHN1cHBvcnRzIG9ubHkgJyArIF9tYXhUZXh0dXJlcyApO1xuXG4gICAgfVxuXG4gICAgX3VzZWRUZXh0dXJlVW5pdHMgKz0gMTtcblxuICAgIHJldHVybiB0ZXh0dXJlVW5pdDtcblxuICB9XG5cbiAgZnVuY3Rpb24gbG9hZFVuaWZvcm1zR2VuZXJpYyAoIHVuaWZvcm1zICkge1xuXG4gICAgdmFyIHRleHR1cmUsIHRleHR1cmVVbml0LCBvZmZzZXQ7XG5cbiAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gdW5pZm9ybXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgIHZhciB1bmlmb3JtID0gdW5pZm9ybXNbIGogXVsgMCBdO1xuXG4gICAgICAvLyBuZWVkc1VwZGF0ZSBwcm9wZXJ0eSBpcyBub3QgYWRkZWQgdG8gYWxsIHVuaWZvcm1zLlxuICAgICAgaWYgKCB1bmlmb3JtLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgdHlwZSA9IHVuaWZvcm0udHlwZTtcbiAgICAgIHZhciB2YWx1ZSA9IHVuaWZvcm0udmFsdWU7XG4gICAgICB2YXIgbG9jYXRpb24gPSB1bmlmb3Jtc1sgaiBdWyAxIF07XG5cbiAgICAgIHN3aXRjaCAoIHR5cGUgKSB7XG5cbiAgICAgICAgY2FzZSAnMWknOlxuICAgICAgICAgIF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJzFmJzpcbiAgICAgICAgICBfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcyZic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0gKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICczZic6XG4gICAgICAgICAgX2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0gKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc0Zic6XG4gICAgICAgICAgX2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlWyAwIF0sIHZhbHVlWyAxIF0sIHZhbHVlWyAyIF0sIHZhbHVlWyAzIF0gKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcxaXYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICczaXYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtM2l2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcxZnYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICcyZnYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICczZnYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc0ZnYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdNYXRyaXgzZnYnOlxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnTWF0cml4NGZ2JzpcbiAgICAgICAgICBfZ2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIGZhbHNlLCB2YWx1ZSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vXG5cbiAgICAgICAgY2FzZSAnaSc6XG5cbiAgICAgICAgICAvLyBzaW5nbGUgaW50ZWdlclxuICAgICAgICAgIF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZic6XG5cbiAgICAgICAgICAvLyBzaW5nbGUgZmxvYXRcbiAgICAgICAgICBfZ2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3YyJzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5WZWN0b3IyXG4gICAgICAgICAgX2dsLnVuaWZvcm0yZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3YzJzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5WZWN0b3IzXG4gICAgICAgICAgX2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnogKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Y0JzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5WZWN0b3I0XG4gICAgICAgICAgX2dsLnVuaWZvcm00ZiggbG9jYXRpb24sIHZhbHVlLngsIHZhbHVlLnksIHZhbHVlLnosIHZhbHVlLncgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuXG4gICAgICAgICAgLy8gc2luZ2xlIFRIUkVFLkNvbG9yXG4gICAgICAgICAgX2dsLnVuaWZvcm0zZiggbG9jYXRpb24sIHZhbHVlLnIsIHZhbHVlLmcsIHZhbHVlLmIgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2l2MSc6XG5cbiAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgICBfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpdic6XG5cbiAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGludGVnZXJzIHdpdGggMyB4IE4gc2l6ZSAoSlMgb3IgdHlwZWQgYXJyYXkpXG4gICAgICAgICAgX2dsLnVuaWZvcm0zaXYoIGxvY2F0aW9uLCB2YWx1ZSApO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZnYxJzpcblxuICAgICAgICAgIC8vIGZsYXQgYXJyYXkgb2YgZmxvYXRzIChKUyBvciB0eXBlZCBhcnJheSlcbiAgICAgICAgICBfZ2wudW5pZm9ybTFmdiggbG9jYXRpb24sIHZhbHVlICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmdic6XG5cbiAgICAgICAgICAvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxuICAgICAgICAgIF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdmFsdWUgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Yydic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IyXG5cbiAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMiAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICBvZmZzZXQgPSBpICogMjtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd2M3YnOlxuXG4gICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yM1xuXG4gICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDMgKiB2YWx1ZS5sZW5ndGggKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgICAgb2Zmc2V0ID0gaSAqIDM7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAwIF0gPSB2YWx1ZVsgaSBdLng7XG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlWyBpIF0uejtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9nbC51bmlmb3JtM2Z2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Y0dic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3I0XG5cbiAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggNCAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICBvZmZzZXQgPSBpICogNDtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDAgXSA9IHZhbHVlWyBpIF0ueDtcbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZVsgaSBdLnk7XG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWVbIGkgXS56O1xuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDMgXSA9IHZhbHVlWyBpIF0udztcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9nbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgdW5pZm9ybS5fYXJyYXkgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20zJzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5NYXRyaXgzXG4gICAgICAgICAgX2dsLnVuaWZvcm1NYXRyaXgzZnYoIGxvY2F0aW9uLCBmYWxzZSwgdmFsdWUuZWxlbWVudHMgKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ20zdic6XG5cbiAgICAgICAgICAvLyBhcnJheSBvZiBUSFJFRS5NYXRyaXgzXG5cbiAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSAqIHZhbHVlLmxlbmd0aCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgICAgICB2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDkgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4M2Z2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtNCc6XG5cbiAgICAgICAgICAvLyBzaW5nbGUgVEhSRUUuTWF0cml4NFxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHZhbHVlLmVsZW1lbnRzICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtNHYnOlxuXG4gICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuTWF0cml4NFxuXG4gICAgICAgICAgaWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgICB1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogdmFsdWUubGVuZ3RoICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICAgIHZhbHVlWyBpIF0uZmxhdHRlblRvQXJyYXlPZmZzZXQoIHVuaWZvcm0uX2FycmF5LCBpICogMTYgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9nbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICd0JzpcblxuICAgICAgICAgIC8vIHNpbmdsZSBUSFJFRS5UZXh0dXJlICgyZCBvciBjdWJlKVxuXG4gICAgICAgICAgdGV4dHVyZSA9IHZhbHVlO1xuICAgICAgICAgIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcblxuICAgICAgICAgIF9nbC51bmlmb3JtMWkoIGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgaWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkN1YmVUZXh0dXJlIHx8XG4gICAgICAgICAgICAgKCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHsgLy8gQ29tcHJlc3NlZFRleHR1cmUgY2FuIGhhdmUgQXJyYXkgaW4gaW1hZ2UgOi9cblxuICAgICAgICAgICAgc2V0Q3ViZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG4gICAgICAgICAgICBzZXRDdWJlVGV4dHVyZUR5bmFtaWMoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndHYnOlxuXG4gICAgICAgICAgLy8gYXJyYXkgb2YgVEhSRUUuVGV4dHVyZSAoMmQpXG5cbiAgICAgICAgICBpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICAgIHVuaWZvcm0uX2FycmF5ID0gW107XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgICAgdW5pZm9ybS5fYXJyYXlbIGkgXSA9IGdldFRleHR1cmVVbml0KCk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgICAgdGV4dHVyZSA9IHVuaWZvcm0udmFsdWVbIGkgXTtcbiAgICAgICAgICAgIHRleHR1cmVVbml0ID0gdW5pZm9ybS5fYXJyYXlbIGkgXTtcblxuICAgICAgICAgICAgaWYgKCAhIHRleHR1cmUgKSBjb250aW51ZTtcblxuICAgICAgICAgICAgX3RoaXMuc2V0VGV4dHVyZSggdGV4dHVyZSwgdGV4dHVyZVVuaXQgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVbmtub3duIHVuaWZvcm0gdHlwZTogJyArIHR5cGUgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cE1hdHJpY2VzICggb2JqZWN0LCBjYW1lcmEgKSB7XG5cbiAgICBvYmplY3QuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcbiAgICBvYmplY3QuX25vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4ICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbG9yTGluZWFyKCBhcnJheSwgb2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICkge1xuXG4gICAgYXJyYXlbIG9mZnNldCArIDAgXSA9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XG4gICAgYXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmcgKiBpbnRlbnNpdHk7XG4gICAgYXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwTGlnaHRzICggbGlnaHRzICkge1xuXG4gICAgdmFyIGwsIGxsLCBsaWdodCxcbiAgICByID0gMCwgZyA9IDAsIGIgPSAwLFxuICAgIGNvbG9yLCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsXG4gICAgaW50ZW5zaXR5LFxuICAgIGRpc3RhbmNlLFxuXG4gICAgemxpZ2h0cyA9IF9saWdodHMsXG5cbiAgICBkaXJDb2xvcnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycyxcbiAgICBkaXJQb3NpdGlvbnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLnBvc2l0aW9ucyxcblxuICAgIHBvaW50Q29sb3JzID0gemxpZ2h0cy5wb2ludC5jb2xvcnMsXG4gICAgcG9pbnRQb3NpdGlvbnMgPSB6bGlnaHRzLnBvaW50LnBvc2l0aW9ucyxcbiAgICBwb2ludERpc3RhbmNlcyA9IHpsaWdodHMucG9pbnQuZGlzdGFuY2VzLFxuICAgIHBvaW50RGVjYXlzID0gemxpZ2h0cy5wb2ludC5kZWNheXMsXG5cbiAgICBzcG90Q29sb3JzID0gemxpZ2h0cy5zcG90LmNvbG9ycyxcbiAgICBzcG90UG9zaXRpb25zID0gemxpZ2h0cy5zcG90LnBvc2l0aW9ucyxcbiAgICBzcG90RGlzdGFuY2VzID0gemxpZ2h0cy5zcG90LmRpc3RhbmNlcyxcbiAgICBzcG90RGlyZWN0aW9ucyA9IHpsaWdodHMuc3BvdC5kaXJlY3Rpb25zLFxuICAgIHNwb3RBbmdsZXNDb3MgPSB6bGlnaHRzLnNwb3QuYW5nbGVzQ29zLFxuICAgIHNwb3RFeHBvbmVudHMgPSB6bGlnaHRzLnNwb3QuZXhwb25lbnRzLFxuICAgIHNwb3REZWNheXMgPSB6bGlnaHRzLnNwb3QuZGVjYXlzLFxuXG4gICAgaGVtaVNreUNvbG9ycyA9IHpsaWdodHMuaGVtaS5za3lDb2xvcnMsXG4gICAgaGVtaUdyb3VuZENvbG9ycyA9IHpsaWdodHMuaGVtaS5ncm91bmRDb2xvcnMsXG4gICAgaGVtaVBvc2l0aW9ucyA9IHpsaWdodHMuaGVtaS5wb3NpdGlvbnMsXG5cbiAgICBkaXJMZW5ndGggPSAwLFxuICAgIHBvaW50TGVuZ3RoID0gMCxcbiAgICBzcG90TGVuZ3RoID0gMCxcbiAgICBoZW1pTGVuZ3RoID0gMCxcblxuICAgIGRpckNvdW50ID0gMCxcbiAgICBwb2ludENvdW50ID0gMCxcbiAgICBzcG90Q291bnQgPSAwLFxuICAgIGhlbWlDb3VudCA9IDAsXG5cbiAgICBkaXJPZmZzZXQgPSAwLFxuICAgIHBvaW50T2Zmc2V0ID0gMCxcbiAgICBzcG90T2Zmc2V0ID0gMCxcbiAgICBoZW1pT2Zmc2V0ID0gMDtcblxuICAgIGZvciAoIGwgPSAwLCBsbCA9IGxpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcblxuICAgICAgbGlnaHQgPSBsaWdodHNbIGwgXTtcblxuICAgICAgaWYgKCBsaWdodC5vbmx5U2hhZG93ICkgY29udGludWU7XG5cbiAgICAgIGNvbG9yID0gbGlnaHQuY29sb3I7XG4gICAgICBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XG4gICAgICBkaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xuXG4gICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xuXG4gICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgciArPSBjb2xvci5yO1xuICAgICAgICBnICs9IGNvbG9yLmc7XG4gICAgICAgIGIgKz0gY29sb3IuYjtcblxuICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG4gICAgICAgIGRpckNvdW50ICs9IDE7XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcbiAgICAgICAgX3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcbiAgICAgICAgX2RpcmVjdGlvbi5zdWIoIF92ZWN0b3IzICk7XG4gICAgICAgIF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAgICAgZGlyT2Zmc2V0ID0gZGlyTGVuZ3RoICogMztcblxuICAgICAgICBkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDAgXSA9IF9kaXJlY3Rpb24ueDtcbiAgICAgICAgZGlyUG9zaXRpb25zWyBkaXJPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG4gICAgICAgIGRpclBvc2l0aW9uc1sgZGlyT2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG4gICAgICAgIHNldENvbG9yTGluZWFyKCBkaXJDb2xvcnMsIGRpck9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgIGRpckxlbmd0aCArPSAxO1xuXG4gICAgICB9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XG5cbiAgICAgICAgcG9pbnRDb3VudCArPSAxO1xuXG4gICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgcG9pbnRPZmZzZXQgPSBwb2ludExlbmd0aCAqIDM7XG5cbiAgICAgICAgc2V0Q29sb3JMaW5lYXIoIHBvaW50Q29sb3JzLCBwb2ludE9mZnNldCwgY29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblxuICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAwIF0gPSBfdmVjdG9yMy54O1xuICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAxIF0gPSBfdmVjdG9yMy55O1xuICAgICAgICBwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgKyAyIF0gPSBfdmVjdG9yMy56O1xuXG4gICAgICAgIC8vIGRpc3RhbmNlIGlzIDAgaWYgZGVjYXkgaXMgMCwgYmVjYXVzZSB0aGVyZSBpcyBubyBhdHRlbnVhdGlvbiBhdCBhbGwuXG4gICAgICAgIHBvaW50RGlzdGFuY2VzWyBwb2ludExlbmd0aCBdID0gZGlzdGFuY2U7XG4gICAgICAgIHBvaW50RGVjYXlzWyBwb2ludExlbmd0aCBdID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XG5cbiAgICAgICAgcG9pbnRMZW5ndGggKz0gMTtcblxuICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSB7XG5cbiAgICAgICAgc3BvdENvdW50ICs9IDE7XG5cbiAgICAgICAgaWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcblxuICAgICAgICBzcG90T2Zmc2V0ID0gc3BvdExlbmd0aCAqIDM7XG5cbiAgICAgICAgc2V0Q29sb3JMaW5lYXIoIHNwb3RDb2xvcnMsIHNwb3RPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKTtcblxuICAgICAgICBfZGlyZWN0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcblxuICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xuICAgICAgICBzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xuXG4gICAgICAgIHNwb3REaXN0YW5jZXNbIHNwb3RMZW5ndGggXSA9IGRpc3RhbmNlO1xuXG4gICAgICAgIF92ZWN0b3IzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xuICAgICAgICBfZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMCBdID0gX2RpcmVjdGlvbi54O1xuICAgICAgICBzcG90RGlyZWN0aW9uc1sgc3BvdE9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcbiAgICAgICAgc3BvdERpcmVjdGlvbnNbIHNwb3RPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgc3BvdEFuZ2xlc0Nvc1sgc3BvdExlbmd0aCBdID0gTWF0aC5jb3MoIGxpZ2h0LmFuZ2xlICk7XG4gICAgICAgIHNwb3RFeHBvbmVudHNbIHNwb3RMZW5ndGggXSA9IGxpZ2h0LmV4cG9uZW50O1xuICAgICAgICBzcG90RGVjYXlzWyBzcG90TGVuZ3RoIF0gPSAoIGxpZ2h0LmRpc3RhbmNlID09PSAwICkgPyAwLjAgOiBsaWdodC5kZWNheTtcblxuICAgICAgICBzcG90TGVuZ3RoICs9IDE7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkge1xuXG4gICAgICAgIGhlbWlDb3VudCArPSAxO1xuXG4gICAgICAgIGlmICggISBsaWdodC52aXNpYmxlICkgY29udGludWU7XG5cbiAgICAgICAgX2RpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgICAgIF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG5cbiAgICAgICAgaGVtaU9mZnNldCA9IGhlbWlMZW5ndGggKiAzO1xuXG4gICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAwIF0gPSBfZGlyZWN0aW9uLng7XG4gICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XG4gICAgICAgIGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAyIF0gPSBfZGlyZWN0aW9uLno7XG5cbiAgICAgICAgc2t5Q29sb3IgPSBsaWdodC5jb2xvcjtcbiAgICAgICAgZ3JvdW5kQ29sb3IgPSBsaWdodC5ncm91bmRDb2xvcjtcblxuICAgICAgICBzZXRDb2xvckxpbmVhciggaGVtaVNreUNvbG9ycywgaGVtaU9mZnNldCwgc2t5Q29sb3IsIGludGVuc2l0eSApO1xuICAgICAgICBzZXRDb2xvckxpbmVhciggaGVtaUdyb3VuZENvbG9ycywgaGVtaU9mZnNldCwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApO1xuXG4gICAgICAgIGhlbWlMZW5ndGggKz0gMTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gbnVsbCBldmVudHVhbCByZW1haW5zIGZyb20gcmVtb3ZlZCBsaWdodHNcbiAgICAvLyAodGhpcyBpcyB0byBhdm9pZCBpZiBpbiBzaGFkZXIpXG5cbiAgICBmb3IgKCBsID0gZGlyTGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggZGlyQ29sb3JzLmxlbmd0aCwgZGlyQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGRpckNvbG9yc1sgbCBdID0gMC4wO1xuICAgIGZvciAoIGwgPSBwb2ludExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHBvaW50Q29sb3JzLmxlbmd0aCwgcG9pbnRDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgcG9pbnRDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICBmb3IgKCBsID0gc3BvdExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHNwb3RDb2xvcnMubGVuZ3RoLCBzcG90Q291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIHNwb3RDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICBmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlTa3lDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlTa3lDb2xvcnNbIGwgXSA9IDAuMDtcbiAgICBmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlHcm91bmRDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlHcm91bmRDb2xvcnNbIGwgXSA9IDAuMDtcblxuICAgIHpsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyTGVuZ3RoO1xuICAgIHpsaWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XG4gICAgemxpZ2h0cy5zcG90Lmxlbmd0aCA9IHNwb3RMZW5ndGg7XG4gICAgemxpZ2h0cy5oZW1pLmxlbmd0aCA9IGhlbWlMZW5ndGg7XG5cbiAgICB6bGlnaHRzLmFtYmllbnRbIDAgXSA9IHI7XG4gICAgemxpZ2h0cy5hbWJpZW50WyAxIF0gPSBnO1xuICAgIHpsaWdodHMuYW1iaWVudFsgMiBdID0gYjtcblxuICB9XG5cbiAgLy8gR0wgc3RhdGUgc2V0dGluZ1xuXG4gIHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XG5cbiAgICBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZU5vbmUgKSB7XG5cbiAgICAgIF9nbC5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoIGZyb250RmFjZURpcmVjdGlvbiA9PT0gVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ1cgKSB7XG5cbiAgICAgICAgX2dsLmZyb250RmFjZSggX2dsLkNXICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgX2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlQmFjayApIHtcblxuICAgICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xuXG4gICAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcblxuICAgICAgfVxuXG4gICAgICBfZ2wuZW5hYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldE1hdGVyaWFsRmFjZXMgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xuXG4gICAgc3RhdGUuc2V0RG91YmxlU2lkZWQoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUgKTtcbiAgICBzdGF0ZS5zZXRGbGlwU2lkZWQoIG1hdGVyaWFsLnNpZGUgPT09IFRIUkVFLkJhY2tTaWRlICk7XG5cbiAgfTtcblxuICAvLyBUZXh0dXJlc1xuXG4gIGZ1bmN0aW9uIHNldFRleHR1cmVQYXJhbWV0ZXJzICggdGV4dHVyZVR5cGUsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICkge1xuXG4gICAgdmFyIGV4dGVuc2lvbjtcblxuICAgIGlmICggaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwUyApICk7XG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfVCwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUud3JhcFQgKSApO1xuXG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX1dSQVBfUywgX2dsLkNMQU1QX1RPX0VER0UgKTtcbiAgICAgIF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xuXG4gICAgICBpZiAoIHRleHR1cmUud3JhcFMgIT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUud3JhcFMgYW5kIFRleHR1cmUud3JhcFQgc2hvdWxkIGJlIHNldCB0byBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nLiAoICcgKyB0ZXh0dXJlLnNvdXJjZUZpbGUgKyAnICknICk7XG5cbiAgICAgIH1cblxuICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xuICAgICAgX2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xuXG4gICAgICBpZiAoIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHRleHR1cmUubWluRmlsdGVyICE9PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBpcyBub3QgcG93ZXIgb2YgdHdvLiBUZXh0dXJlLm1pbkZpbHRlciBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLk5lYXJlc3RGaWx0ZXIgb3IgVEhSRUUuTGluZWFyRmlsdGVyLiAoICcgKyB0ZXh0dXJlLnNvdXJjZUZpbGUgKyAnICknICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xuXG4gICAgaWYgKCBleHRlbnNpb24gJiYgdGV4dHVyZS50eXBlICE9PSBUSFJFRS5GbG9hdFR5cGUgJiYgdGV4dHVyZS50eXBlICE9PSBUSFJFRS5IYWxmRmxvYXRUeXBlICkge1xuXG4gICAgICBpZiAoIHRleHR1cmUuYW5pc290cm9weSA+IDEgfHwgdGV4dHVyZS5fX2N1cnJlbnRBbmlzb3Ryb3B5ICkge1xuXG4gICAgICAgIF9nbC50ZXhQYXJhbWV0ZXJmKCB0ZXh0dXJlVHlwZSwgZXh0ZW5zaW9uLlRFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhULCBNYXRoLm1pbiggdGV4dHVyZS5hbmlzb3Ryb3B5LCBfdGhpcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xuICAgICAgICB0ZXh0dXJlLl9fY3VycmVudEFuaXNvdHJvcHkgPSB0ZXh0dXJlLmFuaXNvdHJvcHk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy51cGxvYWRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgaWYgKCB0ZXh0dXJlLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIHRleHR1cmUuX193ZWJnbEluaXQgPSB0cnVlO1xuXG4gICAgICB0ZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xuXG4gICAgICB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgX3RoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgKys7XG5cbiAgICB9XG5cbiAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XG4gICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcbiAgICBfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xuXG4gICAgdGV4dHVyZS5pbWFnZSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlLCBfbWF4VGV4dHVyZVNpemUgKTtcblxuICAgIHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2UsXG4gICAgaXNJbWFnZVBvd2VyT2ZUd28gPSBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBUSFJFRS5NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICksXG4gICAgZ2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcbiAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XG5cbiAgICBzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUsIGlzSW1hZ2VQb3dlck9mVHdvICk7XG5cbiAgICB2YXIgbWlwbWFwLCBtaXBtYXBzID0gdGV4dHVyZS5taXBtYXBzO1xuXG4gICAgaWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmUgKSB7XG5cbiAgICAgIC8vIHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHMgaWYgYXZhaWxhYmxlXG4gICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcbiAgICAgIC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xuXG4gICAgICBpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICAgIG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcbiAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlICkge1xuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCQUZvcm1hdCAmJiB0ZXh0dXJlLmZvcm1hdCAhPT0gVEhSRUUuUkdCRm9ybWF0ICkge1xuXG4gICAgICAgICAgaWYgKCBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLTEgKSB7XG5cbiAgICAgICAgICAgIHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybiggXCJUSFJFRS5XZWJHTFJlbmRlcmVyOiBBdHRlbXB0IHRvIGxvYWQgdW5zdXBwb3J0ZWQgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdCBpbiAudXBsb2FkVGV4dHVyZSgpXCIgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2UgeyAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxuXG4gICAgICAvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1hbnVhbCBtaXBtYXBzXG4gICAgICAvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcblxuICAgICAgaWYgKCBtaXBtYXBzLmxlbmd0aCA+IDAgJiYgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IG1pcG1hcHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgICBtaXBtYXAgPSBtaXBtYXBzWyBpIF07XG4gICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGdsRm9ybWF0LCBnbFR5cGUsIHRleHR1cmUuaW1hZ2UgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuICB9O1xuXG4gIHRoaXMuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2xvdCApIHtcblxuICAgIGlmICggdGV4dHVyZS5uZWVkc1VwZGF0ZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuICAgICAgaWYgKCBpbWFnZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIHVuZGVmaW5lZCcsIHRleHR1cmUgKTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggaW1hZ2UuY29tcGxldGUgPT09IGZhbHNlICkge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgbWFya2VkIGZvciB1cGRhdGUgYnV0IGltYWdlIGlzIGluY29tcGxldGUnLCB0ZXh0dXJlICk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgfVxuXG4gICAgICBfdGhpcy51cGxvYWRUZXh0dXJlKCB0ZXh0dXJlLCBzbG90ICk7XG4gICAgICByZXR1cm47XG5cbiAgICB9XG5cbiAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XG5cbiAgfTtcblxuICBmdW5jdGlvbiBjbGFtcFRvTWF4U2l6ZSAoIGltYWdlLCBtYXhTaXplICkge1xuXG4gICAgaWYgKCBpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSApIHtcblxuICAgICAgLy8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcbiAgICAgIC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXG5cbiAgICAgIHZhciBzY2FsZSA9IG1heFNpemUgLyBNYXRoLm1heCggaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xuXG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcbiAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBzY2FsZSApO1xuXG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCApO1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcblxuICAgICAgcmV0dXJuIGNhbnZhcztcblxuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q3ViZVRleHR1cmUgKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgaWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcblxuICAgICAgaWYgKCB0ZXh0dXJlLm5lZWRzVXBkYXRlICkge1xuXG4gICAgICAgIGlmICggISB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcblxuICAgICAgICAgIHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XG5cbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgICAgICBfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICk7XG5cbiAgICAgICAgX2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xuXG4gICAgICAgIHZhciBpc0NvbXByZXNzZWQgPSB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuQ29tcHJlc3NlZFRleHR1cmU7XG4gICAgICAgIHZhciBpc0RhdGFUZXh0dXJlID0gdGV4dHVyZS5pbWFnZVsgMCBdIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmU7XG5cbiAgICAgICAgdmFyIGN1YmVJbWFnZSA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgICAgICBpZiAoIF90aGlzLmF1dG9TY2FsZUN1YmVtYXBzICYmICEgaXNDb21wcmVzc2VkICYmICEgaXNEYXRhVGV4dHVyZSApIHtcblxuICAgICAgICAgICAgY3ViZUltYWdlWyBpIF0gPSBjbGFtcFRvTWF4U2l6ZSggdGV4dHVyZS5pbWFnZVsgaSBdLCBfbWF4Q3ViZW1hcFNpemUgKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGN1YmVJbWFnZVsgaSBdID0gaXNEYXRhVGV4dHVyZSA/IHRleHR1cmUuaW1hZ2VbIGkgXS5pbWFnZSA6IHRleHR1cmUuaW1hZ2VbIGkgXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGltYWdlID0gY3ViZUltYWdlWyAwIF0sXG4gICAgICAgIGlzSW1hZ2VQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApLFxuICAgICAgICBnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxuICAgICAgICBnbFR5cGUgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS50eXBlICk7XG5cbiAgICAgICAgc2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cbiAgICAgICAgICBpZiAoICEgaXNDb21wcmVzc2VkICkge1xuXG4gICAgICAgICAgICBpZiAoIGlzRGF0YVRleHR1cmUgKSB7XG5cbiAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBjdWJlSW1hZ2VbIGkgXS53aWR0aCwgY3ViZUltYWdlWyBpIF0uaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXS5kYXRhICk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgc3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgbWlwbWFwLCBtaXBtYXBzID0gY3ViZUltYWdlWyBpIF0ubWlwbWFwcztcblxuICAgICAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IG1pcG1hcHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgICAgICAgbWlwbWFwID0gbWlwbWFwc1sgaiBdO1xuXG4gICAgICAgICAgICAgIGlmICggdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgdGV4dHVyZS5mb3JtYXQgIT09IFRIUkVFLlJHQkZvcm1hdCApIHtcblxuICAgICAgICAgICAgICAgIGlmICggZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkuaW5kZXhPZiggZ2xGb3JtYXQgKSA+IC0xICkge1xuXG4gICAgICAgICAgICAgICAgICBzdGF0ZS5jb21wcmVzc2VkVGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIGosIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIG1pcG1hcC5kYXRhICk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuV2ViR0xSZW5kZXJlcjogQXR0ZW1wdCB0byBsb2FkIHVuc3VwcG9ydGVkIGNvbXByZXNzZWQgdGV4dHVyZSBmb3JtYXQgaW4gLnNldEN1YmVUZXh0dXJlKClcIiApO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwLmRhdGEgKTtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcblxuICAgICAgICAgIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfQ1VCRV9NQVAgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmICggdGV4dHVyZS5vblVwZGF0ZSApIHRleHR1cmUub25VcGRhdGUoIHRleHR1cmUgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZUR5bmFtaWMgKCB0ZXh0dXJlLCBzbG90ICkge1xuXG4gICAgc3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xuICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xuXG4gIH1cblxuICAvLyBSZW5kZXIgdGFyZ2V0c1xuXG4gIGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXIgKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlVGFyZ2V0ICkge1xuXG4gICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xuICAgIF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRleHR1cmVUYXJnZXQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSwgMCApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cFJlbmRlckJ1ZmZlciAoIHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICkge1xuXG4gICAgX2dsLmJpbmRSZW5kZXJidWZmZXIoIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9DT01QT05FTlQxNiwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG4gICAgICBfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgLyogRm9yIHNvbWUgcmVhc29uIHRoaXMgaXMgbm90IHdvcmtpbmcuIERlZmF1bHRpbmcgdG8gUkdCQTQuXG4gICAgfSBlbHNlIGlmICggISByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgIF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuU1RFTkNJTF9JTkRFWDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuICAgICovXG4gICAgfSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xuXG4gICAgICBfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUwsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xuICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgX2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5SR0JBNCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMuc2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICB2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcblxuICAgIGlmICggcmVuZGVyVGFyZ2V0ICYmIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XG4gICAgICBpZiAoIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID09PSB1bmRlZmluZWQgKSByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciA9IHRydWU7XG5cbiAgICAgIHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xuXG4gICAgICByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICBfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcblxuICAgICAgLy8gU2V0dXAgdGV4dHVyZSwgY3JlYXRlIHJlbmRlciBhbmQgZnJhbWUgYnVmZmVyc1xuXG4gICAgICB2YXIgaXNUYXJnZXRQb3dlck9mVHdvID0gVEhSRUUuTWF0aC5pc1Bvd2VyT2ZUd28oIHJlbmRlclRhcmdldC53aWR0aCApICYmIFRIUkVFLk1hdGguaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQuaGVpZ2h0ICksXG4gICAgICAgIGdsRm9ybWF0ID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC5mb3JtYXQgKSxcbiAgICAgICAgZ2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHJlbmRlclRhcmdldC50eXBlICk7XG5cbiAgICAgIGlmICggaXNDdWJlICkge1xuXG4gICAgICAgIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcbiAgICAgICAgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSBbXTtcblxuICAgICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuXG4gICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG4gICAgICAgICAgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgICAgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSA9IF9nbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblxuICAgICAgICAgIHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XG5cbiAgICAgICAgICBzZXR1cEZyYW1lQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGkgKTtcbiAgICAgICAgICBzZXR1cFJlbmRlckJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LnNoYXJlRGVwdGhGcm9tICkge1xuXG4gICAgICAgICAgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20uX193ZWJnbFJlbmRlcmJ1ZmZlcjtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgPSBfZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICk7XG4gICAgICAgIHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcblxuICAgICAgICBzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xuXG4gICAgICAgIHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfMkQgKTtcblxuICAgICAgICBpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcblxuICAgICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmICEgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XG5cbiAgICAgICAgICAgIF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcblxuICAgICAgICAgICAgX2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyICk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHNldHVwUmVuZGVyQnVmZmVyKCByZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiBpc1RhcmdldFBvd2VyT2ZUd28gKSBfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gUmVsZWFzZSBldmVyeXRoaW5nXG5cbiAgICAgIGlmICggaXNDdWJlICkge1xuXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG4gICAgICB9XG5cbiAgICAgIF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG4gICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuICAgIH1cblxuICAgIHZhciBmcmFtZWJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgdngsIHZ5O1xuXG4gICAgaWYgKCByZW5kZXJUYXJnZXQgKSB7XG5cbiAgICAgIGlmICggaXNDdWJlICkge1xuXG4gICAgICAgIGZyYW1lYnVmZmVyID0gcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlIF07XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyO1xuXG4gICAgICB9XG5cbiAgICAgIHdpZHRoID0gcmVuZGVyVGFyZ2V0LndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVuZGVyVGFyZ2V0LmhlaWdodDtcblxuICAgICAgdnggPSAwO1xuICAgICAgdnkgPSAwO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZnJhbWVidWZmZXIgPSBudWxsO1xuXG4gICAgICB3aWR0aCA9IF92aWV3cG9ydFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gX3ZpZXdwb3J0SGVpZ2h0O1xuXG4gICAgICB2eCA9IF92aWV3cG9ydFg7XG4gICAgICB2eSA9IF92aWV3cG9ydFk7XG5cbiAgICB9XG5cbiAgICBpZiAoIGZyYW1lYnVmZmVyICE9PSBfY3VycmVudEZyYW1lYnVmZmVyICkge1xuXG4gICAgICBfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XG4gICAgICBfZ2wudmlld3BvcnQoIHZ4LCB2eSwgd2lkdGgsIGhlaWdodCApO1xuXG4gICAgICBfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XG5cbiAgICB9XG5cbiAgICBfY3VycmVudFdpZHRoID0gd2lkdGg7XG4gICAgX2N1cnJlbnRIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgfTtcblxuICB0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiggcmVuZGVyVGFyZ2V0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBidWZmZXIgKSB7XG5cbiAgICBpZiAoICEgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCApICkge1xuXG4gICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LicgKTtcbiAgICAgIHJldHVybjtcblxuICAgIH1cblxuICAgIGlmICggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciApIHtcblxuICAgICAgaWYgKCByZW5kZXJUYXJnZXQuZm9ybWF0ICE9PSBUSFJFRS5SR0JBRm9ybWF0ICkge1xuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgaW4gUkdCQSBmb3JtYXQuIHJlYWRQaXhlbHMgY2FuIHJlYWQgb25seSBSR0JBIGZvcm1hdC4nICk7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdG9yZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XG5cbiAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyICk7XG5cbiAgICAgICAgcmVzdG9yZSA9IHRydWU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBfZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggX2dsLkZSQU1FQlVGRkVSICkgPT09IF9nbC5GUkFNRUJVRkZFUl9DT01QTEVURSApIHtcblxuICAgICAgICBfZ2wucmVhZFBpeGVscyggeCwgeSwgd2lkdGgsIGhlaWdodCwgX2dsLlJHQkEsIF9nbC5VTlNJR05FRF9CWVRFLCBidWZmZXIgKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZWFkUGl4ZWxzIGZyb20gcmVuZGVyVGFyZ2V0IGZhaWxlZC4gRnJhbWVidWZmZXIgbm90IGNvbXBsZXRlLicgKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHJlc3RvcmUgKSB7XG5cbiAgICAgICAgX2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfY3VycmVudEZyYW1lYnVmZmVyICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCAoIHJlbmRlclRhcmdldCApIHtcblxuICAgIGlmICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xuXG4gICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuICAgICAgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xuICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xuICAgICAgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xuICAgICAgc3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBudWxsICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXG5cbiAgZnVuY3Rpb24gZmlsdGVyRmFsbGJhY2sgKCBmICkge1xuXG4gICAgaWYgKCBmID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyIHx8IGYgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgKSB7XG5cbiAgICAgIHJldHVybiBfZ2wuTkVBUkVTVDtcblxuICAgIH1cblxuICAgIHJldHVybiBfZ2wuTElORUFSO1xuXG4gIH1cblxuICAvLyBNYXAgdGhyZWUuanMgY29uc3RhbnRzIHRvIFdlYkdMIGNvbnN0YW50c1xuXG4gIGZ1bmN0aW9uIHBhcmFtVGhyZWVUb0dMICggcCApIHtcblxuICAgIHZhciBleHRlbnNpb247XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLlJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5SRVBFQVQ7XG4gICAgaWYgKCBwID09PSBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIF9nbC5DTEFNUF9UT19FREdFO1xuICAgIGlmICggcCA9PT0gVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZyApIHJldHVybiBfZ2wuTUlSUk9SRURfUkVQRUFUO1xuXG4gICAgaWYgKCBwID09PSBUSFJFRS5OZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUO1xuICAgIGlmICggcCA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XG4gICAgaWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLkxpbmVhckZpbHRlciApIHJldHVybiBfZ2wuTElORUFSO1xuICAgIGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xuICAgIGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcblxuICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfQllURTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNF80XzRfNDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NTUxVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlRfNV81XzVfMTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzZfNTtcblxuICAgIGlmICggcCA9PT0gVEhSRUUuQnl0ZVR5cGUgKSByZXR1cm4gX2dsLkJZVEU7XG4gICAgaWYgKCBwID09PSBUSFJFRS5TaG9ydFR5cGUgKSByZXR1cm4gX2dsLlNIT1JUO1xuICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydFR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUO1xuICAgIGlmICggcCA9PT0gVEhSRUUuSW50VHlwZSApIHJldHVybiBfZ2wuSU5UO1xuICAgIGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9JTlQ7XG4gICAgaWYgKCBwID09PSBUSFJFRS5GbG9hdFR5cGUgKSByZXR1cm4gX2dsLkZMT0FUO1xuXG4gICAgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xuXG4gICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgIGlmICggcCA9PT0gVEhSRUUuSGFsZkZsb2F0VHlwZSApIHJldHVybiBleHRlbnNpb24uSEFMRl9GTE9BVF9PRVM7XG5cbiAgICB9XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLkFscGhhRm9ybWF0ICkgcmV0dXJuIF9nbC5BTFBIQTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkZvcm1hdCApIHJldHVybiBfZ2wuUkdCO1xuICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQUZvcm1hdCApIHJldHVybiBfZ2wuUkdCQTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLkx1bWluYW5jZUZvcm1hdCApIHJldHVybiBfZ2wuTFVNSU5BTkNFO1xuICAgIGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRV9BTFBIQTtcblxuICAgIGlmICggcCA9PT0gVEhSRUUuQWRkRXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfQUREO1xuICAgIGlmICggcCA9PT0gVEhSRUUuU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19TVUJUUkFDVDtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1Q7XG5cbiAgICBpZiAoIHAgPT09IFRIUkVFLlplcm9GYWN0b3IgKSByZXR1cm4gX2dsLlpFUk87XG4gICAgaWYgKCBwID09PSBUSFJFRS5PbmVGYWN0b3IgKSByZXR1cm4gX2dsLk9ORTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLlNyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQ09MT1I7XG4gICAgaWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xuICAgIGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLlNSQ19BTFBIQTtcbiAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19TUkNfQUxQSEE7XG4gICAgaWYgKCBwID09PSBUSFJFRS5Ec3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuRFNUX0FMUEhBO1xuICAgIGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9BTFBIQTtcblxuICAgIGlmICggcCA9PT0gVEhSRUUuRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9DT0xPUjtcbiAgICBpZiAoIHAgPT09IFRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLk9ORV9NSU5VU19EU1RfQ09MT1I7XG4gICAgaWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yICkgcmV0dXJuIF9nbC5TUkNfQUxQSEFfU0FUVVJBVEU7XG5cbiAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xuXG4gICAgaWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XG5cbiAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCX1MzVENfRFhUMV9FWFQ7XG4gICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XG4gICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XG4gICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQ1X0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUNV9FWFQ7XG5cbiAgICB9XG5cbiAgICBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcblxuICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICBpZiAoIHAgPT09IFRIUkVFLlJHQl9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ180QlBQVjFfSU1HO1xuICAgICAgaWYgKCBwID09PSBUSFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfMkJQUFYxX0lNRztcbiAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcbiAgICAgIGlmICggcCA9PT0gVEhSRUUuUkdCQV9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfMkJQUFYxX0lNRztcblxuICAgIH1cblxuICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcblxuICAgIGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xuXG4gICAgICBpZiAoIHAgPT09IFRIUkVFLk1pbkVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NSU5fRVhUO1xuICAgICAgaWYgKCBwID09PSBUSFJFRS5NYXhFcXVhdGlvbiApIHJldHVybiBleHRlbnNpb24uTUFYX0VYVDtcblxuICAgIH1cblxuICAgIHJldHVybiAwO1xuXG4gIH1cblxuICAvLyBBbGxvY2F0aW9uc1xuXG4gIGZ1bmN0aW9uIGFsbG9jYXRlQm9uZXMgKCBvYmplY3QgKSB7XG5cbiAgICBpZiAoIF9zdXBwb3J0c0JvbmVUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnNrZWxldG9uICYmIG9iamVjdC5za2VsZXRvbi51c2VWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICByZXR1cm4gMTAyNDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIGRlZmF1bHQgZm9yIHdoZW4gb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgIC8vICggZm9yIGV4YW1wbGUgd2hlbiBwcmVidWlsZGluZyBzaGFkZXIgdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxlIG9iamVjdHMgKVxuICAgICAgLy9cbiAgICAgIC8vICAtIGxlYXZlIHNvbWUgZXh0cmEgc3BhY2UgZm9yIG90aGVyIHVuaWZvcm1zXG4gICAgICAvLyAgLSBsaW1pdCBoZXJlIGlzIEFOR0xFJ3MgMjU0IG1heCB1bmlmb3JtIHZlY3RvcnNcbiAgICAgIC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcblxuICAgICAgdmFyIG5WZXJ0ZXhVbmlmb3JtcyA9IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyApO1xuICAgICAgdmFyIG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoICggblZlcnRleFVuaWZvcm1zIC0gMjAgKSAvIDQgKTtcblxuICAgICAgdmFyIG1heEJvbmVzID0gblZlcnRleE1hdHJpY2VzO1xuXG4gICAgICBpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICYmIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlNraW5uZWRNZXNoICkge1xuXG4gICAgICAgIG1heEJvbmVzID0gTWF0aC5taW4oIG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGgsIG1heEJvbmVzICk7XG5cbiAgICAgICAgaWYgKCBtYXhCb25lcyA8IG9iamVjdC5za2VsZXRvbi5ib25lcy5sZW5ndGggKSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtICcgKyBvYmplY3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoICsgJywgdGhpcyBHUFUgc3VwcG9ydHMganVzdCAnICsgbWF4Qm9uZXMgKyAnICh0cnkgT3BlbkdMIGluc3RlYWQgb2YgQU5HTEUpJyApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWF4Qm9uZXM7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGFsbG9jYXRlTGlnaHRzKCBsaWdodHMgKSB7XG5cbiAgICB2YXIgZGlyTGlnaHRzID0gMDtcbiAgICB2YXIgcG9pbnRMaWdodHMgPSAwO1xuICAgIHZhciBzcG90TGlnaHRzID0gMDtcbiAgICB2YXIgaGVtaUxpZ2h0cyA9IDA7XG5cbiAgICBmb3IgKCB2YXIgbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xuXG4gICAgICB2YXIgbGlnaHQgPSBsaWdodHNbIGwgXTtcblxuICAgICAgaWYgKCBsaWdodC5vbmx5U2hhZG93IHx8IGxpZ2h0LnZpc2libGUgPT09IGZhbHNlICkgY29udGludWU7XG5cbiAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkgZGlyTGlnaHRzICsrO1xuICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSBwb2ludExpZ2h0cyArKztcbiAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBzcG90TGlnaHRzICsrO1xuICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkhlbWlzcGhlcmVMaWdodCApIGhlbWlMaWdodHMgKys7XG5cbiAgICB9XG5cbiAgICByZXR1cm4geyAnZGlyZWN0aW9uYWwnOiBkaXJMaWdodHMsICdwb2ludCc6IHBvaW50TGlnaHRzLCAnc3BvdCc6IHNwb3RMaWdodHMsICdoZW1pJzogaGVtaUxpZ2h0cyB9O1xuXG4gIH1cblxuICBmdW5jdGlvbiBhbGxvY2F0ZVNoYWRvd3MoIGxpZ2h0cyApIHtcblxuICAgIHZhciBtYXhTaGFkb3dzID0gMDtcblxuICAgIGZvciAoIHZhciBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XG5cbiAgICAgIHZhciBsaWdodCA9IGxpZ2h0c1sgbCBdO1xuXG4gICAgICBpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xuXG4gICAgICBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkgbWF4U2hhZG93cyArKztcbiAgICAgIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICYmICEgbGlnaHQuc2hhZG93Q2FzY2FkZSApIG1heFNoYWRvd3MgKys7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4U2hhZG93cztcblxuICB9XG5cbiAgLy8gREVQUkVDQVRFRFxuXG4gIHRoaXMuaW5pdE1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmluaXRNYXRlcmlhbCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gIH07XG5cbiAgdGhpcy5hZGRQcmVQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUHJlUGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfTtcblxuICB0aGlzLmFkZFBvc3RQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuYWRkUG9zdFBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xuXG4gIH07XG5cbiAgdGhpcy51cGRhdGVTaGFkb3dNYXAgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudXBkYXRlU2hhZG93TWFwKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XG5cbiAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuICAgIHNoYWRvd01hcEVuYWJsZWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwRW5hYmxlZCBpcyBub3cgLnNoYWRvd01hcC5lbmFibGVkLicgKTtcbiAgICAgICAgc2hhZG93TWFwLmVuYWJsZWQgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvd01hcFR5cGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2hhZG93TWFwLnR5cGU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xuICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcbiAgICAgICAgc2hhZG93TWFwLnR5cGUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNoYWRvd01hcEN1bGxGYWNlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNoYWRvd01hcC5jdWxsRmFjZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zaGFkb3dNYXBDdWxsRmFjZSBpcyBub3cgLnNoYWRvd01hcC5jdWxsRmFjZS4nICk7XG4gICAgICAgIHNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hhZG93TWFwRGVidWc6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gc2hhZG93TWFwLmRlYnVnO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcERlYnVnIGlzIG5vdyAuc2hhZG93TWFwLmRlYnVnLicgKTtcbiAgICAgICAgc2hhZG93TWFwLmRlYnVnID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzaGFkb3dNYXBDYXNjYWRlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHNoYWRvd01hcC5jYXNjYWRlO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcENhc2NhZGUgaXMgbm93IC5zaGFkb3dNYXAuY2FzY2FkZS4nICk7XG4gICAgICAgIHNoYWRvd01hcC5jYXNjYWRlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9ICk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy9XZWJHTFJlbmRlclRhcmdldC5qc1xuXG4vKipcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLndyYXBTID0gb3B0aW9ucy53cmFwUyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy53cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XG4gIHRoaXMud3JhcFQgPSBvcHRpb25zLndyYXBUICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcblxuICB0aGlzLm1hZ0ZpbHRlciA9IG9wdGlvbnMubWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1hZ0ZpbHRlciA6IFRIUkVFLkxpbmVhckZpbHRlcjtcbiAgdGhpcy5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XG5cbiAgdGhpcy5hbmlzb3Ryb3B5ID0gb3B0aW9ucy5hbmlzb3Ryb3B5ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFuaXNvdHJvcHkgOiAxO1xuXG4gIHRoaXMub2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcbiAgdGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gIHRoaXMuZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZm9ybWF0IDogVEhSRUUuUkdCQUZvcm1hdDtcbiAgdGhpcy50eXBlID0gb3B0aW9ucy50eXBlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xuXG4gIHRoaXMuZGVwdGhCdWZmZXIgPSBvcHRpb25zLmRlcHRoQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmRlcHRoQnVmZmVyIDogdHJ1ZTtcbiAgdGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xuXG4gIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcblxuICB0aGlzLnNoYXJlRGVwdGhGcm9tID0gb3B0aW9ucy5zaGFyZURlcHRoRnJvbSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaGFyZURlcHRoRnJvbSA6IG51bGw7XG5cbn07XG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQsXG5cbiAgc2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xuXG4gICAgaWYgKCB0aGlzLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmhlaWdodCAhPT0gaGVpZ2h0ICkge1xuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5kaXNwb3NlKCk7XG5cbiAgICB9XG4gIH0sXG5cbiAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0bXAgPSBuZXcgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQoIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0ICk7XG5cbiAgICB0bXAud3JhcFMgPSB0aGlzLndyYXBTO1xuICAgIHRtcC53cmFwVCA9IHRoaXMud3JhcFQ7XG5cbiAgICB0bXAubWFnRmlsdGVyID0gdGhpcy5tYWdGaWx0ZXI7XG4gICAgdG1wLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xuXG4gICAgdG1wLmFuaXNvdHJvcHkgPSB0aGlzLmFuaXNvdHJvcHk7XG5cbiAgICB0bXAub2Zmc2V0LmNvcHkoIHRoaXMub2Zmc2V0ICk7XG4gICAgdG1wLnJlcGVhdC5jb3B5KCB0aGlzLnJlcGVhdCApO1xuXG4gICAgdG1wLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuICAgIHRtcC50eXBlID0gdGhpcy50eXBlO1xuXG4gICAgdG1wLmRlcHRoQnVmZmVyID0gdGhpcy5kZXB0aEJ1ZmZlcjtcbiAgICB0bXAuc3RlbmNpbEJ1ZmZlciA9IHRoaXMuc3RlbmNpbEJ1ZmZlcjtcblxuICAgIHRtcC5nZW5lcmF0ZU1pcG1hcHMgPSB0aGlzLmdlbmVyYXRlTWlwbWFwcztcblxuICAgIHRtcC5zaGFyZURlcHRoRnJvbSA9IHRoaXMuc2hhcmVEZXB0aEZyb207XG5cbiAgICByZXR1cm4gdG1wO1xuXG4gIH0sXG5cbiAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5FdmVudERpc3BhdGNoZXIucHJvdG90eXBlLmFwcGx5KCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cbiAqL1xuXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XG5cbiAgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuY2FsbCggdGhpcywgd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApO1xuXG4gIHRoaXMuYWN0aXZlQ3ViZUZhY2UgPSAwOyAvLyBQWCAwLCBOWCAxLCBQWSAyLCBOWSAzLCBQWiA0LCBOWiA1XG5cbn07XG5cblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUgKTtcblRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmU7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEV4dGVuc2lvbnMuanNcblxuLyoqXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4qL1xuXG5USFJFRS5XZWJHTEV4dGVuc2lvbnMgPSBmdW5jdGlvbiAoIGdsICkge1xuXG4gIHZhciBleHRlbnNpb25zID0ge307XG5cbiAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgICBpZiAoIGV4dGVuc2lvbnNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICByZXR1cm4gZXh0ZW5zaW9uc1sgbmFtZSBdO1xuXG4gICAgfVxuXG4gICAgdmFyIGV4dGVuc2lvbjtcblxuICAgIHN3aXRjaCAoIG5hbWUgKSB7XG5cbiAgICAgIGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XG4gICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdNT1pfRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XG4gICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxuICAgICAgICBleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggbmFtZSApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBleHRlbnNpb24gPT09IG51bGwgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6ICcgKyBuYW1lICsgJyBleHRlbnNpb24gbm90IHN1cHBvcnRlZC4nICk7XG5cbiAgICB9XG5cbiAgICBleHRlbnNpb25zWyBuYW1lIF0gPSBleHRlbnNpb247XG5cbiAgICByZXR1cm4gZXh0ZW5zaW9uO1xuXG4gIH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTEdlb21ldHJpZXMuanNcblxuLyoqXG4qIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4qL1xuXG5USFJFRS5XZWJHTEdlb21ldHJpZXMgPSBmdW5jdGlvbiAoIGdsLCBpbmZvICkge1xuXG4gIHZhciBnZW9tZXRyaWVzID0ge307XG5cbiAgdGhpcy5nZXQgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICAgIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICAgIGlmICggZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICByZXR1cm4gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcblxuICAgIH1cblxuICAgIGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcblxuICAgIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgICAgZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IGdlb21ldHJ5O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpLnNldEZyb21PYmplY3QoIG9iamVjdCApO1xuXG4gICAgfVxuXG4gICAgaW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcblxuICAgIHJldHVybiBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gb25HZW9tZXRyeURpc3Bvc2UoIGV2ZW50ICkge1xuXG4gICAgdmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgZ2VvbWV0cnkucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbkdlb21ldHJ5RGlzcG9zZSApO1xuXG4gICAgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdO1xuXG4gICAgZm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcblxuICAgICAgdmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIG5hbWUgXTtcblxuICAgICAgaWYgKCBhdHRyaWJ1dGUuYnVmZmVyICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKCBhdHRyaWJ1dGUuYnVmZmVyICk7XG5cbiAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZS5idWZmZXI7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xPYmplY3RzLmpzXG5cbi8qKlxuKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuKi9cblxuVEhSRUUuV2ViR0xPYmplY3RzID0gZnVuY3Rpb24gKCBnbCwgaW5mbyApIHtcblxuICB2YXIgb2JqZWN0cyA9IHt9O1xuICB2YXIgb2JqZWN0c0ltbWVkaWF0ZSA9IFtdO1xuXG4gIHZhciBtb3JwaEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICk7XG5cbiAgdmFyIGdlb21ldHJpZXMgPSBuZXcgVEhSRUUuV2ViR0xHZW9tZXRyaWVzKCBnbCwgaW5mbyApO1xuXG4gIC8vXG5cbiAgZnVuY3Rpb24gb25PYmplY3RSZW1vdmVkKCBldmVudCApIHtcblxuICAgIHZhciBvYmplY3QgPSBldmVudC50YXJnZXQ7XG5cbiAgICBvYmplY3QudHJhdmVyc2UoIGZ1bmN0aW9uICggY2hpbGQgKSB7XG5cbiAgICAgIGNoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdyZW1vdmUnLCBvbk9iamVjdFJlbW92ZWQgKTtcbiAgICAgIHJlbW92ZU9iamVjdCggY2hpbGQgKTtcblxuICAgIH0gKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlT2JqZWN0KCBvYmplY3QgKSB7XG5cbiAgICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHxcbiAgICAgICBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludENsb3VkIHx8XG4gICAgICAgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcblxuICAgICAgZGVsZXRlIG9iamVjdHNbIG9iamVjdC5pZCBdO1xuXG4gICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0IHx8IG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayApIHtcblxuICAgICAgcmVtb3ZlSW5zdGFuY2VzKCBvYmplY3RzSW1tZWRpYXRlLCBvYmplY3QgKTtcblxuICAgIH1cblxuICAgIGRlbGV0ZSBvYmplY3QuX193ZWJnbEluaXQ7XG4gICAgZGVsZXRlIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4O1xuICAgIGRlbGV0ZSBvYmplY3QuX25vcm1hbE1hdHJpeDtcblxuICAgIGRlbGV0ZSBvYmplY3QuX193ZWJnbEFjdGl2ZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlSW5zdGFuY2VzKCBvYmpsaXN0LCBvYmplY3QgKSB7XG5cbiAgICBmb3IgKCB2YXIgbyA9IG9iamxpc3QubGVuZ3RoIC0gMTsgbyA+PSAwOyBvIC0tICkge1xuXG4gICAgICBpZiAoIG9iamxpc3RbIG8gXS5vYmplY3QgPT09IG9iamVjdCApIHtcblxuICAgICAgICBvYmpsaXN0LnNwbGljZSggbywgMSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vXG5cbiAgdGhpcy5vYmplY3RzID0gb2JqZWN0cztcbiAgdGhpcy5vYmplY3RzSW1tZWRpYXRlID0gb2JqZWN0c0ltbWVkaWF0ZTtcblxuICB0aGlzLmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gICAgaWYgKCBvYmplY3QuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgb2JqZWN0Ll9fd2ViZ2xJbml0ID0gdHJ1ZTtcbiAgICAgIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgIG9iamVjdC5fbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuICAgICAgb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIoICdyZW1vdmVkJywgb25PYmplY3RSZW1vdmVkICk7XG5cbiAgICB9XG5cbiAgICBpZiAoIG9iamVjdC5fX3dlYmdsQWN0aXZlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIG9iamVjdC5fX3dlYmdsQWN0aXZlID0gdHJ1ZTtcblxuICAgICAgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRDbG91ZCApIHtcblxuICAgICAgICBvYmplY3RzWyBvYmplY3QuaWQgXSA9IHtcbiAgICAgICAgICBpZDogb2JqZWN0LmlkLFxuICAgICAgICAgIG9iamVjdDogb2JqZWN0LFxuICAgICAgICAgIHo6IDBcbiAgICAgICAgfTtcblxuICAgICAgfSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0IHx8IG9iamVjdC5pbW1lZGlhdGVSZW5kZXJDYWxsYmFjayApIHtcblxuICAgICAgICBvYmplY3RzSW1tZWRpYXRlLnB1c2goIHtcbiAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICBvYmplY3Q6IG9iamVjdCxcbiAgICAgICAgICBvcGFxdWU6IG51bGwsXG4gICAgICAgICAgdHJhbnNwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgejogMFxuICAgICAgICB9ICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG4gIGZ1bmN0aW9uIG51bWVyaWNhbFNvcnQgKCBhLCBiICkge1xuXG4gICAgcmV0dXJuIGJbIDAgXSAtIGFbIDAgXTtcblxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlT2JqZWN0KCBvYmplY3QgKSB7XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzLmdldCggb2JqZWN0ICk7XG5cbiAgICBpZiAoIG9iamVjdC5nZW9tZXRyeS5keW5hbWljID09PSB0cnVlICkge1xuXG4gICAgICBnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcblxuICAgIH1cblxuICAgIC8vIG1vcnBoIHRhcmdldHNcblxuICAgIGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICB2YXIgYWN0aXZlSW5mbHVlbmNlcyA9IFtdO1xuICAgICAgdmFyIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1vcnBoVGFyZ2V0SW5mbHVlbmNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHZhciBpbmZsdWVuY2UgPSBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIGkgXTtcbiAgICAgICAgYWN0aXZlSW5mbHVlbmNlcy5wdXNoKCBbIGluZmx1ZW5jZSwgaSBdICk7XG5cbiAgICAgIH1cblxuICAgICAgYWN0aXZlSW5mbHVlbmNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XG5cbiAgICAgIGlmICggYWN0aXZlSW5mbHVlbmNlcy5sZW5ndGggPiA4ICkge1xuXG4gICAgICAgIGFjdGl2ZUluZmx1ZW5jZXMubGVuZ3RoID0gODtcblxuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBhY3RpdmVJbmZsdWVuY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgbW9ycGhJbmZsdWVuY2VzWyBpIF0gPSBhY3RpdmVJbmZsdWVuY2VzWyBpIF1bIDAgXTtcblxuICAgICAgICB2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzWyBhY3RpdmVJbmZsdWVuY2VzWyBpIF1bIDEgXSBdO1xuICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaFRhcmdldCcgKyBpLCBhdHRyaWJ1dGUgKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XG5cbiAgICAgIGlmICggbWF0ZXJpYWwucHJvZ3JhbSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGlmICggbWF0ZXJpYWwucHJvZ3JhbS51bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IG51bGwgKSB7XG5cbiAgICAgICAgICBnbC51bmlmb3JtMWZ2KCBtYXRlcmlhbC5wcm9ncmFtLnVuaWZvcm1zLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcywgbW9ycGhJbmZsdWVuY2VzICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RPRklYOiBtYXRlcmlhbC5wcm9ncmFtIGlzIHVuZGVmaW5lZCcgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy9cblxuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcblxuICAgIGZvciAoIHZhciBuYW1lIGluIGF0dHJpYnV0ZXMgKSB7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cbiAgICAgIHZhciBidWZmZXJUeXBlID0gKCBuYW1lID09PSAnaW5kZXgnICkgPyBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IGdsLkFSUkFZX0JVRkZFUjtcblxuICAgICAgdmFyIGRhdGEgPSAoIGF0dHJpYnV0ZSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkgPyBhdHRyaWJ1dGUuZGF0YSA6IGF0dHJpYnV0ZTtcblxuICAgICAgaWYgKCBkYXRhLmJ1ZmZlciA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIGRhdGEuYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGRhdGEuYnVmZmVyICk7XG5cbiAgICAgICAgdmFyIHVzYWdlID0gZ2wuU1RBVElDX0RSQVc7XG5cbiAgICAgICAgaWYgKCBkYXRhIGluc3RhbmNlb2YgVEhSRUUuRHluYW1pY0J1ZmZlckF0dHJpYnV0ZVxuICAgICAgICAgICAgIHx8ICggZGF0YSBpbnN0YW5jZW9mIFRIUkVFLkluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSAmJiBkYXRhLmR5bmFtaWMgPT09IHRydWUgKVxuICAgICAgICAgICAgIHx8ICggZGF0YSBpbnN0YW5jZW9mIFRIUkVFLkludGVybGVhdmVkQnVmZmVyICYmIGRhdGEuZHluYW1pYyA9PT0gdHJ1ZSApICkge1xuXG4gICAgICAgICAgdXNhZ2UgPSBnbC5EWU5BTUlDX0RSQVc7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoIGJ1ZmZlclR5cGUsIGRhdGEuYXJyYXksIHVzYWdlICk7XG5cbiAgICAgICAgZGF0YS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICB9IGVsc2UgaWYgKCBkYXRhLm5lZWRzVXBkYXRlID09PSB0cnVlICkge1xuXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoIGJ1ZmZlclR5cGUsIGRhdGEuYnVmZmVyICk7XG5cbiAgICAgICAgaWYgKCBkYXRhLnVwZGF0ZVJhbmdlID09PSB1bmRlZmluZWQgfHwgZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gLTEgKSB7IC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXG5cbiAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCAwLCBkYXRhLmFycmF5ICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggZGF0YS51cGRhdGVSYW5nZS5jb3VudCA9PT0gMCApIHtcblxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnVwZGF0ZU9iamVjdDogdXNpbmcgdXBkYXRlUmFuZ2UgZm9yIFRIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgYW5kIG1hcmtlZCBhcyBuZWVkc1VwZGF0ZSBidXQgY291bnQgaXMgMCwgZW5zdXJlIHlvdSBhcmUgdXNpbmcgc2V0IG1ldGhvZHMgb3IgdXBkYXRpbmcgbWFudWFsbHkuJyApO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCBkYXRhLnVwZGF0ZVJhbmdlLm9mZnNldCAqIGRhdGEuYXJyYXkuQllURVNfUEVSX0VMRU1FTlQsXG4gICAgICAgICAgICAgICAgICAgZGF0YS5hcnJheS5zdWJhcnJheSggZGF0YS51cGRhdGVSYW5nZS5vZmZzZXQsIGRhdGEudXBkYXRlUmFuZ2Uub2Zmc2V0ICsgZGF0YS51cGRhdGVSYW5nZS5jb3VudCApICk7XG5cbiAgICAgICAgICBkYXRhLnVwZGF0ZVJhbmdlLmNvdW50ID0gMDsgLy8gcmVzZXQgcmFuZ2VcblxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggcmVuZGVyTGlzdCApIHtcblxuICAgIGZvciAoIHZhciBpID0gMCwgdWwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IHVsOyBpKysgKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSByZW5kZXJMaXN0W2ldLm9iamVjdDtcblxuICAgICAgaWYgKCBvYmplY3QubWF0ZXJpYWwudmlzaWJsZSAhPT0gZmFsc2UgKSB7XG5cbiAgICAgICAgdXBkYXRlT2JqZWN0KCBvYmplY3QgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFByb2dyYW0uanNcblxuVEhSRUUuV2ViR0xQcm9ncmFtID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHByb2dyYW1JZENvdW50ID0gMDtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKSB7XG5cbiAgICB2YXIgY2h1bmtzID0gW107XG5cbiAgICBmb3IgKCB2YXIgbmFtZSBpbiBkZWZpbmVzICkge1xuXG4gICAgICB2YXIgdmFsdWUgPSBkZWZpbmVzWyBuYW1lIF07XG5cbiAgICAgIGlmICggdmFsdWUgPT09IGZhbHNlICkgY29udGludWU7XG5cbiAgICAgIGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gY2h1bmtzLmpvaW4oICdcXG4nICk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoVW5pZm9ybUxvY2F0aW9ucyggZ2wsIHByb2dyYW0sIGlkZW50aWZpZXJzICkge1xuXG5cbiAgICB2YXIgdW5pZm9ybXMgPSB7fTtcblxuICAgIHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpICsrICkge1xuXG4gICAgICB2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0gLCBpICk7XG4gICAgICB2YXIgbmFtZSA9IGluZm8ubmFtZTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgbmFtZSApO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVU5JRk9STTpcIiwgbmFtZSk7XG5cbiAgICAgIHZhciBzdWZmaXhQb3MgPSBuYW1lLmxhc3RJbmRleE9mKCAnWzBdJyApO1xuICAgICAgaWYgKCBzdWZmaXhQb3MgIT09IC0xICYmIHN1ZmZpeFBvcyA9PT0gbmFtZS5sZW5ndGggLSAzICkge1xuXG4gICAgICAgIHVuaWZvcm1zWyBuYW1lLnN1YnN0ciggMCwgc3VmZml4UG9zICkgXSA9IGxvY2F0aW9uO1xuXG4gICAgICB9XG5cbiAgICAgIHVuaWZvcm1zWyBuYW1lIF0gPSBsb2NhdGlvbjtcblxuICAgIH1cblxuICAgIHJldHVybiB1bmlmb3JtcztcblxuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtLCBpZGVudGlmaWVycyApIHtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG5cbiAgICB2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBuOyBpICsrICkge1xuXG4gICAgICB2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYiggcHJvZ3JhbSAsIGkgKTtcbiAgICAgIHZhciBuYW1lID0gaW5mby5uYW1lO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKFwiVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVkVSVEVYIEFUVFJJQlVURTpcIiwgbmFtZSk7XG5cbiAgICAgIGF0dHJpYnV0ZXNbIG5hbWUgXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBwcm9ncmFtLCBuYW1lICk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcblxuICB9XG5cbiAgZnVuY3Rpb24gZmlsdGVyRW1wdHlMaW5lKCBzdHJpbmcgKSB7XG5cbiAgICByZXR1cm4gc3RyaW5nICE9PSAnJztcblxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggcmVuZGVyZXIsIGNvZGUsIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICkge1xuXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuICAgIHZhciBkZWZpbmVzID0gbWF0ZXJpYWwuZGVmaW5lcztcbiAgICB2YXIgdW5pZm9ybXMgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnVuaWZvcm1zO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gbWF0ZXJpYWwuYXR0cmlidXRlcztcblxuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLnZlcnRleFNoYWRlcjtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBtYXRlcmlhbC5fX3dlYmdsU2hhZGVyLmZyYWdtZW50U2hhZGVyO1xuXG4gICAgdmFyIGluZGV4MEF0dHJpYnV0ZU5hbWUgPSBtYXRlcmlhbC5pbmRleDBBdHRyaWJ1dGVOYW1lO1xuXG4gICAgLypcbiAgICBpZiAoIGluZGV4MEF0dHJpYnV0ZU5hbWUgPT09IHVuZGVmaW5lZCAmJiBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA9PT0gdHJ1ZSApIHtcblxuICAgICAgLy8gcHJvZ3JhbXMgd2l0aCBtb3JwaFRhcmdldHMgZGlzcGxhY2UgcG9zaXRpb24gb3V0IG9mIGF0dHJpYnV0ZSAwXG5cbiAgICAgIGluZGV4MEF0dHJpYnV0ZU5hbWUgPSAncG9zaXRpb24nO1xuXG4gICAgfVxuICAgICovXG5cbiAgICB2YXIgc2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9CQVNJQyc7XG5cbiAgICBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU2hhZG93TWFwICkge1xuXG4gICAgICBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX1BDRic7XG5cbiAgICB9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XG5cbiAgICAgIHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQnO1xuXG4gICAgfVxuXG4gICAgdmFyIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfQ1VCRSc7XG4gICAgdmFyIGVudk1hcE1vZGVEZWZpbmUgPSAnRU5WTUFQX01PREVfUkVGTEVDVElPTic7XG4gICAgdmFyIGVudk1hcEJsZW5kaW5nRGVmaW5lID0gJ0VOVk1BUF9CTEVORElOR19NVUxUSVBMWSc7XG5cbiAgICBpZiAoIHBhcmFtZXRlcnMuZW52TWFwICkge1xuXG4gICAgICBzd2l0Y2ggKCBtYXRlcmlhbC5lbnZNYXAubWFwcGluZyApIHtcblxuICAgICAgICBjYXNlIFRIUkVFLkN1YmVSZWZsZWN0aW9uTWFwcGluZzpcbiAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOlxuICAgICAgICBjYXNlIFRIUkVFLkVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nOlxuICAgICAgICAgIGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfRVFVSVJFQyc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBUSFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZzpcbiAgICAgICAgICBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX1NQSEVSRSc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIH1cblxuICAgICAgc3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XG5cbiAgICAgICAgY2FzZSBUSFJFRS5DdWJlUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgICAgIGNhc2UgVEhSRUUuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XG4gICAgICAgICAgZW52TWFwTW9kZURlZmluZSA9ICdFTlZNQVBfTU9ERV9SRUZSQUNUSU9OJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKCBtYXRlcmlhbC5jb21iaW5lICkge1xuXG4gICAgICAgIGNhc2UgVEhSRUUuTXVsdGlwbHlPcGVyYXRpb246XG4gICAgICAgICAgZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFRIUkVFLk1peE9wZXJhdGlvbjpcbiAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFRIUkVFLkFkZE9wZXJhdGlvbjpcbiAgICAgICAgICBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdmFyIGdhbW1hRmFjdG9yRGVmaW5lID0gKCByZW5kZXJlci5nYW1tYUZhY3RvciA+IDAgKSA/IHJlbmRlcmVyLmdhbW1hRmFjdG9yIDogMS4wO1xuXG4gICAgLy8gY29uc29sZS5sb2coICdidWlsZGluZyBuZXcgcHJvZ3JhbSAnICk7XG5cbiAgICAvL1xuXG4gICAgdmFyIGN1c3RvbURlZmluZXMgPSBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKTtcblxuICAgIC8vXG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIHZhciBwcmVmaXhWZXJ0ZXgsIHByZWZpeEZyYWdtZW50O1xuXG4gICAgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlJhd1NoYWRlck1hdGVyaWFsICkge1xuXG4gICAgICBwcmVmaXhWZXJ0ZXggPSAnJztcbiAgICAgIHByZWZpeEZyYWdtZW50ID0gJyc7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBwcmVmaXhWZXJ0ZXggPSBbXG5cbiAgICAgICAgJ3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXG4gICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBpbnQ7JyxcblxuICAgICAgICBjdXN0b21EZWZpbmVzLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcblxuICAgICAgICByZW5kZXJlci5nYW1tYUlucHV0ID8gJyNkZWZpbmUgR0FNTUFfSU5QVVQnIDogJycsXG4gICAgICAgIHJlbmRlcmVyLmdhbW1hT3V0cHV0ID8gJyNkZWZpbmUgR0FNTUFfT1VUUFVUJyA6ICcnLFxuICAgICAgICAnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxuXG4gICAgICAgICcjZGVmaW5lIE1BWF9ESVJfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcbiAgICAgICAgJyNkZWZpbmUgTUFYX1BPSU5UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhQb2ludExpZ2h0cyxcbiAgICAgICAgJyNkZWZpbmUgTUFYX1NQT1RfTElHSFRTICcgKyBwYXJhbWV0ZXJzLm1heFNwb3RMaWdodHMsXG4gICAgICAgICcjZGVmaW5lIE1BWF9IRU1JX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxuXG4gICAgICAgICcjZGVmaW5lIE1BWF9TSEFET1dTICcgKyBwYXJhbWV0ZXJzLm1heFNoYWRvd3MsXG5cbiAgICAgICAgJyNkZWZpbmUgTUFYX0JPTkVTICcgKyBwYXJhbWV0ZXJzLm1heEJvbmVzLFxuXG4gICAgICAgIHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCc6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuc2tpbm5pbmcgPyAnI2RlZmluZSBVU0VfU0tJTk5JTkcnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/ICcjZGVmaW5lIEJPTkVfVEVYVFVSRScgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubW9ycGhOb3JtYWxzID8gJyNkZWZpbmUgVVNFX01PUlBITk9STUFMUycgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lICcgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyAnI2RlZmluZSBTSEFET1dNQVBfREVCVUcnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuc2hhZG93TWFwQ2FzY2FkZSA/ICcjZGVmaW5lIFNIQURPV01BUF9DQVNDQURFJyA6ICcnLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCgnRVhUX2ZyYWdfZGVwdGgnKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXG5cblxuICAgICAgICAndW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxuXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzMgbm9ybWFsOycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiB1djsnLFxuXG4gICAgICAgICcjaWZkZWYgVVNFX0NPTE9SJyxcblxuICAgICAgICAnIGF0dHJpYnV0ZSB2ZWMzIGNvbG9yOycsXG5cbiAgICAgICAgJyNlbmRpZicsXG5cbiAgICAgICAgJyNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTJyxcblxuICAgICAgICAnIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MDsnLFxuICAgICAgICAnIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxuICAgICAgICAnIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MjsnLFxuICAgICAgICAnIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MzsnLFxuXG4gICAgICAgICcgI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFMnLFxuXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDA7JyxcbiAgICAgICAgJyAgIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTsnLFxuICAgICAgICAnICAgYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwyOycsXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDM7JyxcblxuICAgICAgICAnICNlbHNlJyxcblxuICAgICAgICAnICAgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsXG4gICAgICAgICcgICBhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDU7JyxcbiAgICAgICAgJyAgIGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjsnLFxuICAgICAgICAnICAgYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsXG5cbiAgICAgICAgJyAjZW5kaWYnLFxuXG4gICAgICAgICcjZW5kaWYnLFxuXG4gICAgICAgICcjaWZkZWYgVVNFX1NLSU5OSU5HJyxcblxuICAgICAgICAnIGF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDsnLFxuICAgICAgICAnIGF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7JyxcblxuICAgICAgICAnI2VuZGlmJyxcblxuICAgICAgICAnXFxuJ1xuXG4gICAgICBdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuICAgICAgcHJlZml4RnJhZ21lbnQgPSBbXG5cbiAgICAgICAgKCBwYXJhbWV0ZXJzLmJ1bXBNYXAgfHwgcGFyYW1ldGVycy5ub3JtYWxNYXAgfHwgcGFyYW1ldGVycy5mbGF0U2hhZGluZyB8fCBtYXRlcmlhbC5kZXJpdmF0aXZlcyApID8gJyNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlJyA6ICcnLFxuXG4gICAgICAgICdwcmVjaXNpb24gJyArIHBhcmFtZXRlcnMucHJlY2lzaW9uICsgJyBmbG9hdDsnLFxuICAgICAgICAncHJlY2lzaW9uICcgKyBwYXJhbWV0ZXJzLnByZWNpc2lvbiArICcgaW50OycsXG5cbiAgICAgICAgY3VzdG9tRGVmaW5lcyxcblxuICAgICAgICAnI2RlZmluZSBNQVhfRElSX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhEaXJMaWdodHMsXG4gICAgICAgICcjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4UG9pbnRMaWdodHMsXG4gICAgICAgICcjZGVmaW5lIE1BWF9TUE9UX0xJR0hUUyAnICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxuICAgICAgICAnI2RlZmluZSBNQVhfSEVNSV9MSUdIVFMgJyArIHBhcmFtZXRlcnMubWF4SGVtaUxpZ2h0cyxcblxuICAgICAgICAnI2RlZmluZSBNQVhfU0hBRE9XUyAnICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxuXG4gICAgICAgIHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxuXG4gICAgICAgIHJlbmRlcmVyLmdhbW1hSW5wdXQgPyAnI2RlZmluZSBHQU1NQV9JTlBVVCcgOiAnJyxcbiAgICAgICAgcmVuZGVyZXIuZ2FtbWFPdXRwdXQgPyAnI2RlZmluZSBHQU1NQV9PVVRQVVQnIDogJycsXG4gICAgICAgICcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXG5cbiAgICAgICAgKCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcbiAgICAgICAgKCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZ0V4cCApID8gJyNkZWZpbmUgRk9HX0VYUDInIDogJycsXG5cbiAgICAgICAgcGFyYW1ldGVycy5tYXAgPyAnI2RlZmluZSBVU0VfTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBCbGVuZGluZ0RlZmluZSA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmFvTWFwID8gJyNkZWZpbmUgVVNFX0FPTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcbiAgICAgICAgcGFyYW1ldGVycy5ub3JtYWxNYXAgPyAnI2RlZmluZSBVU0VfTk9STUFMTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gJyNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/ICcjZGVmaW5lIFVTRV9DT0xPUicgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLm1ldGFsID8gJyNkZWZpbmUgTUVUQUwnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gJyNkZWZpbmUgRkxJUF9TSURFRCcgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSBVU0VfU0hBRE9XTUFQJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcERlYnVnID8gJyNkZWZpbmUgU0hBRE9XTUFQX0RFQlVHJyA6ICcnLFxuICAgICAgICBwYXJhbWV0ZXJzLnNoYWRvd01hcENhc2NhZGUgPyAnI2RlZmluZSBTSEFET1dNQVBfQ0FTQ0FERScgOiAnJyxcblxuICAgICAgICBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXG4gICAgICAgIHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiByZW5kZXJlci5leHRlbnNpb25zLmdldCgnRVhUX2ZyYWdfZGVwdGgnKSA/ICcjZGVmaW5lIFVTRV9MT0dERVBUSEJVRl9FWFQnIDogJycsXG5cbiAgICAgICAgJ3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzMgY2FtZXJhUG9zaXRpb247JyxcblxuICAgICAgICAnXFxuJ1xuXG4gICAgICBdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcbicgKTtcblxuICAgIH1cblxuICAgIHZhciB2ZXJ0ZXhHbHNsID0gcHJlZml4VmVydGV4ICsgdmVydGV4U2hhZGVyO1xuICAgIHZhciBmcmFnbWVudEdsc2wgPSBwcmVmaXhGcmFnbWVudCArIGZyYWdtZW50U2hhZGVyO1xuXG4gICAgdmFyIGdsVmVydGV4U2hhZGVyID0gbmV3IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4R2xzbCApO1xuICAgIHZhciBnbEZyYWdtZW50U2hhZGVyID0gbmV3IFRIUkVFLldlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcblxuICAgIGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xWZXJ0ZXhTaGFkZXIgKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIGlmICggaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAvLyBGb3JjZSBhIHBhcnRpY3VsYXIgYXR0cmlidXRlIHRvIGluZGV4IDAuXG4gICAgICAvLyBiZWNhdXNlIHBvdGVudGlhbGx5IGV4cGVuc2l2ZSBlbXVsYXRpb24gaXMgZG9uZSBieSBicm93c2VyIGlmIGF0dHJpYnV0ZSAwIGlzIGRpc2FibGVkLlxuICAgICAgLy8gQW5kLCBjb2xvciwgZm9yIGV4YW1wbGUgaXMgb2Z0ZW4gYXV0b21hdGljYWxseSBib3VuZCB0byBpbmRleCAwIHNvIGRpc2FibGluZyBpdFxuXG4gICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24oIHByb2dyYW0sIDAsIGluZGV4MEF0dHJpYnV0ZU5hbWUgKTtcblxuICAgIH1cblxuICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICB2YXIgcHJvZ3JhbUxvZ0luZm8gPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApO1xuICAgIHZhciB2ZXJ0ZXhFcnJvckxvZ0luZm8gPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbFZlcnRleFNoYWRlciApO1xuICAgIHZhciBmcmFnbWVudEVycm9yTG9nSW5mbyA9IGdsLmdldFNoYWRlckluZm9Mb2coIGdsRnJhZ21lbnRTaGFkZXIgKTtcblxuICAgIGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMgKSA9PT0gZmFsc2UgKSB7XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nSW5mbywgdmVydGV4RXJyb3JMb2dJbmZvLCBmcmFnbWVudEVycm9yTG9nSW5mbyApO1xuXG4gICAgfVxuXG4gICAgaWYgKCBwcm9ncmFtTG9nSW5mbyAhPT0gJycgKSB7XG5cbiAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIHByb2dyYW1Mb2dJbmZvICk7XG5cbiAgICB9XG5cbiAgICAvLyBjbGVhbiB1cFxuXG4gICAgZ2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xuICAgIGdsLmRlbGV0ZVNoYWRlciggZ2xGcmFnbWVudFNoYWRlciApO1xuXG4gICAgLy8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXG5cbiAgICB2YXIgZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2NhY2hlZFVuaWZvcm1zOyB9O1xuXG4gICAgdGhpcy5nZXRVbmlmb3JtcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAvLyBmZXRjaCwgY2FjaGUsIGFuZCBuZXh0IHRpbWUganVzdCB1c2UgYSBkdW1iIGFjY2Vzc29yXG4gICAgICB2YXIgdW5pZm9ybXMgPSBmZXRjaFVuaWZvcm1Mb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XG4gICAgICB0aGlzLl9jYWNoZWRVbmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgICAgdGhpcy5nZXRVbmlmb3JtcyA9IGdldFVuaWZvcm1zO1xuICAgICAgcmV0dXJuIHVuaWZvcm1zO1xuXG4gICAgfTtcblxuICAgIC8vIHNldCB1cCBjYWNoaW5nIGZvciBhdHRyaWJ1dGUgbG9jYXRpb25zXG5cbiAgICB2YXIgZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fY2FjaGVkQXR0cmlidXRlczsgfTtcblxuICAgIHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGZldGNoQXR0cmlidXRlTG9jYXRpb25zKCBnbCwgcHJvZ3JhbSApO1xuICAgICAgdGhpcy5fY2FjaGVkQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzO1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG5cbiAgICB9O1xuXG4gICAgLy8gREVQUkVDQVRFRFxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcblxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLnVuaWZvcm1zIGlzIG5vdyAuZ2V0VW5pZm9ybXMoKS4nICk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VW5pZm9ybXMoKTtcblxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC5hdHRyaWJ1dGVzIGlzIG5vdyAuZ2V0QXR0cmlidXRlcygpLicgKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGVzKCk7XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG5cblxuICAgIC8vXG5cbiAgICB0aGlzLmlkID0gcHJvZ3JhbUlkQ291bnQgKys7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLnVzZWRUaW1lcyA9IDE7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB0aGlzLnZlcnRleFNoYWRlciA9IGdsVmVydGV4U2hhZGVyO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBnbEZyYWdtZW50U2hhZGVyO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfTtcblxufSApKCk7XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9XZWJHTFNoYWRlci5qc1xuXG5USFJFRS5XZWJHTFNoYWRlciA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBhZGRMaW5lTnVtYmVycyA9IGZ1bmN0aW9uICggc3RyaW5nICkge1xuXG4gICAgdmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICBsaW5lc1sgaSBdID0gKCBpICsgMSApICsgJzogJyArIGxpbmVzWyBpIF07XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXMuam9pbiggJ1xcbicgKTtcblxuICB9O1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XG5cbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XG4gICAgZ2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XG5cbiAgICBpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMU2hhZGVyOiBTaGFkZXIgY291bGRuXFwndCBjb21waWxlLicgKTtcblxuICAgIH1cblxuICAgIGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xuXG4gICAgICBjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRlcjogZ2wuZ2V0U2hhZGVySW5mb0xvZygpJywgdHlwZSA9PT0gZ2wuVkVSVEVYX1NIQURFUiA/ICd2ZXJ0ZXgnIDogJ2ZyYWdtZW50JywgZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICksIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSApO1xuXG4gICAgfVxuXG4gICAgLy8gLS1lbmFibGUtcHJpdmlsZWdlZC13ZWJnbC1leHRlbnNpb25cbiAgICAvLyBjb25zb2xlLmxvZyggdHlwZSwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfZGVidWdfc2hhZGVycycgKS5nZXRUcmFuc2xhdGVkU2hhZGVyU291cmNlKCBzaGFkZXIgKSApO1xuXG4gICAgcmV0dXJuIHNoYWRlcjtcblxuICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL1dlYkdMU2hhZG93TWFwLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuV2ViR0xTaGFkb3dNYXAgPSBmdW5jdGlvbiAoIF9yZW5kZXJlciwgX2xpZ2h0cywgX29iamVjdHMgKSB7XG5cbiAgdmFyIF9nbCA9IF9yZW5kZXJlci5jb250ZXh0LFxuICBfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXG4gIF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKSxcblxuICBfbWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgX21heCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgX3dlYmdsT2JqZWN0cyA9IF9vYmplY3RzLm9iamVjdHMsXG4gIF93ZWJnbE9iamVjdHNJbW1lZGlhdGUgPSBfb2JqZWN0cy5vYmplY3RzSW1tZWRpYXRlLFxuXG4gIF9tYXRyaXhQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG5cbiAgX3JlbmRlckxpc3QgPSBbXTtcblxuICAvLyBpbml0XG5cbiAgdmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XG4gIHZhciBkZXB0aFVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggZGVwdGhTaGFkZXIudW5pZm9ybXMgKTtcblxuICB2YXIgX2RlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcbiAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXJcbiAgIH0gKTtcblxuICB2YXIgX2RlcHRoTWF0ZXJpYWxNb3JwaCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuICAgIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICBtb3JwaFRhcmdldHM6IHRydWVcbiAgfSApO1xuXG4gIHZhciBfZGVwdGhNYXRlcmlhbFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHtcbiAgICB1bmlmb3JtczogZGVwdGhVbmlmb3JtcyxcbiAgICB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsXG4gICAgc2tpbm5pbmc6IHRydWVcbiAgfSApO1xuXG4gIHZhciBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgge1xuICAgIHVuaWZvcm1zOiBkZXB0aFVuaWZvcm1zLFxuICAgIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyOiBkZXB0aFNoYWRlci5mcmFnbWVudFNoYWRlcixcbiAgICBtb3JwaFRhcmdldHM6IHRydWUsXG4gICAgc2tpbm5pbmc6IHRydWVcbiAgfSApO1xuXG4gIF9kZXB0aE1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcbiAgX2RlcHRoTWF0ZXJpYWxNb3JwaC5fc2hhZG93UGFzcyA9IHRydWU7XG4gIF9kZXB0aE1hdGVyaWFsU2tpbi5fc2hhZG93UGFzcyA9IHRydWU7XG4gIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcblxuICAvL1xuXG4gIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gIHRoaXMudHlwZSA9IFRIUkVFLlBDRlNoYWRvd01hcDtcbiAgdGhpcy5jdWxsRmFjZSA9IFRIUkVFLkN1bGxGYWNlRnJvbnQ7XG4gIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgdGhpcy5jYXNjYWRlID0gZmFsc2U7XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XG5cbiAgICBpZiAoIHNjb3BlLmVuYWJsZWQgPT09IGZhbHNlICkgcmV0dXJuO1xuXG4gICAgdmFyIGksIGlsLCBqLCBqbCwgbixcblxuICAgIHNoYWRvd01hcCwgc2hhZG93TWF0cml4LCBzaGFkb3dDYW1lcmEsXG4gICAgd2ViZ2xPYmplY3QsIG9iamVjdCwgbWF0ZXJpYWwsIGxpZ2h0LFxuXG4gICAgbGlnaHRzID0gW10sXG4gICAgayA9IDAsXG5cbiAgICBmb2cgPSBudWxsO1xuXG4gICAgLy8gc2V0IEdMIHN0YXRlIGZvciBkZXB0aCBtYXBcblxuICAgIF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XG4gICAgX2dsLmRpc2FibGUoIF9nbC5CTEVORCApO1xuXG4gICAgX2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xuICAgIF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcblxuICAgIGlmICggc2NvcGUuY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XG5cbiAgICAgIF9nbC5jdWxsRmFjZSggX2dsLkZST05UICk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XG5cbiAgICB9XG5cbiAgICBfcmVuZGVyZXIuc3RhdGUuc2V0RGVwdGhUZXN0KCB0cnVlICk7XG5cbiAgICAvLyBwcmVwcm9jZXNzIGxpZ2h0c1xuICAgIC8vICAtIHNraXAgbGlnaHRzIHRoYXQgYXJlIG5vdCBjYXN0aW5nIHNoYWRvd3NcbiAgICAvLyAgLSBjcmVhdGUgdmlydHVhbCBsaWdodHMgZm9yIGNhc2NhZGVkIHNoYWRvdyBtYXBzXG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBfbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBsaWdodCA9IF9saWdodHNbIGkgXTtcblxuICAgICAgaWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcblxuICAgICAgaWYgKCAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApICYmIGxpZ2h0LnNoYWRvd0Nhc2NhZGUgKSB7XG5cbiAgICAgICAgZm9yICggbiA9IDA7IG4gPCBsaWdodC5zaGFkb3dDYXNjYWRlQ291bnQ7IG4gKysgKSB7XG5cbiAgICAgICAgICB2YXIgdmlydHVhbExpZ2h0O1xuXG4gICAgICAgICAgaWYgKCAhIGxpZ2h0LnNoYWRvd0Nhc2NhZGVBcnJheVsgbiBdICkge1xuXG4gICAgICAgICAgICB2aXJ0dWFsTGlnaHQgPSBjcmVhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBuICk7XG4gICAgICAgICAgICB2aXJ0dWFsTGlnaHQub3JpZ2luYWxDYW1lcmEgPSBjYW1lcmE7XG5cbiAgICAgICAgICAgIHZhciBneXJvID0gbmV3IFRIUkVFLkd5cm9zY29wZSgpO1xuICAgICAgICAgICAgZ3lyby5wb3NpdGlvbi5jb3B5KCBsaWdodC5zaGFkb3dDYXNjYWRlT2Zmc2V0ICk7XG5cbiAgICAgICAgICAgIGd5cm8uYWRkKCB2aXJ0dWFsTGlnaHQgKTtcbiAgICAgICAgICAgIGd5cm8uYWRkKCB2aXJ0dWFsTGlnaHQudGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIGNhbWVyYS5hZGQoIGd5cm8gKTtcblxuICAgICAgICAgICAgbGlnaHQuc2hhZG93Q2FzY2FkZUFycmF5WyBuIF0gPSB2aXJ0dWFsTGlnaHQ7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coIFwiQ3JlYXRlZCB2aXJ0dWFsTGlnaHRcIiwgdmlydHVhbExpZ2h0ICk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2aXJ0dWFsTGlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHVwZGF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIG4gKTtcblxuICAgICAgICAgIGxpZ2h0c1sgayBdID0gdmlydHVhbExpZ2h0O1xuICAgICAgICAgIGsgKys7XG5cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGxpZ2h0c1sgayBdID0gbGlnaHQ7XG4gICAgICAgIGsgKys7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIHJlbmRlciBkZXB0aCBtYXBcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgbGlnaHQgPSBsaWdodHNbIGkgXTtcblxuICAgICAgaWYgKCAhIGxpZ2h0LnNoYWRvd01hcCApIHtcblxuICAgICAgICB2YXIgc2hhZG93RmlsdGVyID0gVEhSRUUuTGluZWFyRmlsdGVyO1xuXG4gICAgICAgIGlmICggc2NvcGUudHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcblxuICAgICAgICAgIHNoYWRvd0ZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJzID0geyBtaW5GaWx0ZXI6IHNoYWRvd0ZpbHRlciwgbWFnRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIGZvcm1hdDogVEhSRUUuUkdCQUZvcm1hdCB9O1xuXG4gICAgICAgIGxpZ2h0LnNoYWRvd01hcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggbGlnaHQuc2hhZG93TWFwV2lkdGgsIGxpZ2h0LnNoYWRvd01hcEhlaWdodCwgcGFycyApO1xuICAgICAgICBsaWdodC5zaGFkb3dNYXBTaXplID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxpZ2h0LnNoYWRvd01hcFdpZHRoLCBsaWdodC5zaGFkb3dNYXBIZWlnaHQgKTtcblxuICAgICAgICBsaWdodC5zaGFkb3dNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggISBsaWdodC5zaGFkb3dDYW1lcmEgKSB7XG5cbiAgICAgICAgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlNwb3RMaWdodCApIHtcblxuICAgICAgICAgIGxpZ2h0LnNoYWRvd0NhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggbGlnaHQuc2hhZG93Q2FtZXJhRm92LCBsaWdodC5zaGFkb3dNYXBXaWR0aCAvIGxpZ2h0LnNoYWRvd01hcEhlaWdodCwgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgbGlnaHQuc2hhZG93Q2FtZXJhRmFyICk7XG5cbiAgICAgICAgfSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xuXG4gICAgICAgICAgbGlnaHQuc2hhZG93Q2FtZXJhID0gbmV3IFRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSggbGlnaHQuc2hhZG93Q2FtZXJhTGVmdCwgbGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQsIGxpZ2h0LnNoYWRvd0NhbWVyYVRvcCwgbGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tLCBsaWdodC5zaGFkb3dDYW1lcmFOZWFyLCBsaWdodC5zaGFkb3dDYW1lcmFGYXIgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgY29uc29sZS5lcnJvciggXCJUSFJFRS5TaGFkb3dNYXBQbHVnaW46IFVuc3VwcG9ydGVkIGxpZ2h0IHR5cGUgZm9yIHNoYWRvd1wiLCBsaWdodCApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzY2VuZS5hZGQoIGxpZ2h0LnNoYWRvd0NhbWVyYSApO1xuXG4gICAgICAgIGlmICggc2NlbmUuYXV0b1VwZGF0ZSA9PT0gdHJ1ZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlICYmICEgbGlnaHQuY2FtZXJhSGVscGVyICkge1xuXG4gICAgICAgIGxpZ2h0LmNhbWVyYUhlbHBlciA9IG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvd0NhbWVyYSApO1xuICAgICAgICBzY2VuZS5hZGQoIGxpZ2h0LmNhbWVyYUhlbHBlciApO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggbGlnaHQuaXNWaXJ0dWFsICYmIHZpcnR1YWxMaWdodC5vcmlnaW5hbENhbWVyYSA9PSBjYW1lcmEgKSB7XG5cbiAgICAgICAgdXBkYXRlU2hhZG93Q2FtZXJhKCBjYW1lcmEsIGxpZ2h0ICk7XG5cbiAgICAgIH1cblxuICAgICAgc2hhZG93TWFwID0gbGlnaHQuc2hhZG93TWFwO1xuICAgICAgc2hhZG93TWF0cml4ID0gbGlnaHQuc2hhZG93TWF0cml4O1xuICAgICAgc2hhZG93Q2FtZXJhID0gbGlnaHQuc2hhZG93Q2FtZXJhO1xuXG4gICAgICAvL1xuXG4gICAgICBzaGFkb3dDYW1lcmEucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xuICAgICAgX21hdHJpeFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG4gICAgICBzaGFkb3dDYW1lcmEubG9va0F0KCBfbWF0cml4UG9zaXRpb24gKTtcbiAgICAgIHNoYWRvd0NhbWVyYS51cGRhdGVNYXRyaXhXb3JsZCgpO1xuXG4gICAgICBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZCApO1xuXG4gICAgICAvL1xuXG4gICAgICBpZiAoIGxpZ2h0LmNhbWVyYUhlbHBlciApIGxpZ2h0LmNhbWVyYUhlbHBlci52aXNpYmxlID0gbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZTtcbiAgICAgIGlmICggbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSApIGxpZ2h0LmNhbWVyYUhlbHBlci51cGRhdGUoKTtcblxuICAgICAgLy8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XG5cbiAgICAgIHNoYWRvd01hdHJpeC5zZXQoXG4gICAgICAgIDAuNSwgMC4wLCAwLjAsIDAuNSxcbiAgICAgICAgMC4wLCAwLjUsIDAuMCwgMC41LFxuICAgICAgICAwLjAsIDAuMCwgMC41LCAwLjUsXG4gICAgICAgIDAuMCwgMC4wLCAwLjAsIDEuMFxuICAgICAgKTtcblxuICAgICAgc2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuICAgICAgc2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cbiAgICAgIC8vIHVwZGF0ZSBjYW1lcmEgbWF0cmljZXMgYW5kIGZydXN0dW1cblxuICAgICAgX3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcbiAgICAgIF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XG5cbiAgICAgIC8vIHJlbmRlciBzaGFkb3cgbWFwXG5cbiAgICAgIF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xuICAgICAgX3JlbmRlcmVyLmNsZWFyKCk7XG5cbiAgICAgIC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcblxuICAgICAgX3JlbmRlckxpc3QubGVuZ3RoID0gMDtcblxuICAgICAgcHJvamVjdE9iamVjdCggc2NlbmUsIHNoYWRvd0NhbWVyYSApO1xuXG5cbiAgICAgIC8vIHJlbmRlciByZWd1bGFyIG9iamVjdHNcblxuICAgICAgdmFyIG9iamVjdE1hdGVyaWFsLCB1c2VNb3JwaGluZywgdXNlU2tpbm5pbmc7XG5cbiAgICAgIGZvciAoIGogPSAwLCBqbCA9IF9yZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICAgIHdlYmdsT2JqZWN0ID0gX3JlbmRlckxpc3RbIGogXTtcblxuICAgICAgICBvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XG5cbiAgICAgICAgLy8gY3VsbGluZyBpcyBvdmVycmlkZW4gZ2xvYmFsbHkgZm9yIGFsbCBvYmplY3RzXG4gICAgICAgIC8vIHdoaWxlIHJlbmRlcmluZyBkZXB0aCBtYXBcblxuICAgICAgICAvLyBuZWVkIHRvIGRlYWwgd2l0aCBNZXNoRmFjZU1hdGVyaWFsIHNvbWVob3dcbiAgICAgICAgLy8gaW4gdGhhdCBjYXNlIGp1c3QgdXNlIHRoZSBmaXJzdCBvZiBtYXRlcmlhbC5tYXRlcmlhbHMgZm9yIG5vd1xuICAgICAgICAvLyAocHJvcGVyIHNvbHV0aW9uIHdvdWxkIHJlcXVpcmUgdG8gYnJlYWsgb2JqZWN0cyBieSBtYXRlcmlhbHNcbiAgICAgICAgLy8gIHNpbWlsYXJseSB0byByZWd1bGFyIHJlbmRlcmluZyBhbmQgdGhlbiBzZXQgY29ycmVzcG9uZGluZ1xuICAgICAgICAvLyAgZGVwdGggbWF0ZXJpYWxzIHBlciBlYWNoIGNodW5rIGluc3RlYWQgb2YganVzdCBvbmNlIHBlciBvYmplY3QpXG5cbiAgICAgICAgb2JqZWN0TWF0ZXJpYWwgPSBnZXRPYmplY3RNYXRlcmlhbCggb2JqZWN0ICk7XG5cbiAgICAgICAgdXNlTW9ycGhpbmcgPSBvYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGggPiAwICYmIG9iamVjdE1hdGVyaWFsLm1vcnBoVGFyZ2V0cztcbiAgICAgICAgdXNlU2tpbm5pbmcgPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCAmJiBvYmplY3RNYXRlcmlhbC5za2lubmluZztcblxuICAgICAgICBpZiAoIG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsICkge1xuXG4gICAgICAgICAgbWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcblxuICAgICAgICB9IGVsc2UgaWYgKCB1c2VTa2lubmluZyApIHtcblxuICAgICAgICAgIG1hdGVyaWFsID0gdXNlTW9ycGhpbmcgPyBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA6IF9kZXB0aE1hdGVyaWFsU2tpbjtcblxuICAgICAgICB9IGVsc2UgaWYgKCB1c2VNb3JwaGluZyApIHtcblxuICAgICAgICAgIG1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWxNb3JwaDtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgbWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbDtcblxuICAgICAgICB9XG5cbiAgICAgICAgX3JlbmRlcmVyLnNldE1hdGVyaWFsRmFjZXMoIG9iamVjdE1hdGVyaWFsICk7XG4gICAgICAgIF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICAgIH1cblxuICAgICAgLy8gc2V0IG1hdHJpY2VzIGFuZCByZW5kZXIgaW1tZWRpYXRlIG9iamVjdHNcblxuICAgICAgZm9yICggaiA9IDAsIGpsID0gX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZS5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICB3ZWJnbE9iamVjdCA9IF93ZWJnbE9iamVjdHNJbW1lZGlhdGVbIGogXTtcbiAgICAgICAgb2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xuXG4gICAgICAgIGlmICggb2JqZWN0LnZpc2libGUgJiYgb2JqZWN0LmNhc3RTaGFkb3cgKSB7XG5cbiAgICAgICAgICBvYmplY3QuX21vZGVsVmlld01hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLCBvYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgICAgICAgIF9yZW5kZXJlci5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIHNoYWRvd0NhbWVyYSwgX2xpZ2h0cywgZm9nLCBfZGVwdGhNYXRlcmlhbCwgb2JqZWN0ICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlIEdMIHN0YXRlXG5cbiAgICB2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXG4gICAgY2xlYXJBbHBoYSA9IF9yZW5kZXJlci5nZXRDbGVhckFscGhhKCk7XG5cbiAgICBfZ2wuY2xlYXJDb2xvciggY2xlYXJDb2xvci5yLCBjbGVhckNvbG9yLmcsIGNsZWFyQ29sb3IuYiwgY2xlYXJBbHBoYSApO1xuICAgIF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xuXG4gICAgaWYgKCBzY29wZS5jdWxsRmFjZSA9PT0gVEhSRUUuQ3VsbEZhY2VGcm9udCApIHtcblxuICAgICAgX2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xuXG4gICAgfVxuXG4gICAgX3JlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0LCBzaGFkb3dDYW1lcmEgKSB7XG5cbiAgICBpZiAoIG9iamVjdC52aXNpYmxlID09PSB0cnVlICkge1xuXG4gICAgICB2YXIgd2ViZ2xPYmplY3QgPSBfb2JqZWN0cy5vYmplY3RzWyBvYmplY3QuaWQgXTtcblxuICAgICAgaWYgKCB3ZWJnbE9iamVjdCAmJiBvYmplY3QuY2FzdFNoYWRvdyAmJiAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkID09PSBmYWxzZSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSA9PT0gdHJ1ZSApICkge1xuXG4gICAgICAgIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuICAgICAgICBfcmVuZGVyTGlzdC5wdXNoKCB3ZWJnbE9iamVjdCApO1xuXG4gICAgICB9XG5cbiAgICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIHByb2plY3RPYmplY3QoIG9iamVjdC5jaGlsZHJlblsgaSBdLCBzaGFkb3dDYW1lcmEgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBjYXNjYWRlICkge1xuXG4gICAgdmFyIHZpcnR1YWxMaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCk7XG5cbiAgICB2aXJ0dWFsTGlnaHQuaXNWaXJ0dWFsID0gdHJ1ZTtcblxuICAgIHZpcnR1YWxMaWdodC5vbmx5U2hhZG93ID0gdHJ1ZTtcbiAgICB2aXJ0dWFsTGlnaHQuY2FzdFNoYWRvdyA9IHRydWU7XG5cbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhTmVhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXI7XG4gICAgdmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYUZhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYUZhcjtcblxuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFMZWZ0ID0gbGlnaHQuc2hhZG93Q2FtZXJhTGVmdDtcbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhUmlnaHQgPSBsaWdodC5zaGFkb3dDYW1lcmFSaWdodDtcbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tID0gbGlnaHQuc2hhZG93Q2FtZXJhQm90dG9tO1xuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFUb3AgPSBsaWdodC5zaGFkb3dDYW1lcmFUb3A7XG5cbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XG5cbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93RGFya25lc3MgPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcblxuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dCaWFzID0gbGlnaHQuc2hhZG93Q2FzY2FkZUJpYXNbIGNhc2NhZGUgXTtcbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93TWFwV2lkdGggPSBsaWdodC5zaGFkb3dDYXNjYWRlV2lkdGhbIGNhc2NhZGUgXTtcbiAgICB2aXJ0dWFsTGlnaHQuc2hhZG93TWFwSGVpZ2h0ID0gbGlnaHQuc2hhZG93Q2FzY2FkZUhlaWdodFsgY2FzY2FkZSBdO1xuXG4gICAgdmlydHVhbExpZ2h0LnBvaW50c1dvcmxkID0gW107XG4gICAgdmlydHVhbExpZ2h0LnBvaW50c0ZydXN0dW0gPSBbXTtcblxuICAgIHZhciBwb2ludHNXb3JsZCA9IHZpcnR1YWxMaWdodC5wb2ludHNXb3JsZCxcbiAgICAgIHBvaW50c0ZydXN0dW0gPSB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bTtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XG5cbiAgICAgIHBvaW50c1dvcmxkWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgcG9pbnRzRnJ1c3R1bVsgaSBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIH1cblxuICAgIHZhciBuZWFyWiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVOZWFyWlsgY2FzY2FkZSBdO1xuICAgIHZhciBmYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZUZhclpbIGNhc2NhZGUgXTtcblxuICAgIHBvaW50c0ZydXN0dW1bIDAgXS5zZXQoIC0gMSwgLSAxLCBuZWFyWiApO1xuICAgIHBvaW50c0ZydXN0dW1bIDEgXS5zZXQoICAxLCAtIDEsIG5lYXJaICk7XG4gICAgcG9pbnRzRnJ1c3R1bVsgMiBdLnNldCggLSAxLCAgMSwgbmVhclogKTtcbiAgICBwb2ludHNGcnVzdHVtWyAzIF0uc2V0KCAgMSwgIDEsIG5lYXJaICk7XG5cbiAgICBwb2ludHNGcnVzdHVtWyA0IF0uc2V0KCAtIDEsIC0gMSwgZmFyWiApO1xuICAgIHBvaW50c0ZydXN0dW1bIDUgXS5zZXQoICAxLCAtIDEsIGZhclogKTtcbiAgICBwb2ludHNGcnVzdHVtWyA2IF0uc2V0KCAtIDEsICAxLCBmYXJaICk7XG4gICAgcG9pbnRzRnJ1c3R1bVsgNyBdLnNldCggIDEsICAxLCBmYXJaICk7XG5cbiAgICByZXR1cm4gdmlydHVhbExpZ2h0O1xuXG4gIH1cblxuICAvLyBTeW5jaHJvbml6ZSB2aXJ0dWFsIGxpZ2h0IHdpdGggdGhlIG9yaWdpbmFsIGxpZ2h0XG5cbiAgZnVuY3Rpb24gdXBkYXRlVmlydHVhbExpZ2h0KCBsaWdodCwgY2FzY2FkZSApIHtcblxuICAgIHZhciB2aXJ0dWFsTGlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIGNhc2NhZGUgXTtcblxuICAgIHZpcnR1YWxMaWdodC5wb3NpdGlvbi5jb3B5KCBsaWdodC5wb3NpdGlvbiApO1xuICAgIHZpcnR1YWxMaWdodC50YXJnZXQucG9zaXRpb24uY29weSggbGlnaHQudGFyZ2V0LnBvc2l0aW9uICk7XG4gICAgdmlydHVhbExpZ2h0Lmxvb2tBdCggdmlydHVhbExpZ2h0LnRhcmdldCApO1xuXG4gICAgdmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xuICAgIHZpcnR1YWxMaWdodC5zaGFkb3dEYXJrbmVzcyA9IGxpZ2h0LnNoYWRvd0RhcmtuZXNzO1xuXG4gICAgdmlydHVhbExpZ2h0LnNoYWRvd0JpYXMgPSBsaWdodC5zaGFkb3dDYXNjYWRlQmlhc1sgY2FzY2FkZSBdO1xuXG4gICAgdmFyIG5lYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZU5lYXJaWyBjYXNjYWRlIF07XG4gICAgdmFyIGZhclogPSBsaWdodC5zaGFkb3dDYXNjYWRlRmFyWlsgY2FzY2FkZSBdO1xuXG4gICAgdmFyIHBvaW50c0ZydXN0dW0gPSB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bTtcblxuICAgIHBvaW50c0ZydXN0dW1bIDAgXS56ID0gbmVhclo7XG4gICAgcG9pbnRzRnJ1c3R1bVsgMSBdLnogPSBuZWFyWjtcbiAgICBwb2ludHNGcnVzdHVtWyAyIF0ueiA9IG5lYXJaO1xuICAgIHBvaW50c0ZydXN0dW1bIDMgXS56ID0gbmVhclo7XG5cbiAgICBwb2ludHNGcnVzdHVtWyA0IF0ueiA9IGZhclo7XG4gICAgcG9pbnRzRnJ1c3R1bVsgNSBdLnogPSBmYXJaO1xuICAgIHBvaW50c0ZydXN0dW1bIDYgXS56ID0gZmFyWjtcbiAgICBwb2ludHNGcnVzdHVtWyA3IF0ueiA9IGZhclo7XG5cbiAgfVxuXG4gIC8vIEZpdCBzaGFkb3cgY2FtZXJhJ3Mgb3J0aG8gZnJ1c3R1bSB0byBjYW1lcmEgZnJ1c3R1bVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNoYWRvd0NhbWVyYSggY2FtZXJhLCBsaWdodCApIHtcblxuICAgIHZhciBzaGFkb3dDYW1lcmEgPSBsaWdodC5zaGFkb3dDYW1lcmEsXG4gICAgICBwb2ludHNGcnVzdHVtID0gbGlnaHQucG9pbnRzRnJ1c3R1bSxcbiAgICAgIHBvaW50c1dvcmxkID0gbGlnaHQucG9pbnRzV29ybGQ7XG5cbiAgICBfbWluLnNldCggSW5maW5pdHksIEluZmluaXR5LCBJbmZpbml0eSApO1xuICAgIF9tYXguc2V0KCAtIEluZmluaXR5LCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCA4OyBpICsrICkge1xuXG4gICAgICB2YXIgcCA9IHBvaW50c1dvcmxkWyBpIF07XG5cbiAgICAgIHAuY29weSggcG9pbnRzRnJ1c3R1bVsgaSBdICk7XG4gICAgICBwLnVucHJvamVjdCggY2FtZXJhICk7XG5cbiAgICAgIHAuYXBwbHlNYXRyaXg0KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG5cbiAgICAgIGlmICggcC54IDwgX21pbi54ICkgX21pbi54ID0gcC54O1xuICAgICAgaWYgKCBwLnggPiBfbWF4LnggKSBfbWF4LnggPSBwLng7XG5cbiAgICAgIGlmICggcC55IDwgX21pbi55ICkgX21pbi55ID0gcC55O1xuICAgICAgaWYgKCBwLnkgPiBfbWF4LnkgKSBfbWF4LnkgPSBwLnk7XG5cbiAgICAgIGlmICggcC56IDwgX21pbi56ICkgX21pbi56ID0gcC56O1xuICAgICAgaWYgKCBwLnogPiBfbWF4LnogKSBfbWF4LnogPSBwLno7XG5cbiAgICB9XG5cbiAgICBzaGFkb3dDYW1lcmEubGVmdCA9IF9taW4ueDtcbiAgICBzaGFkb3dDYW1lcmEucmlnaHQgPSBfbWF4Lng7XG4gICAgc2hhZG93Q2FtZXJhLnRvcCA9IF9tYXgueTtcbiAgICBzaGFkb3dDYW1lcmEuYm90dG9tID0gX21pbi55O1xuXG4gICAgLy8gY2FuJ3QgcmVhbGx5IGZpdCBuZWFyL2ZhclxuICAgIC8vc2hhZG93Q2FtZXJhLm5lYXIgPSBfbWluLno7XG4gICAgLy9zaGFkb3dDYW1lcmEuZmFyID0gX21heC56O1xuXG4gICAgc2hhZG93Q2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcblxuICB9XG5cbiAgLy8gRm9yIHRoZSBtb21lbnQganVzdCBpZ25vcmUgb2JqZWN0cyB0aGF0IGhhdmUgbXVsdGlwbGUgbWF0ZXJpYWxzIHdpdGggZGlmZmVyZW50IGFuaW1hdGlvbiBtZXRob2RzXG4gIC8vIE9ubHkgdGhlIGZpcnN0IG1hdGVyaWFsIHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50IGZvciBkZWNpZGluZyB3aGljaCBkZXB0aCBtYXRlcmlhbCB0byB1c2UgZm9yIHNoYWRvdyBtYXBzXG5cbiAgZnVuY3Rpb24gZ2V0T2JqZWN0TWF0ZXJpYWwoIG9iamVjdCApIHtcblxuICAgIHJldHVybiBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsXG4gICAgICA/IG9iamVjdC5tYXRlcmlhbC5tYXRlcmlhbHNbIDAgXVxuICAgICAgOiBvYmplY3QubWF0ZXJpYWw7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9yZW5kZXJlcnMvd2ViZ2wvV2ViR0xTdGF0ZS5qc1xuXG4vKipcbiogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiovXG5cblRIUkVFLldlYkdMU3RhdGUgPSBmdW5jdGlvbiAoIGdsLCBwYXJhbVRocmVlVG9HTCApIHtcblxuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBuZXdBdHRyaWJ1dGVzID0gbmV3IFVpbnQ4QXJyYXkoIDE2ICk7XG4gIHZhciBlbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCAxNiApO1xuXG4gIHZhciBjdXJyZW50QmxlbmRpbmcgPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xuICB2YXIgY3VycmVudEJsZW5kU3JjID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XG4gIHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gbnVsbDtcbiAgdmFyIGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcblxuICB2YXIgY3VycmVudERlcHRoRnVuYyA9IG51bGw7XG4gIHZhciBjdXJyZW50RGVwdGhUZXN0ID0gbnVsbDtcbiAgdmFyIGN1cnJlbnREZXB0aFdyaXRlID0gbnVsbDtcblxuICB2YXIgY3VycmVudENvbG9yV3JpdGUgPSBudWxsO1xuXG4gIHZhciBjdXJyZW50RG91YmxlU2lkZWQgPSBudWxsO1xuICB2YXIgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cbiAgdmFyIGN1cnJlbnRMaW5lV2lkdGggPSBudWxsO1xuXG4gIHZhciBjdXJyZW50UG9seWdvbk9mZnNldCA9IG51bGw7XG4gIHZhciBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IG51bGw7XG4gIHZhciBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gbnVsbDtcblxuICB2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XG5cbiAgdmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHVuZGVmaW5lZDtcbiAgdmFyIGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XG5cbiAgdGhpcy5pbml0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgbmV3QXR0cmlidXRlc1sgaSBdID0gMDtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuZW5hYmxlQXR0cmlidXRlID0gZnVuY3Rpb24gKCBhdHRyaWJ1dGUgKSB7XG5cbiAgICBuZXdBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9IDE7XG5cbiAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXSA9PT0gMCApIHtcblxuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xuICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gMTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gIT09IG5ld0F0dHJpYnV0ZXNbIGkgXSApIHtcblxuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoIGkgKTtcbiAgICAgICAgZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0QmxlbmRpbmcgPSBmdW5jdGlvbiAoIGJsZW5kaW5nLCBibGVuZEVxdWF0aW9uLCBibGVuZFNyYywgYmxlbmREc3QsIGJsZW5kRXF1YXRpb25BbHBoYSwgYmxlbmRTcmNBbHBoYSwgYmxlbmREc3RBbHBoYSApIHtcblxuICAgIGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyApIHtcblxuICAgICAgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuTm9CbGVuZGluZyApIHtcblxuICAgICAgICBnbC5kaXNhYmxlKCBnbC5CTEVORCApO1xuXG4gICAgICB9IGVsc2UgaWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQWRkaXRpdmVCbGVuZGluZyApIHtcblxuICAgICAgICBnbC5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcblxuICAgICAgfSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XG5cbiAgICAgICAgLy8gVE9ETzogRmluZCBibGVuZEZ1bmNTZXBhcmF0ZSgpIGNvbWJpbmF0aW9uXG4gICAgICAgIGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgZ2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5NdWx0aXBseUJsZW5kaW5nICkge1xuXG4gICAgICAgIC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxuICAgICAgICBnbC5lbmFibGUoIGdsLkJMRU5EICk7XG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XG4gICAgICAgIGdsLmJsZW5kRnVuYyggZ2wuWkVSTywgZ2wuU1JDX0NPTE9SICk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcblxuICAgICAgICBnbC5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZ2wuZW5hYmxlKCBnbC5CTEVORCApO1xuICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xuICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuICAgICAgfVxuXG4gICAgICBjdXJyZW50QmxlbmRpbmcgPSBibGVuZGluZztcblxuICAgIH1cblxuICAgIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLkN1c3RvbUJsZW5kaW5nICkge1xuXG4gICAgICBibGVuZEVxdWF0aW9uQWxwaGEgPSBibGVuZEVxdWF0aW9uQWxwaGEgfHwgYmxlbmRFcXVhdGlvbjtcbiAgICAgIGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xuICAgICAgYmxlbmREc3RBbHBoYSA9IGJsZW5kRHN0QWxwaGEgfHwgYmxlbmREc3Q7XG5cbiAgICAgIGlmICggYmxlbmRFcXVhdGlvbiAhPT0gY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICkge1xuXG4gICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb24gKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb25BbHBoYSApICk7XG5cbiAgICAgICAgY3VycmVudEJsZW5kRXF1YXRpb24gPSBibGVuZEVxdWF0aW9uO1xuICAgICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggYmxlbmRTcmMgIT09IGN1cnJlbnRCbGVuZFNyYyB8fCBibGVuZERzdCAhPT0gY3VycmVudEJsZW5kRHN0IHx8IGJsZW5kU3JjQWxwaGEgIT09IGN1cnJlbnRCbGVuZFNyY0FscGhhIHx8IGJsZW5kRHN0QWxwaGEgIT09IGN1cnJlbnRCbGVuZERzdEFscGhhICkge1xuXG4gICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBwYXJhbVRocmVlVG9HTCggYmxlbmRTcmMgKSwgcGFyYW1UaHJlZVRvR0woIGJsZW5kRHN0ICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZFNyY0FscGhhICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdEFscGhhICkgKTtcblxuICAgICAgICBjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcbiAgICAgICAgY3VycmVudEJsZW5kRHN0ID0gYmxlbmREc3Q7XG4gICAgICAgIGN1cnJlbnRCbGVuZFNyY0FscGhhID0gYmxlbmRTcmNBbHBoYTtcbiAgICAgICAgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBjdXJyZW50QmxlbmRFcXVhdGlvbiA9IG51bGw7XG4gICAgICBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xuICAgICAgY3VycmVudEJsZW5kRHN0ID0gbnVsbDtcbiAgICAgIGN1cnJlbnRCbGVuZEVxdWF0aW9uQWxwaGEgPSBudWxsO1xuICAgICAgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xuICAgICAgY3VycmVudEJsZW5kRHN0QWxwaGEgPSBudWxsO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXREZXB0aEZ1bmMgPSBmdW5jdGlvbiAoIGRlcHRoRnVuYyApIHtcblxuICAgICAgaWYgKCBjdXJyZW50RGVwdGhGdW5jICE9PSBkZXB0aEZ1bmMgKSB7XG5cbiAgICAgICAgICBpZiAoIGRlcHRoRnVuYyApIHtcblxuICAgICAgICAgICAgICBzd2l0Y2ggKCBkZXB0aEZ1bmMgKSB7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTmV2ZXJEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTkVWRVIgKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgY2FzZSBUSFJFRS5BbHdheXNEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuQUxXQVlTICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTGVzc0RlcHRoOlxuXG4gICAgICAgICAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVNTICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuTGVzc0VxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkVxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkVRVUFMICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgVEhSRUUuR3JlYXRlckVxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLkdFUVVBTCApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLkdyZWF0ZXJEZXB0aDpcblxuICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuR1JFQVRFUiApO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIFRIUkVFLk5vdEVxdWFsRGVwdGg6XG5cbiAgICAgICAgICAgICAgICAgICAgICBnbC5kZXB0aEZ1bmMoIGdsLk5PVEVRVUFMICk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN1cnJlbnREZXB0aEZ1bmMgPSBkZXB0aEZ1bmM7XG5cbiAgICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0RGVwdGhUZXN0ID0gZnVuY3Rpb24gKCBkZXB0aFRlc3QgKSB7XG5cbiAgICBpZiAoIGN1cnJlbnREZXB0aFRlc3QgIT09IGRlcHRoVGVzdCApIHtcblxuICAgICAgaWYgKCBkZXB0aFRlc3QgKSB7XG5cbiAgICAgICAgZ2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZ2wuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnREZXB0aFRlc3QgPSBkZXB0aFRlc3Q7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLnNldERlcHRoV3JpdGUgPSBmdW5jdGlvbiAoIGRlcHRoV3JpdGUgKSB7XG5cbiAgICBpZiAoIGN1cnJlbnREZXB0aFdyaXRlICE9PSBkZXB0aFdyaXRlICkge1xuXG4gICAgICBnbC5kZXB0aE1hc2soIGRlcHRoV3JpdGUgKTtcbiAgICAgIGN1cnJlbnREZXB0aFdyaXRlID0gZGVwdGhXcml0ZTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0Q29sb3JXcml0ZSA9IGZ1bmN0aW9uICggY29sb3JXcml0ZSApIHtcblxuICAgIGlmICggY3VycmVudENvbG9yV3JpdGUgIT09IGNvbG9yV3JpdGUgKSB7XG5cbiAgICAgIGdsLmNvbG9yTWFzayggY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSwgY29sb3JXcml0ZSApO1xuICAgICAgY3VycmVudENvbG9yV3JpdGUgPSBjb2xvcldyaXRlO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXREb3VibGVTaWRlZCA9IGZ1bmN0aW9uICggZG91YmxlU2lkZWQgKSB7XG5cbiAgICBpZiAoIGN1cnJlbnREb3VibGVTaWRlZCAhPT0gZG91YmxlU2lkZWQgKSB7XG5cbiAgICAgIGlmICggZG91YmxlU2lkZWQgKSB7XG5cbiAgICAgICAgZ2wuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZ2wuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuICAgICAgfVxuXG4gICAgICBjdXJyZW50RG91YmxlU2lkZWQgPSBkb3VibGVTaWRlZDtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0RmxpcFNpZGVkID0gZnVuY3Rpb24gKCBmbGlwU2lkZWQgKSB7XG5cbiAgICBpZiAoIGN1cnJlbnRGbGlwU2lkZWQgIT09IGZsaXBTaWRlZCApIHtcblxuICAgICAgaWYgKCBmbGlwU2lkZWQgKSB7XG5cbiAgICAgICAgZ2wuZnJvbnRGYWNlKCBnbC5DVyApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGdsLmZyb250RmFjZSggZ2wuQ0NXICk7XG5cbiAgICAgIH1cblxuICAgICAgY3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMuc2V0TGluZVdpZHRoID0gZnVuY3Rpb24gKCB3aWR0aCApIHtcblxuICAgIGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XG5cbiAgICAgIGdsLmxpbmVXaWR0aCggd2lkdGggKTtcblxuICAgICAgY3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgdGhpcy5zZXRQb2x5Z29uT2Zmc2V0ID0gZnVuY3Rpb24gKCBwb2x5Z29ub2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xuXG4gICAgaWYgKCBjdXJyZW50UG9seWdvbk9mZnNldCAhPT0gcG9seWdvbm9mZnNldCApIHtcblxuICAgICAgaWYgKCBwb2x5Z29ub2Zmc2V0ICkge1xuXG4gICAgICAgIGdsLmVuYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGdsLmRpc2FibGUoIGdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcblxuICAgICAgfVxuXG4gICAgICBjdXJyZW50UG9seWdvbk9mZnNldCA9IHBvbHlnb25vZmZzZXQ7XG5cbiAgICB9XG5cbiAgICBpZiAoIHBvbHlnb25vZmZzZXQgJiYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkgKSB7XG5cbiAgICAgIGdsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcblxuICAgICAgY3VycmVudFBvbHlnb25PZmZzZXRGYWN0b3IgPSBmYWN0b3I7XG4gICAgICBjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XG5cbiAgICB9XG5cbiAgfTtcblxuICAvLyB0ZXh0dXJlXG5cbiAgdGhpcy5hY3RpdmVUZXh0dXJlID0gZnVuY3Rpb24gKCB3ZWJnbFNsb3QgKSB7XG5cbiAgICBpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XG5cbiAgICBpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCAhPT0gd2ViZ2xTbG90ICkge1xuXG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcbiAgICAgIGN1cnJlbnRUZXh0dXJlU2xvdCA9IHdlYmdsU2xvdDtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5iaW5kVGV4dHVyZSA9IGZ1bmN0aW9uICggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XG5cbiAgICBpZiAoIGN1cnJlbnRUZXh0dXJlU2xvdCA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBfdGhpcy5hY3RpdmVUZXh0dXJlKCk7XG5cbiAgICB9XG5cbiAgICB2YXIgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbY3VycmVudFRleHR1cmVTbG90XTtcblxuICAgIGlmICggYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGJvdW5kVGV4dHVyZSA9IHsgdHlwZTogdW5kZWZpbmVkLCB0ZXh0dXJlOiB1bmRlZmluZWQgfTtcbiAgICAgIGN1cnJlbnRCb3VuZFRleHR1cmVzW2N1cnJlbnRUZXh0dXJlU2xvdF0gPSBib3VuZFRleHR1cmU7XG5cbiAgICB9XG5cbiAgICBpZiAoIGJvdW5kVGV4dHVyZS50eXBlICE9PSB3ZWJnbFR5cGUgfHwgYm91bmRUZXh0dXJlLnRleHR1cmUgIT09IHdlYmdsVGV4dHVyZSApIHtcblxuICAgICAgZ2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlICk7XG5cbiAgICAgIGJvdW5kVGV4dHVyZS50eXBlID0gd2ViZ2xUeXBlO1xuICAgICAgYm91bmRUZXh0dXJlLnRleHR1cmUgPSB3ZWJnbFRleHR1cmU7XG5cbiAgICB9XG5cbiAgfTtcblxuICB0aGlzLmNvbXByZXNzZWRUZXhJbWFnZTJEID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdHJ5IHtcblxuICAgICAgZ2wuY29tcHJlc3NlZFRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIHRoaXMudGV4SW1hZ2UyRCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRyeSB7XG5cbiAgICAgIGdsLnRleEltYWdlMkQuYXBwbHkoIGdsLCBhcmd1bWVudHMgKTtcblxuICAgIH0gY2F0Y2ggKCBlcnJvciApIHtcblxuICAgICAgY29uc29sZS5lcnJvciggZXJyb3IgKTtcblxuICAgIH1cblxuICB9O1xuXG4gIC8vXG5cbiAgdGhpcy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgaWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdID09PSAxICkge1xuXG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheSggaSApO1xuICAgICAgICBlbmFibGVkQXR0cmlidXRlc1sgaSBdID0gMDtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcbiAgICBjdXJyZW50RGVwdGhUZXN0ID0gbnVsbDtcbiAgICBjdXJyZW50RGVwdGhXcml0ZSA9IG51bGw7XG4gICAgY3VycmVudENvbG9yV3JpdGUgPSBudWxsO1xuICAgIGN1cnJlbnREb3VibGVTaWRlZCA9IG51bGw7XG4gICAgY3VycmVudEZsaXBTaWRlZCA9IG51bGw7XG5cbiAgfTtcblxufTtcblxuLy8gRmlsZTpzcmMvcmVuZGVyZXJzL3dlYmdsL3BsdWdpbnMvTGVuc0ZsYXJlUGx1Z2luLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuTGVuc0ZsYXJlUGx1Z2luID0gZnVuY3Rpb24gKCByZW5kZXJlciwgZmxhcmVzICkge1xuXG4gIHZhciBnbCA9IHJlbmRlcmVyLmNvbnRleHQ7XG5cbiAgdmFyIHZlcnRleEJ1ZmZlciwgZWxlbWVudEJ1ZmZlcjtcbiAgdmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xuICB2YXIgaGFzVmVydGV4VGV4dHVyZTtcblxuICB2YXIgdGVtcFRleHR1cmUsIG9jY2x1c2lvblRleHR1cmU7XG5cbiAgdmFyIGluaXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgICAtMSwgLTEsICAwLCAwLFxuICAgICAgIDEsIC0xLCAgMSwgMCxcbiAgICAgICAxLCAgMSwgIDEsIDEsXG4gICAgICAtMSwgIDEsICAwLCAxXG4gICAgXSApO1xuXG4gICAgdmFyIGZhY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbXG4gICAgICAwLCAxLCAyLFxuICAgICAgMCwgMiwgM1xuICAgIF0gKTtcblxuICAgIC8vIGJ1ZmZlcnNcblxuICAgIHZlcnRleEJ1ZmZlciAgICAgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBlbGVtZW50QnVmZmVyICAgID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXICk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgIC8vIHRleHR1cmVzXG5cbiAgICB0ZW1wVGV4dHVyZSAgICAgID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIG9jY2x1c2lvblRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICByZW5kZXJlci5zdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0IsIDE2LCAxNiwgMCwgZ2wuUkdCLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xuXG4gICAgcmVuZGVyZXIuc3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG9jY2x1c2lvblRleHR1cmUgKTtcbiAgICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAxNiwgMTYsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUICk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUICk7XG5cbiAgICBoYXNWZXJ0ZXhUZXh0dXJlID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKSA+IDA7XG5cbiAgICB2YXIgc2hhZGVyO1xuXG4gICAgaWYgKCBoYXNWZXJ0ZXhUZXh0dXJlICkge1xuXG4gICAgICBzaGFkZXIgPSB7XG5cbiAgICAgICAgdmVydGV4U2hhZGVyOiBbXG5cbiAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxuICAgICAgICAgIFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxuICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCByb3RhdGlvbjtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwO1wiLFxuXG4gICAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcbiAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxuXG4gICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICBcInZVViA9IHV2O1wiLFxuXG4gICAgICAgICAgICBcInZlYzIgcG9zID0gcG9zaXRpb247XCIsXG5cbiAgICAgICAgICAgIFwiaWYoIHJlbmRlclR5cGUgPT0gMiApIHtcIixcblxuICAgICAgICAgICAgICBcInZlYzQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuMSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC41LCAwLjEgKSApO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjkgKSApO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuOSApICk7XCIsXG4gICAgICAgICAgICAgIFwidmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjUgKSApO1wiLFxuICAgICAgICAgICAgICBcInZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTtcIixcblxuICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ID0gICAgICAgIHZpc2liaWxpdHkuciAvIDkuMDtcIixcbiAgICAgICAgICAgICAgXCJ2VmlzaWJpbGl0eSAqPSAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjA7XCIsXG4gICAgICAgICAgICAgIFwidlZpc2liaWxpdHkgKj0gICAgICAgdmlzaWJpbGl0eS5iIC8gOS4wO1wiLFxuICAgICAgICAgICAgICBcInZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuYSAvIDkuMDtcIixcblxuICAgICAgICAgICAgICBcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG4gICAgICAgICAgICAgIFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcblxuICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICAgIFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXG5cbiAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApLFxuXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBbXG5cbiAgICAgICAgICBcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxuICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxuICAgICAgICAgIFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxuXG4gICAgICAgICAgXCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxuICAgICAgICAgIFwidmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTtcIixcblxuICAgICAgICAgIFwidm9pZCBtYWluKCkge1wiLFxuXG4gICAgICAgICAgICAvLyBwaW5rIHNxdWFyZVxuXG4gICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMS4wLCAwLjAgKTtcIixcblxuICAgICAgICAgICAgLy8gcmVzdG9yZVxuXG4gICAgICAgICAgICBcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxuXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxuXG4gICAgICAgICAgICAvLyBmbGFyZVxuXG4gICAgICAgICAgICBcIn0gZWxzZSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG4gICAgICAgICAgICAgIFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTtcIixcbiAgICAgICAgICAgICAgXCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxuICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXG5cbiAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKVxuXG4gICAgICB9O1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc2hhZGVyID0ge1xuXG4gICAgICAgIHZlcnRleFNoYWRlcjogW1xuXG4gICAgICAgICAgXCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXG5cbiAgICAgICAgICBcInVuaWZvcm0gdmVjMyBzY3JlZW5Qb3NpdGlvbjtcIixcbiAgICAgICAgICBcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcbiAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXG5cbiAgICAgICAgICBcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxuICAgICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXG5cbiAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cbiAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgXCJ2VVYgPSB1djtcIixcblxuICAgICAgICAgICAgXCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxuXG4gICAgICAgICAgICBcImlmKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXG5cbiAgICAgICAgICAgICAgXCJwb3MueCA9IGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi55O1wiLFxuICAgICAgICAgICAgICBcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXG5cbiAgICAgICAgICAgIFwifVwiLFxuXG4gICAgICAgICAgICBcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxuXG4gICAgICAgICAgXCJ9XCJcblxuICAgICAgICBdLmpvaW4oIFwiXFxuXCIgKSxcblxuICAgICAgICBmcmFnbWVudFNoYWRlcjogW1xuXG4gICAgICAgICAgXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcIixcblxuICAgICAgICAgIFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxuXG4gICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBtYXA7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXG4gICAgICAgICAgXCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXG5cbiAgICAgICAgICBcInZhcnlpbmcgdmVjMiB2VVY7XCIsXG5cbiAgICAgICAgICBcInZvaWQgbWFpbigpIHtcIixcblxuICAgICAgICAgICAgLy8gcGluayBzcXVhcmVcblxuICAgICAgICAgICAgXCJpZiggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxuXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdGV4dHVyZTJEKCBtYXAsIHZVViApLnJnYiwgMC4wICk7XCIsXG5cbiAgICAgICAgICAgIC8vIHJlc3RvcmVcblxuICAgICAgICAgICAgXCJ9IGVsc2UgaWYoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcblxuICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcblxuICAgICAgICAgICAgLy8gZmxhcmVcblxuICAgICAgICAgICAgXCJ9IGVsc2Uge1wiLFxuXG4gICAgICAgICAgICAgIFwiZmxvYXQgdmlzaWJpbGl0eSA9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICkuYTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuNSApICkuYTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICkuYTtcIixcbiAgICAgICAgICAgICAgXCJ2aXNpYmlsaXR5ID0gKCAxLjAgLSB2aXNpYmlsaXR5IC8gNC4wICk7XCIsXG5cbiAgICAgICAgICAgICAgXCJ2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7XCIsXG4gICAgICAgICAgICAgIFwidGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2aXNpYmlsaXR5O1wiLFxuICAgICAgICAgICAgICBcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXG4gICAgICAgICAgICAgIFwiZ2xfRnJhZ0NvbG9yLnJnYiAqPSBjb2xvcjtcIixcblxuICAgICAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgICBcIn1cIlxuXG4gICAgICAgIF0uam9pbiggXCJcXG5cIiApXG5cbiAgICAgIH07XG5cbiAgICB9XG5cbiAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbSggc2hhZGVyICk7XG5cbiAgICBhdHRyaWJ1dGVzID0ge1xuICAgICAgdmVydGV4OiBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwicG9zaXRpb25cIiApLFxuICAgICAgdXY6ICAgICBnbC5nZXRBdHRyaWJMb2NhdGlvbiAoIHByb2dyYW0sIFwidXZcIiApXG4gICAgfTtcblxuICAgIHVuaWZvcm1zID0ge1xuICAgICAgcmVuZGVyVHlwZTogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyZW5kZXJUeXBlXCIgKSxcbiAgICAgIG1hcDogICAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwibWFwXCIgKSxcbiAgICAgIG9jY2x1c2lvbk1hcDogICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib2NjbHVzaW9uTWFwXCIgKSxcbiAgICAgIG9wYWNpdHk6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwib3BhY2l0eVwiICksXG4gICAgICBjb2xvcjogICAgICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcImNvbG9yXCIgKSxcbiAgICAgIHNjYWxlOiAgICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIFwic2NhbGVcIiApLFxuICAgICAgcm90YXRpb246ICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgXCJyb3RhdGlvblwiICksXG4gICAgICBzY3JlZW5Qb3NpdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBcInNjcmVlblBvc2l0aW9uXCIgKVxuICAgIH07XG5cbiAgfTtcblxuICAvKlxuICAgKiBSZW5kZXIgbGVucyBmbGFyZXNcbiAgICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcbiAgICogICAgICAgICByZWFkcyB0aGVzZSBiYWNrIGFuZCBjYWxjdWxhdGVzIG9jY2x1c2lvbi5cbiAgICovXG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0ICkge1xuXG4gICAgaWYgKCBmbGFyZXMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xuXG4gICAgdmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2YXIgaW52QXNwZWN0ID0gdmlld3BvcnRIZWlnaHQgLyB2aWV3cG9ydFdpZHRoLFxuICAgICAgaGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoICogMC41LFxuICAgICAgaGFsZlZpZXdwb3J0SGVpZ2h0ID0gdmlld3BvcnRIZWlnaHQgKiAwLjU7XG5cbiAgICB2YXIgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQsXG4gICAgICBzY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XG5cbiAgICB2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMCApLFxuICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xuXG4gICAgaWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgIGluaXQoKTtcblxuICAgIH1cblxuICAgIGdsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcblxuICAgIHJlbmRlcmVyLnN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XG4gICAgcmVuZGVyZXIuc3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnZlcnRleCApO1xuICAgIHJlbmRlcmVyLnN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xuICAgIHJlbmRlcmVyLnN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIGxlbnMgZmxhcmVzIHRvIHVwZGF0ZSB0aGVpciBvY2NsdXNpb24gYW5kIHBvc2l0aW9uc1xuICAgIC8vIHNldHVwIGdsIGFuZCBjb21tb24gdXNlZCBhdHRyaWJzL3VuZm9ybXNcblxuICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XG4gICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy52ZXJ0ZXgsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDAgKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XG5cbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xuXG4gICAgZ2wuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG4gICAgZ2wuZGVwdGhNYXNrKCBmYWxzZSApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gZmxhcmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHNpemUgPSAxNiAvIHZpZXdwb3J0SGVpZ2h0O1xuICAgICAgc2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XG5cbiAgICAgIC8vIGNhbGMgb2JqZWN0IHNjcmVlbiBwb3NpdGlvblxuXG4gICAgICB2YXIgZmxhcmUgPSBmbGFyZXNbIGkgXTtcblxuICAgICAgdGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbMTJdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxM10sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzE0XSApO1xuXG4gICAgICB0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XG4gICAgICB0ZW1wUG9zaXRpb24uYXBwbHlQcm9qZWN0aW9uKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xuXG4gICAgICAvLyBzZXR1cCBhcnJheXMgZm9yIGdsIHByb2dyYW1zXG5cbiAgICAgIHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApO1xuXG4gICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICsgaGFsZlZpZXdwb3J0V2lkdGg7XG4gICAgICBzY3JlZW5Qb3NpdGlvblBpeGVscy55ID0gc2NyZWVuUG9zaXRpb24ueSAqIGhhbGZWaWV3cG9ydEhlaWdodCArIGhhbGZWaWV3cG9ydEhlaWdodDtcblxuICAgICAgLy8gc2NyZWVuIGN1bGxcblxuICAgICAgaWYgKCBoYXNWZXJ0ZXhUZXh0dXJlIHx8IChcbiAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA+IDAgJiZcbiAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueCA8IHZpZXdwb3J0V2lkdGggJiZcbiAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueSA+IDAgJiZcbiAgICAgICAgc2NyZWVuUG9zaXRpb25QaXhlbHMueSA8IHZpZXdwb3J0SGVpZ2h0ICkgKSB7XG5cbiAgICAgICAgLy8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcblxuICAgICAgICByZW5kZXJlci5zdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMSApO1xuICAgICAgICByZW5kZXJlci5zdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcbiAgICAgICAgZ2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG4gICAgICAgIC8vIHJlbmRlciBwaW5rIHF1YWRcblxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDAgKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xuICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XG5cbiAgICAgICAgZ2wuZGlzYWJsZSggZ2wuQkxFTkQgKTtcbiAgICAgICAgZ2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cbiAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XG5cblxuICAgICAgICAvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcblxuICAgICAgICByZW5kZXJlci5zdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xuICAgICAgICByZW5kZXJlci5zdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xuICAgICAgICBnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCAtIDgsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgLSA4LCAxNiwgMTYsIDAgKTtcblxuXG4gICAgICAgIC8vIHJlc3RvcmUgZ3JhcGhpY3NcblxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDEgKTtcbiAgICAgICAgZ2wuZGlzYWJsZSggZ2wuREVQVEhfVEVTVCApO1xuXG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZW1wVGV4dHVyZSApO1xuICAgICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcblxuXG4gICAgICAgIC8vIHVwZGF0ZSBvYmplY3QgcG9zaXRpb25zXG5cbiAgICAgICAgZmxhcmUucG9zaXRpb25TY3JlZW4uY29weSggc2NyZWVuUG9zaXRpb24gKTtcblxuICAgICAgICBpZiAoIGZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrICkge1xuXG4gICAgICAgICAgZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGZsYXJlLnVwZGF0ZUxlbnNGbGFyZXMoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVuZGVyIGZsYXJlc1xuXG4gICAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMiApO1xuICAgICAgICBnbC5lbmFibGUoIGdsLkJMRU5EICk7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZsYXJlLmxlbnNGbGFyZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgICB2YXIgc3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xuXG4gICAgICAgICAgaWYgKCBzcHJpdGUub3BhY2l0eSA+IDAuMDAxICYmIHNwcml0ZS5zY2FsZSA+IDAuMDAxICkge1xuXG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi54ID0gc3ByaXRlLng7XG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi55ID0gc3ByaXRlLnk7XG4gICAgICAgICAgICBzY3JlZW5Qb3NpdGlvbi56ID0gc3ByaXRlLno7XG5cbiAgICAgICAgICAgIHNpemUgPSBzcHJpdGUuc2l6ZSAqIHNwcml0ZS5zY2FsZSAvIHZpZXdwb3J0SGVpZ2h0O1xuXG4gICAgICAgICAgICBzY2FsZS54ID0gc2l6ZSAqIGludkFzcGVjdDtcbiAgICAgICAgICAgIHNjYWxlLnkgPSBzaXplO1xuXG4gICAgICAgICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcblxuICAgICAgICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xuICAgICAgICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgc3ByaXRlLmNvbG9yLnIsIHNwcml0ZS5jb2xvci5nLCBzcHJpdGUuY29sb3IuYiApO1xuXG4gICAgICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFRleHR1cmUoIHNwcml0ZS50ZXh0dXJlLCAxICk7XG5cbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBnbFxuXG4gICAgZ2wuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcbiAgICBnbC5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcbiAgICBnbC5kZXB0aE1hc2soIHRydWUgKTtcblxuICAgIHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoIHNoYWRlciApIHtcblxuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcbiAgICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cbiAgICB2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyByZW5kZXJlci5nZXRQcmVjaXNpb24oKSArIFwiIGZsb2F0O1xcblwiO1xuXG4gICAgZ2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XG4gICAgZ2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcblxuICAgIGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XG4gICAgZ2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XG5cbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG4gICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcblxuICAgIGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL3JlbmRlcmVycy93ZWJnbC9wbHVnaW5zL1Nwcml0ZVBsdWdpbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLlNwcml0ZVBsdWdpbiA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNwcml0ZXMgKSB7XG5cbiAgdmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcblxuICB2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xuICB2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgdW5pZm9ybXM7XG5cbiAgdmFyIHRleHR1cmU7XG5cbiAgLy8gZGVjb21wb3NlIG1hdHJpeFdvcmxkXG5cbiAgdmFyIHNwcml0ZVBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHNwcml0ZVJvdGF0aW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgdmFyIHNwcml0ZVNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICB2YXIgaW5pdCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcbiAgICAgIC0gMC41LCAtIDAuNSwgIDAsIDAsXG4gICAgICAgIDAuNSwgLSAwLjUsICAxLCAwLFxuICAgICAgICAwLjUsICAgMC41LCAgMSwgMSxcbiAgICAgIC0gMC41LCAgIDAuNSwgIDAsIDFcbiAgICBdICk7XG5cbiAgICB2YXIgZmFjZXMgPSBuZXcgVWludDE2QXJyYXkoIFtcbiAgICAgIDAsIDEsIDIsXG4gICAgICAwLCAyLCAzXG4gICAgXSApO1xuXG4gICAgdmVydGV4QnVmZmVyICA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGVsZW1lbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XG4gICAgZ2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcblxuICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XG4gICAgZ2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xuXG4gICAgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oKTtcblxuICAgIGF0dHJpYnV0ZXMgPSB7XG4gICAgICBwb3NpdGlvbjogICAgIGdsLmdldEF0dHJpYkxvY2F0aW9uICggcHJvZ3JhbSwgJ3Bvc2l0aW9uJyApLFxuICAgICAgdXY6ICAgICAgICAgZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBwcm9ncmFtLCAndXYnIClcbiAgICB9O1xuXG4gICAgdW5pZm9ybXMgPSB7XG4gICAgICB1dk9mZnNldDogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxuICAgICAgdXZTY2FsZTogICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICd1dlNjYWxlJyApLFxuXG4gICAgICByb3RhdGlvbjogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JvdGF0aW9uJyApLFxuICAgICAgc2NhbGU6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcblxuICAgICAgY29sb3I6ICAgICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcbiAgICAgIG1hcDogICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcbiAgICAgIG9wYWNpdHk6ICAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcblxuICAgICAgbW9kZWxWaWV3TWF0cml4OiAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnbW9kZWxWaWV3TWF0cml4JyApLFxuICAgICAgcHJvamVjdGlvbk1hdHJpeDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncHJvamVjdGlvbk1hdHJpeCcgKSxcblxuICAgICAgZm9nVHlwZTogICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dUeXBlJyApLFxuICAgICAgZm9nRGVuc2l0eTogICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0RlbnNpdHknICksXG4gICAgICBmb2dOZWFyOiAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ05lYXInICksXG4gICAgICBmb2dGYXI6ICAgICAgIGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ0ZhcicgKSxcbiAgICAgIGZvZ0NvbG9yOiAgICAgZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nQ29sb3InICksXG5cbiAgICAgIGFscGhhVGVzdDogICAgICBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdhbHBoYVRlc3QnIClcbiAgICB9O1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgY2FudmFzLndpZHRoID0gODtcbiAgICBjYW52YXMuaGVpZ2h0ID0gODtcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgY29udGV4dC5maWxsUmVjdCggMCwgMCwgOCwgOCApO1xuXG4gICAgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBjYW52YXMgKTtcbiAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICB9O1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xuXG4gICAgaWYgKCBzcHJpdGVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcblxuICAgIC8vIHNldHVwIGdsXG5cbiAgICBpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgaW5pdCgpO1xuXG4gICAgfVxuXG4gICAgZ2wudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgcmVuZGVyZXIuc3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcbiAgICByZW5kZXJlci5zdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcbiAgICByZW5kZXJlci5zdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYgKTtcbiAgICByZW5kZXJlci5zdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xuXG4gICAgZ2wuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XG4gICAgZ2wuZW5hYmxlKCBnbC5CTEVORCApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xuXG4gICAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGVsZW1lbnRCdWZmZXIgKTtcblxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xuXG4gICAgcmVuZGVyZXIuc3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcbiAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMCApO1xuXG4gICAgdmFyIG9sZEZvZ1R5cGUgPSAwO1xuICAgIHZhciBzY2VuZUZvZ1R5cGUgPSAwO1xuICAgIHZhciBmb2cgPSBzY2VuZS5mb2c7XG5cbiAgICBpZiAoIGZvZyApIHtcblxuICAgICAgZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5mb2dDb2xvciwgZm9nLmNvbG9yLnIsIGZvZy5jb2xvci5nLCBmb2cuY29sb3IuYiApO1xuXG4gICAgICBpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcblxuICAgICAgICBnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmZvZ05lYXIsIGZvZy5uZWFyICk7XG4gICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRmFyLCBmb2cuZmFyICk7XG5cbiAgICAgICAgZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAxICk7XG4gICAgICAgIG9sZEZvZ1R5cGUgPSAxO1xuICAgICAgICBzY2VuZUZvZ1R5cGUgPSAxO1xuXG4gICAgICB9IGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xuXG4gICAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRGVuc2l0eSwgZm9nLmRlbnNpdHkgKTtcblxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDIgKTtcbiAgICAgICAgb2xkRm9nVHlwZSA9IDI7XG4gICAgICAgIHNjZW5lRm9nVHlwZSA9IDI7XG5cbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMCApO1xuICAgICAgb2xkRm9nVHlwZSA9IDA7XG4gICAgICBzY2VuZUZvZ1R5cGUgPSAwO1xuXG4gICAgfVxuXG5cbiAgICAvLyB1cGRhdGUgcG9zaXRpb25zIGFuZCBzb3J0XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XG5cbiAgICAgIHNwcml0ZS5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xuICAgICAgc3ByaXRlLnogPSAtIHNwcml0ZS5fbW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xuXG4gICAgfVxuXG4gICAgc3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xuXG4gICAgLy8gcmVuZGVyIGFsbCBzcHJpdGVzXG5cbiAgICB2YXIgc2NhbGUgPSBbXTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHNwcml0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcbiAgICAgIHZhciBtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcblxuICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5hbHBoYVRlc3QsIG1hdGVyaWFsLmFscGhhVGVzdCApO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLl9tb2RlbFZpZXdNYXRyaXguZWxlbWVudHMgKTtcblxuICAgICAgc3ByaXRlLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggc3ByaXRlUG9zaXRpb24sIHNwcml0ZVJvdGF0aW9uLCBzcHJpdGVTY2FsZSApO1xuXG4gICAgICBzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcbiAgICAgIHNjYWxlWyAxIF0gPSBzcHJpdGVTY2FsZS55O1xuXG4gICAgICB2YXIgZm9nVHlwZSA9IDA7XG5cbiAgICAgIGlmICggc2NlbmUuZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcblxuICAgICAgICBmb2dUeXBlID0gc2NlbmVGb2dUeXBlO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcblxuICAgICAgICBnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcbiAgICAgICAgb2xkRm9nVHlwZSA9IGZvZ1R5cGU7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XG5cbiAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC5tYXAucmVwZWF0LngsIG1hdGVyaWFsLm1hcC5yZXBlYXQueSApO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGdsLnVuaWZvcm0yZiggdW5pZm9ybXMudXZPZmZzZXQsIDAsIDAgKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XG5cbiAgICAgIH1cblxuICAgICAgZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBtYXRlcmlhbC5vcGFjaXR5ICk7XG4gICAgICBnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XG5cbiAgICAgIGdsLnVuaWZvcm0xZiggdW5pZm9ybXMucm90YXRpb24sIG1hdGVyaWFsLnJvdGF0aW9uICk7XG4gICAgICBnbC51bmlmb3JtMmZ2KCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUgKTtcblxuICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcbiAgICAgIHJlbmRlcmVyLnN0YXRlLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XG4gICAgICByZW5kZXJlci5zdGF0ZS5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XG5cbiAgICAgIGlmICggbWF0ZXJpYWwubWFwICYmIG1hdGVyaWFsLm1hcC5pbWFnZSAmJiBtYXRlcmlhbC5tYXAuaW1hZ2Uud2lkdGggKSB7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0VGV4dHVyZSggbWF0ZXJpYWwubWFwLCAwICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcmVuZGVyZXIuc2V0VGV4dHVyZSggdGV4dHVyZSwgMCApO1xuXG4gICAgICB9XG5cbiAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xuXG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBnbFxuXG4gICAgZ2wuZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcblxuICAgIHJlbmRlcmVyLnJlc2V0R0xTdGF0ZSgpO1xuXG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoKSB7XG5cbiAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblxuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuXG4gICAgZ2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIFtcblxuICAgICAgJ3ByZWNpc2lvbiAnICsgcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCkgKyAnIGZsb2F0OycsXG5cbiAgICAgICd1bmlmb3JtIG1hdDQgbW9kZWxWaWV3TWF0cml4OycsXG4gICAgICAndW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXG4gICAgICAndW5pZm9ybSB2ZWMyIHNjYWxlOycsXG4gICAgICAndW5pZm9ybSB2ZWMyIHV2T2Zmc2V0OycsXG4gICAgICAndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcblxuICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsXG4gICAgICAnYXR0cmlidXRlIHZlYzIgdXY7JyxcblxuICAgICAgJ3ZhcnlpbmcgdmVjMiB2VVY7JyxcblxuICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuXG4gICAgICAgICd2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxuXG4gICAgICAgICd2ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICogc2NhbGU7JyxcblxuICAgICAgICAndmVjMiByb3RhdGVkUG9zaXRpb247JyxcbiAgICAgICAgJ3JvdGF0ZWRQb3NpdGlvbi54ID0gY29zKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggLSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxuICAgICAgICAncm90YXRlZFBvc2l0aW9uLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXG5cbiAgICAgICAgJ3ZlYzQgZmluYWxQb3NpdGlvbjsnLFxuXG4gICAgICAgICdmaW5hbFBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggMC4wLCAwLjAsIDAuMCwgMS4wICk7JyxcbiAgICAgICAgJ2ZpbmFsUG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOycsXG4gICAgICAgICdmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIGZpbmFsUG9zaXRpb247JyxcblxuICAgICAgICAnZ2xfUG9zaXRpb24gPSBmaW5hbFBvc2l0aW9uOycsXG5cbiAgICAgICd9J1xuXG4gICAgXS5qb2luKCAnXFxuJyApICk7XG5cbiAgICBnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBbXG5cbiAgICAgICdwcmVjaXNpb24gJyArIHJlbmRlcmVyLmdldFByZWNpc2lvbigpICsgJyBmbG9hdDsnLFxuXG4gICAgICAndW5pZm9ybSB2ZWMzIGNvbG9yOycsXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgbWFwOycsXG4gICAgICAndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXG5cbiAgICAgICd1bmlmb3JtIGludCBmb2dUeXBlOycsXG4gICAgICAndW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOycsXG4gICAgICAndW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5OycsXG4gICAgICAndW5pZm9ybSBmbG9hdCBmb2dOZWFyOycsXG4gICAgICAndW5pZm9ybSBmbG9hdCBmb2dGYXI7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDsnLFxuXG4gICAgICAndmFyeWluZyB2ZWMyIHZVVjsnLFxuXG4gICAgICAndm9pZCBtYWluKCkgeycsXG5cbiAgICAgICAgJ3ZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTsnLFxuXG4gICAgICAgICdpZiAoIHRleHR1cmUuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7JyxcblxuICAgICAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IgKiB0ZXh0dXJlLnh5eiwgdGV4dHVyZS5hICogb3BhY2l0eSApOycsXG5cbiAgICAgICAgJ2lmICggZm9nVHlwZSA+IDAgKSB7JyxcblxuICAgICAgICAgICdmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7JyxcbiAgICAgICAgICAnZmxvYXQgZm9nRmFjdG9yID0gMC4wOycsXG5cbiAgICAgICAgICAnaWYgKCBmb2dUeXBlID09IDEgKSB7JyxcblxuICAgICAgICAgICAgJ2ZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTsnLFxuXG4gICAgICAgICAgJ30gZWxzZSB7JyxcblxuICAgICAgICAgICAgJ2NvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTsnLFxuICAgICAgICAgICAgJ2ZvZ0ZhY3RvciA9IGV4cDIoIC0gZm9nRGVuc2l0eSAqIGZvZ0RlbnNpdHkgKiBkZXB0aCAqIGRlcHRoICogTE9HMiApOycsXG4gICAgICAgICAgICAnZm9nRmFjdG9yID0gMS4wIC0gY2xhbXAoIGZvZ0ZhY3RvciwgMC4wLCAxLjAgKTsnLFxuXG4gICAgICAgICAgJ30nLFxuXG4gICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9IG1peCggZ2xfRnJhZ0NvbG9yLCB2ZWM0KCBmb2dDb2xvciwgZ2xfRnJhZ0NvbG9yLncgKSwgZm9nRmFjdG9yICk7JyxcblxuICAgICAgICAnfScsXG5cbiAgICAgICd9J1xuXG4gICAgXS5qb2luKCAnXFxuJyApICk7XG5cbiAgICBnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcbiAgICBnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xuXG4gICAgZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIgKTtcbiAgICBnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWdtZW50U2hhZGVyICk7XG5cbiAgICBnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXG4gICAgcmV0dXJuIHByb2dyYW07XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcblxuICAgIGlmICggYS56ICE9PSBiLnogKSB7XG5cbiAgICAgIHJldHVybiBiLnogLSBhLno7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXR1cm4gYi5pZCAtIGEuaWQ7XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvR2VvbWV0cnlVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuR2VvbWV0cnlVdGlscyA9IHtcblxuICBtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeTEsIGdlb21ldHJ5MiwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5tZXJnZSgpIGhhcyBiZWVuIG1vdmVkIHRvIEdlb21ldHJ5LiBVc2UgZ2VvbWV0cnkubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkgaW5zdGVhZC4nICk7XG5cbiAgICB2YXIgbWF0cml4O1xuXG4gICAgaWYgKCBnZW9tZXRyeTIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xuXG4gICAgICBnZW9tZXRyeTIubWF0cml4QXV0b1VwZGF0ZSAmJiBnZW9tZXRyeTIudXBkYXRlTWF0cml4KCk7XG5cbiAgICAgIG1hdHJpeCA9IGdlb21ldHJ5Mi5tYXRyaXg7XG4gICAgICBnZW9tZXRyeTIgPSBnZW9tZXRyeTIuZ2VvbWV0cnk7XG5cbiAgICB9XG5cbiAgICBnZW9tZXRyeTEubWVyZ2UoIGdlb21ldHJ5MiwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICk7XG5cbiAgfSxcblxuICBjZW50ZXI6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XG5cbiAgICBjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAuY2VudGVyKCkgaGFzIGJlZW4gbW92ZWQgdG8gR2VvbWV0cnkuIFVzZSBnZW9tZXRyeS5jZW50ZXIoKSBpbnN0ZWFkLicgKTtcbiAgICByZXR1cm4gZ2VvbWV0cnkuY2VudGVyKCk7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvSW1hZ2VVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBEYW9zaGVuZyBNdSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9EYW9zaGVuZ011L1xuICovXG5cblRIUkVFLkltYWdlVXRpbHMgPSB7XG5cbiAgY3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcblxuICBsb2FkVGV4dHVyZTogZnVuY3Rpb24gKCB1cmwsIG1hcHBpbmcsIG9uTG9hZCwgb25FcnJvciApIHtcblxuICAgIHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcbiAgICBsb2FkZXIuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSggdW5kZWZpbmVkLCBtYXBwaW5nICk7XG5cbiAgICBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG4gICAgICB0ZXh0dXJlLmltYWdlID0gaW1hZ2U7XG4gICAgICB0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgIH0sIHVuZGVmaW5lZCwgZnVuY3Rpb24gKCBldmVudCApIHtcblxuICAgICAgaWYgKCBvbkVycm9yICkgb25FcnJvciggZXZlbnQgKTtcblxuICAgIH0gKTtcblxuICAgIHRleHR1cmUuc291cmNlRmlsZSA9IHVybDtcblxuICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gIH0sXG5cbiAgbG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIGFycmF5LCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XG5cbiAgICB2YXIgaW1hZ2VzID0gW107XG5cbiAgICB2YXIgbG9hZGVyID0gbmV3IFRIUkVFLkltYWdlTG9hZGVyKCk7XG4gICAgbG9hZGVyLmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcblxuICAgIHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkN1YmVUZXh0dXJlKCBpbWFnZXMsIG1hcHBpbmcgKTtcblxuICAgIC8vIG5vIGZsaXBwaW5nIG5lZWRlZCBmb3IgY3ViZSB0ZXh0dXJlc1xuXG4gICAgdGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuXG4gICAgdmFyIGxvYWRlZCA9IDA7XG5cbiAgICB2YXIgbG9hZFRleHR1cmUgPSBmdW5jdGlvbiAoIGkgKSB7XG5cbiAgICAgIGxvYWRlci5sb2FkKCBhcnJheVsgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xuXG4gICAgICAgIHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcblxuICAgICAgICBsb2FkZWQgKz0gMTtcblxuICAgICAgICBpZiAoIGxvYWRlZCA9PT0gNiApIHtcblxuICAgICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0sIHVuZGVmaW5lZCwgb25FcnJvciApO1xuXG4gICAgfTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgKysgaSApIHtcblxuICAgICAgbG9hZFRleHR1cmUoIGkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gIH0sXG5cbiAgbG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICBjb25zb2xlLmVycm9yKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkQ29tcHJlc3NlZFRleHR1cmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKVxuXG4gIH0sXG5cbiAgbG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xuXG4gICAgY29uc29sZS5lcnJvciggJ1RIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApXG5cbiAgfSxcblxuICBnZXROb3JtYWxNYXA6IGZ1bmN0aW9uICggaW1hZ2UsIGRlcHRoICkge1xuXG4gICAgLy8gQWRhcHRlZCBmcm9tIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL2xhYi9oZWlnaHRub3JtYWwvXG5cbiAgICB2YXIgY3Jvc3MgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICAgIHJldHVybiBbIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSwgYVsgMiBdICogYlsgMCBdIC0gYVsgMCBdICogYlsgMiBdLCBhWyAwIF0gKiBiWyAxIF0gLSBhWyAxIF0gKiBiWyAwIF0gXTtcblxuICAgIH07XG5cbiAgICB2YXIgc3VidHJhY3QgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XG5cbiAgICAgIHJldHVybiBbIGFbIDAgXSAtIGJbIDAgXSwgYVsgMSBdIC0gYlsgMSBdLCBhWyAyIF0gLSBiWyAyIF0gXTtcblxuICAgIH07XG5cbiAgICB2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKCBhICkge1xuXG4gICAgICB2YXIgbCA9IE1hdGguc3FydCggYVsgMCBdICogYVsgMCBdICsgYVsgMSBdICogYVsgMSBdICsgYVsgMiBdICogYVsgMiBdICk7XG4gICAgICByZXR1cm4gWyBhWyAwIF0gLyBsLCBhWyAxIF0gLyBsLCBhWyAyIF0gLyBsIF07XG5cbiAgICB9O1xuXG4gICAgZGVwdGggPSBkZXB0aCB8IDE7XG5cbiAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcbiAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcblxuICAgIHZhciBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKS5kYXRhO1xuICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSggd2lkdGgsIGhlaWdodCApO1xuICAgIHZhciBvdXRwdXQgPSBpbWFnZURhdGEuZGF0YTtcblxuICAgIGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICsrICkge1xuXG4gICAgICBmb3IgKCB2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkgKysgKSB7XG5cbiAgICAgICAgdmFyIGx5ID0geSAtIDEgPCAwID8gMCA6IHkgLSAxO1xuICAgICAgICB2YXIgdXkgPSB5ICsgMSA+IGhlaWdodCAtIDEgPyBoZWlnaHQgLSAxIDogeSArIDE7XG4gICAgICAgIHZhciBseCA9IHggLSAxIDwgMCA/IDAgOiB4IC0gMTtcbiAgICAgICAgdmFyIHV4ID0geCArIDEgPiB3aWR0aCAtIDEgPyB3aWR0aCAtIDEgOiB4ICsgMTtcblxuICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgIHZhciBvcmlnaW4gPSBbIDAsIDAsIGRhdGFbICggeSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgLSAxLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIGx4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgIHBvaW50cy5wdXNoKCBbIC0gMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICBwb2ludHMucHVzaCggWyAwLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuICAgICAgICBwb2ludHMucHVzaCggWyAxLCAwLCBkYXRhWyAoIHkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgIHBvaW50cy5wdXNoKCBbIDEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XG4gICAgICAgIHBvaW50cy5wdXNoKCBbIDAsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcbiAgICAgICAgcG9pbnRzLnB1c2goIFsgLSAxLCAxLCBkYXRhWyAoIHV5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xuXG4gICAgICAgIHZhciBub3JtYWxzID0gW107XG4gICAgICAgIHZhciBudW1fcG9pbnRzID0gcG9pbnRzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1fcG9pbnRzOyBpICsrICkge1xuXG4gICAgICAgICAgdmFyIHYxID0gcG9pbnRzWyBpIF07XG4gICAgICAgICAgdmFyIHYyID0gcG9pbnRzWyAoIGkgKyAxICkgJSBudW1fcG9pbnRzIF07XG4gICAgICAgICAgdjEgPSBzdWJ0cmFjdCggdjEsIG9yaWdpbiApO1xuICAgICAgICAgIHYyID0gc3VidHJhY3QoIHYyLCBvcmlnaW4gKTtcbiAgICAgICAgICBub3JtYWxzLnB1c2goIG5vcm1hbGl6ZSggY3Jvc3MoIHYxLCB2MiApICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vcm1hbCA9IFsgMCwgMCwgMCBdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG5vcm1hbHMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICAgICAgbm9ybWFsWyAwIF0gKz0gbm9ybWFsc1sgaSBdWyAwIF07XG4gICAgICAgICAgbm9ybWFsWyAxIF0gKz0gbm9ybWFsc1sgaSBdWyAxIF07XG4gICAgICAgICAgbm9ybWFsWyAyIF0gKz0gbm9ybWFsc1sgaSBdWyAyIF07XG5cbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbFsgMCBdIC89IG5vcm1hbHMubGVuZ3RoO1xuICAgICAgICBub3JtYWxbIDEgXSAvPSBub3JtYWxzLmxlbmd0aDtcbiAgICAgICAgbm9ybWFsWyAyIF0gLz0gbm9ybWFscy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGlkeCA9ICggeSAqIHdpZHRoICsgeCApICogNDtcblxuICAgICAgICBvdXRwdXRbIGlkeCBdID0gKCAoIG5vcm1hbFsgMCBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XG4gICAgICAgIG91dHB1dFsgaWR4ICsgMSBdID0gKCAoIG5vcm1hbFsgMSBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XG4gICAgICAgIG91dHB1dFsgaWR4ICsgMiBdID0gKCBub3JtYWxbIDIgXSAqIDI1NSApIHwgMDtcbiAgICAgICAgb3V0cHV0WyBpZHggKyAzIF0gPSAyNTU7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcblxuICAgIHJldHVybiBjYW52YXM7XG5cbiAgfSxcblxuICBnZW5lcmF0ZURhdGFUZXh0dXJlOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGNvbG9yICkge1xuXG4gICAgdmFyIHNpemUgPSB3aWR0aCAqIGhlaWdodDtcbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KCAzICogc2l6ZSApO1xuXG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKCBjb2xvci5yICogMjU1ICk7XG4gICAgdmFyIGcgPSBNYXRoLmZsb29yKCBjb2xvci5nICogMjU1ICk7XG4gICAgdmFyIGIgPSBNYXRoLmZsb29yKCBjb2xvci5iICogMjU1ICk7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xuXG4gICAgICBkYXRhWyBpICogMyBdICAgICAgPSByO1xuICAgICAgZGF0YVsgaSAqIDMgKyAxIF0gPSBnO1xuICAgICAgZGF0YVsgaSAqIDMgKyAyIF0gPSBiO1xuXG4gICAgfVxuXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIFRIUkVFLlJHQkZvcm1hdCApO1xuICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRleHR1cmU7XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvU2NlbmVVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuU2NlbmVVdGlscyA9IHtcblxuICBjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XG5cbiAgICB2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IG1hdGVyaWFscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBncm91cC5hZGQoIG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWxzWyBpIF0gKSApO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwO1xuXG4gIH0sXG5cbiAgZGV0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBwYXJlbnQsIHNjZW5lICkge1xuXG4gICAgY2hpbGQuYXBwbHlNYXRyaXgoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgIHBhcmVudC5yZW1vdmUoIGNoaWxkICk7XG4gICAgc2NlbmUuYWRkKCBjaGlsZCApO1xuXG4gIH0sXG5cbiAgYXR0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBzY2VuZSwgcGFyZW50ICkge1xuXG4gICAgdmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgbWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIHBhcmVudC5tYXRyaXhXb3JsZCApO1xuICAgIGNoaWxkLmFwcGx5TWF0cml4KCBtYXRyaXhXb3JsZEludmVyc2UgKTtcblxuICAgIHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcbiAgICBwYXJlbnQuYWRkKCBjaGlsZCApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL0ZvbnRVdGlscy5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKlxuICogRm9yIFRleHQgb3BlcmF0aW9ucyBpbiB0aHJlZS5qcyAoU2VlIFRleHRHZW9tZXRyeSlcbiAqXG4gKiBJdCB1c2VzIHRlY2huaXF1ZXMgdXNlZCBpbjpcbiAqXG4gKiAgVHJpYW5ndWxhdGlvbiBwb3J0ZWQgZnJvbSBBUzNcbiAqICAgIFNpbXBsZSBQb2x5Z29uIFRyaWFuZ3VsYXRpb25cbiAqICAgIGh0dHA6Ly9hY3Rpb25zbmlwcGV0LmNvbS8/cD0xNDYyXG4gKlxuICogIEEgTWV0aG9kIHRvIHRyaWFuZ3VsYXRlIHNoYXBlcyB3aXRoIGhvbGVzXG4gKiAgICBodHRwOi8vd3d3LnNha3JpLm5ldC9ibG9nLzIwMDkvMDYvMTIvYW4tYXBwcm9hY2gtdG8tdHJpYW5ndWxhdGluZy1wb2x5Z29ucy13aXRoLWhvbGVzL1xuICpcbiAqL1xuXG5USFJFRS5Gb250VXRpbHMgPSB7XG5cbiAgZmFjZXM6IHt9LFxuXG4gIC8vIEp1c3QgZm9yIG5vdy4gZmFjZVt3ZWlnaHRdW3N0eWxlXVxuXG4gIGZhY2U6ICdoZWx2ZXRpa2VyJyxcbiAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgc3R5bGU6ICdub3JtYWwnLFxuICBzaXplOiAxNTAsXG4gIGRpdmlzaW9uczogMTAsXG5cbiAgZ2V0RmFjZTogZnVuY3Rpb24gKCkge1xuXG4gICAgdHJ5IHtcblxuICAgICAgcmV0dXJuIHRoaXMuZmFjZXNbIHRoaXMuZmFjZSBdWyB0aGlzLndlaWdodCBdWyB0aGlzLnN0eWxlIF07XG5cbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIHRocm93IFwiVGhlIGZvbnQgXCIgKyB0aGlzLmZhY2UgKyBcIiB3aXRoIFwiICsgdGhpcy53ZWlnaHQgKyBcIiB3ZWlnaHQgYW5kIFwiICsgdGhpcy5zdHlsZSArIFwiIHN0eWxlIGlzIG1pc3NpbmcuXCJcblxuICAgIH1cblxuICB9LFxuXG4gIGxvYWRGYWNlOiBmdW5jdGlvbiAoIGRhdGEgKSB7XG5cbiAgICB2YXIgZmFtaWx5ID0gZGF0YS5mYW1pbHlOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB2YXIgVGhyZWVGb250ID0gdGhpcztcblxuICAgIFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdIHx8IHt9O1xuXG4gICAgVGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSB8fCB7fTtcbiAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XG5cbiAgICBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXVsgZGF0YS5jc3NGb250U3R5bGUgXSA9IGRhdGE7XG5cbiAgICByZXR1cm4gZGF0YTtcblxuICB9LFxuXG4gIGRyYXdUZXh0OiBmdW5jdGlvbiAoIHRleHQgKSB7XG5cbiAgICAvLyBSZW5kZXJUZXh0XG5cbiAgICB2YXIgaSxcbiAgICAgIGZhY2UgPSB0aGlzLmdldEZhY2UoKSxcbiAgICAgIHNjYWxlID0gdGhpcy5zaXplIC8gZmFjZS5yZXNvbHV0aW9uLFxuICAgICAgb2Zmc2V0ID0gMCxcbiAgICAgIGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICksXG4gICAgICBsZW5ndGggPSBjaGFycy5sZW5ndGg7XG5cbiAgICB2YXIgZm9udFBhdGhzID0gW107XG5cbiAgICBmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcblxuICAgICAgdmFyIHBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xuXG4gICAgICB2YXIgcmV0ID0gdGhpcy5leHRyYWN0R2x5cGhQb2ludHMoIGNoYXJzWyBpIF0sIGZhY2UsIHNjYWxlLCBvZmZzZXQsIHBhdGggKTtcbiAgICAgIG9mZnNldCArPSByZXQub2Zmc2V0O1xuXG4gICAgICBmb250UGF0aHMucHVzaCggcmV0LnBhdGggKTtcblxuICAgIH1cblxuICAgIC8vIGdldCB0aGUgd2lkdGhcblxuICAgIHZhciB3aWR0aCA9IG9mZnNldCAvIDI7XG4gICAgLy9cbiAgICAvLyBmb3IgKCBwID0gMDsgcCA8IGFsbFB0cy5sZW5ndGg7IHArKyApIHtcbiAgICAvL1xuICAgIC8vICBhbGxQdHNbIHAgXS54IC09IHdpZHRoO1xuICAgIC8vXG4gICAgLy8gfVxuXG4gICAgLy92YXIgZXh0cmFjdCA9IHRoaXMuZXh0cmFjdFBvaW50cyggYWxsUHRzLCBjaGFyYWN0ZXJQdHMgKTtcbiAgICAvL2V4dHJhY3QuY29udG91ciA9IGFsbFB0cztcblxuICAgIC8vZXh0cmFjdC5wYXRocyA9IGZvbnRQYXRocztcbiAgICAvL2V4dHJhY3Qub2Zmc2V0ID0gd2lkdGg7XG5cbiAgICByZXR1cm4geyBwYXRoczogZm9udFBhdGhzLCBvZmZzZXQ6IHdpZHRoIH07XG5cbiAgfSxcblxuXG5cblxuICBleHRyYWN0R2x5cGhQb2ludHM6IGZ1bmN0aW9uICggYywgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApIHtcblxuICAgIHZhciBwdHMgPSBbXTtcblxuICAgIHZhciBpLCBpMiwgZGl2aXNpb25zLFxuICAgICAgb3V0bGluZSwgYWN0aW9uLCBsZW5ndGgsXG4gICAgICBzY2FsZVgsIHNjYWxlWSxcbiAgICAgIHgsIHksIGNweCwgY3B5LCBjcHgwLCBjcHkwLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLFxuICAgICAgbGFzdGUsXG4gICAgICBnbHlwaCA9IGZhY2UuZ2x5cGhzWyBjIF0gfHwgZmFjZS5nbHlwaHNbICc/JyBdO1xuXG4gICAgaWYgKCAhIGdseXBoICkgcmV0dXJuO1xuXG4gICAgaWYgKCBnbHlwaC5vICkge1xuXG4gICAgICBvdXRsaW5lID0gZ2x5cGguX2NhY2hlZE91dGxpbmUgfHwgKCBnbHlwaC5fY2FjaGVkT3V0bGluZSA9IGdseXBoLm8uc3BsaXQoICcgJyApICk7XG4gICAgICBsZW5ndGggPSBvdXRsaW5lLmxlbmd0aDtcblxuICAgICAgc2NhbGVYID0gc2NhbGU7XG4gICAgICBzY2FsZVkgPSBzY2FsZTtcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBsZW5ndGg7ICkge1xuXG4gICAgICAgIGFjdGlvbiA9IG91dGxpbmVbIGkgKysgXTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCBhY3Rpb24gKTtcblxuICAgICAgICBzd2l0Y2ggKCBhY3Rpb24gKSB7XG5cbiAgICAgICAgY2FzZSAnbSc6XG5cbiAgICAgICAgICAvLyBNb3ZlIFRvXG5cbiAgICAgICAgICB4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XG5cbiAgICAgICAgICBwYXRoLm1vdmVUbyggeCwgeSApO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2wnOlxuXG4gICAgICAgICAgLy8gTGluZSBUb1xuXG4gICAgICAgICAgeCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICB5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xuICAgICAgICAgIHBhdGgubGluZVRvKCB4LCB5ICk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG5cbiAgICAgICAgICAvLyBRdWFkcmF0aWNDdXJ2ZVRvXG5cbiAgICAgICAgICBjcHggID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZVk7XG4gICAgICAgICAgY3B4MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlWCArIG9mZnNldDtcbiAgICAgICAgICBjcHkxID0gb3V0bGluZVsgaSArKyBdICogc2NhbGVZO1xuXG4gICAgICAgICAgcGF0aC5xdWFkcmF0aWNDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgsIGNweSApO1xuXG4gICAgICAgICAgbGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICBpZiAoIGxhc3RlICkge1xuXG4gICAgICAgICAgICBjcHgwID0gbGFzdGUueDtcbiAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICAgICAgICBmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG4gICAgICAgICAgICAgIHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG4gICAgICAgICAgICAgIFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHgwLCBjcHgxLCBjcHggKTtcbiAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYic6XG5cbiAgICAgICAgICAvLyBDdWJpYyBCZXppZXIgQ3VydmVcblxuICAgICAgICAgIGNweCAgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIGNweSAgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuICAgICAgICAgIGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIGNweTEgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuICAgICAgICAgIGNweDIgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xuICAgICAgICAgIGNweTIgPSBvdXRsaW5lWyBpICsrIF0gKiAgc2NhbGVZO1xuXG4gICAgICAgICAgcGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xuXG4gICAgICAgICAgbGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XG5cbiAgICAgICAgICBpZiAoIGxhc3RlICkge1xuXG4gICAgICAgICAgICBjcHgwID0gbGFzdGUueDtcbiAgICAgICAgICAgIGNweTAgPSBsYXN0ZS55O1xuXG4gICAgICAgICAgICBmb3IgKCBpMiA9IDEsIGRpdmlzaW9ucyA9IHRoaXMuZGl2aXNpb25zOyBpMiA8PSBkaXZpc2lvbnM7IGkyICsrICkge1xuXG4gICAgICAgICAgICAgIHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XG4gICAgICAgICAgICAgIFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcbiAgICAgICAgICAgICAgVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgcmV0dXJuIHsgb2Zmc2V0OiBnbHlwaC5oYSAqIHNjYWxlLCBwYXRoOnBhdGggfTtcbiAgfVxuXG59O1xuXG5cblRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyA9IGZ1bmN0aW9uICggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuICAvLyBQYXJhbWV0ZXJzXG5cbiAgcGFyYW1ldGVycyA9IHBhcmFtZXRlcnMgfHwge307XG5cbiAgdmFyIHNpemUgPSBwYXJhbWV0ZXJzLnNpemUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc2l6ZSA6IDEwMDtcbiAgdmFyIGN1cnZlU2VnbWVudHMgPSBwYXJhbWV0ZXJzLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyA6IDQ7XG5cbiAgdmFyIGZvbnQgPSBwYXJhbWV0ZXJzLmZvbnQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuZm9udCA6ICdoZWx2ZXRpa2VyJztcbiAgdmFyIHdlaWdodCA9IHBhcmFtZXRlcnMud2VpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndlaWdodCA6ICdub3JtYWwnO1xuICB2YXIgc3R5bGUgPSBwYXJhbWV0ZXJzLnN0eWxlICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0eWxlIDogJ25vcm1hbCc7XG5cbiAgVEhSRUUuRm9udFV0aWxzLnNpemUgPSBzaXplO1xuICBUSFJFRS5Gb250VXRpbHMuZGl2aXNpb25zID0gY3VydmVTZWdtZW50cztcblxuICBUSFJFRS5Gb250VXRpbHMuZmFjZSA9IGZvbnQ7XG4gIFRIUkVFLkZvbnRVdGlscy53ZWlnaHQgPSB3ZWlnaHQ7XG4gIFRIUkVFLkZvbnRVdGlscy5zdHlsZSA9IHN0eWxlO1xuXG4gIC8vIEdldCBhIEZvbnQgZGF0YSBqc29uIG9iamVjdFxuXG4gIHZhciBkYXRhID0gVEhSRUUuRm9udFV0aWxzLmRyYXdUZXh0KCB0ZXh0ICk7XG5cbiAgdmFyIHBhdGhzID0gZGF0YS5wYXRocztcbiAgdmFyIHNoYXBlcyA9IFtdO1xuXG4gIGZvciAoIHZhciBwID0gMCwgcGwgPSBwYXRocy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcblxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xuXG4gIH1cblxuICByZXR1cm4gc2hhcGVzO1xuXG59O1xuXG5cbi8qKlxuICogVGhpcyBjb2RlIGlzIGEgcXVpY2sgcG9ydCBvZiBjb2RlIHdyaXR0ZW4gaW4gQysrIHdoaWNoIHdhcyBzdWJtaXR0ZWQgdG9cbiAqIGZsaXBjb2RlLmNvbSBieSBKb2huIFcuIFJhdGNsaWZmICAvLyBKdWx5IDIyLCAyMDAwXG4gKiBTZWUgb3JpZ2luYWwgY29kZSBhbmQgbW9yZSBpbmZvcm1hdGlvbiBoZXJlOlxuICogaHR0cDovL3d3dy5mbGlwY29kZS5jb20vYXJjaGl2ZXMvRWZmaWNpZW50X1BvbHlnb25fVHJpYW5ndWxhdGlvbi5zaHRtbFxuICpcbiAqIHBvcnRlZCB0byBhY3Rpb25zY3JpcHQgYnkgWmV2YW4gUm9zc2VyXG4gKiB3d3cuYWN0aW9uc25pcHBldC5jb21cbiAqXG4gKiBwb3J0ZWQgdG8gamF2YXNjcmlwdCBieSBKb3NodWEgS29vXG4gKiBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKlxuICovXG5cblxuKCBmdW5jdGlvbiAoIG5hbWVzcGFjZSApIHtcblxuICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAvLyB0YWtlcyBpbiBhbiBjb250b3VyIGFycmF5IGFuZCByZXR1cm5zXG5cbiAgdmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoIGNvbnRvdXIsIGluZGljZXMgKSB7XG5cbiAgICB2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuXG4gICAgaWYgKCBuIDwgMyApIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgdmVydHMgPSBbXSxcbiAgICAgIHZlcnRJbmRpY2VzID0gW107XG5cbiAgICAvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xuXG4gICAgdmFyIHUsIHYsIHc7XG5cbiAgICBpZiAoIGFyZWEoIGNvbnRvdXIgKSA+IDAuMCApIHtcblxuICAgICAgZm9yICggdiA9IDA7IHYgPCBuOyB2ICsrICkgdmVydHNbIHYgXSA9IHY7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBmb3IgKCB2ID0gMDsgdiA8IG47IHYgKysgKSB2ZXJ0c1sgdiBdID0gKCBuIC0gMSApIC0gdjtcblxuICAgIH1cblxuICAgIHZhciBudiA9IG47XG5cbiAgICAvKiAgcmVtb3ZlIG52IC0gMiB2ZXJ0aWNlcywgY3JlYXRpbmcgMSB0cmlhbmdsZSBldmVyeSB0aW1lICovXG5cbiAgICB2YXIgY291bnQgPSAyICogbnY7ICAgLyogZXJyb3IgZGV0ZWN0aW9uICovXG5cbiAgICBmb3IgKCB2ID0gbnYgLSAxOyBudiA+IDI7ICkge1xuXG4gICAgICAvKiBpZiB3ZSBsb29wLCBpdCBpcyBwcm9iYWJseSBhIG5vbi1zaW1wbGUgcG9seWdvbiAqL1xuXG4gICAgICBpZiAoICggY291bnQgLS0gKSA8PSAwICkge1xuXG4gICAgICAgIC8vKiogVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXG5cbiAgICAgICAgLy90aHJvdyAoIFwiV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hXCIgKTtcbiAgICAgICAgLy9yZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gU29tZXRpbWVzIHdhcm5pbmcgaXMgZmluZSwgZXNwZWNpYWxseSBwb2x5Z29ucyBhcmUgdHJpYW5ndWxhdGVkIGluIHJldmVyc2UuXG4gICAgICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkZvbnRVdGlsczogV2FybmluZywgdW5hYmxlIHRvIHRyaWFuZ3VsYXRlIHBvbHlnb24hIGluIFRyaWFuZ3VsYXRlLnByb2Nlc3MoKScgKTtcblxuICAgICAgICBpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgIH1cblxuICAgICAgLyogdGhyZWUgY29uc2VjdXRpdmUgdmVydGljZXMgaW4gY3VycmVudCBwb2x5Z29uLCA8dSx2LHc+ICovXG5cbiAgICAgIHUgPSB2OyAgICBpZiAoIG52IDw9IHUgKSB1ID0gMDsgICAgIC8qIHByZXZpb3VzICovXG4gICAgICB2ID0gdSArIDE7ICBpZiAoIG52IDw9IHYgKSB2ID0gMDsgICAgIC8qIG5ldyB2ICAgICovXG4gICAgICB3ID0gdiArIDE7ICBpZiAoIG52IDw9IHcgKSB3ID0gMDsgICAgIC8qIG5leHQgICAgICovXG5cbiAgICAgIGlmICggc25pcCggY29udG91ciwgdSwgdiwgdywgbnYsIHZlcnRzICkgKSB7XG5cbiAgICAgICAgdmFyIGEsIGIsIGMsIHMsIHQ7XG5cbiAgICAgICAgLyogdHJ1ZSBuYW1lcyBvZiB0aGUgdmVydGljZXMgKi9cblxuICAgICAgICBhID0gdmVydHNbIHUgXTtcbiAgICAgICAgYiA9IHZlcnRzWyB2IF07XG4gICAgICAgIGMgPSB2ZXJ0c1sgdyBdO1xuXG4gICAgICAgIC8qIG91dHB1dCBUcmlhbmdsZSAqL1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKCBbIGNvbnRvdXJbIGEgXSxcbiAgICAgICAgICBjb250b3VyWyBiIF0sXG4gICAgICAgICAgY29udG91clsgYyBdIF0gKTtcblxuXG4gICAgICAgIHZlcnRJbmRpY2VzLnB1c2goIFsgdmVydHNbIHUgXSwgdmVydHNbIHYgXSwgdmVydHNbIHcgXSBdICk7XG5cbiAgICAgICAgLyogcmVtb3ZlIHYgZnJvbSB0aGUgcmVtYWluaW5nIHBvbHlnb24gKi9cblxuICAgICAgICBmb3IgKCBzID0gdiwgdCA9IHYgKyAxOyB0IDwgbnY7IHMgKyssIHQgKysgKSB7XG5cbiAgICAgICAgICB2ZXJ0c1sgcyBdID0gdmVydHNbIHQgXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgbnYgLS07XG5cbiAgICAgICAgLyogcmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXIgKi9cblxuICAgICAgICBjb3VudCA9IDIgKiBudjtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKCBpbmRpY2VzICkgcmV0dXJuIHZlcnRJbmRpY2VzO1xuICAgIHJldHVybiByZXN1bHQ7XG5cbiAgfTtcblxuICAvLyBjYWxjdWxhdGUgYXJlYSBvZiB0aGUgY29udG91ciBwb2x5Z29uXG5cbiAgdmFyIGFyZWEgPSBmdW5jdGlvbiAoIGNvbnRvdXIgKSB7XG5cbiAgICB2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xuICAgIHZhciBhID0gMC4wO1xuXG4gICAgZm9yICggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSArKyApIHtcblxuICAgICAgYSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcblxuICAgIH1cblxuICAgIHJldHVybiBhICogMC41O1xuXG4gIH07XG5cbiAgdmFyIHNuaXAgPSBmdW5jdGlvbiAoIGNvbnRvdXIsIHUsIHYsIHcsIG4sIHZlcnRzICkge1xuXG4gICAgdmFyIHA7XG4gICAgdmFyIGF4LCBheSwgYngsIGJ5O1xuICAgIHZhciBjeCwgY3ksIHB4LCBweTtcblxuICAgIGF4ID0gY29udG91clsgdmVydHNbIHUgXSBdLng7XG4gICAgYXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcblxuICAgIGJ4ID0gY29udG91clsgdmVydHNbIHYgXSBdLng7XG4gICAgYnkgPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueTtcblxuICAgIGN4ID0gY29udG91clsgdmVydHNbIHcgXSBdLng7XG4gICAgY3kgPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueTtcblxuICAgIGlmICggRVBTSUxPTiA+ICggKCAoIGJ4IC0gYXggKSAqICggY3kgLSBheSApICkgLSAoICggYnkgLSBheSApICogKCBjeCAtIGF4ICkgKSApICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGFYLCBhWSwgYlgsIGJZLCBjWCwgY1k7XG4gICAgdmFyIGFweCwgYXB5LCBicHgsIGJweSwgY3B4LCBjcHk7XG4gICAgdmFyIGNDUk9TU2FwLCBiQ1JPU1NjcCwgYUNST1NTYnA7XG5cbiAgICBhWCA9IGN4IC0gYng7ICBhWSA9IGN5IC0gYnk7XG4gICAgYlggPSBheCAtIGN4OyAgYlkgPSBheSAtIGN5O1xuICAgIGNYID0gYnggLSBheDsgIGNZID0gYnkgLSBheTtcblxuICAgIGZvciAoIHAgPSAwOyBwIDwgbjsgcCArKyApIHtcblxuICAgICAgcHggPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueDtcbiAgICAgIHB5ID0gY29udG91clsgdmVydHNbIHAgXSBdLnk7XG5cbiAgICAgIGlmICggKCAoIHB4ID09PSBheCApICYmICggcHkgPT09IGF5ICkgKSB8fFxuICAgICAgICAgKCAoIHB4ID09PSBieCApICYmICggcHkgPT09IGJ5ICkgKSB8fFxuICAgICAgICAgKCAoIHB4ID09PSBjeCApICYmICggcHkgPT09IGN5ICkgKSApIGNvbnRpbnVlO1xuXG4gICAgICBhcHggPSBweCAtIGF4OyAgYXB5ID0gcHkgLSBheTtcbiAgICAgIGJweCA9IHB4IC0gYng7ICBicHkgPSBweSAtIGJ5O1xuICAgICAgY3B4ID0gcHggLSBjeDsgIGNweSA9IHB5IC0gY3k7XG5cbiAgICAgIC8vIHNlZSBpZiBwIGlzIGluc2lkZSB0cmlhbmdsZSBhYmNcblxuICAgICAgYUNST1NTYnAgPSBhWCAqIGJweSAtIGFZICogYnB4O1xuICAgICAgY0NST1NTYXAgPSBjWCAqIGFweSAtIGNZICogYXB4O1xuICAgICAgYkNST1NTY3AgPSBiWCAqIGNweSAtIGJZICogY3B4O1xuXG4gICAgICBpZiAoICggYUNST1NTYnAgPj0gLSBFUFNJTE9OICkgJiYgKCBiQ1JPU1NjcCA+PSAtIEVQU0lMT04gKSAmJiAoIGNDUk9TU2FwID49IC0gRVBTSUxPTiApICkgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfTtcblxuXG4gIG5hbWVzcGFjZS5Ucmlhbmd1bGF0ZSA9IHByb2Nlc3M7XG4gIG5hbWVzcGFjZS5Ucmlhbmd1bGF0ZS5hcmVhID0gYXJlYTtcblxuICByZXR1cm4gbmFtZXNwYWNlO1xuXG59ICkoIFRIUkVFLkZvbnRVdGlscyApO1xuXG4vLyBUbyB1c2UgdGhlIHR5cGVmYWNlLmpzIGZhY2UgZmlsZXMsIGhvb2sgdXAgdGhlIEFQSVxuXG5USFJFRS50eXBlZmFjZV9qcyA9IHsgZmFjZXM6IFRIUkVFLkZvbnRVdGlscy5mYWNlcywgbG9hZEZhY2U6IFRIUkVFLkZvbnRVdGlscy5sb2FkRmFjZSB9O1xuaWYgKCB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgKSBzZWxmLl90eXBlZmFjZV9qcyA9IFRIUkVFLnR5cGVmYWNlX2pzO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYXVkaW8vQXVkaW8uanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF1ZGlvID0gZnVuY3Rpb24gKCBsaXN0ZW5lciApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0F1ZGlvJztcblxuICB0aGlzLmNvbnRleHQgPSBsaXN0ZW5lci5jb250ZXh0O1xuICB0aGlzLnNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgdGhpcy5zb3VyY2Uub25lbmRlZCA9IHRoaXMub25FbmRlZC5iaW5kKHRoaXMpO1xuXG4gIHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XG4gIHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcblxuICB0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcbiAgdGhpcy5wYW5uZXIuY29ubmVjdCggdGhpcy5nYWluICk7XG5cbiAgdGhpcy5hdXRvcGxheSA9IGZhbHNlO1xuXG4gIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5BdWRpby5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpbztcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIGZpbGUgKSB7XG5cbiAgdmFyIHNjb3BlID0gdGhpcztcblxuICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICByZXF1ZXN0Lm9wZW4oICdHRVQnLCBmaWxlLCB0cnVlICk7XG4gIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoIGUgKSB7XG5cbiAgICBzY29wZS5jb250ZXh0LmRlY29kZUF1ZGlvRGF0YSggdGhpcy5yZXNwb25zZSwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XG5cbiAgICAgIHNjb3BlLnNvdXJjZS5idWZmZXIgPSBidWZmZXI7XG5cbiAgICAgIGlmKCBzY29wZS5hdXRvcGxheSApIHNjb3BlLnBsYXkoKTtcblxuICAgIH0gKTtcblxuICB9O1xuICByZXF1ZXN0LnNlbmQoKTtcblxuICByZXR1cm4gdGhpcztcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoKSB7XG5cbiAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiBBdWRpbyBpcyBhbHJlYWR5IHBsYXlpbmcuJyApO1xuICAgIHJldHVybjtcblxuICB9XG5cbiAgdmFyIHNvdXJjZSA9IHRoaXMuY29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcblxuICBzb3VyY2UuYnVmZmVyID0gdGhpcy5zb3VyY2UuYnVmZmVyO1xuICBzb3VyY2UubG9vcCA9IHRoaXMuc291cmNlLmxvb3A7XG4gIHNvdXJjZS5vbmVuZGVkID0gdGhpcy5zb3VyY2Uub25lbmRlZDtcbiAgc291cmNlLmNvbm5lY3QoIHRoaXMucGFubmVyICk7XG4gIHNvdXJjZS5zdGFydCggMCwgdGhpcy5zdGFydFRpbWUgKTtcblxuICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLnNvdXJjZS5zdG9wKCk7XG4gIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLnNvdXJjZS5zdG9wKCk7XG4gIHRoaXMuc3RhcnRUaW1lID0gMDtcblxufTtcblxuVEhSRUUuQXVkaW8ucHJvdG90eXBlLm9uRW5kZWQgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0TG9vcCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XG5cbiAgdGhpcy5zb3VyY2UubG9vcCA9IHZhbHVlO1xuXG59O1xuXG5USFJFRS5BdWRpby5wcm90b3R5cGUuc2V0UmVmRGlzdGFuY2UgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gIHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRSb2xsb2ZmRmFjdG9yID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcblxuICB0aGlzLnBhbm5lci5yb2xsb2ZmRmFjdG9yID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS5zZXRWb2x1bWUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG4gIHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7XG5cbn07XG5cblRIUkVFLkF1ZGlvLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICggZm9yY2UgKSB7XG5cbiAgICBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcblxuICAgIHBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xuXG4gICAgdGhpcy5wYW5uZXIuc2V0UG9zaXRpb24oIHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnogKTtcblxuICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2F1ZGlvL0F1ZGlvTGlzdGVuZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF1ZGlvTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcblxuICB0aGlzLmNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xuXG59O1xuXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuQXVkaW9MaXN0ZW5lci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BdWRpb0xpc3RlbmVyO1xuXG5USFJFRS5BdWRpb0xpc3RlbmVyLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9ICggZnVuY3Rpb24gKCkge1xuXG4gIHZhciBwb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciBxdWF0ZXJuaW9uID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbiAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICB2YXIgb3JpZW50YXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIGZvcmNlICkge1xuXG4gICAgVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XG5cbiAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XG4gICAgdmFyIHVwID0gdGhpcy51cDtcblxuICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcXVhdGVybmlvbiwgc2NhbGUgKTtcblxuICAgIG9yaWVudGF0aW9uLnNldCggMCwgMCwgLTEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcblxuICAgIGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XG4gICAgbGlzdGVuZXIuc2V0T3JpZW50YXRpb24oIG9yaWVudGF0aW9uLngsIG9yaWVudGF0aW9uLnksIG9yaWVudGF0aW9uLnosIHVwLngsIHVwLnksIHVwLnogKTtcblxuICB9O1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxuICpcbiAqIFNvbWUgY29tbW9uIG9mIEN1cnZlIG1ldGhvZHNcbiAqIC5nZXRQb2ludCh0KSwgZ2V0VGFuZ2VudCh0KVxuICogLmdldFBvaW50QXQodSksIGdldFRhZ2VudEF0KHUpXG4gKiAuZ2V0UG9pbnRzKCksIC5nZXRTcGFjZWRQb2ludHMoKVxuICogLmdldExlbmd0aCgpXG4gKiAudXBkYXRlQXJjTGVuZ3RocygpXG4gKlxuICogVGhpcyBmb2xsb3dpbmcgY2xhc3NlcyBzdWJjbGFzc2VzIFRIUkVFLkN1cnZlOlxuICpcbiAqIC0tIDJkIGNsYXNzZXMgLS1cbiAqIFRIUkVFLkxpbmVDdXJ2ZVxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmVcbiAqIFRIUkVFLlNwbGluZUN1cnZlXG4gKiBUSFJFRS5BcmNDdXJ2ZVxuICogVEhSRUUuRWxsaXBzZUN1cnZlXG4gKlxuICogLS0gM2QgY2xhc3NlcyAtLVxuICogVEhSRUUuTGluZUN1cnZlM1xuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlM1xuICogVEhSRUUuU3BsaW5lQ3VydmUzXG4gKiBUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTNcbiAqXG4gKiBBIHNlcmllcyBvZiBjdXJ2ZXMgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGEgVEhSRUUuQ3VydmVQYXRoXG4gKlxuICoqL1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBBYnN0cmFjdCBDdXJ2ZSBiYXNlIGNsYXNzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkN1cnZlID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG4vLyBWaXJ0dWFsIGJhc2UgY2xhc3MgbWV0aG9kIHRvIG92ZXJ3cml0ZSBhbmQgaW1wbGVtZW50IGluIHN1YmNsYXNzZXNcbi8vICAtIHQgWzAgLi4gMV1cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gIGNvbnNvbGUud2FybiggXCJUSFJFRS5DdXJ2ZTogV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcbiAgcmV0dXJuIG51bGw7XG5cbn07XG5cbi8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxuLy8gLSB1IFswIC4uIDFdXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1ICkge1xuXG4gIHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuICByZXR1cm4gdGhpcy5nZXRQb2ludCggdCApO1xuXG59O1xuXG4vLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA1O1xuXG4gIHZhciBkLCBwdHMgPSBbXTtcblxuICBmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XG5cbiAgICBwdHMucHVzaCggdGhpcy5nZXRQb2ludCggZCAvIGRpdmlzaW9ucyApICk7XG5cbiAgfVxuXG4gIHJldHVybiBwdHM7XG5cbn07XG5cbi8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICBpZiAoICEgZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcblxuICB2YXIgZCwgcHRzID0gW107XG5cbiAgZm9yICggZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xuXG4gICAgcHRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XG5cbiAgfVxuXG4gIHJldHVybiBwdHM7XG5cbn07XG5cbi8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXG5cblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcbiAgcmV0dXJuIGxlbmd0aHNbIGxlbmd0aHMubGVuZ3RoIC0gMSBdO1xuXG59O1xuXG4vLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0TGVuZ3RocyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucykgPyAodGhpcy5fX2FyY0xlbmd0aERpdmlzaW9ucykgOiAyMDA7XG5cbiAgaWYgKCB0aGlzLmNhY2hlQXJjTGVuZ3Roc1xuICAgICYmICggdGhpcy5jYWNoZUFyY0xlbmd0aHMubGVuZ3RoID09PSBkaXZpc2lvbnMgKyAxIClcbiAgICAmJiAhIHRoaXMubmVlZHNVcGRhdGUpIHtcblxuICAgIC8vY29uc29sZS5sb2coIFwiY2FjaGVkXCIsIHRoaXMuY2FjaGVBcmNMZW5ndGhzICk7XG4gICAgcmV0dXJuIHRoaXMuY2FjaGVBcmNMZW5ndGhzO1xuXG4gIH1cblxuICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cbiAgdmFyIGNhY2hlID0gW107XG4gIHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xuICB2YXIgcCwgc3VtID0gMDtcblxuICBjYWNoZS5wdXNoKCAwICk7XG5cbiAgZm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xuXG4gICAgY3VycmVudCA9IHRoaXMuZ2V0UG9pbnQgKCBwIC8gZGl2aXNpb25zICk7XG4gICAgc3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xuICAgIGNhY2hlLnB1c2goIHN1bSApO1xuICAgIGxhc3QgPSBjdXJyZW50O1xuXG4gIH1cblxuICB0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xuXG4gIHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOnN1bSB9OyBTdW0gaXMgaW4gdGhlIGxhc3QgZWxlbWVudC5cblxufTtcblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUudXBkYXRlQXJjTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgdGhpcy5nZXRMZW5ndGhzKCk7XG59O1xuXG4vLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWkgZGlzdGFuY2VcblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFV0b1RtYXBwaW5nID0gZnVuY3Rpb24gKCB1LCBkaXN0YW5jZSApIHtcblxuICB2YXIgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xuXG4gIHZhciBpID0gMCwgaWwgPSBhcmNMZW5ndGhzLmxlbmd0aDtcblxuICB2YXIgdGFyZ2V0QXJjTGVuZ3RoOyAvLyBUaGUgdGFyZ2V0ZWQgdSBkaXN0YW5jZSB2YWx1ZSB0byBnZXRcblxuICBpZiAoIGRpc3RhbmNlICkge1xuXG4gICAgdGFyZ2V0QXJjTGVuZ3RoID0gZGlzdGFuY2U7XG5cbiAgfSBlbHNlIHtcblxuICAgIHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcblxuICB9XG5cbiAgLy92YXIgdGltZSA9IERhdGUubm93KCk7XG5cbiAgLy8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcblxuICB2YXIgbG93ID0gMCwgaGlnaCA9IGlsIC0gMSwgY29tcGFyaXNvbjtcblxuICB3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xuXG4gICAgaSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXG5cbiAgICBjb21wYXJpc29uID0gYXJjTGVuZ3Roc1sgaSBdIC0gdGFyZ2V0QXJjTGVuZ3RoO1xuXG4gICAgaWYgKCBjb21wYXJpc29uIDwgMCApIHtcblxuICAgICAgbG93ID0gaSArIDE7XG5cbiAgICB9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcblxuICAgICAgaGlnaCA9IGkgLSAxO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgaGlnaCA9IGk7XG4gICAgICBicmVhaztcblxuICAgICAgLy8gRE9ORVxuXG4gICAgfVxuXG4gIH1cblxuICBpID0gaGlnaDtcblxuICAvL2NvbnNvbGUubG9nKCdiJyAsIGksIGxvdywgaGlnaCwgRGF0ZS5ub3coKS0gdGltZSk7XG5cbiAgaWYgKCBhcmNMZW5ndGhzWyBpIF0gPT09IHRhcmdldEFyY0xlbmd0aCApIHtcblxuICAgIHZhciB0ID0gaSAvICggaWwgLSAxICk7XG4gICAgcmV0dXJuIHQ7XG5cbiAgfVxuXG4gIC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcblxuICB2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1sgaSBdO1xuICB2YXIgbGVuZ3RoQWZ0ZXIgPSBhcmNMZW5ndGhzWyBpICsgMSBdO1xuXG4gIHZhciBzZWdtZW50TGVuZ3RoID0gbGVuZ3RoQWZ0ZXIgLSBsZW5ndGhCZWZvcmU7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xuXG4gIHZhciBzZWdtZW50RnJhY3Rpb24gPSAoIHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSApIC8gc2VnbWVudExlbmd0aDtcblxuICAgIC8vIGFkZCB0aGF0IGZyYWN0aW9uYWwgYW1vdW50IHRvIHRcblxuICB2YXIgdCA9ICggaSArIHNlZ21lbnRGcmFjdGlvbiApIC8gKCBpbCAtIDEgKTtcblxuICByZXR1cm4gdDtcblxufTtcblxuLy8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxuLy8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxuLy8gMiBwb2ludHMgYSBzbWFsbCBkZWx0YSBhcGFydCB3aWxsIGJlIHVzZWQgdG8gZmluZCBpdHMgZ3JhZGllbnRcbi8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cblxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICB2YXIgZGVsdGEgPSAwLjAwMDE7XG4gIHZhciB0MSA9IHQgLSBkZWx0YTtcbiAgdmFyIHQyID0gdCArIGRlbHRhO1xuXG4gIC8vIENhcHBpbmcgaW4gY2FzZSBvZiBkYW5nZXJcblxuICBpZiAoIHQxIDwgMCApIHQxID0gMDtcbiAgaWYgKCB0MiA+IDEgKSB0MiA9IDE7XG5cbiAgdmFyIHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XG4gIHZhciBwdDIgPSB0aGlzLmdldFBvaW50KCB0MiApO1xuXG4gIHZhciB2ZWMgPSBwdDIuY2xvbmUoKS5zdWIocHQxKTtcbiAgcmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcblxufTtcblxuXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudEF0ID0gZnVuY3Rpb24gKCB1ICkge1xuXG4gIHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xuICByZXR1cm4gdGhpcy5nZXRUYW5nZW50KCB0ICk7XG5cbn07XG5cblxuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgVXRpbHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmUuVXRpbHMgPSB7XG5cbiAgdGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xuXG4gICAgcmV0dXJuIDIgKiAoIDEgLSB0ICkgKiAoIHAxIC0gcDAgKSArIDIgKiB0ICogKCBwMiAtIHAxICk7XG5cbiAgfSxcblxuICAvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcblxuICB0YW5nZW50Q3ViaWNCZXppZXI6IGZ1bmN0aW9uICh0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuICAgIHJldHVybiAtIDMgKiBwMCAqICgxIC0gdCkgKiAoMSAtIHQpICArXG4gICAgICAzICogcDEgKiAoMSAtIHQpICogKDEgLSB0KSAtIDYgKiB0ICogcDEgKiAoMSAtIHQpICtcbiAgICAgIDYgKiB0ICogIHAyICogKDEgLSB0KSAtIDMgKiB0ICogdCAqIHAyICtcbiAgICAgIDMgKiB0ICogdCAqIHAzO1xuXG4gIH0sXG5cbiAgdGFuZ2VudFNwbGluZTogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuICAgIC8vIFRvIGNoZWNrIGlmIG15IGZvcm11bGFzIGFyZSBjb3JyZWN0XG5cbiAgICB2YXIgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7ICAvLyBkZXJpdmVkIGZyb20gMnReMyDiiJIgM3ReMiArIDFcbiAgICB2YXIgaDEwID0gMyAqIHQgKiB0IC0gNCAqIHQgKyAxOyAvLyB0XjMg4oiSIDJ0XjIgKyB0XG4gICAgdmFyIGgwMSA9IC0gNiAqIHQgKiB0ICsgNiAqIHQ7ICAvLyDiiJIgMnQzICsgM3QyXG4gICAgdmFyIGgxMSA9IDMgKiB0ICogdCAtIDIgKiB0OyAgLy8gdDMg4oiSIHQyXG5cbiAgICByZXR1cm4gaDAwICsgaDEwICsgaDAxICsgaDExO1xuXG4gIH0sXG5cbiAgLy8gQ2F0bXVsbC1Sb21cblxuICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24oIHAwLCBwMSwgcDIsIHAzLCB0ICkge1xuXG4gICAgdmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XG4gICAgdmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG4gICAgdmFyIHQyID0gdCAqIHQ7XG4gICAgdmFyIHQzID0gdCAqIHQyO1xuICAgIHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gIH1cblxufTtcblxuXG4vLyBUT0RPOiBUcmFuc2Zvcm1hdGlvbiBmb3IgQ3VydmVzP1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICAzRCBDdXJ2ZXNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gQSBGYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgbmV3IGN1cnZlIHN1YmNsYXNzZXNcblxuVEhSRUUuQ3VydmUuY3JlYXRlID0gZnVuY3Rpb24gKCBjb25zdHJ1Y3RvciwgZ2V0UG9pbnRGdW5jICkge1xuXG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlLmdldFBvaW50ID0gZ2V0UG9pbnRGdW5jO1xuXG4gIHJldHVybiBjb25zdHJ1Y3RvcjtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvQ3VydmVQYXRoLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICpcbiAqKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ3VydmVkIFBhdGggLSBhIGN1cnZlIHBhdGggaXMgc2ltcGx5IGEgYXJyYXkgb2YgY29ubmVjdGVkXG4gKiAgY3VydmVzLCBidXQgcmV0YWlucyB0aGUgYXBpIG9mIGEgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3VydmVQYXRoID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMuY3VydmVzID0gW107XG4gIHRoaXMuYmVuZHMgPSBbXTtcblxuICB0aGlzLmF1dG9DbG9zZSA9IGZhbHNlOyAvLyBBdXRvbWF0aWNhbGx5IGNsb3NlcyB0aGUgcGF0aFxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkN1cnZlUGF0aDtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoIGN1cnZlICkge1xuXG4gIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE9cbiAgLy8gSWYgdGhlIGVuZGluZyBvZiBjdXJ2ZSBpcyBub3QgY29ubmVjdGVkIHRvIHRoZSBzdGFydGluZ1xuICAvLyBvciB0aGUgbmV4dCBjdXJ2ZSwgdGhlbiwgdGhpcyBpcyBub3QgYSByZWFsIHBhdGhcbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY2xvc2VQYXRoID0gZnVuY3Rpb24oKSB7XG4gIC8vIFRPRE8gVGVzdFxuICAvLyBhbmQgdmVyaWZ5IGZvciB2ZWN0b3IzIChuZWVkcyB0byBpbXBsZW1lbnQgZXF1YWxzKVxuICAvLyBBZGQgYSBsaW5lIGN1cnZlIGlmIHN0YXJ0IGFuZCBlbmQgb2YgbGluZXMgYXJlIG5vdCBjb25uZWN0ZWRcbiAgdmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1swXS5nZXRQb2ludCgwKTtcbiAgdmFyIGVuZFBvaW50ID0gdGhpcy5jdXJ2ZXNbdGhpcy5jdXJ2ZXMubGVuZ3RoIC0gMV0uZ2V0UG9pbnQoMSk7XG5cbiAgaWYgKCEgc3RhcnRQb2ludC5lcXVhbHMoZW5kUG9pbnQpKSB7XG4gICAgdGhpcy5jdXJ2ZXMucHVzaCggbmV3IFRIUkVFLkxpbmVDdXJ2ZShlbmRQb2ludCwgc3RhcnRQb2ludCkgKTtcbiAgfVxuXG59O1xuXG4vLyBUbyBnZXQgYWNjdXJhdGUgcG9pbnQgd2l0aCByZWZlcmVuY2UgdG9cbi8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcbi8vIGZvbGxvd2luZyBoYXMgdG8gYmUgZG9uZTpcblxuLy8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxuLy8gMi4gTG9jYXRlIGFuZCBpZGVudGlmeSB0eXBlIG9mIGN1cnZlXG4vLyAzLiBHZXQgdCBmb3IgdGhlIGN1cnZlXG4vLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gIHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XG4gIHZhciBjdXJ2ZUxlbmd0aHMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICB2YXIgaSA9IDAsIGRpZmYsIGN1cnZlO1xuXG4gIC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxuXG4gIHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XG5cbiAgICBpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XG5cbiAgICAgIGRpZmYgPSBjdXJ2ZUxlbmd0aHNbIGkgXSAtIGQ7XG4gICAgICBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XG5cbiAgICAgIHZhciB1ID0gMSAtIGRpZmYgLyBjdXJ2ZS5nZXRMZW5ndGgoKTtcblxuICAgICAgcmV0dXJuIGN1cnZlLmdldFBvaW50QXQoIHUgKTtcblxuICAgIH1cblxuICAgIGkgKys7XG5cbiAgfVxuXG4gIHJldHVybiBudWxsO1xuXG4gIC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxuXG59O1xuXG4vKlxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG59OyovXG5cblxuLy8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxuLy8gVEhSRUUuQ3VydmUsIGdldExlbmd0aCgpIGRlcGVuZHMgb24gZ2V0UG9pbnQoKSBidXQgaW4gVEhSRUUuQ3VydmVQYXRoXG4vLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG5cbiAgdmFyIGxlbnMgPSB0aGlzLmdldEN1cnZlTGVuZ3RocygpO1xuICByZXR1cm4gbGVuc1sgbGVucy5sZW5ndGggLSAxIF07XG5cbn07XG5cbi8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxuLy8gV2UgY2Fubm90IG92ZXJ3cml0ZSBnZXRMZW5ndGhzKCkgYmVjYXVzZSBVdG9UIG1hcHBpbmcgdXNlcyBpdC5cblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHMgPSBmdW5jdGlvbigpIHtcblxuICAvLyBXZSB1c2UgY2FjaGUgdmFsdWVzIGlmIGN1cnZlcyBhbmQgY2FjaGUgYXJyYXkgYXJlIHNhbWUgbGVuZ3RoXG5cbiAgaWYgKCB0aGlzLmNhY2hlTGVuZ3RocyAmJiB0aGlzLmNhY2hlTGVuZ3Rocy5sZW5ndGggPT09IHRoaXMuY3VydmVzLmxlbmd0aCApIHtcblxuICAgIHJldHVybiB0aGlzLmNhY2hlTGVuZ3RocztcblxuICB9XG5cbiAgLy8gR2V0IGxlbmd0aCBvZiBzdWJzdXJ2ZVxuICAvLyBQdXNoIHN1bXMgaW50byBjYWNoZWQgYXJyYXlcblxuICB2YXIgbGVuZ3RocyA9IFtdLCBzdW1zID0gMDtcbiAgdmFyIGksIGlsID0gdGhpcy5jdXJ2ZXMubGVuZ3RoO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBzdW1zICs9IHRoaXMuY3VydmVzWyBpIF0uZ2V0TGVuZ3RoKCk7XG4gICAgbGVuZ3Rocy5wdXNoKCBzdW1zICk7XG5cbiAgfVxuXG4gIHRoaXMuY2FjaGVMZW5ndGhzID0gbGVuZ3RocztcblxuICByZXR1cm4gbGVuZ3RocztcblxufTtcblxuXG5cbi8vIFJldHVybnMgbWluIGFuZCBtYXggY29vcmRpbmF0ZXNcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcblxuICB2YXIgbWF4WCwgbWF4WSwgbWF4WjtcbiAgdmFyIG1pblgsIG1pblksIG1pblo7XG5cbiAgbWF4WCA9IG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gIG1pblggPSBtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuXG4gIHZhciBwLCBpLCBpbCwgc3VtO1xuXG4gIHZhciB2MyA9IHBvaW50c1swXSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjM7XG5cbiAgc3VtID0gdjMgPyBuZXcgVEhSRUUuVmVjdG9yMygpIDogbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICBmb3IgKCBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBwID0gcG9pbnRzWyBpIF07XG5cbiAgICBpZiAoIHAueCA+IG1heFggKSBtYXhYID0gcC54O1xuICAgIGVsc2UgaWYgKCBwLnggPCBtaW5YICkgbWluWCA9IHAueDtcblxuICAgIGlmICggcC55ID4gbWF4WSApIG1heFkgPSBwLnk7XG4gICAgZWxzZSBpZiAoIHAueSA8IG1pblkgKSBtaW5ZID0gcC55O1xuXG4gICAgaWYgKCB2MyApIHtcblxuICAgICAgaWYgKCBwLnogPiBtYXhaICkgbWF4WiA9IHAuejtcbiAgICAgIGVsc2UgaWYgKCBwLnogPCBtaW5aICkgbWluWiA9IHAuejtcblxuICAgIH1cblxuICAgIHN1bS5hZGQoIHAgKTtcblxuICB9XG5cbiAgdmFyIHJldCA9IHtcblxuICAgIG1pblg6IG1pblgsXG4gICAgbWluWTogbWluWSxcbiAgICBtYXhYOiBtYXhYLFxuICAgIG1heFk6IG1heFlcblxuICB9O1xuXG4gIGlmICggdjMgKSB7XG5cbiAgICByZXQubWF4WiA9IG1heFo7XG4gICAgcmV0Lm1pblogPSBtaW5aO1xuXG4gIH1cblxuICByZXR1cm4gcmV0O1xuXG59O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDcmVhdGUgR2VvbWV0cmllcyBIZWxwZXJzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIHBhdGggcG9pbnRzIChmb3IgTGluZSBvciBQb2ludHMgb2JqZWN0cylcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XG5cbiAgdmFyIHB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBkaXZpc2lvbnMsIHRydWUgKTtcbiAgcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xuXG59O1xuXG4vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW5jZSBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxuXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5ID0gZnVuY3Rpb24oIGRpdmlzaW9ucyApIHtcblxuICB2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xuICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeSggcHRzICk7XG5cbn07XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzICkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gIGZvciAoIHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSwgcG9pbnRzWyBpIF0ueiB8fCAwKSApO1xuXG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnk7XG5cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQmVuZCAvIFdyYXAgSGVscGVyIE1ldGhvZHNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLy8gV3JhcCBwYXRoIC8gQmVuZCBtb2RpZmllcnM/XG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkV3JhcFBhdGggPSBmdW5jdGlvbiAoIGJlbmRwYXRoICkge1xuXG4gIHRoaXMuYmVuZHMucHVzaCggYmVuZHBhdGggKTtcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cbiAgdmFyIG9sZFB0cyA9IHRoaXMuZ2V0UG9pbnRzKCBzZWdtZW50cyApOyAvLyBnZXRQb2ludHMgZ2V0U3BhY2VkUG9pbnRzXG4gIHZhciBpLCBpbDtcblxuICBpZiAoICEgYmVuZHMgKSB7XG5cbiAgICBiZW5kcyA9IHRoaXMuYmVuZHM7XG5cbiAgfVxuXG4gIGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgb2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuICB9XG5cbiAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XG5cbiAgdmFyIG9sZFB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBzZWdtZW50cyApO1xuXG4gIHZhciBpLCBpbDtcblxuICBpZiAoICEgYmVuZHMgKSB7XG5cbiAgICBiZW5kcyA9IHRoaXMuYmVuZHM7XG5cbiAgfVxuXG4gIGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgb2xkUHRzID0gdGhpcy5nZXRXcmFwUG9pbnRzKCBvbGRQdHMsIGJlbmRzWyBpIF0gKTtcblxuICB9XG5cbiAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gVGhpcyByZXR1cm5zIGdldFBvaW50cygpIGJlbmQvd3JhcHBlZCBhcm91bmQgdGhlIGNvbnRvdXIgb2YgYSBwYXRoLlxuLy8gUmVhZCBodHRwOi8vd3d3LnBsYW5ldGNsZWdnLmNvbS9wcm9qZWN0cy9XYXJwaW5nVGV4dFRvU3BsaW5lcy5odG1sXG5cblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0V3JhcFBvaW50cyA9IGZ1bmN0aW9uICggb2xkUHRzLCBwYXRoICkge1xuXG4gIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgdmFyIGksIGlsLCBwLCBvbGRYLCBvbGRZLCB4Tm9ybTtcblxuICBmb3IgKCBpID0gMCwgaWwgPSBvbGRQdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBwID0gb2xkUHRzWyBpIF07XG5cbiAgICBvbGRYID0gcC54O1xuICAgIG9sZFkgPSBwLnk7XG5cbiAgICB4Tm9ybSA9IG9sZFggLyBib3VuZHMubWF4WDtcblxuICAgIC8vIElmIHVzaW5nIGFjdHVhbCBkaXN0YW5jZSwgZm9yIGxlbmd0aCA+IHBhdGgsIHJlcXVpcmVzIGxpbmUgZXh0cnVzaW9uc1xuICAgIC8veE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKHhOb3JtLCBvbGRYKTsgLy8gMyBzdHlsZXMuIDEpIHdyYXAgc3RyZXRjaGVkLiAyKSB3cmFwIHN0cmV0Y2ggYnkgYXJjIGxlbmd0aCAzKSB3YXJwIGJ5IGFjdHVhbCBkaXN0YW5jZVxuXG4gICAgeE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKCB4Tm9ybSwgb2xkWCApO1xuXG4gICAgLy8gY2hlY2sgZm9yIG91dCBvZiBib3VuZHM/XG5cbiAgICB2YXIgcGF0aFB0ID0gcGF0aC5nZXRQb2ludCggeE5vcm0gKTtcbiAgICB2YXIgbm9ybWFsID0gcGF0aC5nZXRUYW5nZW50KCB4Tm9ybSApO1xuICAgIG5vcm1hbC5zZXQoIC0gbm9ybWFsLnksIG5vcm1hbC54ICkubXVsdGlwbHlTY2FsYXIoIG9sZFkgKTtcblxuICAgIHAueCA9IHBhdGhQdC54ICsgbm9ybWFsLng7XG4gICAgcC55ID0gcGF0aFB0LnkgKyBub3JtYWwueTtcblxuICB9XG5cbiAgcmV0dXJuIG9sZFB0cztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvR3lyb3Njb3BlLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5HeXJvc2NvcGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgVEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xuXG59O1xuXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuR3lyb3Njb3BlO1xuXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHRyYW5zbGF0aW9uT2JqZWN0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHF1YXRlcm5pb25PYmplY3QgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xuICB2YXIgc2NhbGVPYmplY3QgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHZhciB0cmFuc2xhdGlvbldvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHF1YXRlcm5pb25Xb3JsZCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XG4gIHZhciBzY2FsZVdvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCBmb3JjZSApIHtcblxuICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSAmJiB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuXG4gICAgLy8gdXBkYXRlIG1hdHJpeFdvcmxkXG5cbiAgICBpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSApIHtcblxuICAgICAgaWYgKCB0aGlzLnBhcmVudCApIHtcblxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xuXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCB0cmFuc2xhdGlvbldvcmxkLCBxdWF0ZXJuaW9uV29ybGQsIHNjYWxlV29ybGQgKTtcbiAgICAgICAgdGhpcy5tYXRyaXguZGVjb21wb3NlKCB0cmFuc2xhdGlvbk9iamVjdCwgcXVhdGVybmlvbk9iamVjdCwgc2NhbGVPYmplY3QgKTtcblxuICAgICAgICB0aGlzLm1hdHJpeFdvcmxkLmNvbXBvc2UoIHRyYW5zbGF0aW9uV29ybGQsIHF1YXRlcm5pb25PYmplY3QsIHNjYWxlV29ybGQgKTtcblxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIHRoaXMubWF0cml4V29ybGQuY29weSggdGhpcy5tYXRyaXggKTtcblxuICAgICAgfVxuXG5cbiAgICAgIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICBmb3JjZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgY2hpbGRyZW5cblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgdGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xuXG4gICAgfVxuXG4gIH07XG5cbn0oKSApO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY29yZS9QYXRoLmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQ3JlYXRlcyBmcmVlIGZvcm0gMmQgcGF0aCB1c2luZyBzZXJpZXMgb2YgcG9pbnRzLCBsaW5lcyBvciBjdXJ2ZXMuXG4gKlxuICoqL1xuXG5USFJFRS5QYXRoID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XG5cbiAgVEhSRUUuQ3VydmVQYXRoLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5hY3Rpb25zID0gW107XG5cbiAgaWYgKCBwb2ludHMgKSB7XG5cbiAgICB0aGlzLmZyb21Qb2ludHMoIHBvaW50cyApO1xuXG4gIH1cblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlICk7XG5USFJFRS5QYXRoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhdGg7XG5cblRIUkVFLlBhdGhBY3Rpb25zID0ge1xuXG4gIE1PVkVfVE86ICdtb3ZlVG8nLFxuICBMSU5FX1RPOiAnbGluZVRvJyxcbiAgUVVBRFJBVElDX0NVUlZFX1RPOiAncXVhZHJhdGljQ3VydmVUbycsIC8vIEJlemllciBxdWFkcmF0aWMgY3VydmVcbiAgQkVaSUVSX0NVUlZFX1RPOiAnYmV6aWVyQ3VydmVUbycsICAgICAvLyBCZXppZXIgY3ViaWMgY3VydmVcbiAgQ1NQTElORV9USFJVOiAnc3BsaW5lVGhydScsICAgICAgIC8vIENhdG11bGwtcm9tIHNwbGluZVxuICBBUkM6ICdhcmMnLCAgICAgICAgICAgICAgIC8vIENpcmNsZVxuICBFTExJUFNFOiAnZWxsaXBzZSdcbn07XG5cbi8vIFRPRE8gQ2xlYW4gdXAgUEFUSCBBUElcblxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXG4vLyAtIHZlY3RvcnM6IGFycmF5IG9mIFZlY3RvcjJcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcblxuICB0aGlzLm1vdmVUbyggdmVjdG9yc1sgMCBdLngsIHZlY3RvcnNbIDAgXS55ICk7XG5cbiAgZm9yICggdmFyIHYgPSAxLCB2bGVuID0gdmVjdG9ycy5sZW5ndGg7IHYgPCB2bGVuOyB2ICsrICkge1xuXG4gICAgdGhpcy5saW5lVG8oIHZlY3RvcnNbIHYgXS54LCB2ZWN0b3JzWyB2IF0ueSApO1xuXG4gIH1cblxufTtcblxuLy8gc3RhcnRQYXRoKCkgZW5kUGF0aCgpP1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG4gIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcblxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcblxuICB2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcblxuICB2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xuICB2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xuXG4gIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5MaW5lQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSwgbmV3IFRIUkVFLlZlY3RvcjIoIHgsIHkgKSApO1xuICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuTElORV9UTywgYXJnczogYXJncyB9ICk7XG5cbn07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQeCwgYUNQeSApLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFYLCBhWSApICk7XG4gIHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XG5cbiAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5RVUFEUkFUSUNfQ1VSVkVfVE8sIGFyZ3M6IGFyZ3MgfSApO1xuXG59O1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhQ1AyeCwgYUNQMnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgYVgsIGFZICkge1xuXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXG4gIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDEgXS5hcmdzO1xuXG4gIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgdmFyIGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcbiAgICAgICAgICAgICAgICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYUNQMXgsIGFDUDF5ICksXG4gICAgICAgICAgICAgICAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGFDUDJ4LCBhQ1AyeSApLFxuICAgICAgICAgICAgICAgICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xuICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuc3BsaW5lVGhydSA9IGZ1bmN0aW9uKCBwdHMgLypBcnJheSBvZiBWZWN0b3IqLyApIHtcblxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcbiAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XG5cbiAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcbi8vLS0tXG4gIHZhciBucHRzID0gWyBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICkgXTtcbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIG5wdHMsIHB0cyApO1xuXG4gIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggbnB0cyApO1xuICB0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xuXG4gIHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVLCBhcmdzOiBhcmdzIH0gKTtcblxufTtcblxuLy8gRlVUVVJFOiBDaGFuZ2UgdGhlIEFQSSBvciBmb2xsb3cgY2FudmFzIEFQST9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgdmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMV0uYXJncztcbiAgdmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcbiAgdmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcblxuICB0aGlzLmFic2FyYyhhWCArIHgwLCBhWSArIHkwLCBhUmFkaXVzLFxuICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcblxuIH07XG5cbiBUSFJFRS5QYXRoLnByb3RvdHlwZS5hYnNhcmMgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcbiAgdGhpcy5hYnNlbGxpcHNlKGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XG4gfTtcblxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gIHZhciBsYXN0YXJncyA9IHRoaXMuYWN0aW9uc1sgdGhpcy5hY3Rpb25zLmxlbmd0aCAtIDFdLmFyZ3M7XG4gIHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XG4gIHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XG5cbiAgdGhpcy5hYnNlbGxpcHNlKGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xuXG4gfTtcblxuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5hYnNlbGxpcHNlID0gZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG4gIHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcbiAgICAgICAgICAgICAgICAgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcbiAgdGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcblxuICB2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoMSk7XG4gIGFyZ3MucHVzaChsYXN0UG9pbnQueCk7XG4gIGFyZ3MucHVzaChsYXN0UG9pbnQueSk7XG5cbiAgdGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFLCBhcmdzOiBhcmdzIH0gKTtcblxuIH07XG5cblRIUkVFLlBhdGgucHJvdG90eXBlLmdldFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xuXG4gIGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcblxuICB2YXIgcG9pbnRzID0gW107XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgZGl2aXNpb25zOyBpICsrICkge1xuXG4gICAgcG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xuXG4gICAgLy9pZiggIXRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApIHRocm93IFwiRElFXCI7XG5cbiAgfVxuXG4gIC8vIGlmICggY2xvc2VkUGF0aCApIHtcbiAgLy9cbiAgLy8gIHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xuICAvL1xuICAvLyB9XG5cbiAgcmV0dXJuIHBvaW50cztcblxufTtcblxuLyogUmV0dXJuIGFuIGFycmF5IG9mIHZlY3RvcnMgYmFzZWQgb24gY29udG91ciBvZiB0aGUgcGF0aCAqL1xuXG5USFJFRS5QYXRoLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiggZGl2aXNpb25zLCBjbG9zZWRQYXRoICkge1xuXG4gIGlmICh0aGlzLnVzZVNwYWNlZFBvaW50cykge1xuICAgIGNvbnNvbGUubG9nKCd0YXRhJyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKTtcbiAgfVxuXG4gIGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcblxuICB2YXIgcG9pbnRzID0gW107XG5cbiAgdmFyIGksIGlsLCBpdGVtLCBhY3Rpb24sIGFyZ3M7XG4gIHZhciBjcHgsIGNweSwgY3B4MiwgY3B5MiwgY3B4MSwgY3B5MSwgY3B4MCwgY3B5MCxcbiAgICBsYXN0ZSwgaixcbiAgICB0LCB0eCwgdHk7XG5cbiAgZm9yICggaSA9IDAsIGlsID0gdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgaXRlbSA9IHRoaXMuYWN0aW9uc1sgaSBdO1xuXG4gICAgYWN0aW9uID0gaXRlbS5hY3Rpb247XG4gICAgYXJncyA9IGl0ZW0uYXJncztcblxuICAgIHN3aXRjaCAoIGFjdGlvbiApIHtcblxuICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTzpcblxuICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5MSU5FX1RPOlxuXG4gICAgICBwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLlFVQURSQVRJQ19DVVJWRV9UTzpcblxuICAgICAgY3B4ICA9IGFyZ3NbIDIgXTtcbiAgICAgIGNweSAgPSBhcmdzWyAzIF07XG5cbiAgICAgIGNweDEgPSBhcmdzWyAwIF07XG4gICAgICBjcHkxID0gYXJnc1sgMSBdO1xuXG4gICAgICBpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgIGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgIGNweDAgPSBsYXN0ZS54O1xuICAgICAgICBjcHkwID0gbGFzdGUueTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG4gICAgICAgIGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuICAgICAgICBjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuICAgICAgfVxuXG4gICAgICBmb3IgKCBqID0gMTsgaiA8PSBkaXZpc2lvbnM7IGogKysgKSB7XG5cbiAgICAgICAgdCA9IGogLyBkaXZpc2lvbnM7XG5cbiAgICAgICAgdHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgY3B4MCwgY3B4MSwgY3B4ICk7XG4gICAgICAgIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPOlxuXG4gICAgICBjcHggID0gYXJnc1sgNCBdO1xuICAgICAgY3B5ICA9IGFyZ3NbIDUgXTtcblxuICAgICAgY3B4MSA9IGFyZ3NbIDAgXTtcbiAgICAgIGNweTEgPSBhcmdzWyAxIF07XG5cbiAgICAgIGNweDIgPSBhcmdzWyAyIF07XG4gICAgICBjcHkyID0gYXJnc1sgMyBdO1xuXG4gICAgICBpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xuXG4gICAgICAgIGxhc3RlID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdO1xuXG4gICAgICAgIGNweDAgPSBsYXN0ZS54O1xuICAgICAgICBjcHkwID0gbGFzdGUueTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xuXG4gICAgICAgIGNweDAgPSBsYXN0ZVsgbGFzdGUubGVuZ3RoIC0gMiBdO1xuICAgICAgICBjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcblxuICAgICAgfVxuXG5cbiAgICAgIGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcblxuICAgICAgICB0ID0gaiAvIGRpdmlzaW9ucztcblxuICAgICAgICB0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCBjcHgwLCBjcHgxLCBjcHgyLCBjcHggKTtcbiAgICAgICAgdHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5DU1BMSU5FX1RIUlU6XG5cbiAgICAgIGxhc3RlID0gdGhpcy5hY3Rpb25zWyBpIC0gMSBdLmFyZ3M7XG5cbiAgICAgIHZhciBsYXN0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF0sIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF0gKTtcbiAgICAgIHZhciBzcHRzID0gWyBsYXN0IF07XG5cbiAgICAgIHZhciBuID0gZGl2aXNpb25zICogYXJnc1sgMCBdLmxlbmd0aDtcblxuICAgICAgc3B0cyA9IHNwdHMuY29uY2F0KCBhcmdzWyAwIF0gKTtcblxuICAgICAgdmFyIHNwbGluZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggc3B0cyApO1xuXG4gICAgICBmb3IgKCBqID0gMTsgaiA8PSBuOyBqICsrICkge1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCBzcGxpbmUuZ2V0UG9pbnRBdCggaiAvIG4gKSApIDtcblxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQVJDOlxuXG4gICAgICB2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxuICAgICAgICBhUmFkaXVzID0gYXJnc1sgMiBdLFxuICAgICAgICBhU3RhcnRBbmdsZSA9IGFyZ3NbIDMgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNCBdLFxuICAgICAgICBhQ2xvY2t3aXNlID0gISEgYXJnc1sgNSBdO1xuXG4gICAgICB2YXIgZGVsdGFBbmdsZSA9IGFFbmRBbmdsZSAtIGFTdGFydEFuZ2xlO1xuICAgICAgdmFyIGFuZ2xlO1xuICAgICAgdmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xuXG4gICAgICBmb3IgKCBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xuXG4gICAgICAgIHQgPSBqIC8gdGRpdmlzaW9ucztcblxuICAgICAgICBpZiAoICEgYUNsb2Nrd2lzZSApIHtcblxuICAgICAgICAgIHQgPSAxIC0gdDtcblxuICAgICAgICB9XG5cbiAgICAgICAgYW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG4gICAgICAgIHR4ID0gYVggKyBhUmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XG4gICAgICAgIHR5ID0gYVkgKyBhUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cbiAgICAgICAgLy9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xuXG4gICAgICAgIHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcblxuICAgICAgfVxuXG4gICAgICAvL2NvbnNvbGUubG9nKHBvaW50cyk7XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFOlxuXG4gICAgICB2YXIgYVggPSBhcmdzWyAwIF0sIGFZID0gYXJnc1sgMSBdLFxuICAgICAgICB4UmFkaXVzID0gYXJnc1sgMiBdLFxuICAgICAgICB5UmFkaXVzID0gYXJnc1sgMyBdLFxuICAgICAgICBhU3RhcnRBbmdsZSA9IGFyZ3NbIDQgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNSBdLFxuICAgICAgICBhQ2xvY2t3aXNlID0gISEgYXJnc1sgNiBdO1xuXG5cbiAgICAgIHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XG4gICAgICB2YXIgYW5nbGU7XG4gICAgICB2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XG5cbiAgICAgIGZvciAoIGogPSAxOyBqIDw9IHRkaXZpc2lvbnM7IGogKysgKSB7XG5cbiAgICAgICAgdCA9IGogLyB0ZGl2aXNpb25zO1xuXG4gICAgICAgIGlmICggISBhQ2xvY2t3aXNlICkge1xuXG4gICAgICAgICAgdCA9IDEgLSB0O1xuXG4gICAgICAgIH1cblxuICAgICAgICBhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG5cbiAgICAgICAgdHggPSBhWCArIHhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcbiAgICAgICAgdHkgPSBhWSArIHlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKCd0JywgdCwgJ2FuZ2xlJywgYW5nbGUsICd0eCcsIHR4LCAndHknLCB0eSk7XG5cbiAgICAgICAgcG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vY29uc29sZS5sb2cocG9pbnRzKTtcblxuICAgICAgYnJlYWs7XG5cbiAgICB9IC8vIGVuZCBzd2l0Y2hcblxuICB9XG5cblxuXG4gIC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cbiAgdmFyIGxhc3RQb2ludCA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDFdO1xuICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcbiAgaWYgKCBNYXRoLmFicyhsYXN0UG9pbnQueCAtIHBvaW50c1sgMCBdLngpIDwgRVBTSUxPTiAmJlxuICAgICAgIE1hdGguYWJzKGxhc3RQb2ludC55IC0gcG9pbnRzWyAwIF0ueSkgPCBFUFNJTE9OKVxuICAgIHBvaW50cy5zcGxpY2UoIHBvaW50cy5sZW5ndGggLSAxLCAxKTtcbiAgaWYgKCBjbG9zZWRQYXRoICkge1xuXG4gICAgcG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XG5cbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG5cbn07XG5cbi8vXG4vLyBCcmVha3MgcGF0aCBpbnRvIHNoYXBlc1xuLy9cbi8vICBBc3N1bXB0aW9ucyAoaWYgcGFyYW1ldGVyIGlzQ0NXPT10cnVlIHRoZSBvcHBvc2l0ZSBob2xkcyk6XG4vLyAgLSBzb2xpZCBzaGFwZXMgYXJlIGRlZmluZWQgY2xvY2t3aXNlIChDVylcbi8vICAtIGhvbGVzIGFyZSBkZWZpbmVkIGNvdW50ZXJjbG9ja3dpc2UgKENDVylcbi8vXG4vLyAgSWYgcGFyYW1ldGVyIG5vSG9sZXM9PXRydWU6XG4vLyAgLSBhbGwgc3ViUGF0aHMgYXJlIHJlZ2FyZGVkIGFzIHNvbGlkIHNoYXBlc1xuLy8gIC0gZGVmaW5pdGlvbiBvcmRlciBDVy9DQ1cgaGFzIG5vIHJlbGV2YW5jZVxuLy9cblxuVEhSRUUuUGF0aC5wcm90b3R5cGUudG9TaGFwZXMgPSBmdW5jdGlvbiggaXNDQ1csIG5vSG9sZXMgKSB7XG5cbiAgZnVuY3Rpb24gZXh0cmFjdFN1YnBhdGhzKCBpbkFjdGlvbnMgKSB7XG5cbiAgICB2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcblxuICAgIHZhciBzdWJQYXRocyA9IFtdLCBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cbiAgICBmb3IgKCBpID0gMCwgaWwgPSBpbkFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIGl0ZW0gPSBpbkFjdGlvbnNbIGkgXTtcblxuICAgICAgYXJncyA9IGl0ZW0uYXJncztcbiAgICAgIGFjdGlvbiA9IGl0ZW0uYWN0aW9uO1xuXG4gICAgICBpZiAoIGFjdGlvbiA9PT0gVEhSRUUuUGF0aEFjdGlvbnMuTU9WRV9UTyApIHtcblxuICAgICAgICBpZiAoIGxhc3RQYXRoLmFjdGlvbnMubGVuZ3RoICE9PSAwICkge1xuXG4gICAgICAgICAgc3ViUGF0aHMucHVzaCggbGFzdFBhdGggKTtcbiAgICAgICAgICBsYXN0UGF0aCA9IG5ldyBUSFJFRS5QYXRoKCk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGxhc3RQYXRoWyBhY3Rpb24gXS5hcHBseSggbGFzdFBhdGgsIGFyZ3MgKTtcblxuICAgIH1cblxuICAgIGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT09IDAgKSB7XG5cbiAgICAgIHN1YlBhdGhzLnB1c2goIGxhc3RQYXRoICk7XG5cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyhzdWJQYXRocyk7XG5cbiAgICByZXR1cm4gIHN1YlBhdGhzO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9TaGFwZXNOb0hvbGVzKCBpblN1YnBhdGhzICkge1xuXG4gICAgdmFyIHNoYXBlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IGluU3VicGF0aHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xuXG4gICAgICB2YXIgdG1wU2hhcGUgPSBuZXcgVEhSRUUuU2hhcGUoKTtcbiAgICAgIHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XG4gICAgICB0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcblxuICAgICAgc2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cbiAgICByZXR1cm4gc2hhcGVzO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNQb2ludEluc2lkZVBvbHlnb24oIGluUHQsIGluUG9seWdvbiApIHtcbiAgICB2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcblxuICAgIHZhciBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcblxuICAgIC8vIGluUHQgb24gcG9seWdvbiBjb250b3VyID0+IGltbWVkaWF0ZSBzdWNjZXNzICAgIG9yXG4gICAgLy8gdG9nZ2xpbmcgb2YgaW5zaWRlL291dHNpZGUgYXQgZXZlcnkgc2luZ2xlISBpbnRlcnNlY3Rpb24gcG9pbnQgb2YgYW4gZWRnZVxuICAgIC8vICB3aXRoIHRoZSBob3Jpem9udGFsIGxpbmUgdGhyb3VnaCBpblB0LCBsZWZ0IG9mIGluUHRcbiAgICAvLyAgbm90IGNvdW50aW5nIGxvd2VyWSBlbmRwb2ludHMgb2YgZWRnZXMgYW5kIHdob2xlIGVkZ2VzIG9uIHRoYXQgbGluZVxuICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKCB2YXIgcCA9IHBvbHlMZW4gLSAxLCBxID0gMDsgcSA8IHBvbHlMZW47IHAgPSBxICsrICkge1xuICAgICAgdmFyIGVkZ2VMb3dQdCAgPSBpblBvbHlnb25bIHAgXTtcbiAgICAgIHZhciBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBxIF07XG5cbiAgICAgIHZhciBlZGdlRHggPSBlZGdlSGlnaFB0LnggLSBlZGdlTG93UHQueDtcbiAgICAgIHZhciBlZGdlRHkgPSBlZGdlSGlnaFB0LnkgLSBlZGdlTG93UHQueTtcblxuICAgICAgaWYgKCBNYXRoLmFicyhlZGdlRHkpID4gRVBTSUxPTiApIHsgICAgIC8vIG5vdCBwYXJhbGxlbFxuICAgICAgICBpZiAoIGVkZ2VEeSA8IDAgKSB7XG4gICAgICAgICAgZWRnZUxvd1B0ICA9IGluUG9seWdvblsgcSBdOyBlZGdlRHggPSAtIGVkZ2VEeDtcbiAgICAgICAgICBlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBwIF07IGVkZ2VEeSA9IC0gZWRnZUR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICggKCBpblB0LnkgPCBlZGdlTG93UHQueSApIHx8ICggaW5QdC55ID4gZWRnZUhpZ2hQdC55ICkgKSAgICBjb250aW51ZTtcblxuICAgICAgICBpZiAoIGluUHQueSA9PT0gZWRnZUxvd1B0LnkgKSB7XG4gICAgICAgICAgaWYgKCBpblB0LnggPT09IGVkZ2VMb3dQdC54ICkgICByZXR1cm4gIHRydWU7ICAgLy8gaW5QdCBpcyBvbiBjb250b3VyID9cbiAgICAgICAgICAvLyBjb250aW51ZTsgICAgICAgIC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcGVycEVkZ2UgPSBlZGdlRHkgKiAoaW5QdC54IC0gZWRnZUxvd1B0LngpIC0gZWRnZUR4ICogKGluUHQueSAtIGVkZ2VMb3dQdC55KTtcbiAgICAgICAgICBpZiAoIHBlcnBFZGdlID09PSAwICkgICAgICAgcmV0dXJuICB0cnVlOyAgIC8vIGluUHQgaXMgb24gY29udG91ciA/XG4gICAgICAgICAgaWYgKCBwZXJwRWRnZSA8IDAgKSAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGluc2lkZSA9ICEgaW5zaWRlOyAgICAvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgICAgLy8gcGFyYWxsZWwgb3IgY29saW5lYXJcbiAgICAgICAgaWYgKCBpblB0LnkgIT09IGVkZ2VMb3dQdC55ICkgICAgIGNvbnRpbnVlOyAgICAgLy8gcGFyYWxsZWxcbiAgICAgICAgLy8gZWdkZSBsaWVzIG9uIHRoZSBzYW1lIGhvcml6b250YWwgbGluZSBhcyBpblB0XG4gICAgICAgIGlmICggKCAoIGVkZ2VIaWdoUHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlTG93UHQueCApICkgfHxcbiAgICAgICAgICAgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKSAgICByZXR1cm4gIHRydWU7IC8vIGluUHQ6IFBvaW50IG9uIGNvbnRvdXIgIVxuICAgICAgICAvLyBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gIGluc2lkZTtcbiAgfVxuXG5cbiAgdmFyIHN1YlBhdGhzID0gZXh0cmFjdFN1YnBhdGhzKCB0aGlzLmFjdGlvbnMgKTtcbiAgaWYgKCBzdWJQYXRocy5sZW5ndGggPT09IDAgKSByZXR1cm4gW107XG5cbiAgaWYgKCBub0hvbGVzID09PSB0cnVlICkgcmV0dXJuICB0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XG5cblxuICB2YXIgc29saWQsIHRtcFBhdGgsIHRtcFNoYXBlLCBzaGFwZXMgPSBbXTtcblxuICBpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSkge1xuXG4gICAgdG1wUGF0aCA9IHN1YlBhdGhzWzBdO1xuICAgIHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XG4gICAgdG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcbiAgICB0bXBTaGFwZS5jdXJ2ZXMgPSB0bXBQYXRoLmN1cnZlcztcbiAgICBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcbiAgICByZXR1cm4gc2hhcGVzO1xuXG4gIH1cblxuICB2YXIgaG9sZXNGaXJzdCA9ICEgVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcbiAgaG9sZXNGaXJzdCA9IGlzQ0NXID8gISBob2xlc0ZpcnN0IDogaG9sZXNGaXJzdDtcblxuICAvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xuXG4gIHZhciBiZXR0ZXJTaGFwZUhvbGVzID0gW107XG4gIHZhciBuZXdTaGFwZXMgPSBbXTtcbiAgdmFyIG5ld1NoYXBlSG9sZXMgPSBbXTtcbiAgdmFyIG1haW5JZHggPSAwO1xuICB2YXIgdG1wUG9pbnRzO1xuXG4gIG5ld1NoYXBlc1ttYWluSWR4XSA9IHVuZGVmaW5lZDtcbiAgbmV3U2hhcGVIb2xlc1ttYWluSWR4XSA9IFtdO1xuXG4gIHZhciBpLCBpbDtcblxuICBmb3IgKCBpID0gMCwgaWwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xuICAgIHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XG4gICAgc29saWQgPSBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XG4gICAgc29saWQgPSBpc0NDVyA/ICEgc29saWQgOiBzb2xpZDtcblxuICAgIGlmICggc29saWQgKSB7XG5cbiAgICAgIGlmICggKCEgaG9sZXNGaXJzdCApICYmICggbmV3U2hhcGVzW21haW5JZHhdICkgKSAgbWFpbklkeCArKztcblxuICAgICAgbmV3U2hhcGVzW21haW5JZHhdID0geyBzOiBuZXcgVEhSRUUuU2hhcGUoKSwgcDogdG1wUG9pbnRzIH07XG4gICAgICBuZXdTaGFwZXNbbWFpbklkeF0ucy5hY3Rpb25zID0gdG1wUGF0aC5hY3Rpb25zO1xuICAgICAgbmV3U2hhcGVzW21haW5JZHhdLnMuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XG5cbiAgICAgIGlmICggaG9sZXNGaXJzdCApIG1haW5JZHggKys7XG4gICAgICBuZXdTaGFwZUhvbGVzW21haW5JZHhdID0gW107XG5cbiAgICAgIC8vY29uc29sZS5sb2coJ2N3JywgaSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBuZXdTaGFwZUhvbGVzW21haW5JZHhdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWzBdIH0gKTtcblxuICAgICAgLy9jb25zb2xlLmxvZygnY2N3JywgaSk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIG9ubHkgSG9sZXM/IC0+IHByb2JhYmx5IGFsbCBTaGFwZXMgd2l0aCB3cm9uZyBvcmllbnRhdGlvblxuICBpZiAoICEgbmV3U2hhcGVzWzBdICkgcmV0dXJuICB0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XG5cblxuICBpZiAoIG5ld1NoYXBlcy5sZW5ndGggPiAxICkge1xuICAgIHZhciBhbWJpZ2lvdXMgPSBmYWxzZTtcbiAgICB2YXIgdG9DaGFuZ2UgPSBbXTtcblxuICAgIGZvciAodmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XG4gICAgICBiZXR0ZXJTaGFwZUhvbGVzW3NJZHhdID0gW107XG4gICAgfVxuICAgIGZvciAodmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XG4gICAgICB2YXIgc2hvID0gbmV3U2hhcGVIb2xlc1tzSWR4XTtcbiAgICAgIGZvciAodmFyIGhJZHggPSAwOyBoSWR4IDwgc2hvLmxlbmd0aDsgaElkeCArKyApIHtcbiAgICAgICAgdmFyIGhvID0gc2hvW2hJZHhdO1xuICAgICAgICB2YXIgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4ICsrICkge1xuICAgICAgICAgIGlmICggaXNQb2ludEluc2lkZVBvbHlnb24oIGhvLnAsIG5ld1NoYXBlc1tzMklkeF0ucCApICkge1xuICAgICAgICAgICAgaWYgKCBzSWR4ICE9PSBzMklkeCApIHRvQ2hhbmdlLnB1c2goIHsgZnJvbXM6IHNJZHgsIHRvczogczJJZHgsIGhvbGU6IGhJZHggfSApO1xuICAgICAgICAgICAgaWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XG4gICAgICAgICAgICAgIGhvbGVfdW5hc3NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBiZXR0ZXJTaGFwZUhvbGVzW3MySWR4XS5wdXNoKCBobyApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW1iaWdpb3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBob2xlX3VuYXNzaWduZWQgKSB7IGJldHRlclNoYXBlSG9sZXNbc0lkeF0ucHVzaCggaG8gKTsgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhcImFtYmlnaW91czogXCIsIGFtYmlnaW91cyk7XG4gICAgaWYgKCB0b0NoYW5nZS5sZW5ndGggPiAwICkge1xuICAgICAgLy8gY29uc29sZS5sb2coXCJ0byBjaGFuZ2U6IFwiLCB0b0NoYW5nZSk7XG4gICAgICBpZiAoISBhbWJpZ2lvdXMpICBuZXdTaGFwZUhvbGVzID0gYmV0dGVyU2hhcGVIb2xlcztcbiAgICB9XG4gIH1cblxuICB2YXIgdG1wSG9sZXMsIGosIGpsO1xuICBmb3IgKCBpID0gMCwgaWwgPSBuZXdTaGFwZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG4gICAgdG1wU2hhcGUgPSBuZXdTaGFwZXNbaV0ucztcbiAgICBzaGFwZXMucHVzaCggdG1wU2hhcGUgKTtcbiAgICB0bXBIb2xlcyA9IG5ld1NoYXBlSG9sZXNbaV07XG4gICAgZm9yICggaiA9IDAsIGpsID0gdG1wSG9sZXMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG4gICAgICB0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBIb2xlc1tqXS5oICk7XG4gICAgfVxuICB9XG5cbiAgLy9jb25zb2xlLmxvZyhcInNoYXBlXCIsIHNoYXBlcyk7XG5cbiAgcmV0dXJuIHNoYXBlcztcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2NvcmUvU2hhcGUuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXG4gKiBEZWZpbmVzIGEgMmQgc2hhcGUgcGxhbmUgdXNpbmcgcGF0aHMuXG4gKiovXG5cbi8vIFNURVAgMSBDcmVhdGUgYSBwYXRoLlxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxuLy8gU1RFUCAzIEV4dHJ1ZGVHZW9tZXRyeSB0YWtlcyBpbiBTaGFwZS9TaGFwZXNcbi8vIFNURVAgM2EgLSBFeHRyYWN0IHBvaW50cyBmcm9tIGVhY2ggc2hhcGUsIHR1cm4gdG8gdmVydGljZXNcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXG5cblRIUkVFLlNoYXBlID0gZnVuY3Rpb24gKCkge1xuXG4gIFRIUkVFLlBhdGguYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuICB0aGlzLmhvbGVzID0gW107XG5cbn07XG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XG5USFJFRS5TaGFwZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TaGFwZTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBFeHRydWRlR2VvbWV0cnlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJ1ZGUgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XG5cbiAgdmFyIGV4dHJ1ZGVkID0gbmV3IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xuICByZXR1cm4gZXh0cnVkZWQ7XG5cbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZCB0byByZXR1cm4gU2hhcGVHZW9tZXRyeVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUubWFrZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TaGFwZUdlb21ldHJ5KCB0aGlzLCBvcHRpb25zICk7XG4gIHJldHVybiBnZW9tZXRyeTtcblxufTtcblxuLy8gR2V0IHBvaW50cyBvZiBob2xlc1xuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0UG9pbnRzSG9sZXMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICB2YXIgaSwgaWwgPSB0aGlzLmhvbGVzLmxlbmd0aCwgaG9sZXNQdHMgPSBbXTtcblxuICBmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgaG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zLCB0aGlzLmJlbmRzICk7XG5cbiAgfVxuXG4gIHJldHVybiBob2xlc1B0cztcblxufTtcblxuLy8gR2V0IHBvaW50cyBvZiBob2xlcyAoc3BhY2VkIGJ5IHJlZ3VsYXIgZGlzdGFuY2UpXG5cblRIUkVFLlNoYXBlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHNIb2xlcyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLCBob2xlc1B0cyA9IFtdO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICBob2xlc1B0c1sgaSBdID0gdGhpcy5ob2xlc1sgaSBdLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIHRoaXMuYmVuZHMgKTtcblxuICB9XG5cbiAgcmV0dXJuIGhvbGVzUHRzO1xuXG59O1xuXG5cbi8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChrZXlwb2ludHMgYmFzZWQgb24gc2VnbWVudHMgcGFyYW1ldGVyKVxuXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xuXG4gIHJldHVybiB7XG5cbiAgICBzaGFwZTogdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zICksXG4gICAgaG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXG5cbiAgfTtcblxufTtcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICBpZiAodGhpcy51c2VTcGFjZWRQb2ludHMpIHtcbiAgICByZXR1cm4gdGhpcy5leHRyYWN0QWxsU3BhY2VkUG9pbnRzKGRpdmlzaW9ucyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5leHRyYWN0QWxsUG9pbnRzKGRpdmlzaW9ucyk7XG5cbn07XG5cbi8vXG4vLyBUSFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50c1dpdGhCZW5kID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMsIGJlbmQgKSB7XG4vL1xuLy8gIHJldHVybiB7XG4vL1xuLy8gICAgc2hhcGU6IHRoaXMudHJhbnNmb3JtKCBiZW5kLCBkaXZpc2lvbnMgKSxcbi8vICAgIGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMsIGJlbmQgKVxuLy9cbi8vICB9O1xuLy9cbi8vIH07XG5cbi8vIEdldCBwb2ludHMgb2Ygc2hhcGUgYW5kIGhvbGVzIChzcGFjZWQgYnkgcmVndWxhciBkaXN0YW5jZSlcblxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJhY3RBbGxTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcblxuICByZXR1cm4ge1xuXG4gICAgc2hhcGU6IHRoaXMuZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApLFxuICAgIGhvbGVzOiB0aGlzLmdldFNwYWNlZFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxuXG4gIH07XG5cbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIFV0aWxzXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlNoYXBlLlV0aWxzID0ge1xuXG4gIHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XG5cbiAgICBmdW5jdGlvbiBwb2ludF9pbl9zZWdtZW50XzJEX2NvbGluKCBpblNlZ1B0MSwgaW5TZWdQdDIsIGluT3RoZXJQdCApIHtcbiAgICAgIC8vIGluT3RoZXJQdCBuZWVkcyB0byBiZSBjb2xpbmVhciB0byB0aGUgaW5TZWdtZW50XG4gICAgICBpZiAoIGluU2VnUHQxLnggIT09IGluU2VnUHQyLnggKSB7XG4gICAgICAgIGlmICggaW5TZWdQdDEueCA8IGluU2VnUHQyLnggKSB7XG4gICAgICAgICAgcmV0dXJuICAoICggaW5TZWdQdDEueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDIueCApICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICAoICggaW5TZWdQdDIueCA8PSBpbk90aGVyUHQueCApICYmICggaW5PdGhlclB0LnggPD0gaW5TZWdQdDEueCApICk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggaW5TZWdQdDEueSA8IGluU2VnUHQyLnkgKSB7XG4gICAgICAgICAgcmV0dXJuICAoICggaW5TZWdQdDEueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDIueSApICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICAoICggaW5TZWdQdDIueSA8PSBpbk90aGVyUHQueSApICYmICggaW5PdGhlclB0LnkgPD0gaW5TZWdQdDEueSApICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEsIGluU2VnMlB0MiwgaW5FeGNsdWRlQWRqYWNlbnRTZWdzICkge1xuICAgICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAgIHZhciBzZWcxZHggPSBpblNlZzFQdDIueCAtIGluU2VnMVB0MS54LCAgIHNlZzFkeSA9IGluU2VnMVB0Mi55IC0gaW5TZWcxUHQxLnk7XG4gICAgICB2YXIgc2VnMmR4ID0gaW5TZWcyUHQyLnggLSBpblNlZzJQdDEueCwgICBzZWcyZHkgPSBpblNlZzJQdDIueSAtIGluU2VnMlB0MS55O1xuXG4gICAgICB2YXIgc2VnMXNlZzJkeCA9IGluU2VnMVB0MS54IC0gaW5TZWcyUHQxLng7XG4gICAgICB2YXIgc2VnMXNlZzJkeSA9IGluU2VnMVB0MS55IC0gaW5TZWcyUHQxLnk7XG5cbiAgICAgIHZhciBsaW1pdCAgID0gc2VnMWR5ICogc2VnMmR4IC0gc2VnMWR4ICogc2VnMmR5O1xuICAgICAgdmFyIHBlcnBTZWcxICA9IHNlZzFkeSAqIHNlZzFzZWcyZHggLSBzZWcxZHggKiBzZWcxc2VnMmR5O1xuXG4gICAgICBpZiAoIE1hdGguYWJzKGxpbWl0KSA+IEVQU0lMT04gKSB7ICAgICAgLy8gbm90IHBhcmFsbGVsXG5cbiAgICAgICAgdmFyIHBlcnBTZWcyO1xuICAgICAgICBpZiAoIGxpbWl0ID4gMCApIHtcbiAgICAgICAgICBpZiAoICggcGVycFNlZzEgPCAwICkgfHwgKCBwZXJwU2VnMSA+IGxpbWl0ICkgKSAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XG4gICAgICAgICAgaWYgKCAoIHBlcnBTZWcyIDwgMCApIHx8ICggcGVycFNlZzIgPiBsaW1pdCApICkgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoICggcGVycFNlZzEgPiAwICkgfHwgKCBwZXJwU2VnMSA8IGxpbWl0ICkgKSAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIHBlcnBTZWcyID0gc2VnMmR5ICogc2VnMXNlZzJkeCAtIHNlZzJkeCAqIHNlZzFzZWcyZHk7XG4gICAgICAgICAgaWYgKCAoIHBlcnBTZWcyID4gMCApIHx8ICggcGVycFNlZzIgPCBsaW1pdCApICkgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGkuZS4gdG8gcmVkdWNlIHJvdW5kaW5nIGVycm9yc1xuICAgICAgICAvLyBpbnRlcnNlY3Rpb24gYXQgZW5kcG9pbnQgb2Ygc2VnbWVudCMxP1xuICAgICAgICBpZiAoIHBlcnBTZWcyID09PSAwICkge1xuICAgICAgICAgIGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuICAgICAgICAgICAgICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApICAgcmV0dXJuIFtdO1xuICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICggcGVycFNlZzIgPT09IGxpbWl0ICkge1xuICAgICAgICAgIGlmICggKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAmJlxuICAgICAgICAgICAgICggKCBwZXJwU2VnMSA9PT0gMCApIHx8ICggcGVycFNlZzEgPT09IGxpbWl0ICkgKSApICAgcmV0dXJuIFtdO1xuICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MiBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludGVyc2VjdGlvbiBhdCBlbmRwb2ludCBvZiBzZWdtZW50IzI/XG4gICAgICAgIGlmICggcGVycFNlZzEgPT09IDAgKSAgIHJldHVybiBbIGluU2VnMlB0MSBdO1xuICAgICAgICBpZiAoIHBlcnBTZWcxID09PSBsaW1pdCApIHJldHVybiBbIGluU2VnMlB0MiBdO1xuXG4gICAgICAgIC8vIHJldHVybiByZWFsIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICB2YXIgZmFjdG9yU2VnMSA9IHBlcnBTZWcyIC8gbGltaXQ7XG4gICAgICAgIHJldHVybiAgWyB7IHg6IGluU2VnMVB0MS54ICsgZmFjdG9yU2VnMSAqIHNlZzFkeCxcbiAgICAgICAgICAgICAgeTogaW5TZWcxUHQxLnkgKyBmYWN0b3JTZWcxICogc2VnMWR5IH0gXTtcblxuICAgICAgfSBlbHNlIHsgICAgLy8gcGFyYWxsZWwgb3IgY29saW5lYXJcbiAgICAgICAgaWYgKCAoIHBlcnBTZWcxICE9PSAwICkgfHxcbiAgICAgICAgICAgKCBzZWcyZHkgKiBzZWcxc2VnMmR4ICE9PSBzZWcyZHggKiBzZWcxc2VnMmR5ICkgKSAgICAgIHJldHVybiBbXTtcblxuICAgICAgICAvLyB0aGV5IGFyZSBjb2xsaW5lYXIgb3IgZGVnZW5lcmF0ZVxuICAgICAgICB2YXIgc2VnMVB0ID0gKCAoc2VnMWR4ID09PSAwKSAmJiAoc2VnMWR5ID09PSAwKSApOyAgLy8gc2VnbWVudDEgaXN0IGp1c3QgYSBwb2ludD9cbiAgICAgICAgdmFyIHNlZzJQdCA9ICggKHNlZzJkeCA9PT0gMCkgJiYgKHNlZzJkeSA9PT0gMCkgKTsgIC8vIHNlZ21lbnQyIGlzdCBqdXN0IGEgcG9pbnQ/XG4gICAgICAgIC8vIGJvdGggc2VnbWVudHMgYXJlIHBvaW50c1xuICAgICAgICBpZiAoIHNlZzFQdCAmJiBzZWcyUHQgKSB7XG4gICAgICAgICAgaWYgKCAoaW5TZWcxUHQxLnggIT09IGluU2VnMlB0MS54KSB8fFxuICAgICAgICAgICAgIChpblNlZzFQdDEueSAhPT0gaW5TZWcyUHQxLnkpICkgICAgcmV0dXJuIFtdOyAgLy8gdGhleSBhcmUgZGlzdGluY3QgIHBvaW50c1xuICAgICAgICAgIHJldHVybiBbIGluU2VnMVB0MSBdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhleSBhcmUgdGhlIHNhbWUgcG9pbnRcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWdtZW50IzEgIGlzIGEgc2luZ2xlIHBvaW50XG4gICAgICAgIGlmICggc2VnMVB0ICkge1xuICAgICAgICAgIGlmICghIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMlB0MSwgaW5TZWcyUHQyLCBpblNlZzFQdDEgKSApICAgIHJldHVybiBbXTsgICAgLy8gYnV0IG5vdCBpbiBzZWdtZW50IzJcbiAgICAgICAgICByZXR1cm4gWyBpblNlZzFQdDEgXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWdtZW50IzIgIGlzIGEgc2luZ2xlIHBvaW50XG4gICAgICAgIGlmICggc2VnMlB0ICkge1xuICAgICAgICAgIGlmICghIHBvaW50X2luX3NlZ21lbnRfMkRfY29saW4oIGluU2VnMVB0MSwgaW5TZWcxUHQyLCBpblNlZzJQdDEgKSApICAgIHJldHVybiBbXTsgICAgLy8gYnV0IG5vdCBpbiBzZWdtZW50IzFcbiAgICAgICAgICByZXR1cm4gWyBpblNlZzJQdDEgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXkgYXJlIGNvbGxpbmVhciBzZWdtZW50cywgd2hpY2ggbWlnaHQgb3ZlcmxhcFxuICAgICAgICB2YXIgc2VnMW1pbiwgc2VnMW1heCwgc2VnMW1pblZhbCwgc2VnMW1heFZhbDtcbiAgICAgICAgdmFyIHNlZzJtaW4sIHNlZzJtYXgsIHNlZzJtaW5WYWwsIHNlZzJtYXhWYWw7XG4gICAgICAgIGlmIChzZWcxZHggIT09IDApIHsgICAvLyB0aGUgc2VnbWVudHMgYXJlIE5PVCBvbiBhIHZlcnRpY2FsIGxpbmVcbiAgICAgICAgICBpZiAoIGluU2VnMVB0MS54IDwgaW5TZWcxUHQyLnggKSB7XG4gICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLng7XG4gICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQyOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLng7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueDtcbiAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBpblNlZzJQdDEueCA8IGluU2VnMlB0Mi54ICkge1xuICAgICAgICAgICAgc2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS54O1xuICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0Mjsgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi54O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQyOyBzZWcybWluVmFsID0gaW5TZWcyUHQyLng7XG4gICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLng7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAgICAgICAgLy8gdGhlIHNlZ21lbnRzIGFyZSBvbiBhIHZlcnRpY2FsIGxpbmVcbiAgICAgICAgICBpZiAoIGluU2VnMVB0MS55IDwgaW5TZWcxUHQyLnkgKSB7XG4gICAgICAgICAgICBzZWcxbWluID0gaW5TZWcxUHQxOyBzZWcxbWluVmFsID0gaW5TZWcxUHQxLnk7XG4gICAgICAgICAgICBzZWcxbWF4ID0gaW5TZWcxUHQyOyBzZWcxbWF4VmFsID0gaW5TZWcxUHQyLnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZzFtaW4gPSBpblNlZzFQdDI7IHNlZzFtaW5WYWwgPSBpblNlZzFQdDIueTtcbiAgICAgICAgICAgIHNlZzFtYXggPSBpblNlZzFQdDE7IHNlZzFtYXhWYWwgPSBpblNlZzFQdDEueTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBpblNlZzJQdDEueSA8IGluU2VnMlB0Mi55ICkge1xuICAgICAgICAgICAgc2VnMm1pbiA9IGluU2VnMlB0MTsgc2VnMm1pblZhbCA9IGluU2VnMlB0MS55O1xuICAgICAgICAgICAgc2VnMm1heCA9IGluU2VnMlB0Mjsgc2VnMm1heFZhbCA9IGluU2VnMlB0Mi55O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWcybWluID0gaW5TZWcyUHQyOyBzZWcybWluVmFsID0gaW5TZWcyUHQyLnk7XG4gICAgICAgICAgICBzZWcybWF4ID0gaW5TZWcyUHQxOyBzZWcybWF4VmFsID0gaW5TZWcyUHQxLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICggc2VnMW1pblZhbCA8PSBzZWcybWluVmFsICkge1xuICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8ICBzZWcybWluVmFsICkgcmV0dXJuIFtdO1xuICAgICAgICAgIGlmICggc2VnMW1heFZhbCA9PT0gc2VnMm1pblZhbCApICB7XG4gICAgICAgICAgICBpZiAoIGluRXhjbHVkZUFkamFjZW50U2VncyApICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIHJldHVybiBbIHNlZzJtaW4gXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBzZWcxbWF4VmFsIDw9IHNlZzJtYXhWYWwgKSByZXR1cm4gWyBzZWcybWluLCBzZWcxbWF4IF07XG4gICAgICAgICAgcmV0dXJuICBbIHNlZzJtaW4sIHNlZzJtYXggXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIHNlZzFtaW5WYWwgPiAgc2VnMm1heFZhbCApIHJldHVybiBbXTtcbiAgICAgICAgICBpZiAoIHNlZzFtaW5WYWwgPT09IHNlZzJtYXhWYWwgKSAge1xuICAgICAgICAgICAgaWYgKCBpbkV4Y2x1ZGVBZGphY2VudFNlZ3MgKSAgICByZXR1cm4gW107XG4gICAgICAgICAgICByZXR1cm4gWyBzZWcxbWluIF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICggc2VnMW1heFZhbCA8PSBzZWcybWF4VmFsICkgcmV0dXJuIFsgc2VnMW1pbiwgc2VnMW1heCBdO1xuICAgICAgICAgIHJldHVybiAgWyBzZWcxbWluLCBzZWcybWF4IF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50SW5zaWRlQW5nbGUoIGluVmVydGV4LCBpbkxlZ0Zyb21QdCwgaW5MZWdUb1B0LCBpbk90aGVyUHQgKSB7XG4gICAgICAvLyBUaGUgb3JkZXIgb2YgbGVncyBpcyBpbXBvcnRhbnRcblxuICAgICAgdmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XG5cbiAgICAgIC8vIHRyYW5zbGF0aW9uIG9mIGFsbCBwb2ludHMsIHNvIHRoYXQgVmVydGV4IGlzIGF0ICgwLDApXG4gICAgICB2YXIgbGVnRnJvbVB0WCAgPSBpbkxlZ0Zyb21QdC54IC0gaW5WZXJ0ZXgueCwgIGxlZ0Zyb21QdFkgPSBpbkxlZ0Zyb21QdC55IC0gaW5WZXJ0ZXgueTtcbiAgICAgIHZhciBsZWdUb1B0WCAgPSBpbkxlZ1RvUHQueCAtIGluVmVydGV4LngsICBsZWdUb1B0WSAgID0gaW5MZWdUb1B0LnkgLSBpblZlcnRleC55O1xuICAgICAgdmFyIG90aGVyUHRYICA9IGluT3RoZXJQdC54IC0gaW5WZXJ0ZXgueCwgIG90aGVyUHRZICAgPSBpbk90aGVyUHQueSAtIGluVmVydGV4Lnk7XG5cbiAgICAgIC8vIG1haW4gYW5nbGUgPjA6IDwgMTgwIGRlZy47IDA6IDE4MCBkZWcuOyA8MDogPiAxODAgZGVnLlxuICAgICAgdmFyIGZyb20ydG9BbmdsZSAgPSBsZWdGcm9tUHRYICogbGVnVG9QdFkgLSBsZWdGcm9tUHRZICogbGVnVG9QdFg7XG4gICAgICB2YXIgZnJvbTJvdGhlckFuZ2xlID0gbGVnRnJvbVB0WCAqIG90aGVyUHRZIC0gbGVnRnJvbVB0WSAqIG90aGVyUHRYO1xuXG4gICAgICBpZiAoIE1hdGguYWJzKGZyb20ydG9BbmdsZSkgPiBFUFNJTE9OICkgeyAgICAgLy8gYW5nbGUgIT0gMTgwIGRlZy5cblxuICAgICAgICB2YXIgb3RoZXIydG9BbmdsZSAgID0gb3RoZXJQdFggKiBsZWdUb1B0WSAtIG90aGVyUHRZICogbGVnVG9QdFg7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IFwiICsgZnJvbTJ0b0FuZ2xlICsgXCIsIGZyb20yb3RoZXI6IFwiICsgZnJvbTJvdGhlckFuZ2xlICsgXCIsIG90aGVyMnRvOiBcIiArIG90aGVyMnRvQW5nbGUgKTtcblxuICAgICAgICBpZiAoIGZyb20ydG9BbmdsZSA+IDAgKSB7ICAgICAgIC8vIG1haW4gYW5nbGUgPCAxODAgZGVnLlxuICAgICAgICAgIHJldHVybiAgKCAoIGZyb20yb3RoZXJBbmdsZSA+PSAwICkgJiYgKCBvdGhlcjJ0b0FuZ2xlID49IDAgKSApO1xuICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAvLyBtYWluIGFuZ2xlID4gMTgwIGRlZy5cbiAgICAgICAgICByZXR1cm4gICggKCBmcm9tMm90aGVyQW5nbGUgPj0gMCApIHx8ICggb3RoZXIydG9BbmdsZSA+PSAwICkgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8vIGFuZ2xlID09IDE4MCBkZWcuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBcImZyb20ydG86IDE4MCBkZWcuLCBmcm9tMm90aGVyOiBcIiArIGZyb20yb3RoZXJBbmdsZSAgKTtcbiAgICAgICAgcmV0dXJuICAoIGZyb20yb3RoZXJBbmdsZSA+IDAgKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUhvbGVzKCBjb250b3VyLCBob2xlcyApIHtcblxuICAgICAgdmFyIHNoYXBlID0gY29udG91ci5jb25jYXQoKTsgLy8gd29yayBvbiB0aGlzIHNoYXBlXG4gICAgICB2YXIgaG9sZTtcblxuICAgICAgZnVuY3Rpb24gaXNDdXRMaW5lSW5zaWRlQW5nbGVzKCBpblNoYXBlSWR4LCBpbkhvbGVJZHggKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGhvbGUgcG9pbnQgbGllcyB3aXRoaW4gYW5nbGUgYXJvdW5kIHNoYXBlIHBvaW50XG4gICAgICAgIHZhciBsYXN0U2hhcGVJZHggPSBzaGFwZS5sZW5ndGggLSAxO1xuXG4gICAgICAgIHZhciBwcmV2U2hhcGVJZHggPSBpblNoYXBlSWR4IC0gMTtcbiAgICAgICAgaWYgKCBwcmV2U2hhcGVJZHggPCAwICkgICAgIHByZXZTaGFwZUlkeCA9IGxhc3RTaGFwZUlkeDtcblxuICAgICAgICB2YXIgbmV4dFNoYXBlSWR4ID0gaW5TaGFwZUlkeCArIDE7XG4gICAgICAgIGlmICggbmV4dFNoYXBlSWR4ID4gbGFzdFNoYXBlSWR4ICkgIG5leHRTaGFwZUlkeCA9IDA7XG5cbiAgICAgICAgdmFyIGluc2lkZUFuZ2xlID0gaXNQb2ludEluc2lkZUFuZ2xlKCBzaGFwZVtpblNoYXBlSWR4XSwgc2hhcGVbIHByZXZTaGFwZUlkeCBdLCBzaGFwZVsgbmV4dFNoYXBlSWR4IF0sIGhvbGVbaW5Ib2xlSWR4XSApO1xuICAgICAgICBpZiAoISBpbnNpZGVBbmdsZSApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKFNoYXBlKTogXCIgKyBpblNoYXBlSWR4ICsgXCIsIFBvaW50OiBcIiArIGhvbGVbaW5Ib2xlSWR4XS54ICsgXCIvXCIgKyBob2xlW2luSG9sZUlkeF0ueSApO1xuICAgICAgICAgIHJldHVybiAgZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBzaGFwZSBwb2ludCBsaWVzIHdpdGhpbiBhbmdsZSBhcm91bmQgaG9sZSBwb2ludFxuICAgICAgICB2YXIgbGFzdEhvbGVJZHggPSBob2xlLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgdmFyIHByZXZIb2xlSWR4ID0gaW5Ib2xlSWR4IC0gMTtcbiAgICAgICAgaWYgKCBwcmV2SG9sZUlkeCA8IDAgKSAgICAgIHByZXZIb2xlSWR4ID0gbGFzdEhvbGVJZHg7XG5cbiAgICAgICAgdmFyIG5leHRIb2xlSWR4ID0gaW5Ib2xlSWR4ICsgMTtcbiAgICAgICAgaWYgKCBuZXh0SG9sZUlkeCA+IGxhc3RIb2xlSWR4ICkgIG5leHRIb2xlSWR4ID0gMDtcblxuICAgICAgICBpbnNpZGVBbmdsZSA9IGlzUG9pbnRJbnNpZGVBbmdsZSggaG9sZVtpbkhvbGVJZHhdLCBob2xlWyBwcmV2SG9sZUlkeCBdLCBob2xlWyBuZXh0SG9sZUlkeCBdLCBzaGFwZVtpblNoYXBlSWR4XSApO1xuICAgICAgICBpZiAoISBpbnNpZGVBbmdsZSApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggXCJWZXJ0ZXggKEhvbGUpOiBcIiArIGluSG9sZUlkeCArIFwiLCBQb2ludDogXCIgKyBzaGFwZVtpblNoYXBlSWR4XS54ICsgXCIvXCIgKyBzaGFwZVtpblNoYXBlSWR4XS55ICk7XG4gICAgICAgICAgcmV0dXJuICBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAgdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW50ZXJzZWN0c1NoYXBlRWRnZSggaW5TaGFwZVB0LCBpbkhvbGVQdCApIHtcbiAgICAgICAgLy8gY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggc2hhcGUgZWRnZXNcbiAgICAgICAgdmFyIHNJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcbiAgICAgICAgZm9yICggc0lkeCA9IDA7IHNJZHggPCBzaGFwZS5sZW5ndGg7IHNJZHggKysgKSB7XG4gICAgICAgICAgbmV4dElkeCA9IHNJZHggKyAxOyBuZXh0SWR4ICU9IHNoYXBlLmxlbmd0aDtcbiAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIHNoYXBlW3NJZHhdLCBzaGFwZVtuZXh0SWR4XSwgdHJ1ZSApO1xuICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKSAgICByZXR1cm4gIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXBIb2xlcyA9IFtdO1xuXG4gICAgICBmdW5jdGlvbiBpbnRlcnNlY3RzSG9sZUVkZ2UoIGluU2hhcGVQdCwgaW5Ib2xlUHQgKSB7XG4gICAgICAgIC8vIGNoZWNrcyBmb3IgaW50ZXJzZWN0aW9ucyB3aXRoIGhvbGUgZWRnZXNcbiAgICAgICAgdmFyIGloSWR4LCBjaGtIb2xlLFxuICAgICAgICAgIGhJZHgsIG5leHRJZHgsIGludGVyc2VjdGlvbjtcbiAgICAgICAgZm9yICggaWhJZHggPSAwOyBpaElkeCA8IGluZGVwSG9sZXMubGVuZ3RoOyBpaElkeCArKyApIHtcbiAgICAgICAgICBjaGtIb2xlID0gaG9sZXNbaW5kZXBIb2xlc1tpaElkeF1dO1xuICAgICAgICAgIGZvciAoIGhJZHggPSAwOyBoSWR4IDwgY2hrSG9sZS5sZW5ndGg7IGhJZHggKysgKSB7XG4gICAgICAgICAgICBuZXh0SWR4ID0gaElkeCArIDE7IG5leHRJZHggJT0gY2hrSG9sZS5sZW5ndGg7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rfc2VnbWVudHNfMkQoIGluU2hhcGVQdCwgaW5Ib2xlUHQsIGNoa0hvbGVbaElkeF0sIGNoa0hvbGVbbmV4dElkeF0sIHRydWUgKTtcbiAgICAgICAgICAgIGlmICggaW50ZXJzZWN0aW9uLmxlbmd0aCA+IDAgKSAgICByZXR1cm4gIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAgZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBob2xlSW5kZXgsIHNoYXBlSW5kZXgsXG4gICAgICAgIHNoYXBlUHQsIGhvbGVQdCxcbiAgICAgICAgaG9sZUlkeCwgY3V0S2V5LCBmYWlsZWRDdXRzID0gW10sXG4gICAgICAgIHRtcFNoYXBlMSwgdG1wU2hhcGUyLFxuICAgICAgICB0bXBIb2xlMSwgdG1wSG9sZTI7XG5cbiAgICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgICBpbmRlcEhvbGVzLnB1c2goIGggKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgbWluU2hhcGVJbmRleCA9IDA7XG4gICAgICB2YXIgY291bnRlciA9IGluZGVwSG9sZXMubGVuZ3RoICogMjtcbiAgICAgIHdoaWxlICggaW5kZXBIb2xlcy5sZW5ndGggPiAwICkge1xuICAgICAgICBjb3VudGVyIC0tO1xuICAgICAgICBpZiAoIGNvdW50ZXIgPCAwICkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCBcIkluZmluaXRlIExvb3AhIEhvbGVzIGxlZnQ6XCIgKyBpbmRlcEhvbGVzLmxlbmd0aCArIFwiLCBQcm9iYWJseSBIb2xlIG91dHNpZGUgU2hhcGUhXCIgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlYXJjaCBmb3Igc2hhcGUtdmVydGV4IGFuZCBob2xlLXZlcnRleCxcbiAgICAgICAgLy8gd2hpY2ggY2FuIGJlIGNvbm5lY3RlZCB3aXRob3V0IGludGVyc2VjdGlvbnNcbiAgICAgICAgZm9yICggc2hhcGVJbmRleCA9IG1pblNoYXBlSW5kZXg7IHNoYXBlSW5kZXggPCBzaGFwZS5sZW5ndGg7IHNoYXBlSW5kZXggKysgKSB7XG5cbiAgICAgICAgICBzaGFwZVB0ID0gc2hhcGVbIHNoYXBlSW5kZXggXTtcbiAgICAgICAgICBob2xlSW5kZXggPSAtIDE7XG5cbiAgICAgICAgICAvLyBzZWFyY2ggZm9yIGhvbGUgd2hpY2ggY2FuIGJlIHJlYWNoZWQgd2l0aG91dCBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgZm9yICggdmFyIGggPSAwOyBoIDwgaW5kZXBIb2xlcy5sZW5ndGg7IGggKysgKSB7XG4gICAgICAgICAgICBob2xlSWR4ID0gaW5kZXBIb2xlc1toXTtcblxuICAgICAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBjaGVja3NcbiAgICAgICAgICAgIGN1dEtleSA9IHNoYXBlUHQueCArIFwiOlwiICsgc2hhcGVQdC55ICsgXCI6XCIgKyBob2xlSWR4O1xuICAgICAgICAgICAgaWYgKCBmYWlsZWRDdXRzW2N1dEtleV0gIT09IHVuZGVmaW5lZCApICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgaG9sZSA9IGhvbGVzW2hvbGVJZHhdO1xuICAgICAgICAgICAgZm9yICggdmFyIGgyID0gMDsgaDIgPCBob2xlLmxlbmd0aDsgaDIgKysgKSB7XG4gICAgICAgICAgICAgIGhvbGVQdCA9IGhvbGVbIGgyIF07XG4gICAgICAgICAgICAgIGlmICghIGlzQ3V0TGluZUluc2lkZUFuZ2xlcyggc2hhcGVJbmRleCwgaDIgKSApICAgY29udGludWU7XG4gICAgICAgICAgICAgIGlmICggaW50ZXJzZWN0c1NoYXBlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKSAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBpZiAoIGludGVyc2VjdHNIb2xlRWRnZSggc2hhcGVQdCwgaG9sZVB0ICkgKSAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICBob2xlSW5kZXggPSBoMjtcbiAgICAgICAgICAgICAgaW5kZXBIb2xlcy5zcGxpY2UoaCwgMSk7XG5cbiAgICAgICAgICAgICAgdG1wU2hhcGUxID0gc2hhcGUuc2xpY2UoIDAsIHNoYXBlSW5kZXggKyAxICk7XG4gICAgICAgICAgICAgIHRtcFNoYXBlMiA9IHNoYXBlLnNsaWNlKCBzaGFwZUluZGV4ICk7XG4gICAgICAgICAgICAgIHRtcEhvbGUxID0gaG9sZS5zbGljZSggaG9sZUluZGV4ICk7XG4gICAgICAgICAgICAgIHRtcEhvbGUyID0gaG9sZS5zbGljZSggMCwgaG9sZUluZGV4ICsgMSApO1xuXG4gICAgICAgICAgICAgIHNoYXBlID0gdG1wU2hhcGUxLmNvbmNhdCggdG1wSG9sZTEgKS5jb25jYXQoIHRtcEhvbGUyICkuY29uY2F0KCB0bXBTaGFwZTIgKTtcblxuICAgICAgICAgICAgICBtaW5TaGFwZUluZGV4ID0gc2hhcGVJbmRleDtcblxuICAgICAgICAgICAgICAvLyBEZWJ1ZyBvbmx5LCB0byBzaG93IHRoZSBzZWxlY3RlZCBjdXRzXG4gICAgICAgICAgICAgIC8vIGdsb2JfQ3V0TGluZXMucHVzaCggWyBzaGFwZVB0LCBob2xlUHQgXSApO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCBob2xlSW5kZXggPj0gMCApIGJyZWFrOyAgICAvLyBob2xlLXZlcnRleCBmb3VuZFxuXG4gICAgICAgICAgICBmYWlsZWRDdXRzW2N1dEtleV0gPSB0cnVlOyAgICAgIC8vIHJlbWVtYmVyIGZhaWx1cmVcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCBob2xlSW5kZXggPj0gMCApIGJyZWFrOyAgICAvLyBob2xlLXZlcnRleCBmb3VuZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaGFwZTsgICAgICAgLyogc2hhcGUgd2l0aCBubyBob2xlcyAqL1xuICAgIH1cblxuXG4gICAgdmFyIGksIGlsLCBmLCBmYWNlLFxuICAgICAga2V5LCBpbmRleCxcbiAgICAgIGFsbFBvaW50c01hcCA9IHt9O1xuXG4gICAgLy8gVG8gbWFpbnRhaW4gcmVmZXJlbmNlIHRvIG9sZCBzaGFwZSwgb25lIG11c3QgbWF0Y2ggY29vcmRpbmF0ZXMsIG9yIG9mZnNldCB0aGUgaW5kaWNlcyBmcm9tIG9yaWdpbmFsIGFycmF5cy4gSXQncyBwcm9iYWJseSBlYXNpZXIgdG8gZG8gdGhlIGZpcnN0LlxuXG4gICAgdmFyIGFsbHBvaW50cyA9IGNvbnRvdXIuY29uY2F0KCk7XG5cbiAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBhbGxwb2ludHMsIGhvbGVzW2hdICk7XG5cbiAgICB9XG5cbiAgICAvL2NvbnNvbGUubG9nKCBcImFsbHBvaW50c1wiLGFsbHBvaW50cywgYWxscG9pbnRzLmxlbmd0aCApO1xuXG4gICAgLy8gcHJlcGFyZSBhbGwgcG9pbnRzIG1hcFxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gYWxscG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBrZXkgPSBhbGxwb2ludHNbIGkgXS54ICsgXCI6XCIgKyBhbGxwb2ludHNbIGkgXS55O1xuXG4gICAgICBpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oIFwiVEhSRUUuU2hhcGU6IER1cGxpY2F0ZSBwb2ludFwiLCBrZXkgKTtcblxuICAgICAgfVxuXG4gICAgICBhbGxQb2ludHNNYXBbIGtleSBdID0gaTtcblxuICAgIH1cblxuICAgIC8vIHJlbW92ZSBob2xlcyBieSBjdXR0aW5nIHBhdGhzIHRvIGhvbGVzIGFuZCBhZGRpbmcgdGhlbSB0byB0aGUgc2hhcGVcbiAgICB2YXIgc2hhcGVXaXRob3V0SG9sZXMgPSByZW1vdmVIb2xlcyggY29udG91ciwgaG9sZXMgKTtcblxuICAgIHZhciB0cmlhbmdsZXMgPSBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUoIHNoYXBlV2l0aG91dEhvbGVzLCBmYWxzZSApOyAvLyBUcnVlIHJldHVybnMgaW5kaWNlcyBmb3IgcG9pbnRzIG9mIHNwb29sZWQgc2hhcGVcbiAgICAvL2NvbnNvbGUubG9nKCBcInRyaWFuZ2xlc1wiLHRyaWFuZ2xlcywgdHJpYW5nbGVzLmxlbmd0aCApO1xuXG4gICAgLy8gY2hlY2sgYWxsIGZhY2UgdmVydGljZXMgYWdhaW5zdCBhbGwgcG9pbnRzIG1hcFxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICBmYWNlID0gdHJpYW5nbGVzWyBpIF07XG5cbiAgICAgIGZvciAoIGYgPSAwOyBmIDwgMzsgZiArKyApIHtcblxuICAgICAgICBrZXkgPSBmYWNlWyBmIF0ueCArIFwiOlwiICsgZmFjZVsgZiBdLnk7XG5cbiAgICAgICAgaW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xuXG4gICAgICAgIGlmICggaW5kZXggIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgIGZhY2VbIGYgXSA9IGluZGV4O1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcy5jb25jYXQoKTtcblxuICB9LFxuXG4gIGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcblxuICAgIHJldHVybiBUSFJFRS5Gb250VXRpbHMuVHJpYW5ndWxhdGUuYXJlYSggcHRzICkgPCAwO1xuXG4gIH0sXG5cbiAgLy8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXG4gIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfY3VydmVcblxuICAvLyBRdWFkIEJlemllciBGdW5jdGlvbnNcblxuICBiMnAwOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cbiAgICB2YXIgayA9IDEgLSB0O1xuICAgIHJldHVybiBrICogayAqIHA7XG5cbiAgfSxcblxuICBiMnAxOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cbiAgICByZXR1cm4gMiAqICggMSAtIHQgKSAqIHQgKiBwO1xuXG4gIH0sXG5cbiAgYjJwMjogZnVuY3Rpb24gKCB0LCBwICkge1xuXG4gICAgcmV0dXJuIHQgKiB0ICogcDtcblxuICB9LFxuXG4gIGIyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XG5cbiAgICByZXR1cm4gdGhpcy5iMnAwKCB0LCBwMCApICsgdGhpcy5iMnAxKCB0LCBwMSApICsgdGhpcy5iMnAyKCB0LCBwMiApO1xuXG4gIH0sXG5cbiAgLy8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xuXG4gIGIzcDA6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuICAgIHZhciBrID0gMSAtIHQ7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIHA7XG5cbiAgfSxcblxuICBiM3AxOiBmdW5jdGlvbiAoIHQsIHAgKSB7XG5cbiAgICB2YXIgayA9IDEgLSB0O1xuICAgIHJldHVybiAzICogayAqIGsgKiB0ICogcDtcblxuICB9LFxuXG4gIGIzcDI6IGZ1bmN0aW9uICggdCwgcCApIHtcblxuICAgIHZhciBrID0gMSAtIHQ7XG4gICAgcmV0dXJuIDMgKiBrICogdCAqIHQgKiBwO1xuXG4gIH0sXG5cbiAgYjNwMzogZnVuY3Rpb24gKCB0LCBwICkge1xuXG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHA7XG5cbiAgfSxcblxuICBiMzogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcblxuICAgIHJldHVybiB0aGlzLmIzcDAoIHQsIHAwICkgKyB0aGlzLmIzcDEoIHQsIHAxICkgKyB0aGlzLmIzcDIoIHQsIHAyICkgKyAgdGhpcy5iM3AzKCB0LCBwMyApO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgTGluZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5MaW5lQ3VydmUgPSBmdW5jdGlvbiAoIHYxLCB2MiApIHtcblxuICB0aGlzLnYxID0gdjE7XG4gIHRoaXMudjIgPSB2MjtcblxufTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxpbmVDdXJ2ZTtcblxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuICB2YXIgcG9pbnQgPSB0aGlzLnYyLmNsb25lKCkuc3ViKHRoaXMudjEpO1xuICBwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xuXG4gIHJldHVybiBwb2ludDtcblxufTtcblxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XG5cblRIUkVFLkxpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcblxuICByZXR1cm4gdGhpcy5nZXRQb2ludCggdSApO1xuXG59O1xuXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICB2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIodGhpcy52MSk7XG5cbiAgcmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvUXVhZHJhdGljQmV6aWVyQ3VydmUuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgUXVhZHJhdGljIEJlemllciBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlID0gZnVuY3Rpb24gKCB2MCwgdjEsIHYyICkge1xuXG4gIHRoaXMudjAgPSB2MDtcbiAgdGhpcy52MSA9IHYxO1xuICB0aGlzLnYyID0gdjI7XG5cbn07XG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmU7XG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xuXG4gIHZlY3Rvci54ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcbiAgdmVjdG9yLnkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xuXG4gIHJldHVybiB2ZWN0b3I7XG5cbn07XG5cblxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcblxuICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICB2ZWN0b3IueCA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcbiAgdmVjdG9yLnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50UXVhZHJhdGljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XG5cbiAgLy8gcmV0dXJucyB1bml0IHZlY3RvclxuXG4gIHJldHVybiB2ZWN0b3Iubm9ybWFsaXplKCk7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9jdXJ2ZXMvQ3ViaWNCZXppZXJDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDdWJpYyBCZXppZXIgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XG5cbiAgdGhpcy52MCA9IHYwO1xuICB0aGlzLnYxID0gdjE7XG4gIHRoaXMudjIgPSB2MjtcbiAgdGhpcy52MyA9IHYzO1xuXG59O1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DdWJpY0JlemllckN1cnZlO1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcblxuICB2YXIgdHgsIHR5O1xuXG4gIHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xuICB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcblxuICByZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xuXG59O1xuXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XG5cbiAgdmFyIHR4LCB0eTtcblxuICB0eCA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRDdWJpY0JlemllciggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG4gIHR5ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcblxuICB2YXIgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcbiAgdGFuZ2VudC5ub3JtYWxpemUoKTtcblxuICByZXR1cm4gdGFuZ2VudDtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBTcGxpbmUgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuU3BsaW5lQ3VydmUgPSBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IyICovICkge1xuXG4gIHRoaXMucG9pbnRzID0gKCBwb2ludHMgPT0gdW5kZWZpbmVkICkgPyBbXSA6IHBvaW50cztcblxufTtcblxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGxpbmVDdXJ2ZTtcblxuVEhSRUUuU3BsaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcblxuICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICB2YXIgd2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcblxuICB2YXIgcG9pbnQwID0gcG9pbnRzWyBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxIF07XG4gIHZhciBwb2ludDEgPSBwb2ludHNbIGludFBvaW50IF07XG4gIHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xuICB2YXIgcG9pbnQzID0gcG9pbnRzWyBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDIgXTtcblxuICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICB2ZWN0b3IueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICk7XG4gIHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKTtcblxuICByZXR1cm4gdmVjdG9yO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0VsbGlwc2VDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBFbGxpcHNlIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLkVsbGlwc2VDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xuXG4gIHRoaXMuYVggPSBhWDtcbiAgdGhpcy5hWSA9IGFZO1xuXG4gIHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XG4gIHRoaXMueVJhZGl1cyA9IHlSYWRpdXM7XG5cbiAgdGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xuICB0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZTtcblxuICB0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xuXG59O1xuXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuRWxsaXBzZUN1cnZlO1xuXG5USFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xuXG4gIHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xuXG4gIGlmICggZGVsdGFBbmdsZSA8IDAgKSBkZWx0YUFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICBpZiAoIGRlbHRhQW5nbGUgPiBNYXRoLlBJICogMiApIGRlbHRhQW5nbGUgLT0gTWF0aC5QSSAqIDI7XG5cbiAgdmFyIGFuZ2xlO1xuXG4gIGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICkge1xuXG4gICAgYW5nbGUgPSB0aGlzLmFFbmRBbmdsZSArICggMSAtIHQgKSAqICggTWF0aC5QSSAqIDIgLSBkZWx0YUFuZ2xlICk7XG5cbiAgfSBlbHNlIHtcblxuICAgIGFuZ2xlID0gdGhpcy5hU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xuXG4gIH1cblxuICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcblxuICB2ZWN0b3IueCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcbiAgdmVjdG9yLnkgPSB0aGlzLmFZICsgdGhpcy55UmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XG5cbiAgcmV0dXJuIHZlY3RvcjtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9BcmNDdXJ2ZS5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBBcmMgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQXJjQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcblxuICBUSFJFRS5FbGxpcHNlQ3VydmUuY2FsbCggdGhpcywgYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XG59O1xuXG5USFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlICk7XG5USFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5BcmNDdXJ2ZTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9MaW5lQ3VydmUzLmpzXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogIExpbmUzRFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5USFJFRS5MaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gIGZ1bmN0aW9uICggdjEsIHYyICkge1xuXG4gICAgdGhpcy52MSA9IHYxO1xuICAgIHRoaXMudjIgPSB2MjtcblxuICB9LFxuXG4gIGZ1bmN0aW9uICggdCApIHtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmVjdG9yLnN1YlZlY3RvcnMoIHRoaXMudjIsIHRoaXMudjEgKTsgLy8gZGlmZlxuICAgIHZlY3Rvci5tdWx0aXBseVNjYWxhciggdCApO1xuICAgIHZlY3Rvci5hZGQoIHRoaXMudjEgKTtcblxuICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL1F1YWRyYXRpY0JlemllckN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBRdWFkcmF0aWMgQmV6aWVyIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICBmdW5jdGlvbiAoIHYwLCB2MSwgdjIgKSB7XG5cbiAgICB0aGlzLnYwID0gdjA7XG4gICAgdGhpcy52MSA9IHYxO1xuICAgIHRoaXMudjIgPSB2MjtcblxuICB9LFxuXG4gIGZ1bmN0aW9uICggdCApIHtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCApO1xuICAgIHZlY3Rvci55ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcbiAgICB2ZWN0b3IueiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56ICk7XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuXG4gIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DdWJpY0JlemllckN1cnZlMy5qc1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqICBDdWJpYyBCZXppZXIgM0QgY3VydmVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXG5cbiAgZnVuY3Rpb24gKCB2MCwgdjEsIHYyLCB2MyApIHtcblxuICAgIHRoaXMudjAgPSB2MDtcbiAgICB0aGlzLnYxID0gdjE7XG4gICAgdGhpcy52MiA9IHYyO1xuICAgIHRoaXMudjMgPSB2MztcblxuICB9LFxuXG4gIGZ1bmN0aW9uICggdCApIHtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmVjdG9yLnggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC54LCB0aGlzLnYxLngsIHRoaXMudjIueCwgdGhpcy52My54ICk7XG4gICAgdmVjdG9yLnkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XG4gICAgdmVjdG9yLnogPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC56LCB0aGlzLnYxLnosIHRoaXMudjIueiwgdGhpcy52My56ICk7XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuXG4gIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9TcGxpbmVDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgU3BsaW5lIDNEIGN1cnZlXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cblxuVEhSRUUuU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gIGZ1bmN0aW9uICggcG9pbnRzIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8pIHtcblxuICAgIGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZUN1cnZlMyB3aWxsIGJlIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMycgKTtcbiAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbiAgfSxcblxuICBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcblxuICAgIHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgdmFyIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICB2YXIgcG9pbnQwID0gcG9pbnRzWyBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDEgXTtcbiAgICB2YXIgcG9pbnQxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuICAgIHZhciBwb2ludDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xuICAgIHZhciBwb2ludDMgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMiBdO1xuXG4gICAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICB2ZWN0b3IueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueCwgcG9pbnQxLngsIHBvaW50Mi54LCBwb2ludDMueCwgd2VpZ2h0ICk7XG4gICAgdmVjdG9yLnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLnksIHBvaW50MS55LCBwb2ludDIueSwgcG9pbnQzLnksIHdlaWdodCApO1xuICAgIHZlY3Rvci56ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC56LCBwb2ludDEueiwgcG9pbnQyLnosIHBvaW50My56LCB3ZWlnaHQgKTtcblxuICAgIHJldHVybiB2ZWN0b3I7XG5cbiAgfVxuXG4pO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvY3VydmVzL0NhdG11bGxSb21DdXJ2ZTMuanNcblxuLyoqXG4gKiBAYXV0aG9yIHp6ODUgaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqXG4gKiBDZW50cmlwZXRhbCBDYXRtdWxsUm9tIEN1cnZlIC0gd2hpY2ggaXMgdXNlZnVsIGZvciBhdm9pZGluZ1xuICogY3VzcHMgYW5kIHNlbGYtaW50ZXJzZWN0aW9ucyBpbiBub24tdW5pZm9ybSBjYXRtdWxsIHJvbSBjdXJ2ZXMuXG4gKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxuICpcbiAqIGN1cnZlLnR5cGUgYWNjZXB0cyBjZW50cmlwZXRhbChkZWZhdWx0KSwgY2hvcmRhbCBhbmQgY2F0bXVsbHJvbVxuICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxuICovXG5cblRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgPSAoIGZ1bmN0aW9uKCkge1xuXG4gIHZhclxuICAgIHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgcHggPSBuZXcgQ3ViaWNQb2x5KCksXG4gICAgcHkgPSBuZXcgQ3ViaWNQb2x5KCksXG4gICAgcHogPSBuZXcgQ3ViaWNQb2x5KCk7XG5cbiAgLypcbiAgQmFzZWQgb24gYW4gb3B0aW1pemVkIGMrKyBzb2x1dGlvbiBpblxuICAgLSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk0ODk3MzYvY2F0bXVsbC1yb20tY3VydmUtd2l0aC1uby1jdXNwcy1hbmQtbm8tc2VsZi1pbnRlcnNlY3Rpb25zL1xuICAgLSBodHRwOi8vaWRlb25lLmNvbS9Ob0ViVk1cblxuICBUaGlzIEN1YmljUG9seSBjbGFzcyBjb3VsZCBiZSB1c2VkIGZvciByZXVzaW5nIHNvbWUgdmFyaWFibGVzIGFuZCBjYWxjdWxhdGlvbnMsXG4gIGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxuICB3aGljaCBjYW4gYmUgcGxhY2VkIGluIEN1cnZlVXRpbHMuXG4gICovXG5cbiAgZnVuY3Rpb24gQ3ViaWNQb2x5KCkge1xuXG4gIH1cblxuICAvKlxuICAgKiBDb21wdXRlIGNvZWZmaWNpZW50cyBmb3IgYSBjdWJpYyBwb2x5bm9taWFsXG4gICAqICAgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xuICAgKiBzdWNoIHRoYXRcbiAgICogICBwKDApID0geDAsIHAoMSkgPSB4MVxuICAgKiAgYW5kXG4gICAqICAgcCcoMCkgPSB0MCwgcCcoMSkgPSB0MS5cbiAgICovXG4gIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCB4MCwgeDEsIHQwLCB0MSApIHtcblxuICAgIHRoaXMuYzAgPSB4MDtcbiAgICB0aGlzLmMxID0gdDA7XG4gICAgdGhpcy5jMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XG4gICAgdGhpcy5jMyA9IDIgKiB4MCAtIDIgKiB4MSArIHQwICsgdDE7XG5cbiAgfTtcblxuICBDdWJpY1BvbHkucHJvdG90eXBlLmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uKCB4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0MiApIHtcblxuICAgIC8vIGNvbXB1dGUgdGFuZ2VudHMgd2hlbiBwYXJhbWV0ZXJpemVkIGluIFt0MSx0Ml1cbiAgICB2YXIgdDEgPSAoIHgxIC0geDAgKSAvIGR0MCAtICggeDIgLSB4MCApIC8gKCBkdDAgKyBkdDEgKSArICggeDIgLSB4MSApIC8gZHQxO1xuICAgIHZhciB0MiA9ICggeDIgLSB4MSApIC8gZHQxIC0gKCB4MyAtIHgxICkgLyAoIGR0MSArIGR0MiApICsgKCB4MyAtIHgyICkgLyBkdDI7XG5cbiAgICAvLyByZXNjYWxlIHRhbmdlbnRzIGZvciBwYXJhbWV0cml6YXRpb24gaW4gWzAsMV1cbiAgICB0MSAqPSBkdDE7XG4gICAgdDIgKj0gZHQxO1xuXG4gICAgLy8gaW5pdEN1YmljUG9seVxuICAgIHRoaXMuaW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcblxuICB9O1xuXG4gIC8vIHN0YW5kYXJkIENhdG11bGwtUm9tIHNwbGluZTogaW50ZXJwb2xhdGUgYmV0d2VlbiB4MSBhbmQgeDIgd2l0aCBwcmV2aW91cy9mb2xsb3dpbmcgcG9pbnRzIHgxL3g0XG4gIEN1YmljUG9seS5wcm90b3R5cGUuaW5pdENhdG11bGxSb20gPSBmdW5jdGlvbiggeDAsIHgxLCB4MiwgeDMsIHRlbnNpb24gKSB7XG5cbiAgICB0aGlzLmluaXQoIHgxLCB4MiwgdGVuc2lvbiAqICggeDIgLSB4MCApLCB0ZW5zaW9uICogKCB4MyAtIHgxICkgKTtcblxuICB9O1xuXG4gIEN1YmljUG9seS5wcm90b3R5cGUuY2FsYyA9IGZ1bmN0aW9uKCB0ICkge1xuXG4gICAgdmFyIHQyID0gdCAqIHQ7XG4gICAgdmFyIHQzID0gdDIgKiB0O1xuICAgIHJldHVybiB0aGlzLmMwICsgdGhpcy5jMSAqIHQgKyB0aGlzLmMyICogdDIgKyB0aGlzLmMzICogdDM7XG5cbiAgfTtcblxuICAvLyBTdWJjbGFzcyBUaHJlZS5qcyBjdXJ2ZVxuICByZXR1cm4gVEhSRUUuQ3VydmUuY3JlYXRlKFxuXG4gICAgZnVuY3Rpb24gKCBwIC8qIGFycmF5IG9mIFZlY3RvcjMgKi8gKSB7XG5cbiAgICAgIHRoaXMucG9pbnRzID0gcCB8fCBbXTtcblxuICAgIH0sXG5cbiAgICBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcbiAgICAgICAgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIGw7XG5cbiAgICAgIGwgPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICBpZiAoIGwgPCAyICkgY29uc29sZS5sb2coICdkdWgsIHlvdSBuZWVkIGF0IGxlYXN0IDIgcG9pbnRzJyApO1xuXG4gICAgICBwb2ludCA9ICggbCAtIDEgKSAqIHQ7XG4gICAgICBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XG4gICAgICB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgICBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XG5cbiAgICAgICAgaW50UG9pbnQgPSBsIC0gMjtcbiAgICAgICAgd2VpZ2h0ID0gMTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgcDAsIHAxLCBwMiwgcDM7XG5cbiAgICAgIGlmICggaW50UG9pbnQgPT09IDAgKSB7XG5cbiAgICAgICAgLy8gZXh0cmFwb2xhdGUgZmlyc3QgcG9pbnRcbiAgICAgICAgdG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgMCBdLCBwb2ludHNbIDEgXSApLmFkZCggcG9pbnRzWyAwIF0gKTtcbiAgICAgICAgcDAgPSB0bXA7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgcDAgPSBwb2ludHNbIGludFBvaW50IC0gMSBdO1xuXG4gICAgICB9XG5cbiAgICAgIHAxID0gcG9pbnRzWyBpbnRQb2ludCBdO1xuICAgICAgcDIgPSBwb2ludHNbIGludFBvaW50ICsgMSBdO1xuXG4gICAgICBpZiAoIGludFBvaW50ICsgMiA8IGwgKSB7XG5cbiAgICAgICAgcDMgPSBwb2ludHNbIGludFBvaW50ICsgMiBdXG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gZXh0cmFwb2xhdGUgbGFzdCBwb2ludFxuICAgICAgICB0bXAuc3ViVmVjdG9ycyggcG9pbnRzWyBsIC0gMSBdLCBwb2ludHNbIGwgLSAyIF0gKS5hZGQoIHBvaW50c1sgbCAtIDIgXSApO1xuICAgICAgICBwMyA9IHRtcDtcblxuICAgICAgfVxuXG4gICAgICBpZiAoIHRoaXMudHlwZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLnR5cGUgPT09ICdjaG9yZGFsJyApIHtcblxuICAgICAgICAvLyBpbml0IENlbnRyaXBldGFsIC8gQ2hvcmRhbCBDYXRtdWxsLVJvbVxuICAgICAgICB2YXIgcG93ID0gdGhpcy50eXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xuICAgICAgICB2YXIgZHQwID0gTWF0aC5wb3coIHAwLmRpc3RhbmNlVG9TcXVhcmVkKCBwMSApLCBwb3cgKTtcbiAgICAgICAgdmFyIGR0MSA9IE1hdGgucG93KCBwMS5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSwgcG93ICk7XG4gICAgICAgIHZhciBkdDIgPSBNYXRoLnBvdyggcDIuZGlzdGFuY2VUb1NxdWFyZWQoIHAzICksIHBvdyApO1xuXG4gICAgICAgIC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXG4gICAgICAgIGlmICggZHQxIDwgMWUtNCApIGR0MSA9IDEuMDtcbiAgICAgICAgaWYgKCBkdDAgPCAxZS00ICkgZHQwID0gZHQxO1xuICAgICAgICBpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XG5cbiAgICAgICAgcHguaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyICk7XG4gICAgICAgIHB5LmluaXROb251bmlmb3JtQ2F0bXVsbFJvbSggcDAueSwgcDEueSwgcDIueSwgcDMueSwgZHQwLCBkdDEsIGR0MiApO1xuICAgICAgICBwei5pbml0Tm9udW5pZm9ybUNhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIGR0MCwgZHQxLCBkdDIgKTtcblxuICAgICAgfSBlbHNlIGlmICggdGhpcy50eXBlID09PSAnY2F0bXVsbHJvbScgKSB7XG5cbiAgICAgICAgdmFyIHRlbnNpb24gPSB0aGlzLnRlbnNpb24gIT09IHVuZGVmaW5lZCA/IHRoaXMudGVuc2lvbiA6IDAuNTtcbiAgICAgICAgcHguaW5pdENhdG11bGxSb20oIHAwLngsIHAxLngsIHAyLngsIHAzLngsIHRlbnNpb24gKTtcbiAgICAgICAgcHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRlbnNpb24gKTtcbiAgICAgICAgcHouaW5pdENhdG11bGxSb20oIHAwLnosIHAxLnosIHAyLnosIHAzLnosIHRlbnNpb24gKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKFxuICAgICAgICBweC5jYWxjKCB3ZWlnaHQgKSxcbiAgICAgICAgcHkuY2FsYyggd2VpZ2h0ICksXG4gICAgICAgIHB6LmNhbGMoIHdlaWdodCApXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gdjtcblxuICAgIH1cblxuICApO1xuXG59ICkoKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2N1cnZlcy9DbG9zZWRTcGxpbmVDdXJ2ZTMuanNcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiAgQ2xvc2VkIFNwbGluZSAzRCBjdXJ2ZVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cblRIUkVFLkNsb3NlZFNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcblxuICBmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovKSB7XG5cbiAgICB0aGlzLnBvaW50cyA9ICggcG9pbnRzID09IHVuZGVmaW5lZCApID8gW10gOiBwb2ludHM7XG5cbiAgfSxcblxuICBmdW5jdGlvbiAoIHQgKSB7XG5cbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgdmFyIHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMCApICogdDsgLy8gVGhpcyBuZWVkcyB0byBiZSBmcm9tIDAtbGVuZ3RoICsxXG5cbiAgICB2YXIgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xuICAgIHZhciB3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xuXG4gICAgaW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xuXG4gICAgdmFyIHBvaW50MCA9IHBvaW50c1sgKCBpbnRQb2ludCAtIDEgKSAlIHBvaW50cy5sZW5ndGggXTtcbiAgICB2YXIgcG9pbnQxID0gcG9pbnRzWyAoIGludFBvaW50ICAgICApICUgcG9pbnRzLmxlbmd0aCBdO1xuICAgIHZhciBwb2ludDIgPSBwb2ludHNbICggaW50UG9pbnQgKyAxICkgJSBwb2ludHMubGVuZ3RoIF07XG4gICAgdmFyIHBvaW50MyA9IHBvaW50c1sgKCBpbnRQb2ludCArIDIgKSAlIHBvaW50cy5sZW5ndGggXTtcblxuICAgIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gICAgdmVjdG9yLnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnQwLngsIHBvaW50MS54LCBwb2ludDIueCwgcG9pbnQzLngsIHdlaWdodCApO1xuICAgIHZlY3Rvci55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50MC55LCBwb2ludDEueSwgcG9pbnQyLnksIHBvaW50My55LCB3ZWlnaHQgKTtcbiAgICB2ZWN0b3IueiA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKCBwb2ludDAueiwgcG9pbnQxLnosIHBvaW50Mi56LCBwb2ludDMueiwgd2VpZ2h0ICk7XG5cbiAgICByZXR1cm4gdmVjdG9yO1xuXG4gIH1cblxuKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9BbmltYXRpb25IYW5kbGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cbiAqL1xuXG5USFJFRS5BbmltYXRpb25IYW5kbGVyID0ge1xuXG4gIExJTkVBUjogMCxcbiAgQ0FUTVVMTFJPTTogMSxcbiAgQ0FUTVVMTFJPTV9GT1JXQVJEOiAyLFxuXG4gIC8vXG5cbiAgYWRkOiBmdW5jdGlvbiAoKSB7IGNvbnNvbGUud2FybiggJ1RIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkKCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4nICk7IH0sXG4gIGdldDogZnVuY3Rpb24gKCkgeyBjb25zb2xlLndhcm4oICdUSFJFRS5BbmltYXRpb25IYW5kbGVyLmdldCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuJyApOyB9LFxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHsgY29uc29sZS53YXJuKCAnVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5yZW1vdmUoKSBoYXMgYmVlbiBkZXByZWNhdGVkLicgKTsgfSxcblxuICAvL1xuXG4gIGFuaW1hdGlvbnM6IFtdLFxuXG4gIGluaXQ6IGZ1bmN0aW9uICggZGF0YSApIHtcblxuICAgIGlmICggZGF0YS5pbml0aWFsaXplZCA9PT0gdHJ1ZSApIHJldHVybiBkYXRhO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBrZXlzXG5cbiAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCBkYXRhLmhpZXJhcmNoeS5sZW5ndGg7IGggKysgKSB7XG5cbiAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG1pbnVzIHRpbWVzXG5cbiAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lIDwgMCApIHtcblxuICAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID0gMDtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHF1YXRlcm5pb25zXG5cbiAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICEgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgaW5zdGFuY2VvZiBUSFJFRS5RdWF0ZXJuaW9uICkgKSB7XG5cbiAgICAgICAgICB2YXIgcXVhdCA9IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnJvdDtcbiAgICAgICAgICBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpLmZyb21BcnJheSggcXVhdCApO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICAvLyBwcmVwYXJlIG1vcnBoIHRhcmdldCBrZXlzXG5cbiAgICAgIGlmICggZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aCAmJiBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXS5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAvLyBnZXQgYWxsIHVzZWRcblxuICAgICAgICB2YXIgdXNlZE1vcnBoVGFyZ2V0cyA9IHt9O1xuXG4gICAgICAgIGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICAgICAgICBmb3IgKCB2YXIgbSA9IDA7IG0gPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xuXG4gICAgICAgICAgICB2YXIgbW9ycGhUYXJnZXROYW1lID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF07XG4gICAgICAgICAgICB1c2VkTW9ycGhUYXJnZXRzWyBtb3JwaFRhcmdldE5hbWUgXSA9IC0gMTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5oaWVyYXJjaHlbIGggXS51c2VkTW9ycGhUYXJnZXRzID0gdXNlZE1vcnBoVGFyZ2V0cztcblxuXG4gICAgICAgIC8vIHNldCBhbGwgdXNlZCBvbiBhbGwgZnJhbWVzXG5cbiAgICAgICAgZm9yICggdmFyIGsgPSAwOyBrIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzLmxlbmd0aDsgayArKyApIHtcblxuICAgICAgICAgIHZhciBpbmZsdWVuY2VzID0ge307XG5cbiAgICAgICAgICBmb3IgKCB2YXIgbW9ycGhUYXJnZXROYW1lIGluIHVzZWRNb3JwaFRhcmdldHMgKSB7XG5cbiAgICAgICAgICAgIGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XG5cbiAgICAgICAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXSA9PT0gbW9ycGhUYXJnZXROYW1lICkge1xuXG4gICAgICAgICAgICAgICAgaW5mbHVlbmNlc1sgbW9ycGhUYXJnZXROYW1lIF0gPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNJbmZsdWVuY2VzWyBtIF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggbSA9PT0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aCApIHtcblxuICAgICAgICAgICAgICBpbmZsdWVuY2VzWyBtb3JwaFRhcmdldE5hbWUgXSA9IDA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0c0luZmx1ZW5jZXMgPSBpbmZsdWVuY2VzO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG5cbiAgICAgIC8vIHJlbW92ZSBhbGwga2V5cyB0aGF0IGFyZSBvbiB0aGUgc2FtZSB0aW1lXG5cbiAgICAgIGZvciAoIHZhciBrID0gMTsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XG5cbiAgICAgICAgaWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS50aW1lID09PSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgLSAxIF0udGltZSApIHtcblxuICAgICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5zcGxpY2UoIGssIDEgKTtcbiAgICAgICAgICBrIC0tO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG5cbiAgICAgIC8vIHNldCBpbmRleFxuXG4gICAgICBmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xuXG4gICAgICAgIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLmluZGV4ID0gaztcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZGF0YS5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICByZXR1cm4gZGF0YTtcblxuICB9LFxuXG4gIHBhcnNlOiBmdW5jdGlvbiAoIHJvb3QgKSB7XG5cbiAgICB2YXIgcGFyc2VSZWN1cnNlSGllcmFyY2h5ID0gZnVuY3Rpb24gKCByb290LCBoaWVyYXJjaHkgKSB7XG5cbiAgICAgIGhpZXJhcmNoeS5wdXNoKCByb290ICk7XG5cbiAgICAgIGZvciAoIHZhciBjID0gMDsgYyA8IHJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBjICsrIClcbiAgICAgICAgcGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LmNoaWxkcmVuWyBjIF0sIGhpZXJhcmNoeSApO1xuXG4gICAgfTtcblxuICAgIC8vIHNldHVwIGhpZXJhcmNoeVxuXG4gICAgdmFyIGhpZXJhcmNoeSA9IFtdO1xuXG4gICAgaWYgKCByb290IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XG5cbiAgICAgIGZvciAoIHZhciBiID0gMDsgYiA8IHJvb3Quc2tlbGV0b24uYm9uZXMubGVuZ3RoOyBiICsrICkge1xuXG4gICAgICAgIGhpZXJhcmNoeS5wdXNoKCByb290LnNrZWxldG9uLmJvbmVzWyBiIF0gKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LCBoaWVyYXJjaHkgKTtcblxuICAgIH1cblxuICAgIHJldHVybiBoaWVyYXJjaHk7XG5cbiAgfSxcblxuICBwbGF5OiBmdW5jdGlvbiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGlmICggdGhpcy5hbmltYXRpb25zLmluZGV4T2YoIGFuaW1hdGlvbiApID09PSAtIDEgKSB7XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKCBhbmltYXRpb24gKTtcblxuICAgIH1cblxuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICggYW5pbWF0aW9uICkge1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5hbmltYXRpb25zLmluZGV4T2YoIGFuaW1hdGlvbiApO1xuXG4gICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuXG4gICAgICB0aGlzLmFuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXG4gICAgfVxuXG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoIGRlbHRhVGltZU1TICkge1xuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSArKyApIHtcblxuICAgICAgdGhpcy5hbmltYXRpb25zWyBpIF0ucmVzZXRCbGVuZFdlaWdodHMoICk7XG5cbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xuXG4gICAgICB0aGlzLmFuaW1hdGlvbnNbIGkgXS51cGRhdGUoIGRlbHRhVGltZU1TICk7XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL0FuaW1hdGlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqL1xuXG5USFJFRS5BbmltYXRpb24gPSBmdW5jdGlvbiAoIHJvb3QsIGRhdGEgKSB7XG5cbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5kYXRhID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5pbml0KCBkYXRhICk7XG4gIHRoaXMuaGllcmFyY2h5ID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZSggcm9vdCApO1xuXG4gIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICB0aGlzLnRpbWVTY2FsZSA9IDE7XG5cbiAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgdGhpcy53ZWlnaHQgPSAwO1xuXG4gIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUjtcblxufTtcblxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuQW5pbWF0aW9uLFxuXG4gIGtleVR5cGVzOiAgWyBcInBvc1wiLCBcInJvdFwiLCBcInNjbFwiIF0sXG5cbiAgcGxheTogZnVuY3Rpb24gKCBzdGFydFRpbWUsIHdlaWdodCApIHtcblxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWUgIT09IHVuZGVmaW5lZCA/IHN0YXJ0VGltZSA6IDA7XG4gICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQgIT09IHVuZGVmaW5lZCA/IHdlaWdodCA6IDE7XG5cbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkoIHRoaXMgKTtcblxuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcblxuICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG4gIH0sXG5cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG5cbiAgICAgIGlmICggb2JqZWN0LmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgb2JqZWN0LmFuaW1hdGlvbkNhY2hlID0ge1xuICAgICAgICAgIGFuaW1hdGlvbnM6IHt9LFxuICAgICAgICAgIGJsZW5kaW5nOiB7XG4gICAgICAgICAgICBwb3NpdGlvbldlaWdodDogMC4wLFxuICAgICAgICAgICAgcXVhdGVybmlvbldlaWdodDogMC4wLFxuICAgICAgICAgICAgc2NhbGVXZWlnaHQ6IDAuMFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSB0aGlzLmRhdGEubmFtZTtcbiAgICAgIHZhciBhbmltYXRpb25zID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlLmFuaW1hdGlvbnM7XG4gICAgICB2YXIgYW5pbWF0aW9uQ2FjaGUgPSBhbmltYXRpb25zWyBuYW1lIF07XG5cbiAgICAgIGlmICggYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICBhbmltYXRpb25DYWNoZSA9IHtcbiAgICAgICAgICBwcmV2S2V5OiB7IHBvczogMCwgcm90OiAwLCBzY2w6IDAgfSxcbiAgICAgICAgICBuZXh0S2V5OiB7IHBvczogMCwgcm90OiAwLCBzY2w6IDAgfSxcbiAgICAgICAgICBvcmlnaW5hbE1hdHJpeDogb2JqZWN0Lm1hdHJpeFxuICAgICAgICB9O1xuXG4gICAgICAgIGFuaW1hdGlvbnNbIG5hbWUgXSA9IGFuaW1hdGlvbkNhY2hlO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBrZXlzIHRvIG1hdGNoIG91ciBjdXJyZW50IHRpbWVcblxuICAgICAgZm9yICggdmFyIHQgPSAwOyB0IDwgMzsgdCArKyApIHtcblxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMua2V5VHlwZXNbIHQgXTtcblxuICAgICAgICB2YXIgcHJldktleSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XG4gICAgICAgIHZhciBuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgMSApO1xuXG4gICAgICAgIHdoaWxlICggbmV4dEtleS50aW1lIDwgdGhpcy5jdXJyZW50VGltZSAmJiBuZXh0S2V5LmluZGV4ID4gcHJldktleS5pbmRleCApIHtcblxuICAgICAgICAgIHByZXZLZXkgPSBuZXh0S2V5O1xuICAgICAgICAgIG5leHRLZXkgPSB0aGlzLmdldE5leHRLZXlXaXRoKCB0eXBlLCBoLCBuZXh0S2V5LmluZGV4ICsgMSApO1xuXG4gICAgICAgIH1cblxuICAgICAgICBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF0gPSBwcmV2S2V5O1xuICAgICAgICBhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF0gPSBuZXh0S2V5O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfSxcblxuICByZXNldEJsZW5kV2VpZ2h0czogZnVuY3Rpb24gKCkge1xuXG4gICAgZm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICB2YXIgb2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcbiAgICAgIHZhciBhbmltYXRpb25DYWNoZSA9IG9iamVjdC5hbmltYXRpb25DYWNoZTtcblxuICAgICAgaWYgKCBhbmltYXRpb25DYWNoZSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHZhciBibGVuZGluZyA9IGFuaW1hdGlvbkNhY2hlLmJsZW5kaW5nO1xuXG4gICAgICAgIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ID0gMC4wO1xuICAgICAgICBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID0gMC4wO1xuICAgICAgICBibGVuZGluZy5zY2FsZVdlaWdodCA9IDAuMDtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0sXG5cbiAgdXBkYXRlOiAoIGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIHZhciB0YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBuZXdWZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHZhciBuZXdRdWF0ID0gbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcblxuICAgIC8vIENhdG11bGwtUm9tIHNwbGluZVxuXG4gICAgdmFyIGludGVycG9sYXRlQ2F0bXVsbFJvbSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzY2FsZSApIHtcblxuICAgICAgdmFyIGMgPSBbXSwgdjMgPSBbXSxcbiAgICAgIHBvaW50LCBpbnRQb2ludCwgd2VpZ2h0LCB3MiwgdzMsXG4gICAgICBwYSwgcGIsIHBjLCBwZDtcblxuICAgICAgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiBzY2FsZTtcbiAgICAgIGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcbiAgICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XG5cbiAgICAgIGNbIDAgXSA9IGludFBvaW50ID09PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XG4gICAgICBjWyAxIF0gPSBpbnRQb2ludDtcbiAgICAgIGNbIDIgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMTtcbiAgICAgIGNbIDMgXSA9IGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDMgPyBpbnRQb2ludCA6IGludFBvaW50ICsgMjtcblxuICAgICAgcGEgPSBwb2ludHNbIGNbIDAgXSBdO1xuICAgICAgcGIgPSBwb2ludHNbIGNbIDEgXSBdO1xuICAgICAgcGMgPSBwb2ludHNbIGNbIDIgXSBdO1xuICAgICAgcGQgPSBwb2ludHNbIGNbIDMgXSBdO1xuXG4gICAgICB3MiA9IHdlaWdodCAqIHdlaWdodDtcbiAgICAgIHczID0gd2VpZ2h0ICogdzI7XG5cbiAgICAgIHYzWyAwIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDAgXSwgcGJbIDAgXSwgcGNbIDAgXSwgcGRbIDAgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICAgIHYzWyAxIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDEgXSwgcGJbIDEgXSwgcGNbIDEgXSwgcGRbIDEgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcbiAgICAgIHYzWyAyIF0gPSBpbnRlcnBvbGF0ZSggcGFbIDIgXSwgcGJbIDIgXSwgcGNbIDIgXSwgcGRbIDIgXSwgd2VpZ2h0LCB3MiwgdzMgKTtcblxuICAgICAgcmV0dXJuIHYzO1xuXG4gICAgfTtcblxuICAgIHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcblxuICAgICAgdmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXG4gICAgICAgIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XG5cbiAgICAgIHJldHVybiAoIDIgKiAoIHAxIC0gcDIgKSArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiAoIHAxIC0gcDIgKSAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xuXG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG4gICAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuICAgICAgdGhpcy5jdXJyZW50VGltZSArPSBkZWx0YSAqIHRoaXMudGltZVNjYWxlO1xuXG4gICAgICBpZiAoIHRoaXMud2VpZ2h0ID09PSAwIClcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICAvL1xuXG4gICAgICB2YXIgZHVyYXRpb24gPSB0aGlzLmRhdGEubGVuZ3RoO1xuXG4gICAgICBpZiAoIHRoaXMuY3VycmVudFRpbWUgPiBkdXJhdGlvbiB8fCB0aGlzLmN1cnJlbnRUaW1lIDwgMCApIHtcblxuICAgICAgICBpZiAoIHRoaXMubG9vcCApIHtcblxuICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgJT0gZHVyYXRpb247XG5cbiAgICAgICAgICBpZiAoIHRoaXMuY3VycmVudFRpbWUgPCAwIClcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgKz0gZHVyYXRpb247XG5cbiAgICAgICAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICAgIHZhciBhbmltYXRpb25DYWNoZSA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5hbmltYXRpb25zW3RoaXMuZGF0YS5uYW1lXTtcbiAgICAgICAgdmFyIGJsZW5kaW5nID0gb2JqZWN0LmFuaW1hdGlvbkNhY2hlLmJsZW5kaW5nO1xuXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBwb3Mvcm90L3NjbFxuXG4gICAgICAgIGZvciAoIHZhciB0ID0gMDsgdCA8IDM7IHQgKysgKSB7XG5cbiAgICAgICAgICAvLyBnZXQga2V5c1xuXG4gICAgICAgICAgdmFyIHR5cGUgICAgPSB0aGlzLmtleVR5cGVzWyB0IF07XG4gICAgICAgICAgdmFyIHByZXZLZXkgPSBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF07XG4gICAgICAgICAgdmFyIG5leHRLZXkgPSBhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF07XG5cbiAgICAgICAgICBpZiAoICggdGhpcy50aW1lU2NhbGUgPiAwICYmIG5leHRLZXkudGltZSA8PSB0aGlzLmN1cnJlbnRUaW1lICkgfHxcbiAgICAgICAgICAgICggdGhpcy50aW1lU2NhbGUgPCAwICYmIHByZXZLZXkudGltZSA+PSB0aGlzLmN1cnJlbnRUaW1lICkgKSB7XG5cbiAgICAgICAgICAgIHByZXZLZXkgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xuICAgICAgICAgICAgbmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIDEgKTtcblxuICAgICAgICAgICAgd2hpbGUgKCBuZXh0S2V5LnRpbWUgPCB0aGlzLmN1cnJlbnRUaW1lICYmIG5leHRLZXkuaW5kZXggPiBwcmV2S2V5LmluZGV4ICkge1xuXG4gICAgICAgICAgICAgIHByZXZLZXkgPSBuZXh0S2V5O1xuICAgICAgICAgICAgICBuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgbmV4dEtleS5pbmRleCArIDEgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhbmltYXRpb25DYWNoZS5wcmV2S2V5WyB0eXBlIF0gPSBwcmV2S2V5O1xuICAgICAgICAgICAgYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdID0gbmV4dEtleTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzY2FsZSA9ICggdGhpcy5jdXJyZW50VGltZSAtIHByZXZLZXkudGltZSApIC8gKCBuZXh0S2V5LnRpbWUgLSBwcmV2S2V5LnRpbWUgKTtcblxuICAgICAgICAgIHZhciBwcmV2WFlaID0gcHJldktleVsgdHlwZSBdO1xuICAgICAgICAgIHZhciBuZXh0WFlaID0gbmV4dEtleVsgdHlwZSBdO1xuXG4gICAgICAgICAgaWYgKCBzY2FsZSA8IDAgKSBzY2FsZSA9IDA7XG4gICAgICAgICAgaWYgKCBzY2FsZSA+IDEgKSBzY2FsZSA9IDE7XG5cbiAgICAgICAgICAvLyBpbnRlcnBvbGF0ZVxuXG4gICAgICAgICAgaWYgKCB0eXBlID09PSBcInBvc1wiICkge1xuXG4gICAgICAgICAgICBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSICkge1xuXG4gICAgICAgICAgICAgIG5ld1ZlY3Rvci54ID0gcHJldlhZWlsgMCBdICsgKCBuZXh0WFlaWyAwIF0gLSBwcmV2WFlaWyAwIF0gKSAqIHNjYWxlO1xuICAgICAgICAgICAgICBuZXdWZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgICAgbmV3VmVjdG9yLnogPSBwcmV2WFlaWyAyIF0gKyAoIG5leHRYWVpbIDIgXSAtIHByZXZYWVpbIDIgXSApICogc2NhbGU7XG5cbiAgICAgICAgICAgICAgLy8gYmxlbmRcbiAgICAgICAgICAgICAgdmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnBvc2l0aW9uV2VpZ2h0ICk7XG4gICAgICAgICAgICAgIG9iamVjdC5wb3NpdGlvbi5sZXJwKCBuZXdWZWN0b3IsIHByb3BvcnRpb25hbFdlaWdodCApO1xuICAgICAgICAgICAgICBibGVuZGluZy5wb3NpdGlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuICAgICAgICAgICAgICBwb2ludHNbIDAgXSA9IHRoaXMuZ2V0UHJldktleVdpdGgoIFwicG9zXCIsIGgsIHByZXZLZXkuaW5kZXggLSAxIClbIFwicG9zXCIgXTtcbiAgICAgICAgICAgICAgcG9pbnRzWyAxIF0gPSBwcmV2WFlaO1xuICAgICAgICAgICAgICBwb2ludHNbIDIgXSA9IG5leHRYWVo7XG4gICAgICAgICAgICAgIHBvaW50c1sgMyBdID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJwb3NcIiwgaCwgbmV4dEtleS5pbmRleCArIDEgKVsgXCJwb3NcIiBdO1xuXG4gICAgICAgICAgICAgIHNjYWxlID0gc2NhbGUgKiAwLjMzICsgMC4zMztcblxuICAgICAgICAgICAgICB2YXIgY3VycmVudFBvaW50ID0gaW50ZXJwb2xhdGVDYXRtdWxsUm9tKCBwb2ludHMsIHNjYWxlICk7XG4gICAgICAgICAgICAgIHZhciBwcm9wb3J0aW9uYWxXZWlnaHQgPSB0aGlzLndlaWdodCAvICggdGhpcy53ZWlnaHQgKyBibGVuZGluZy5wb3NpdGlvbldlaWdodCApO1xuICAgICAgICAgICAgICBibGVuZGluZy5wb3NpdGlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgICAvLyBibGVuZFxuXG4gICAgICAgICAgICAgIHZhciB2ZWN0b3IgPSBvYmplY3QucG9zaXRpb247XG5cbiAgICAgICAgICAgICAgdmVjdG9yLnggPSB2ZWN0b3IueCArICggY3VycmVudFBvaW50WyAwIF0gLSB2ZWN0b3IueCApICogcHJvcG9ydGlvbmFsV2VpZ2h0O1xuICAgICAgICAgICAgICB2ZWN0b3IueSA9IHZlY3Rvci55ICsgKCBjdXJyZW50UG9pbnRbIDEgXSAtIHZlY3Rvci55ICkgKiBwcm9wb3J0aW9uYWxXZWlnaHQ7XG4gICAgICAgICAgICAgIHZlY3Rvci56ID0gdmVjdG9yLnogKyAoIGN1cnJlbnRQb2ludFsgMiBdIC0gdmVjdG9yLnogKSAqIHByb3BvcnRpb25hbFdlaWdodDtcblxuICAgICAgICAgICAgICBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGZvcndhcmRQb2ludCA9IGludGVycG9sYXRlQ2F0bXVsbFJvbSggcG9pbnRzLCBzY2FsZSAqIDEuMDEgKTtcblxuICAgICAgICAgICAgICAgIHRhcmdldC5zZXQoIGZvcndhcmRQb2ludFsgMCBdLCBmb3J3YXJkUG9pbnRbIDEgXSwgZm9yd2FyZFBvaW50WyAyIF0gKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc3ViKCB2ZWN0b3IgKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQueSA9IDA7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMiggdGFyZ2V0LngsIHRhcmdldC56ICk7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnJvdGF0aW9uLnNldCggMCwgYW5nbGUsIDAgKTtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoIHR5cGUgPT09IFwicm90XCIgKSB7XG5cbiAgICAgICAgICAgIFRIUkVFLlF1YXRlcm5pb24uc2xlcnAoIHByZXZYWVosIG5leHRYWVosIG5ld1F1YXQsIHNjYWxlICk7XG5cbiAgICAgICAgICAgIC8vIEF2b2lkIHBheWluZyB0aGUgY29zdCBvZiBhbiBhZGRpdGlvbmFsIHNsZXJwIGlmIHdlIGRvbid0IGhhdmUgdG9cbiAgICAgICAgICAgIGlmICggYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCA9PT0gMCApIHtcblxuICAgICAgICAgICAgICBvYmplY3QucXVhdGVybmlvbi5jb3B5KG5ld1F1YXQpO1xuICAgICAgICAgICAgICBibGVuZGluZy5xdWF0ZXJuaW9uV2VpZ2h0ID0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgdmFyIHByb3BvcnRpb25hbFdlaWdodCA9IHRoaXMud2VpZ2h0IC8gKCB0aGlzLndlaWdodCArIGJsZW5kaW5nLnF1YXRlcm5pb25XZWlnaHQgKTtcbiAgICAgICAgICAgICAgVEhSRUUuUXVhdGVybmlvbi5zbGVycCggb2JqZWN0LnF1YXRlcm5pb24sIG5ld1F1YXQsIG9iamVjdC5xdWF0ZXJuaW9uLCBwcm9wb3J0aW9uYWxXZWlnaHQgKTtcbiAgICAgICAgICAgICAgYmxlbmRpbmcucXVhdGVybmlvbldlaWdodCArPSB0aGlzLndlaWdodDtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmICggdHlwZSA9PT0gXCJzY2xcIiApIHtcblxuICAgICAgICAgICAgbmV3VmVjdG9yLnggPSBwcmV2WFlaWyAwIF0gKyAoIG5leHRYWVpbIDAgXSAtIHByZXZYWVpbIDAgXSApICogc2NhbGU7XG4gICAgICAgICAgICBuZXdWZWN0b3IueSA9IHByZXZYWVpbIDEgXSArICggbmV4dFhZWlsgMSBdIC0gcHJldlhZWlsgMSBdICkgKiBzY2FsZTtcbiAgICAgICAgICAgIG5ld1ZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xuXG4gICAgICAgICAgICB2YXIgcHJvcG9ydGlvbmFsV2VpZ2h0ID0gdGhpcy53ZWlnaHQgLyAoIHRoaXMud2VpZ2h0ICsgYmxlbmRpbmcuc2NhbGVXZWlnaHQgKTtcbiAgICAgICAgICAgIG9iamVjdC5zY2FsZS5sZXJwKCBuZXdWZWN0b3IsIHByb3BvcnRpb25hbFdlaWdodCApO1xuICAgICAgICAgICAgYmxlbmRpbmcuc2NhbGVXZWlnaHQgKz0gdGhpcy53ZWlnaHQ7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgfTtcblxuICB9ICkoKSxcblxuICBnZXROZXh0S2V5V2l0aDogZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG4gICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcbiAgICAgICB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcblxuICAgICAga2V5ID0ga2V5IDwga2V5cy5sZW5ndGggLSAxID8ga2V5IDoga2V5cy5sZW5ndGggLSAxO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAga2V5ID0ga2V5ICUga2V5cy5sZW5ndGg7XG5cbiAgICB9XG5cbiAgICBmb3IgKCA7IGtleSA8IGtleXMubGVuZ3RoOyBrZXkgKysgKSB7XG5cbiAgICAgIGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgIHJldHVybiBrZXlzWyBrZXkgXTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XG5cbiAgfSxcblxuICBnZXRQcmV2S2V5V2l0aDogZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xuXG4gICAgaWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcbiAgICAgIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTV9GT1JXQVJEICkge1xuXG4gICAgICBrZXkgPSBrZXkgPiAwID8ga2V5IDogMDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGtleSA9IGtleSA+PSAwID8ga2V5IDoga2V5ICsga2V5cy5sZW5ndGg7XG5cbiAgICB9XG5cblxuICAgIGZvciAoIDsga2V5ID49IDA7IGtleSAtLSApIHtcblxuICAgICAgaWYgKCBrZXlzWyBrZXkgXVsgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xuXG4gIH1cblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2FuaW1hdGlvbi9LZXlGcmFtZUFuaW1hdGlvbi5qc1xuXG4vKipcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3Iga2hhbmcgZHVvbmdcbiAqIEBhdXRob3IgZXJpayBraXRzb25cbiAqL1xuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggZGF0YSApIHtcblxuICB0aGlzLnJvb3QgPSBkYXRhLm5vZGU7XG4gIHRoaXMuZGF0YSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuaW5pdCggZGF0YSApO1xuICB0aGlzLmhpZXJhcmNoeSA9IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucGFyc2UoIHRoaXMucm9vdCApO1xuICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgdGhpcy50aW1lU2NhbGUgPSAwLjAwMTtcbiAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gIHRoaXMubG9vcCA9IHRydWU7XG5cbiAgLy8gaW5pdGlhbGl6ZSB0byBmaXJzdCBrZXlmcmFtZXNcblxuICBmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICB2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ua2V5cyxcbiAgICAgIHNpZHMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLnNpZHMsXG4gICAgICBvYmogPSB0aGlzLmhpZXJhcmNoeVtoXTtcblxuICAgIGlmICgga2V5cy5sZW5ndGggJiYgc2lkcyApIHtcblxuICAgICAgZm9yICggdmFyIHMgPSAwOyBzIDwgc2lkcy5sZW5ndGg7IHMgKysgKSB7XG5cbiAgICAgICAgdmFyIHNpZCA9IHNpZHNbIHMgXSxcbiAgICAgICAgICBuZXh0ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggc2lkLCBoLCAwICk7XG5cbiAgICAgICAgaWYgKCBuZXh0ICkge1xuXG4gICAgICAgICAgbmV4dC5hcHBseSggc2lkICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIG9iai5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgICB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLm5vZGUudXBkYXRlTWF0cml4KCk7XG4gICAgICBvYmoubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB9XG5cbiAgfVxuXG59O1xuXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IFRIUkVFLktleUZyYW1lQW5pbWF0aW9uLFxuXG4gIHBsYXk6IGZ1bmN0aW9uICggc3RhcnRUaW1lICkge1xuXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IHN0YXJ0VGltZSAhPT0gdW5kZWZpbmVkID8gc3RhcnRUaW1lIDogMDtcblxuICAgIGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkge1xuXG4gICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG5cbiAgICAgIC8vIHJlc2V0IGtleSBjYWNoZVxuXG4gICAgICB2YXIgaCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGgsXG4gICAgICAgIG9iamVjdCxcbiAgICAgICAgbm9kZTtcblxuICAgICAgZm9yICggaCA9IDA7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgICBvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xuICAgICAgICBub2RlID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdO1xuXG4gICAgICAgIGlmICggbm9kZS5hbmltYXRpb25DYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZSA9IHt9O1xuICAgICAgICAgIG5vZGUuYW5pbWF0aW9uQ2FjaGUucHJldktleSA9IG51bGw7XG4gICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5uZXh0S2V5ID0gbnVsbDtcbiAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4ID0gb2JqZWN0Lm1hdHJpeDtcblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLmtleXM7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG5cbiAgICAgICAgICBub2RlLmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBrZXlzWyAwIF07XG4gICAgICAgICAgbm9kZS5hbmltYXRpb25DYWNoZS5uZXh0S2V5ID0ga2V5c1sgMSBdO1xuXG4gICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbigga2V5c1swXS50aW1lLCB0aGlzLnN0YXJ0VGltZSApO1xuICAgICAgICAgIHRoaXMuZW5kVGltZSA9IE1hdGgubWF4KCBrZXlzW2tleXMubGVuZ3RoIC0gMV0udGltZSwgdGhpcy5lbmRUaW1lICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMudXBkYXRlKCAwICk7XG5cbiAgICB9XG5cbiAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICBUSFJFRS5BbmltYXRpb25IYW5kbGVyLnBsYXkoIHRoaXMgKTtcblxuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc1BhdXNlZCAgPSBmYWxzZTtcblxuICAgIFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuc3RvcCggdGhpcyApO1xuXG4gICAgLy8gcmVzZXQgSklUIG1hdHJpeCBhbmQgcmVtb3ZlIGNhY2hlXG5cbiAgICBmb3IgKCB2YXIgaCA9IDA7IGggPCB0aGlzLmRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCArKyApIHtcblxuICAgICAgdmFyIG9iaiA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuICAgICAgaWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlICE9PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gbm9kZS5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeDtcblxuICAgICAgICBvcmlnaW5hbC5jb3B5KCBvYmoubWF0cml4ICk7XG4gICAgICAgIG9iai5tYXRyaXggPSBvcmlnaW5hbDtcblxuICAgICAgICBkZWxldGUgbm9kZS5hbmltYXRpb25DYWNoZTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG4gICAgaWYgKCB0aGlzLmlzUGxheWluZyA9PT0gZmFsc2UgKSByZXR1cm47XG5cbiAgICB0aGlzLmN1cnJlbnRUaW1lICs9IGRlbHRhICogdGhpcy50aW1lU2NhbGU7XG5cbiAgICAvL1xuXG4gICAgdmFyIGR1cmF0aW9uID0gdGhpcy5kYXRhLmxlbmd0aDtcblxuICAgIGlmICggdGhpcy5sb29wID09PSB0cnVlICYmIHRoaXMuY3VycmVudFRpbWUgPiBkdXJhdGlvbiApIHtcblxuICAgICAgdGhpcy5jdXJyZW50VGltZSAlPSBkdXJhdGlvbjtcblxuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBNYXRoLm1pbiggdGhpcy5jdXJyZW50VGltZSwgZHVyYXRpb24gKTtcblxuICAgIGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgdmFyIG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcblxuICAgICAgdmFyIGtleXMgPSBub2RlLmtleXMsXG4gICAgICAgIGFuaW1hdGlvbkNhY2hlID0gbm9kZS5hbmltYXRpb25DYWNoZTtcblxuXG4gICAgICBpZiAoIGtleXMubGVuZ3RoICkge1xuXG4gICAgICAgIHZhciBwcmV2S2V5ID0gYW5pbWF0aW9uQ2FjaGUucHJldktleTtcbiAgICAgICAgdmFyIG5leHRLZXkgPSBhbmltYXRpb25DYWNoZS5uZXh0S2V5O1xuXG4gICAgICAgIGlmICggbmV4dEtleS50aW1lIDw9IHRoaXMuY3VycmVudFRpbWUgKSB7XG5cbiAgICAgICAgICB3aGlsZSAoIG5leHRLZXkudGltZSA8IHRoaXMuY3VycmVudFRpbWUgJiYgbmV4dEtleS5pbmRleCA+IHByZXZLZXkuaW5kZXggKSB7XG5cbiAgICAgICAgICAgIHByZXZLZXkgPSBuZXh0S2V5O1xuICAgICAgICAgICAgbmV4dEtleSA9IGtleXNbIHByZXZLZXkuaW5kZXggKyAxIF07XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmltYXRpb25DYWNoZS5wcmV2S2V5ID0gcHJldktleTtcbiAgICAgICAgICBhbmltYXRpb25DYWNoZS5uZXh0S2V5ID0gbmV4dEtleTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCBuZXh0S2V5LnRpbWUgPj0gdGhpcy5jdXJyZW50VGltZSApIHtcblxuICAgICAgICAgIHByZXZLZXkuaW50ZXJwb2xhdGUoIG5leHRLZXksIHRoaXMuY3VycmVudFRpbWUgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgcHJldktleS5pbnRlcnBvbGF0ZSggbmV4dEtleSwgbmV4dEtleS50aW1lICk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5ub2RlLnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgICBvYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9LFxuXG4gIGdldE5leHRLZXlXaXRoOiBmdW5jdGlvbiAoIHNpZCwgaCwga2V5ICkge1xuXG4gICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcbiAgICBrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSArKyApIHtcblxuICAgICAgaWYgKCBrZXlzWyBrZXkgXS5oYXNUYXJnZXQoIHNpZCApICkge1xuXG4gICAgICAgIHJldHVybiBrZXlzWyBrZXkgXTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXNbIDAgXTtcblxuICB9LFxuXG4gIGdldFByZXZLZXlXaXRoOiBmdW5jdGlvbiAoIHNpZCwgaCwga2V5ICkge1xuXG4gICAgdmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcbiAgICBrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xuXG4gICAgZm9yICggOyBrZXkgPj0gMDsga2V5IC0tICkge1xuXG4gICAgICBpZiAoIGtleXNbIGtleSBdLmhhc1RhcmdldCggc2lkICkgKSB7XG5cbiAgICAgICAgcmV0dXJuIGtleXNbIGtleSBdO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5c1sga2V5cy5sZW5ndGggLSAxIF07XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvYW5pbWF0aW9uL01vcnBoQW5pbWF0aW9uLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbVxuICogQGF1dGhvciB3aWxseS12dnUgLyBodHRwOi8vd2lsbHktdnZ1LmdpdGh1Yi5pb1xuICovXG5cblRIUkVFLk1vcnBoQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBtZXNoICkge1xuXG4gIHRoaXMubWVzaCA9IG1lc2g7XG4gIHRoaXMuZnJhbWVzID0gbWVzaC5tb3JwaFRhcmdldEluZmx1ZW5jZXMubGVuZ3RoO1xuICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgdGhpcy5kdXJhdGlvbiA9IDEwMDA7XG4gIHRoaXMubG9vcCA9IHRydWU7XG4gIHRoaXMubGFzdEZyYW1lID0gMDtcbiAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xuXG4gIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbn07XG5cblRIUkVFLk1vcnBoQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogVEhSRUUuTW9ycGhBbmltYXRpb24sXG5cbiAgcGxheTogZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuXG4gIH0sXG5cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG5cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uICggZGVsdGEgKSB7XG5cbiAgICBpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHJldHVybjtcblxuICAgIHRoaXMuY3VycmVudFRpbWUgKz0gZGVsdGE7XG5cbiAgICBpZiAoIHRoaXMubG9vcCA9PT0gdHJ1ZSAmJiB0aGlzLmN1cnJlbnRUaW1lID4gdGhpcy5kdXJhdGlvbiApIHtcblxuICAgICAgdGhpcy5jdXJyZW50VGltZSAlPSB0aGlzLmR1cmF0aW9uO1xuXG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50VGltZSA9IE1hdGgubWluKCB0aGlzLmN1cnJlbnRUaW1lLCB0aGlzLmR1cmF0aW9uICk7XG5cbiAgICB2YXIgaW50ZXJwb2xhdGlvbiA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmZyYW1lcztcbiAgICB2YXIgZnJhbWUgPSBNYXRoLmZsb29yKCB0aGlzLmN1cnJlbnRUaW1lIC8gaW50ZXJwb2xhdGlvbiApO1xuXG4gICAgdmFyIGluZmx1ZW5jZXMgPSB0aGlzLm1lc2gubW9ycGhUYXJnZXRJbmZsdWVuY2VzO1xuXG4gICAgaWYgKCBmcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUgKSB7XG5cbiAgICAgIGluZmx1ZW5jZXNbIHRoaXMubGFzdEZyYW1lIF0gPSAwO1xuICAgICAgaW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50RnJhbWUgXSA9IDE7XG4gICAgICBpbmZsdWVuY2VzWyBmcmFtZSBdID0gMDtcblxuICAgICAgdGhpcy5sYXN0RnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gZnJhbWU7XG5cbiAgICB9XG5cbiAgICBpbmZsdWVuY2VzWyBmcmFtZSBdID0gKCB0aGlzLmN1cnJlbnRUaW1lICUgaW50ZXJwb2xhdGlvbiApIC8gaW50ZXJwb2xhdGlvbjtcbiAgICBpbmZsdWVuY2VzWyB0aGlzLmxhc3RGcmFtZSBdID0gMSAtIGluZmx1ZW5jZXNbIGZyYW1lIF07XG5cbiAgfVxuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9Cb3hHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvQ3ViZS5hc1xuICovXG5cblRIUkVFLkJveEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdCb3hHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBkZXB0aDogZGVwdGgsXG4gICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgZGVwdGhTZWdtZW50czogZGVwdGhTZWdtZW50c1xuICB9O1xuXG4gIHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcbiAgdGhpcy5oZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG4gIHRoaXMuZGVwdGhTZWdtZW50cyA9IGRlcHRoU2VnbWVudHMgfHwgMTtcblxuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIHZhciB3aWR0aF9oYWxmID0gd2lkdGggLyAyO1xuICB2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xuICB2YXIgZGVwdGhfaGFsZiA9IGRlcHRoIC8gMjtcblxuICBidWlsZFBsYW5lKCAneicsICd5JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoX2hhbGYgKTsgLy8gcHhcbiAgYnVpbGRQbGFuZSggJ3onLCAneScsICAgMSwgLSAxLCBkZXB0aCwgaGVpZ2h0LCAtIHdpZHRoX2hhbGYgKTsgLy8gbnhcbiAgYnVpbGRQbGFuZSggJ3gnLCAneicsICAgMSwgICAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodF9oYWxmICk7IC8vIHB5XG4gIGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAtIGhlaWdodF9oYWxmICk7IC8vIG55XG4gIGJ1aWxkUGxhbmUoICd4JywgJ3knLCAgIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgZGVwdGhfaGFsZiApOyAvLyBwelxuICBidWlsZFBsYW5lKCAneCcsICd5JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGhfaGFsZiApOyAvLyBuelxuXG4gIGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoICkge1xuXG4gICAgdmFyIHcsIGl4LCBpeSxcbiAgICBncmlkWCA9IHNjb3BlLndpZHRoU2VnbWVudHMsXG4gICAgZ3JpZFkgPSBzY29wZS5oZWlnaHRTZWdtZW50cyxcbiAgICB3aWR0aF9oYWxmID0gd2lkdGggLyAyLFxuICAgIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMixcbiAgICBvZmZzZXQgPSBzY29wZS52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICBpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd4JyApICkge1xuXG4gICAgICB3ID0gJ3onO1xuXG4gICAgfSBlbHNlIGlmICggKCB1ID09PSAneCcgJiYgdiA9PT0gJ3onICkgfHwgKCB1ID09PSAneicgJiYgdiA9PT0gJ3gnICkgKSB7XG5cbiAgICAgIHcgPSAneSc7XG4gICAgICBncmlkWSA9IHNjb3BlLmRlcHRoU2VnbWVudHM7XG5cbiAgICB9IGVsc2UgaWYgKCAoIHUgPT09ICd6JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneicgKSApIHtcblxuICAgICAgdyA9ICd4JztcbiAgICAgIGdyaWRYID0gc2NvcGUuZGVwdGhTZWdtZW50cztcblxuICAgIH1cblxuICAgIHZhciBncmlkWDEgPSBncmlkWCArIDEsXG4gICAgZ3JpZFkxID0gZ3JpZFkgKyAxLFxuICAgIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYLFxuICAgIHNlZ21lbnRfaGVpZ2h0ID0gaGVpZ2h0IC8gZ3JpZFksXG4gICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICAgIG5vcm1hbFsgdyBdID0gZGVwdGggPiAwID8gMSA6IC0gMTtcblxuICAgIGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG4gICAgICBmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcblxuICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgICAgdmVjdG9yWyB1IF0gPSAoIGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGYgKSAqIHVkaXI7XG4gICAgICAgIHZlY3RvclsgdiBdID0gKCBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGYgKSAqIHZkaXI7XG4gICAgICAgIHZlY3RvclsgdyBdID0gZGVwdGg7XG5cbiAgICAgICAgc2NvcGUudmVydGljZXMucHVzaCggdmVjdG9yICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cbiAgICAgIGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XG5cbiAgICAgICAgdmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuICAgICAgICB2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgICAgdmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeSArIDEgKTtcbiAgICAgICAgdmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cbiAgICAgICAgdmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApO1xuICAgICAgICB2YXIgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcbiAgICAgICAgdmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKTtcbiAgICAgICAgdmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICk7XG5cbiAgICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEgKyBvZmZzZXQsIGIgKyBvZmZzZXQsIGQgKyBvZmZzZXQgKTtcbiAgICAgICAgZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XG4gICAgICAgIGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XG5cbiAgICAgICAgc2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xuICAgICAgICBzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgICBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCBiICsgb2Zmc2V0LCBjICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XG4gICAgICAgIGZhY2Uubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xuICAgICAgICBmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSApO1xuXG4gICAgICAgIHNjb3BlLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZiLmNsb25lKCksIHV2YywgdXZkLmNsb25lKCkgXSApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuXG59O1xuXG5USFJFRS5Cb3hHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkJveEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkJveEdlb21ldHJ5O1xuXG5USFJFRS5DdWJlR2VvbWV0cnkgPSBUSFJFRS5Cb3hHZW9tZXRyeTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvQ2lyY2xlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGh1Z2hlc1xuICovXG5cblRIUkVFLkNpcmNsZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuICBzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XG5cbiAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG4gIHZhciBpLCB1dnMgPSBbXSxcbiAgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgY2VudGVyVVYgPSBuZXcgVEhSRUUuVmVjdG9yMiggMC41LCAwLjUgKTtcblxuICB0aGlzLnZlcnRpY2VzLnB1c2goY2VudGVyKTtcbiAgdXZzLnB1c2goIGNlbnRlclVWICk7XG5cbiAgZm9yICggaSA9IDA7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICB2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICB2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBpIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcbiAgICB2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cbiAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuICAgIHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggKCB2ZXJ0ZXgueCAvIHJhZGl1cyArIDEgKSAvIDIsICggdmVydGV4LnkgLyByYWRpdXMgKyAxICkgLyAyICkgKTtcblxuICB9XG5cbiAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMSApO1xuXG4gIGZvciAoIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGksIGkgKyAxLCAwLCBbIG4uY2xvbmUoKSwgbi5jbG9uZSgpLCBuLmNsb25lKCkgXSApICk7XG4gICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIGkgXS5jbG9uZSgpLCB1dnNbIGkgKyAxIF0uY2xvbmUoKSwgY2VudGVyVVYuY2xvbmUoKSBdICk7XG5cbiAgfVxuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoIG5ldyBUSFJFRS5WZWN0b3IzKCksIHJhZGl1cyApO1xuXG59O1xuXG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkNpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkNpcmNsZUdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9DaXJjbGVCdWZmZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xuICovXG5cblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0NpcmNsZUJ1ZmZlckdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgc2VnbWVudHM6IHNlZ21lbnRzLFxuICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuICBzZWdtZW50cyA9IHNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgc2VnbWVudHMgKSA6IDg7XG5cbiAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG4gIHZhciB2ZXJ0aWNlcyA9IHNlZ21lbnRzICsgMjtcblxuICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMgKiAzICk7XG4gIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggdmVydGljZXMgKiAzICk7XG4gIHZhciB1dnMgPSBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0aWNlcyAqIDIgKTtcblxuICAvLyBjZW50ZXIgZGF0YSBpcyBhbHJlYWR5IHplcm8sIGJ1dCBuZWVkIHRvIHNldCBhIGZldyBleHRyYXNcbiAgbm9ybWFsc1szXSA9IDEuMDtcbiAgdXZzWzBdID0gMC41O1xuICB1dnNbMV0gPSAwLjU7XG5cbiAgZm9yICggdmFyIHMgPSAwLCBpID0gMywgaWkgPSAyIDsgcyA8PSBzZWdtZW50czsgcysrLCBpICs9IDMsIGlpICs9IDIgKSB7XG5cbiAgICB2YXIgc2VnbWVudCA9IHRoZXRhU3RhcnQgKyBzIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcblxuICAgIHBvc2l0aW9uc1tpXSA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XG4gICAgcG9zaXRpb25zW2kgKyAxXSA9IHJhZGl1cyAqIE1hdGguc2luKCBzZWdtZW50ICk7XG5cbiAgICBub3JtYWxzW2kgKyAyXSA9IDE7IC8vIG5vcm1hbCB6XG5cbiAgICB1dnNbaWldID0gKCBwb3NpdGlvbnNbaV0gLyByYWRpdXMgKyAxICkgLyAyO1xuICAgIHV2c1tpaSArIDFdID0gKCBwb3NpdGlvbnNbaSArIDFdIC8gcmFkaXVzICsgMSApIC8gMjtcblxuICB9XG5cbiAgdmFyIGluZGljZXMgPSBbXTtcblxuICBmb3IgKCB2YXIgaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICBpbmRpY2VzLnB1c2goIGkgKTtcbiAgICBpbmRpY2VzLnB1c2goIGkgKyAxICk7XG4gICAgaW5kaWNlcy5wdXNoKCAwICk7XG5cbiAgfVxuXG4gIHRoaXMuYWRkQXR0cmlidXRlKCAnaW5kZXgnLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgVWludDE2QXJyYXkoIGluZGljZXMgKSwgMSApICk7XG4gIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLkNpcmNsZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0N5bGluZGVyR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkN5bGluZGVyR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0N5bGluZGVyR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICByYWRpdXNUb3A6IHJhZGl1c1RvcCxcbiAgICByYWRpdXNCb3R0b206IHJhZGl1c0JvdHRvbSxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIG9wZW5FbmRlZDogb3BlbkVuZGVkLFxuICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gIH07XG5cbiAgcmFkaXVzVG9wID0gcmFkaXVzVG9wICE9PSB1bmRlZmluZWQgPyByYWRpdXNUb3AgOiAyMDtcbiAgcmFkaXVzQm90dG9tID0gcmFkaXVzQm90dG9tICE9PSB1bmRlZmluZWQgPyByYWRpdXNCb3R0b20gOiAyMDtcbiAgaGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XG5cbiAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICBoZWlnaHRTZWdtZW50cyA9IGhlaWdodFNlZ21lbnRzIHx8IDE7XG5cbiAgb3BlbkVuZGVkID0gb3BlbkVuZGVkICE9PSB1bmRlZmluZWQgPyBvcGVuRW5kZWQgOiBmYWxzZTtcbiAgdGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xuICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IDIgKiBNYXRoLlBJO1xuXG4gIHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcblxuICB2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XG5cbiAgZm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICB2YXIgdmVydGljZXNSb3cgPSBbXTtcbiAgICB2YXIgdXZzUm93ID0gW107XG5cbiAgICB2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcbiAgICB2YXIgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XG5cbiAgICBmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdmVydGV4LnggPSByYWRpdXMgKiBNYXRoLnNpbiggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xuICAgICAgdmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xuICAgICAgdmVydGV4LnogPSByYWRpdXMgKiBNYXRoLmNvcyggdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydCApO1xuXG4gICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xuXG4gICAgICB2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcbiAgICAgIHV2c1Jvdy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdSwgMSAtIHYgKSApO1xuXG4gICAgfVxuXG4gICAgdmVydGljZXMucHVzaCggdmVydGljZXNSb3cgKTtcbiAgICB1dnMucHVzaCggdXZzUm93ICk7XG5cbiAgfVxuXG4gIHZhciB0YW5UaGV0YSA9ICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgLyBoZWlnaHQ7XG4gIHZhciBuYSwgbmI7XG5cbiAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgIGlmICggcmFkaXVzVG9wICE9PSAwICkge1xuXG4gICAgICBuYSA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggXSBdLmNsb25lKCk7XG4gICAgICBuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAwIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgbmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4IF0gXS5jbG9uZSgpO1xuICAgICAgbmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcblxuICAgIH1cblxuICAgIG5hLnNldFkoIE1hdGguc3FydCggbmEueCAqIG5hLnggKyBuYS56ICogbmEueiApICogdGFuVGhldGEgKS5ub3JtYWxpemUoKTtcbiAgICBuYi5zZXRZKCBNYXRoLnNxcnQoIG5iLnggKiBuYi54ICsgbmIueiAqIG5iLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XG5cbiAgICBmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgICB2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XG4gICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xuICAgICAgdmFyIHYzID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG4gICAgICB2YXIgdjQgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xuXG4gICAgICB2YXIgbjEgPSBuYS5jbG9uZSgpO1xuICAgICAgdmFyIG4yID0gbmEuY2xvbmUoKTtcbiAgICAgIHZhciBuMyA9IG5iLmNsb25lKCk7XG4gICAgICB2YXIgbjQgPSBuYi5jbG9uZSgpO1xuXG4gICAgICB2YXIgdXYxID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MiA9IHV2c1sgeSArIDEgXVsgeCBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4ICsgMSBdLmNsb25lKCk7XG4gICAgICB2YXIgdXY0ID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2NCBdICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MiwgdjMsIHY0LCBbIG4yLmNsb25lKCksIG4zLCBuNC5jbG9uZSgpIF0gKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIC8vIHRvcCBjYXBcblxuICBpZiAoIG9wZW5FbmRlZCA9PT0gZmFsc2UgJiYgcmFkaXVzVG9wID4gMCApIHtcblxuICAgIHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIGhlaWdodEhhbGYsIDAgKSApO1xuXG4gICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHYxID0gdmVydGljZXNbIDAgXVsgeCBdO1xuICAgICAgdmFyIHYyID0gdmVydGljZXNbIDAgXVsgeCArIDEgXTtcbiAgICAgIHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcblxuICAgICAgdmFyIG4xID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcbiAgICAgIHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XG4gICAgICB2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApO1xuXG4gICAgICB2YXIgdXYxID0gdXZzWyAwIF1bIHggXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MiA9IHV2c1sgMCBdWyB4ICsgMSBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYzID0gbmV3IFRIUkVFLlZlY3RvcjIoIHV2Mi54LCAwICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMgXSApO1xuXG4gICAgfVxuXG4gIH1cblxuICAvLyBib3R0b20gY2FwXG5cbiAgaWYgKCBvcGVuRW5kZWQgPT09IGZhbHNlICYmIHJhZGl1c0JvdHRvbSA+IDAgKSB7XG5cbiAgICB0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIGhlaWdodEhhbGYsIDAgKSApO1xuXG4gICAgZm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHYxID0gdmVydGljZXNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF07XG4gICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgaGVpZ2h0U2VnbWVudHMgXVsgeCBdO1xuICAgICAgdmFyIHYzID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxO1xuXG4gICAgICB2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG4gICAgICB2YXIgbjIgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG4gICAgICB2YXIgbjMgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XG5cbiAgICAgIHZhciB1djEgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggKyAxIF0uY2xvbmUoKTtcbiAgICAgIHZhciB1djIgPSB1dnNbIGhlaWdodFNlZ21lbnRzIF1bIHggXS5jbG9uZSgpO1xuICAgICAgdmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIueCwgMSApO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0gKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzIF0gKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRWRnZXNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICovXG5cblRIUkVFLkVkZ2VzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhyZXNob2xkQW5nbGUgPSAoIHRocmVzaG9sZEFuZ2xlICE9PSB1bmRlZmluZWQgKSA/IHRocmVzaG9sZEFuZ2xlIDogMTtcblxuICB2YXIgdGhyZXNob2xkRG90ID0gTWF0aC5jb3MoIFRIUkVFLk1hdGguZGVnVG9SYWQoIHRocmVzaG9sZEFuZ2xlICkgKTtcblxuICB2YXIgZWRnZSA9IFsgMCwgMCBdLCBoYXNoID0ge307XG4gIHZhciBzb3J0RnVuY3Rpb24gPSBmdW5jdGlvbiAoIGEsIGIgKSB7IHJldHVybiBhIC0gYiB9O1xuXG4gIHZhciBrZXlzID0gWyAnYScsICdiJywgJ2MnIF07XG5cbiAgdmFyIGdlb21ldHJ5MjtcblxuICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XG5cbiAgICBnZW9tZXRyeTIgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgICBnZW9tZXRyeTIuZnJvbUJ1ZmZlckdlb21ldHJ5KCBnZW9tZXRyeSApO1xuXG4gIH0gZWxzZSB7XG5cbiAgICBnZW9tZXRyeTIgPSBnZW9tZXRyeS5jbG9uZSgpO1xuXG4gIH1cblxuICBnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xuICBnZW9tZXRyeTIuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbiAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkyLnZlcnRpY2VzO1xuICB2YXIgZmFjZXMgPSBnZW9tZXRyeTIuZmFjZXM7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cbiAgICAgIGVkZ2VbIDAgXSA9IGZhY2VbIGtleXNbIGogXSBdO1xuICAgICAgZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG4gICAgICBlZGdlLnNvcnQoIHNvcnRGdW5jdGlvbiApO1xuXG4gICAgICB2YXIga2V5ID0gZWRnZS50b1N0cmluZygpO1xuXG4gICAgICBpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgaGFzaFsga2V5IF0gPSB7IHZlcnQxOiBlZGdlWyAwIF0sIHZlcnQyOiBlZGdlWyAxIF0sIGZhY2UxOiBpLCBmYWNlMjogdW5kZWZpbmVkIH07XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaGFzaFsga2V5IF0uZmFjZTIgPSBpO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG4gIHZhciBjb29yZHMgPSBbXTtcblxuICBmb3IgKCB2YXIga2V5IGluIGhhc2ggKSB7XG5cbiAgICB2YXIgaCA9IGhhc2hbIGtleSBdO1xuXG4gICAgaWYgKCBoLmZhY2UyID09PSB1bmRlZmluZWQgfHwgZmFjZXNbIGguZmFjZTEgXS5ub3JtYWwuZG90KCBmYWNlc1sgaC5mYWNlMiBdLm5vcm1hbCApIDw9IHRocmVzaG9sZERvdCApIHtcblxuICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQxIF07XG4gICAgICBjb29yZHMucHVzaCggdmVydGV4LnggKTtcbiAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xuICAgICAgY29vcmRzLnB1c2goIHZlcnRleC56ICk7XG5cbiAgICAgIHZlcnRleCA9IHZlcnRpY2VzWyBoLnZlcnQyIF07XG4gICAgICBjb29yZHMucHVzaCggdmVydGV4LnggKTtcbiAgICAgIGNvb3Jkcy5wdXNoKCB2ZXJ0ZXgueSApO1xuICAgICAgY29vcmRzLnB1c2goIHZlcnRleC56ICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCBjb29yZHMgKSwgMyApICk7XG5cbn07XG5cblRIUkVFLkVkZ2VzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5FZGdlc0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkVkZ2VzR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0V4dHJ1ZGVHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcbiAqXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxuICpcbiAqIHBhcmFtZXRlcnMgPSB7XG4gKlxuICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnZW1lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xuICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXG4gKlxuICogIGJldmVsRW5hYmxlZDogPGJvb2w+LCAvLyB0dXJuIG9uIGJldmVsXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSBzaGFwZSBvdXRsaW5lIGlzIGJldmVsXG4gKiAgYmV2ZWxTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBiZXZlbCBsYXllcnNcbiAqXG4gKiAgZXh0cnVkZVBhdGg6IDxUSFJFRS5DdXJ2ZVBhdGg+IC8vIDNkIHNwbGluZSBwYXRoIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmcuIChjcmVhdGVzIEZyYW1lcyBpZiAuZnJhbWVzIGFyZW4ndCBkZWZpbmVkKVxuICogIGZyYW1lczogPFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXM+IC8vIGNvbnRhaW5pbmcgYXJyYXlzIG9mIHRhbmdlbnRzLCBub3JtYWxzLCBiaW5vcm1hbHNcbiAqXG4gKiAgdXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKiovXG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gIGlmICggdHlwZW9mKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICBzaGFwZXMgPSBbXTtcbiAgICByZXR1cm47XG4gIH1cblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XG5cbiAgc2hhcGVzID0gQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPyBzaGFwZXMgOiBbIHNoYXBlcyBdO1xuXG4gIHRoaXMuYWRkU2hhcGVMaXN0KCBzaGFwZXMsIG9wdGlvbnMgKTtcblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gIC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXG4gIC8vIGFzIHRoZW4gZnJvbnQgYW5kIGJhY2sgc2lkZXMgZ2V0IHNtb290aGVkIHRvb1xuICAvLyBzaG91bGQgZG8gc2VwYXJhdGUgc21vb3RoaW5nIGp1c3QgZm9yIHNpZGVzXG5cbiAgLy90aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbiAgLy9jb25zb2xlLmxvZyggXCJ0b29rXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XG5cbn07XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnk7XG5cblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XG4gIHZhciBzbCA9IHNoYXBlcy5sZW5ndGg7XG5cbiAgZm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XG4gICAgdmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XG4gICAgdGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcbiAgfVxufTtcblxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uICggc2hhcGUsIG9wdGlvbnMgKSB7XG5cbiAgdmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcblxuICB2YXIgYmV2ZWxUaGlja25lc3MgPSBvcHRpb25zLmJldmVsVGhpY2tuZXNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsVGhpY2tuZXNzIDogNjsgLy8gMTBcbiAgdmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxuICB2YXIgYmV2ZWxTZWdtZW50cyA9IG9wdGlvbnMuYmV2ZWxTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFNlZ21lbnRzIDogMztcblxuICB2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcblxuICB2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cbiAgdmFyIHN0ZXBzID0gb3B0aW9ucy5zdGVwcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVwcyA6IDE7XG5cbiAgdmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcbiAgdmFyIGV4dHJ1ZGVQdHMsIGV4dHJ1ZGVCeVBhdGggPSBmYWxzZTtcblxuICAvLyBVc2UgZGVmYXVsdCBXb3JsZFVWR2VuZXJhdG9yIGlmIG5vIFVWIGdlbmVyYXRvcnMgYXJlIHNwZWNpZmllZC5cbiAgdmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xuXG4gIHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XG4gIGlmICggZXh0cnVkZVBhdGggKSB7XG5cbiAgICBleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xuXG4gICAgZXh0cnVkZUJ5UGF0aCA9IHRydWU7XG4gICAgYmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxuXG4gICAgLy8gU0VUVVAgVE5CIHZhcmlhYmxlc1xuXG4gICAgLy8gUmV1c2UgVE5CIGZyb20gVHViZUdlb210cnkgZm9yIG5vdy5cbiAgICAvLyBUT0RPMSAtIGhhdmUgYSAuaXNDbG9zZWQgaW4gc3BsaW5lP1xuXG4gICAgc3BsaW5lVHViZSA9IG9wdGlvbnMuZnJhbWVzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmZyYW1lcyA6IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKGV4dHJ1ZGVQYXRoLCBzdGVwcywgZmFsc2UpO1xuXG4gICAgLy8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XG5cbiAgICBiaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICBwb3NpdGlvbjIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIH1cblxuICAvLyBTYWZlZ3VhcmRzIGlmIGJldmVscyBhcmUgbm90IGVuYWJsZWRcblxuICBpZiAoICEgYmV2ZWxFbmFibGVkICkge1xuXG4gICAgYmV2ZWxTZWdtZW50cyA9IDA7XG4gICAgYmV2ZWxUaGlja25lc3MgPSAwO1xuICAgIGJldmVsU2l6ZSA9IDA7XG5cbiAgfVxuXG4gIC8vIFZhcmlhYmxlcyBpbml0YWxpemF0aW9uXG5cbiAgdmFyIGFob2xlLCBoLCBobDsgLy8gbG9vcGluZyBvZiBob2xlc1xuICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gIHZhciBzaGFwZXNPZmZzZXQgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICB2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cbiAgdmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG4gIHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG4gIHZhciByZXZlcnNlID0gISBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKSA7XG5cbiAgaWYgKCByZXZlcnNlICkge1xuXG4gICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5yZXZlcnNlKCk7XG5cbiAgICAvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxuXG4gICAgZm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XG5cbiAgICAgIGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgICAgaWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggYWhvbGUgKSApIHtcblxuICAgICAgICBob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXG5cbiAgfVxuXG5cbiAgdmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSAoIHZlcnRpY2VzLCBob2xlcyApO1xuXG4gIC8qIFZlcnRpY2VzICovXG5cbiAgdmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcblxuICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBhaG9sZSApO1xuXG4gIH1cblxuXG4gIGZ1bmN0aW9uIHNjYWxlUHQyICggcHQsIHZlYywgc2l6ZSApIHtcblxuICAgIGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcIlRIUkVFLkV4dHJ1ZGVHZW9tZXRyeTogdmVjIGRvZXMgbm90IGV4aXN0XCIgKTtcblxuICAgIHJldHVybiB2ZWMuY2xvbmUoKS5tdWx0aXBseVNjYWxhciggc2l6ZSApLmFkZCggcHQgKTtcblxuICB9XG5cbiAgdmFyIGIsIGJzLCB0LCB6LFxuICAgIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXG4gICAgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcblxuXG4gIC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcblxuXG4gIGZ1bmN0aW9uIGdldEJldmVsVmVjKCBpblB0LCBpblByZXYsIGluTmV4dCApIHtcblxuICAgIHZhciBFUFNJTE9OID0gMC4wMDAwMDAwMDAxO1xuXG4gICAgLy8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxuICAgIC8vICAgc2hpZnRldCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcbiAgICAvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcbiAgICAvL1xuICAgIC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXG4gICAgLy8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cblxuICAgIHZhciB2X3RyYW5zX3gsIHZfdHJhbnNfeSwgc2hyaW5rX2J5ID0gMTsgICAgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxuXG4gICAgLy8gZ29vZCByZWFkaW5nIGZvciBnZW9tZXRyeSBhbGdvcml0aG1zIChoZXJlOiBsaW5lLWxpbmUgaW50ZXJzZWN0aW9uKVxuICAgIC8vIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA1LV9pbnRlcnNlY3QtMS5odG1sXG5cbiAgICB2YXIgdl9wcmV2X3ggPSBpblB0LnggLSBpblByZXYueCwgdl9wcmV2X3kgPSBpblB0LnkgLSBpblByZXYueTtcbiAgICB2YXIgdl9uZXh0X3ggPSBpbk5leHQueCAtIGluUHQueCwgdl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcblxuICAgIHZhciB2X3ByZXZfbGVuc3EgPSAoIHZfcHJldl94ICogdl9wcmV2X3ggKyB2X3ByZXZfeSAqIHZfcHJldl95ICk7XG5cbiAgICAvLyBjaGVjayBmb3IgY29saW5lYXIgZWRnZXNcbiAgICB2YXIgY29saW5lYXIwID0gKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG4gICAgaWYgKCBNYXRoLmFicyggY29saW5lYXIwICkgPiBFUFNJTE9OICkgeyAgICAvLyBub3QgY29saW5lYXJcblxuICAgICAgLy8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXG5cbiAgICAgIHZhciB2X3ByZXZfbGVuID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgKTtcbiAgICAgIHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xuXG4gICAgICAvLyBzaGlmdCBhZGphY2VudCBwb2ludHMgYnkgdW5pdCB2ZWN0b3JzIHRvIHRoZSBsZWZ0XG5cbiAgICAgIHZhciBwdFByZXZTaGlmdF94ID0gKCBpblByZXYueCAtIHZfcHJldl95IC8gdl9wcmV2X2xlbiApO1xuICAgICAgdmFyIHB0UHJldlNoaWZ0X3kgPSAoIGluUHJldi55ICsgdl9wcmV2X3ggLyB2X3ByZXZfbGVuICk7XG5cbiAgICAgIHZhciBwdE5leHRTaGlmdF94ID0gKCBpbk5leHQueCAtIHZfbmV4dF95IC8gdl9uZXh0X2xlbiApO1xuICAgICAgdmFyIHB0TmV4dFNoaWZ0X3kgPSAoIGluTmV4dC55ICsgdl9uZXh0X3ggLyB2X25leHRfbGVuICk7XG5cbiAgICAgIC8vIHNjYWxpbmcgZmFjdG9yIGZvciB2X3ByZXYgdG8gaW50ZXJzZWN0aW9uIHBvaW50XG5cbiAgICAgIHZhciBzZiA9ICggICggcHROZXh0U2hpZnRfeCAtIHB0UHJldlNoaWZ0X3ggKSAqIHZfbmV4dF95IC1cbiAgICAgICAgICAgICggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICAgICkgL1xuICAgICAgICAgICAgKCB2X3ByZXZfeCAqIHZfbmV4dF95IC0gdl9wcmV2X3kgKiB2X25leHRfeCApO1xuXG4gICAgICAvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxuXG4gICAgICB2X3RyYW5zX3ggPSAoIHB0UHJldlNoaWZ0X3ggKyB2X3ByZXZfeCAqIHNmIC0gaW5QdC54ICk7XG4gICAgICB2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XG5cbiAgICAgIC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XG4gICAgICAvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXG4gICAgICB2YXIgdl90cmFuc19sZW5zcSA9ICggdl90cmFuc194ICogdl90cmFuc194ICsgdl90cmFuc195ICogdl90cmFuc195ICk7XG4gICAgICBpZiAoIHZfdHJhbnNfbGVuc3EgPD0gMiApIHtcbiAgICAgICAgcmV0dXJuICBuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7ICAgIC8vIGhhbmRsZSBzcGVjaWFsIGNhc2Ugb2YgY29saW5lYXIgZWRnZXNcblxuICAgICAgdmFyIGRpcmVjdGlvbl9lcSA9IGZhbHNlOyAgIC8vIGFzc3VtZXM6IG9wcG9zaXRlXG4gICAgICBpZiAoIHZfcHJldl94ID4gRVBTSUxPTiApIHtcbiAgICAgICAgaWYgKCB2X25leHRfeCA+IEVQU0lMT04gKSB7IGRpcmVjdGlvbl9lcSA9IHRydWU7IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICggdl9wcmV2X3ggPCAtIEVQU0lMT04gKSB7XG4gICAgICAgICAgaWYgKCB2X25leHRfeCA8IC0gRVBTSUxPTiApIHsgZGlyZWN0aW9uX2VxID0gdHJ1ZTsgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICggTWF0aC5zaWduKHZfcHJldl95KSA9PT0gTWF0aC5zaWduKHZfbmV4dF95KSApIHsgZGlyZWN0aW9uX2VxID0gdHJ1ZTsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICggZGlyZWN0aW9uX2VxICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXCIpO1xuICAgICAgICB2X3RyYW5zX3ggPSAtIHZfcHJldl95O1xuICAgICAgICB2X3RyYW5zX3kgPSAgdl9wcmV2X3g7XG4gICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXCIpO1xuICAgICAgICB2X3RyYW5zX3ggPSB2X3ByZXZfeDtcbiAgICAgICAgdl90cmFuc195ID0gdl9wcmV2X3k7XG4gICAgICAgIHNocmlua19ieSA9IE1hdGguc3FydCggdl9wcmV2X2xlbnNxIC8gMiApO1xuICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuICBuZXcgVEhSRUUuVmVjdG9yMiggdl90cmFuc194IC8gc2hyaW5rX2J5LCB2X3RyYW5zX3kgLyBzaHJpbmtfYnkgKTtcblxuICB9XG5cblxuICB2YXIgY29udG91ck1vdmVtZW50cyA9IFtdO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cbiAgICBpZiAoIGogPT09IGlsICkgaiA9IDA7XG4gICAgaWYgKCBrID09PSBpbCApIGsgPSAwO1xuXG4gICAgLy8gIChqKS0tLShpKS0tLShrKVxuICAgIC8vIGNvbnNvbGUubG9nKCdpLGosaycsIGksIGogLCBrKVxuXG4gICAgY29udG91ck1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcblxuICB9XG5cbiAgdmFyIGhvbGVzTW92ZW1lbnRzID0gW10sIG9uZUhvbGVNb3ZlbWVudHMsIHZlcnRpY2VzTW92ZW1lbnRzID0gY29udG91ck1vdmVtZW50cy5jb25jYXQoKTtcblxuICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgIGFob2xlID0gaG9sZXNbIGggXTtcblxuICAgIG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XG5cbiAgICAgIGlmICggaiA9PT0gaWwgKSBqID0gMDtcbiAgICAgIGlmICggayA9PT0gaWwgKSBrID0gMDtcblxuICAgICAgLy8gIChqKS0tLShpKS0tLShrKVxuICAgICAgb25lSG9sZU1vdmVtZW50c1sgaSBdID0gZ2V0QmV2ZWxWZWMoIGFob2xlWyBpIF0sIGFob2xlWyBqIF0sIGFob2xlWyBrIF0gKTtcblxuICAgIH1cblxuICAgIGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcbiAgICB2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xuXG4gIH1cblxuXG4gIC8vIExvb3AgYmV2ZWxTZWdtZW50cywgMSBmb3IgdGhlIGZyb250LCAxIGZvciB0aGUgYmFja1xuXG4gIGZvciAoIGIgPSAwOyBiIDwgYmV2ZWxTZWdtZW50czsgYiArKyApIHtcbiAgLy9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XG5cbiAgICB0ID0gYiAvIGJldmVsU2VnbWVudHM7XG4gICAgeiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xuXG4gICAgLy96ID0gYmV2ZWxUaGlja25lc3MgKiB0O1xuICAgIGJzID0gYmV2ZWxTaXplICogKCBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJIC8gMiApICkgOyAvLyBjdXJ2ZWRcbiAgICAvL2JzID0gYmV2ZWxTaXplICogdCA7IC8vIGxpbmVhclxuXG4gICAgLy8gY29udHJhY3Qgc2hhcGVcblxuICAgIGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgIHZlcnQgPSBzY2FsZVB0MiggY29udG91clsgaSBdLCBjb250b3VyTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICAgIHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XG5cbiAgICB9XG5cbiAgICAvLyBleHBhbmQgaG9sZXNcblxuICAgIGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xuXG4gICAgICBhaG9sZSA9IGhvbGVzWyBoIF07XG4gICAgICBvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcblxuICAgICAgZm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XG5cbiAgICAgICAgdmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XG5cbiAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksICAtIHogKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICBicyA9IGJldmVsU2l6ZTtcblxuICAvLyBCYWNrIGZhY2luZyB2ZXJ0aWNlc1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuICAgIHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XG5cbiAgICBpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgICAgdiggdmVydC54LCB2ZXJ0LnksIDAgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XG5cbiAgICAgIG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbMF0gKS5tdWx0aXBseVNjYWxhcih2ZXJ0LngpO1xuICAgICAgYmlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbMF0gKS5tdWx0aXBseVNjYWxhcih2ZXJ0LnkpO1xuXG4gICAgICBwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1swXSApLmFkZChub3JtYWwpLmFkZChiaW5vcm1hbCk7XG5cbiAgICAgIHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcblxuICAgIH1cblxuICB9XG5cbiAgLy8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cbiAgLy8gSW5jbHVkaW5nIGZyb250IGZhY2luZyB2ZXJ0aWNlc1xuXG4gIHZhciBzO1xuXG4gIGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xuXG4gICAgZm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xuXG4gICAgICB2ZXJ0ID0gYmV2ZWxFbmFibGVkID8gc2NhbGVQdDIoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzTW92ZW1lbnRzWyBpIF0sIGJzICkgOiB2ZXJ0aWNlc1sgaSBdO1xuXG4gICAgICBpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcblxuICAgICAgICB2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xuXG4gICAgICAgIG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbc10gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XG4gICAgICAgIGJpbm9ybWFsLmNvcHkoIHNwbGluZVR1YmUuYmlub3JtYWxzW3NdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xuXG4gICAgICAgIHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzW3NdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XG5cbiAgICAgICAgdiggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG5cbiAgLy8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xuXG4gIC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcbiAgZm9yICggYiA9IGJldmVsU2VnbWVudHMgLSAxOyBiID49IDA7IGIgLS0gKSB7XG5cbiAgICB0ID0gYiAvIGJldmVsU2VnbWVudHM7XG4gICAgeiA9IGJldmVsVGhpY2tuZXNzICogKCAxIC0gdCApO1xuICAgIC8vYnMgPSBiZXZlbFNpemUgKiAoIDEtTWF0aC5zaW4gKCAoIDEgLSB0ICkgKiBNYXRoLlBJLzIgKSApO1xuICAgIGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4gKCB0ICogTWF0aC5QSSAvIDIgKSA7XG5cbiAgICAvLyBjb250cmFjdCBzaGFwZVxuXG4gICAgZm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgdmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcbiAgICAgIHYoIHZlcnQueCwgdmVydC55LCAgYW1vdW50ICsgeiApO1xuXG4gICAgfVxuXG4gICAgLy8gZXhwYW5kIGhvbGVzXG5cbiAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuICAgICAgb25lSG9sZU1vdmVtZW50cyA9IGhvbGVzTW92ZW1lbnRzWyBoIF07XG5cbiAgICAgIGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgICAgIHZlcnQgPSBzY2FsZVB0MiggYWhvbGVbIGkgXSwgb25lSG9sZU1vdmVtZW50c1sgaSBdLCBicyApO1xuXG4gICAgICAgIGlmICggISBleHRydWRlQnlQYXRoICkge1xuXG4gICAgICAgICAgdiggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgc3RlcHMgLSAxIF0ueCArIHogKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgLyogRmFjZXMgKi9cblxuICAvLyBUb3AgYW5kIGJvdHRvbSBmYWNlc1xuXG4gIGJ1aWxkTGlkRmFjZXMoKTtcblxuICAvLyBTaWRlcyBmYWNlc1xuXG4gIGJ1aWxkU2lkZUZhY2VzKCk7XG5cblxuICAvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcblxuICAgIGlmICggYmV2ZWxFbmFibGVkICkge1xuXG4gICAgICB2YXIgbGF5ZXIgPSAwIDsgLy8gc3RlcHMgKyAxXG4gICAgICB2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xuXG4gICAgICAvLyBCb3R0b20gZmFjZXNcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICBmMyggZmFjZVsgMiBdICsgb2Zmc2V0LCBmYWNlWyAxIF0gKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCApO1xuXG4gICAgICB9XG5cbiAgICAgIGxheWVyID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcbiAgICAgIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcblxuICAgICAgLy8gVG9wIGZhY2VzXG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcbiAgICAgICAgZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gQm90dG9tIGZhY2VzXG5cbiAgICAgIGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcblxuICAgICAgICBmYWNlID0gZmFjZXNbIGkgXTtcbiAgICAgICAgZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBUb3AgZmFjZXNcblxuICAgICAgZm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xuXG4gICAgICAgIGZhY2UgPSBmYWNlc1sgaSBdO1xuICAgICAgICBmMyggZmFjZVsgMCBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAxIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDIgXSArIHZsZW4gKiBzdGVwcyApO1xuXG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICAvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxuXG4gIGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xuXG4gICAgdmFyIGxheWVyb2Zmc2V0ID0gMDtcbiAgICBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICk7XG4gICAgbGF5ZXJvZmZzZXQgKz0gY29udG91ci5sZW5ndGg7XG5cbiAgICBmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcblxuICAgICAgYWhvbGUgPSBob2xlc1sgaCBdO1xuICAgICAgc2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcblxuICAgICAgLy8sIHRydWVcbiAgICAgIGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcblxuICAgIHZhciBqLCBrO1xuICAgIGkgPSBjb250b3VyLmxlbmd0aDtcblxuICAgIHdoaWxlICggLS0gaSA+PSAwICkge1xuXG4gICAgICBqID0gaTtcbiAgICAgIGsgPSBpIC0gMTtcbiAgICAgIGlmICggayA8IDAgKSBrID0gY29udG91ci5sZW5ndGggLSAxO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcblxuICAgICAgdmFyIHMgPSAwLCBzbCA9IHN0ZXBzICArIGJldmVsU2VnbWVudHMgKiAyO1xuXG4gICAgICBmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xuXG4gICAgICAgIHZhciBzbGVuMSA9IHZsZW4gKiBzO1xuICAgICAgICB2YXIgc2xlbjIgPSB2bGVuICogKCBzICsgMSApO1xuXG4gICAgICAgIHZhciBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXG4gICAgICAgICAgYiA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4xLFxuICAgICAgICAgIGMgPSBsYXllcm9mZnNldCArIGsgKyBzbGVuMixcbiAgICAgICAgICBkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XG5cbiAgICAgICAgZjQoIGEsIGIsIGMsIGQsIGNvbnRvdXIsIHMsIHNsLCBqLCBrICk7XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG5cbiAgZnVuY3Rpb24gdiggeCwgeSwgeiApIHtcblxuICAgIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZjMoIGEsIGIsIGMgKSB7XG5cbiAgICBhICs9IHNoYXBlc09mZnNldDtcbiAgICBiICs9IHNoYXBlc09mZnNldDtcbiAgICBjICs9IHNoYXBlc09mZnNldDtcblxuICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYyApICk7XG5cbiAgICB2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVUb3BVViggc2NvcGUsIGEsIGIsIGMgKTtcblxuICAgIHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQsIHdhbGxDb250b3VyLCBzdGVwSW5kZXgsIHN0ZXBzTGVuZ3RoLCBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xuXG4gICAgYSArPSBzaGFwZXNPZmZzZXQ7XG4gICAgYiArPSBzaGFwZXNPZmZzZXQ7XG4gICAgYyArPSBzaGFwZXNPZmZzZXQ7XG4gICAgZCArPSBzaGFwZXNPZmZzZXQ7XG5cbiAgICBzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuICAgIHNjb3BlLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG5cbiAgICB2YXIgdXZzID0gdXZnZW4uZ2VuZXJhdGVTaWRlV2FsbFVWKCBzY29wZSwgYSwgYiwgYywgZCApO1xuXG4gICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAwIF0sIHV2c1sgMSBdLCB1dnNbIDMgXSBdICk7XG4gICAgc2NvcGUuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyAxIF0sIHV2c1sgMiBdLCB1dnNbIDMgXSBdICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA9IHtcblxuICBnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xuXG4gICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICB2YXIgYSA9IHZlcnRpY2VzWyBpbmRleEEgXTtcbiAgICB2YXIgYiA9IHZlcnRpY2VzWyBpbmRleEIgXTtcbiAgICB2YXIgYyA9IHZlcnRpY2VzWyBpbmRleEMgXTtcblxuICAgIHJldHVybiBbXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYS54LCBhLnkgKSxcbiAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLngsIGIueSApLFxuICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueCwgYy55IClcbiAgICBdO1xuXG4gIH0sXG5cbiAgZ2VuZXJhdGVTaWRlV2FsbFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBpbmRleEEsIGluZGV4QiwgaW5kZXhDLCBpbmRleEQgKSB7XG5cbiAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIHZhciBhID0gdmVydGljZXNbIGluZGV4QSBdO1xuICAgIHZhciBiID0gdmVydGljZXNbIGluZGV4QiBdO1xuICAgIHZhciBjID0gdmVydGljZXNbIGluZGV4QyBdO1xuICAgIHZhciBkID0gdmVydGljZXNbIGluZGV4RCBdO1xuXG4gICAgaWYgKCBNYXRoLmFicyggYS55IC0gYi55ICkgPCAwLjAxICkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGEueCwgMSAtIGEueiApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYi54LCAxIC0gYi56ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBjLngsIDEgLSBjLnogKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGQueCwgMSAtIGQueiApXG4gICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggYS55LCAxIC0gYS56ICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCBiLnksIDEgLSBiLnogKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIGMueSwgMSAtIGMueiApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggZC55LCAxIC0gZC56IClcbiAgICAgIF07XG4gICAgfVxuICB9XG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9TaGFwZUdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXG4gKlxuICogQ3JlYXRlcyBhIG9uZS1zaWRlZCBwb2x5Z29uYWwgZ2VvbWV0cnkgZnJvbSBhIHBhdGggc2hhcGUuIFNpbWlsYXIgdG9cbiAqIEV4dHJ1ZGVHZW9tZXRyeS5cbiAqXG4gKiBwYXJhbWV0ZXJzID0ge1xuICpcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxuICpcbiAqICBtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXG4gKiAgdXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcbiAqXG4gKiB9XG4gKiovXG5cblRIUkVFLlNoYXBlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1NoYXBlR2VvbWV0cnknO1xuXG4gIGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkgc2hhcGVzID0gWyBzaGFwZXMgXTtcblxuICB0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU2hhcGVHZW9tZXRyeTtcblxuLyoqXG4gKiBBZGQgYW4gYXJyYXkgb2Ygc2hhcGVzIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnkuXG4gKi9cblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlTGlzdCA9IGZ1bmN0aW9uICggc2hhcGVzLCBvcHRpb25zICkge1xuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgdGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcblxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8qKlxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cbiAqL1xuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xuXG4gIGlmICggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICkgb3B0aW9ucyA9IHt9O1xuICB2YXIgY3VydmVTZWdtZW50cyA9IG9wdGlvbnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzIDogMTI7XG5cbiAgdmFyIG1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbDtcbiAgdmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciA9PT0gdW5kZWZpbmVkID8gVEhSRUUuRXh0cnVkZUdlb21ldHJ5LldvcmxkVVZHZW5lcmF0b3IgOiBvcHRpb25zLlVWR2VuZXJhdG9yO1xuXG4gIC8vXG5cbiAgdmFyIGksIGwsIGhvbGU7XG5cbiAgdmFyIHNoYXBlc09mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICB2YXIgc2hhcGVQb2ludHMgPSBzaGFwZS5leHRyYWN0UG9pbnRzKCBjdXJ2ZVNlZ21lbnRzICk7XG5cbiAgdmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XG4gIHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xuXG4gIHZhciByZXZlcnNlID0gISBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdmVydGljZXMgKTtcblxuICBpZiAoIHJldmVyc2UgKSB7XG5cbiAgICB2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcblxuICAgIC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUuLi5cblxuICAgIGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgICAgaG9sZSA9IGhvbGVzWyBpIF07XG5cbiAgICAgIGlmICggVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcblxuICAgICAgICBob2xlc1sgaSBdID0gaG9sZS5yZXZlcnNlKCk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldmVyc2UgPSBmYWxzZTtcblxuICB9XG5cbiAgdmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XG5cbiAgLy8gVmVydGljZXNcblxuICB2YXIgY29udG91ciA9IHZlcnRpY2VzO1xuXG4gIGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIGhvbGUgPSBob2xlc1sgaSBdO1xuICAgIHZlcnRpY2VzID0gdmVydGljZXMuY29uY2F0KCBob2xlICk7XG5cbiAgfVxuXG4gIC8vXG5cbiAgdmFyIHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gIHZhciBmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcblxuICAgIHZlcnQgPSB2ZXJ0aWNlc1sgaSBdO1xuXG4gICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggdmVydC54LCB2ZXJ0LnksIDAgKSApO1xuXG4gIH1cblxuICBmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XG5cbiAgICBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIHZhciBhID0gZmFjZVsgMCBdICsgc2hhcGVzT2Zmc2V0O1xuICAgIHZhciBiID0gZmFjZVsgMSBdICsgc2hhcGVzT2Zmc2V0O1xuICAgIHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xuXG4gICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcbiAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZVRvcFVWKCB0aGlzLCBhLCBiLCBjICkgKTtcblxuICB9XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL0xhdGhlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xuICogQGF1dGhvciB6ejg1IC8gaHR0cHM6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICovXG5cbi8vIHBvaW50cyAtIHRvIGNyZWF0ZSBhIGNsb3NlZCB0b3J1cywgb25lIG11c3QgdXNlIGEgc2V0IG9mIHBvaW50c1xuLy8gICAgbGlrZSBzbzogWyBhLCBiLCBjLCBkLCBhIF0sIHNlZSBmaXJzdCBpcyB0aGUgc2FtZSBhcyBsYXN0LlxuLy8gc2VnbWVudHMgLSB0aGUgbnVtYmVyIG9mIGNpcmN1bWZlcmVuY2Ugc2VnbWVudHMgdG8gY3JlYXRlXG4vLyBwaGlTdGFydCAtIHRoZSBzdGFydGluZyByYWRpYW5cbi8vIHBoaUxlbmd0aCAtIHRoZSByYWRpYW4gKDAgdG8gMipQSSkgcmFuZ2Ugb2YgdGhlIGxhdGhlZCBzZWN0aW9uXG4vLyAgICAyKnBpIGlzIGEgY2xvc2VkIGxhdGhlLCBsZXNzIHRoYW4gMlBJIGlzIGEgcG9ydGlvbi5cblxuVEhSRUUuTGF0aGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ0xhdGhlR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBwb2ludHM6IHBvaW50cyxcbiAgICBzZWdtZW50czogc2VnbWVudHMsXG4gICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoXG4gIH07XG5cbiAgc2VnbWVudHMgPSBzZWdtZW50cyB8fCAxMjtcbiAgcGhpU3RhcnQgPSBwaGlTdGFydCB8fCAwO1xuICBwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XG5cbiAgdmFyIGludmVyc2VQb2ludExlbmd0aCA9IDEuMCAvICggcG9pbnRzLmxlbmd0aCAtIDEgKTtcbiAgdmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSBzZWdtZW50czsgaSA8PSBpbDsgaSArKyApIHtcblxuICAgIHZhciBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XG5cbiAgICB2YXIgYyA9IE1hdGguY29zKCBwaGkgKSxcbiAgICAgIHMgPSBNYXRoLnNpbiggcGhpICk7XG5cbiAgICBmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICB2YXIgcHQgPSBwb2ludHNbIGogXTtcblxuICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgICAgIHZlcnRleC54ID0gYyAqIHB0LnggLSBzICogcHQueTtcbiAgICAgIHZlcnRleC55ID0gcyAqIHB0LnggKyBjICogcHQueTtcbiAgICAgIHZlcnRleC56ID0gcHQuejtcblxuICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgIH1cblxuICB9XG5cbiAgdmFyIG5wID0gcG9pbnRzLmxlbmd0aDtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcblxuICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBwb2ludHMubGVuZ3RoIC0gMTsgaiA8IGpsOyBqICsrICkge1xuXG4gICAgICB2YXIgYmFzZSA9IGogKyBucCAqIGk7XG4gICAgICB2YXIgYSA9IGJhc2U7XG4gICAgICB2YXIgYiA9IGJhc2UgKyBucDtcbiAgICAgIHZhciBjID0gYmFzZSArIDEgKyBucDtcbiAgICAgIHZhciBkID0gYmFzZSArIDE7XG5cbiAgICAgIHZhciB1MCA9IGkgKiBpbnZlcnNlU2VnbWVudHM7XG4gICAgICB2YXIgdjAgPSBqICogaW52ZXJzZVBvaW50TGVuZ3RoO1xuICAgICAgdmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XG4gICAgICB2YXIgdjEgPSB2MCArIGludmVyc2VQb2ludExlbmd0aDtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuXG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG5cbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MCApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYwICksXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MCwgdjEgKVxuXG4gICAgICBdICk7XG5cbiAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcblxuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xuXG4gICAgICAgIG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjAgKSxcbiAgICAgICAgbmV3IFRIUkVFLlZlY3RvcjIoIHUxLCB2MSApLFxuICAgICAgICBuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYxIClcblxuICAgICAgXSApO1xuXG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5MYXRoZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkxhdGhlR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BsYW5lR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL3BhcGVydmlzaW9uM2QuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL2FzMy90cnVuay9zcmMvb3JnL3BhcGVydmlzaW9uM2Qvb2JqZWN0cy9wcmltaXRpdmVzL1BsYW5lLmFzXG4gKi9cblxuVEhSRUUuUGxhbmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMgKSB7XG5cbiAgY29uc29sZS5sb2coICdUSFJFRS5QbGFuZUdlb21ldHJ5OiBDb25zaWRlciB1c2luZyBUSFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5IGZvciBsb3dlciBtZW1vcnkgZm9vdHByaW50LicgKTtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BsYW5lR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcbiAgfTtcblxuICB0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkgKTtcblxufTtcblxuVEhSRUUuUGxhbmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlBsYW5lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGxhbmVHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUGxhbmVCdWZmZXJHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcbiAqL1xuXG5USFJFRS5QbGFuZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1BsYW5lQnVmZmVyR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcbiAgfTtcblxuICB2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcbiAgdmFyIGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMjtcblxuICB2YXIgZ3JpZFggPSBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgMTtcbiAgdmFyIGdyaWRZID0gTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCAxO1xuXG4gIHZhciBncmlkWDEgPSBncmlkWCArIDE7XG4gIHZhciBncmlkWTEgPSBncmlkWSArIDE7XG5cbiAgdmFyIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xuICB2YXIgc2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcblxuICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBncmlkWDEgKiBncmlkWTEgKiAzICk7XG4gIHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMyApO1xuICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheSggZ3JpZFgxICogZ3JpZFkxICogMiApO1xuXG4gIHZhciBvZmZzZXQgPSAwO1xuICB2YXIgb2Zmc2V0MiA9IDA7XG5cbiAgZm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xuXG4gICAgdmFyIHkgPSBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGY7XG5cbiAgICBmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XG5cbiAgICAgIHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcblxuICAgICAgdmVydGljZXNbIG9mZnNldCAgICAgXSA9IHg7XG4gICAgICB2ZXJ0aWNlc1sgb2Zmc2V0ICsgMSBdID0gLSB5O1xuXG4gICAgICBub3JtYWxzWyBvZmZzZXQgKyAyIF0gPSAxO1xuXG4gICAgICB1dnNbIG9mZnNldDIgICAgIF0gPSBpeCAvIGdyaWRYO1xuICAgICAgdXZzWyBvZmZzZXQyICsgMSBdID0gMSAtICggaXkgLyBncmlkWSApO1xuXG4gICAgICBvZmZzZXQgKz0gMztcbiAgICAgIG9mZnNldDIgKz0gMjtcblxuICAgIH1cblxuICB9XG5cbiAgb2Zmc2V0ID0gMDtcblxuICB2YXIgaW5kaWNlcyA9IG5ldyAoICggdmVydGljZXMubGVuZ3RoIC8gMyApID4gNjU1MzUgPyBVaW50MzJBcnJheSA6IFVpbnQxNkFycmF5ICkoIGdyaWRYICogZ3JpZFkgKiA2ICk7XG5cbiAgZm9yICggdmFyIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkgKysgKSB7XG5cbiAgICBmb3IgKCB2YXIgaXggPSAwOyBpeCA8IGdyaWRYOyBpeCArKyApIHtcblxuICAgICAgdmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xuICAgICAgdmFyIGIgPSBpeCArIGdyaWRYMSAqICggaXkgKyAxICk7XG4gICAgICB2YXIgYyA9ICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xuICAgICAgdmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XG5cbiAgICAgIGluZGljZXNbIG9mZnNldCAgICAgXSA9IGE7XG4gICAgICBpbmRpY2VzWyBvZmZzZXQgKyAxIF0gPSBiO1xuICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMiBdID0gZDtcblxuICAgICAgaW5kaWNlc1sgb2Zmc2V0ICsgMyBdID0gYjtcbiAgICAgIGluZGljZXNbIG9mZnNldCArIDQgXSA9IGM7XG4gICAgICBpbmRpY2VzWyBvZmZzZXQgKyA1IF0gPSBkO1xuXG4gICAgICBvZmZzZXQgKz0gNjtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdpbmRleCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGluZGljZXMsIDEgKSApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcblxufTtcblxuVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlBsYW5lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUGxhbmVCdWZmZXJHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUmluZ0dlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBLYWxlYiBNdXJwaHlcbiAqL1xuXG5USFJFRS5SaW5nR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnUmluZ0dlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgaW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcbiAgICB0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxuICAgIHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcbiAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICB9O1xuXG4gIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgMDtcbiAgb3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyB8fCA1MDtcblxuICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XG5cbiAgdGhldGFTZWdtZW50cyA9IHRoZXRhU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCB0aGV0YVNlZ21lbnRzICkgOiA4O1xuICBwaGlTZWdtZW50cyA9IHBoaVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMSwgcGhpU2VnbWVudHMgKSA6IDg7XG5cbiAgdmFyIGksIG8sIHV2cyA9IFtdLCByYWRpdXMgPSBpbm5lclJhZGl1cywgcmFkaXVzU3RlcCA9ICggKCBvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzICkgLyBwaGlTZWdtZW50cyApO1xuXG4gIGZvciAoIGkgPSAwOyBpIDwgcGhpU2VnbWVudHMgKyAxOyBpICsrICkgeyAvLyBjb25jZW50cmljIGNpcmNsZXMgaW5zaWRlIHJpbmdcblxuICAgIGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyArIDE7IG8gKysgKSB7IC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXG5cbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgbyAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcbiAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHNlZ21lbnQgKTtcbiAgICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcblxuICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcbiAgICAgIHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggKCB2ZXJ0ZXgueCAvIG91dGVyUmFkaXVzICsgMSApIC8gMiwgKCB2ZXJ0ZXgueSAvIG91dGVyUmFkaXVzICsgMSApIC8gMiApICk7XG4gICAgfVxuXG4gICAgcmFkaXVzICs9IHJhZGl1c1N0ZXA7XG5cbiAgfVxuXG4gIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcblxuICBmb3IgKCBpID0gMDsgaSA8IHBoaVNlZ21lbnRzOyBpICsrICkgeyAvLyBjb25jZW50cmljIGNpcmNsZXMgaW5zaWRlIHJpbmdcblxuICAgIHZhciB0aGV0YVNlZ21lbnQgPSBpICogKHRoZXRhU2VnbWVudHMgKyAxKTtcblxuICAgIGZvciAoIG8gPSAwOyBvIDwgdGhldGFTZWdtZW50cyA7IG8gKysgKSB7IC8vIG51bWJlciBvZiBzZWdtZW50cyBwZXIgY2lyY2xlXG5cbiAgICAgIHZhciBzZWdtZW50ID0gbyArIHRoZXRhU2VnbWVudDtcblxuICAgICAgdmFyIHYxID0gc2VnbWVudDtcbiAgICAgIHZhciB2MiA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMTtcbiAgICAgIHZhciB2MyA9IHNlZ21lbnQgKyB0aGV0YVNlZ21lbnRzICsgMjtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbi5jbG9uZSgpLCBuLmNsb25lKCksIG4uY2xvbmUoKSBdICkgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyB2MSBdLmNsb25lKCksIHV2c1sgdjIgXS5jbG9uZSgpLCB1dnNbIHYzIF0uY2xvbmUoKSBdKTtcblxuICAgICAgdjEgPSBzZWdtZW50O1xuICAgICAgdjIgPSBzZWdtZW50ICsgdGhldGFTZWdtZW50cyArIDI7XG4gICAgICB2MyA9IHNlZ21lbnQgKyAxO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuLmNsb25lKCksIG4uY2xvbmUoKSwgbi5jbG9uZSgpIF0gKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dnNbIHYxIF0uY2xvbmUoKSwgdXZzWyB2MiBdLmNsb25lKCksIHV2c1sgdjMgXS5jbG9uZSgpIF0pO1xuXG4gICAgfVxuICB9XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlJpbmdHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5SaW5nR2VvbWV0cnk7XG5cblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvU3BoZXJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICBjb25zb2xlLmxvZyggJ1RIUkVFLlNwaGVyZUdlb21ldHJ5OiBDb25zaWRlciB1c2luZyBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeSBmb3IgbG93ZXIgbWVtb3J5IGZvb3RwcmludC4nICk7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXG4gICAgaGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxuICAgIHBoaVN0YXJ0OiBwaGlTdGFydCxcbiAgICBwaGlMZW5ndGg6IHBoaUxlbmd0aCxcbiAgICB0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxuICAgIHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxuICB9O1xuXG4gIHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcblxuICB3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCA4ICk7XG4gIGhlaWdodFNlZ21lbnRzID0gTWF0aC5tYXgoIDIsIE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgNiApO1xuXG4gIHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcbiAgcGhpTGVuZ3RoID0gcGhpTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBwaGlMZW5ndGggOiBNYXRoLlBJICogMjtcblxuICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XG4gIHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcblxuICB2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XG5cbiAgZm9yICggeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICB2YXIgdmVydGljZXNSb3cgPSBbXTtcbiAgICB2YXIgdXZzUm93ID0gW107XG5cbiAgICBmb3IgKCB4ID0gMDsgeCA8PSB3aWR0aFNlZ21lbnRzOyB4ICsrICkge1xuXG4gICAgICB2YXIgdSA9IHggLyB3aWR0aFNlZ21lbnRzO1xuICAgICAgdmFyIHYgPSB5IC8gaGVpZ2h0U2VnbWVudHM7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdmVydGV4LnggPSAtIHJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG4gICAgICB2ZXJ0ZXgueSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG4gICAgICB2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG5cbiAgICAgIHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XG5cbiAgICAgIHZlcnRpY2VzUm93LnB1c2goIHRoaXMudmVydGljZXMubGVuZ3RoIC0gMSApO1xuICAgICAgdXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XG5cbiAgICB9XG5cbiAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuICAgIHV2cy5wdXNoKCB1dnNSb3cgKTtcblxuICB9XG5cbiAgZm9yICggeSA9IDA7IHkgPCBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcblxuICAgIGZvciAoIHggPSAwOyB4IDwgd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcbiAgICAgIHZhciB2MiA9IHZlcnRpY2VzWyB5IF1bIHggXTtcbiAgICAgIHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XG4gICAgICB2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcblxuICAgICAgdmFyIG4xID0gdGhpcy52ZXJ0aWNlc1sgdjEgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuICAgICAgdmFyIG4yID0gdGhpcy52ZXJ0aWNlc1sgdjIgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuICAgICAgdmFyIG4zID0gdGhpcy52ZXJ0aWNlc1sgdjMgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuICAgICAgdmFyIG40ID0gdGhpcy52ZXJ0aWNlc1sgdjQgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xuXG4gICAgICB2YXIgdXYxID0gdXZzWyB5IF1bIHggKyAxIF0uY2xvbmUoKTtcbiAgICAgIHZhciB1djIgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XG4gICAgICB2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcbiAgICAgIHZhciB1djQgPSB1dnNbIHkgKyAxIF1bIHggKyAxIF0uY2xvbmUoKTtcblxuICAgICAgaWYgKCBNYXRoLmFicyggdGhpcy52ZXJ0aWNlc1sgdjEgXS55ICkgPT09IHJhZGl1cyApIHtcblxuICAgICAgICB1djEueCA9ICggdXYxLnggKyB1djIueCApIC8gMjtcbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MywgdjQsIFsgbjEsIG4zLCBuNCBdICkgKTtcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MywgdXY0IF0gKTtcblxuICAgICAgfSBlbHNlIGlmICggTWF0aC5hYnMoIHRoaXMudmVydGljZXNbIHYzIF0ueSApID09PSByYWRpdXMgKSB7XG5cbiAgICAgICAgdXYzLnggPSAoIHV2My54ICsgdXY0LnggKSAvIDI7XG4gICAgICAgIHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XG4gICAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjQsIFsgbjEsIG4yLCBuNCBdICkgKTtcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXY0IF0gKTtcblxuICAgICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjIsIHYzLCB2NCwgWyBuMi5jbG9uZSgpLCBuMywgbjQuY2xvbmUoKSBdICkgKTtcbiAgICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djIuY2xvbmUoKSwgdXYzLCB1djQuY2xvbmUoKSBdICk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcblxuICB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSggbmV3IFRIUkVFLlZlY3RvcjMoKSwgcmFkaXVzICk7XG5cbn07XG5cblRIUkVFLlNwaGVyZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuU3BoZXJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuU3BoZXJlR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1NwaGVyZUJ1ZmZlckdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXG4gKiBiYXNlZCBvbiBUSFJFRS5TcGhlcmVHZW9tZXRyeVxuICovXG5cblRIUkVFLlNwaGVyZUJ1ZmZlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgd2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcbiAgICBoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXG4gICAgcGhpU3RhcnQ6IHBoaVN0YXJ0LFxuICAgIHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxuICAgIHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXG4gICAgdGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDUwO1xuXG4gIHdpZHRoU2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDggKTtcbiAgaGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XG5cbiAgcGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xuICBwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xuXG4gIHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcbiAgdGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xuXG4gIHZhciB2ZXJ0ZXhDb3VudCA9ICggKCB3aWR0aFNlZ21lbnRzICsgMSApICogKCBoZWlnaHRTZWdtZW50cyArIDEgKSApO1xuXG4gIHZhciBwb3NpdGlvbnMgPSBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCB2ZXJ0ZXhDb3VudCAqIDMgKSwgMyApO1xuICB2YXIgbm9ybWFscyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMyApLCAzKTtcbiAgdmFyIHV2cyA9IG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBGbG9hdDMyQXJyYXkoIHZlcnRleENvdW50ICogMiApLCAyICk7XG5cbiAgdmFyIGluZGV4ID0gMCwgdmVydGljZXMgPSBbXSwgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICBmb3IgKCB2YXIgeSA9IDA7IHkgPD0gaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XG5cbiAgICB2YXIgdmVydGljZXNSb3cgPSBbXTtcblxuICAgIHZhciB2ID0geSAvIGhlaWdodFNlZ21lbnRzO1xuXG4gICAgZm9yICggdmFyIHggPSAwOyB4IDw9IHdpZHRoU2VnbWVudHM7IHggKysgKSB7XG5cbiAgICAgIHZhciB1ID0geCAvIHdpZHRoU2VnbWVudHM7XG5cbiAgICAgIHZhciBweCA9IC0gcmFkaXVzICogTWF0aC5jb3MoIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcbiAgICAgIHZhciBweSA9IHJhZGl1cyAqIE1hdGguY29zKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XG4gICAgICB2YXIgcHogPSByYWRpdXMgKiBNYXRoLnNpbiggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xuXG4gICAgICBub3JtYWwuc2V0KCBweCwgcHksIHB6ICkubm9ybWFsaXplKCk7XG5cbiAgICAgIHBvc2l0aW9ucy5zZXRYWVooIGluZGV4LCBweCwgcHksIHB6ICk7XG4gICAgICBub3JtYWxzLnNldFhZWiggaW5kZXgsIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcbiAgICAgIHV2cy5zZXRYWSggaW5kZXgsIHUsIDEgLSB2ICk7XG5cbiAgICAgIHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICk7XG5cbiAgICAgIGluZGV4Kys7XG5cbiAgICB9XG5cbiAgICB2ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1JvdyApO1xuXG4gIH1cblxuICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gIGZvciAoIHZhciB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xuXG4gICAgZm9yICggdmFyIHggPSAwOyB4IDwgd2lkdGhTZWdtZW50czsgeCArKyApIHtcblxuICAgICAgdmFyIHYxID0gdmVydGljZXNbIHkgICAgIF1bIHggKyAxIF07XG4gICAgICB2YXIgdjIgPSB2ZXJ0aWNlc1sgeSAgICAgXVsgeCAgICAgXTtcbiAgICAgIHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICAgICBdO1xuICAgICAgdmFyIHY0ID0gdmVydGljZXNbIHkgKyAxIF1bIHggKyAxIF07XG5cbiAgICAgIGlmICggeSAhPT0gMCApIGluZGljZXMucHVzaCggdjEsIHYyLCB2NCApO1xuICAgICAgaWYgKCB5ICE9PSBoZWlnaHRTZWdtZW50cyAtIDEgKSBpbmRpY2VzLnB1c2goIHYyLCB2MywgdjQgKTtcblxuICAgIH1cblxuICB9XG5cbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdpbmRleCcsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIG5ldyBVaW50MTZBcnJheSggaW5kaWNlcyApLCAxICkgKTtcbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xuICB0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5vcm1hbHMgKTtcbiAgdGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIHV2cyApO1xuXG4gIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxufTtcblxuVEhSRUUuU3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TcGhlcmVCdWZmZXJHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVGV4dEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiBGb3IgY3JlYXRpbmcgM0QgdGV4dCBnZW9tZXRyeSBpbiB0aHJlZS5qc1xuICpcbiAqIFRleHQgPSAzRCBUZXh0XG4gKlxuICogcGFyYW1ldGVycyA9IHtcbiAqICBzaXplOiAgICAgICA8ZmxvYXQ+LCAgLy8gc2l6ZSBvZiB0aGUgdGV4dFxuICogIGhlaWdodDogICAgIDxmbG9hdD4sICAvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XG4gKiAgY3VydmVTZWdtZW50czogIDxpbnQ+LCAgICAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcbiAqXG4gKiAgZm9udDogICAgICAgPHN0cmluZz4sICAgLy8gZm9udCBuYW1lXG4gKiAgd2VpZ2h0OiAgICAgPHN0cmluZz4sICAgLy8gZm9udCB3ZWlnaHQgKG5vcm1hbCwgYm9sZClcbiAqICBzdHlsZTogICAgICA8c3RyaW5nPiwgICAvLyBmb250IHN0eWxlICAobm9ybWFsLCBpdGFsaWNzKVxuICpcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgICAgIC8vIHR1cm4gb24gYmV2ZWxcbiAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgICAgLy8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcbiAqICBiZXZlbFNpemU6ICAgIDxmbG9hdD4sICAgIC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcbiAqICB9XG4gKlxuICovXG5cbi8qICBVc2FnZSBFeGFtcGxlc1xuXG4gIC8vIFRleHRHZW9tZXRyeSB3cmFwcGVyXG5cbiAgdmFyIHRleHQzZCA9IG5ldyBUZXh0R2VvbWV0cnkoIHRleHQsIG9wdGlvbnMgKTtcblxuICAvLyBDb21wbGV0ZSBtYW5uZXJcblxuICB2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgb3B0aW9ucyApO1xuICB2YXIgdGV4dDNkID0gbmV3IEV4dHJ1ZGVHZW9tZXRyeSggdGV4dFNoYXBlcywgb3B0aW9ucyApO1xuXG4qL1xuXG5cblRIUkVFLlRleHRHZW9tZXRyeSA9IGZ1bmN0aW9uICggdGV4dCwgcGFyYW1ldGVycyApIHtcblxuICBwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICB2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgcGFyYW1ldGVycyApO1xuXG4gIC8vIHRyYW5zbGF0ZSBwYXJhbWV0ZXJzIHRvIEV4dHJ1ZGVHZW9tZXRyeSBBUElcblxuICBwYXJhbWV0ZXJzLmFtb3VudCA9IHBhcmFtZXRlcnMuaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmhlaWdodCA6IDUwO1xuXG4gIC8vIGRlZmF1bHRzXG5cbiAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsVGhpY2tuZXNzID0gMTA7XG4gIGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcbiAgaWYgKCBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcblxuICBUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgdGV4dFNoYXBlcywgcGFyYW1ldGVycyApO1xuXG4gIHRoaXMudHlwZSA9ICdUZXh0R2VvbWV0cnknO1xuXG59O1xuXG5USFJFRS5UZXh0R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuVGV4dEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRleHRHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvVG9ydXNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogYmFzZWQgb24gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2F3YXkzZC9zb3VyY2UvYnJvd3NlL3RydW5rL2ZwMTAvQXdheTNETGl0ZS9zcmMvYXdheTNkbGl0ZS9wcmltaXRpdmVzL1RvcnVzLmFzP3I9Mjg4OFxuICovXG5cblRIUkVFLlRvcnVzR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjICkge1xuXG4gIFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnR5cGUgPSAnVG9ydXNHZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIHR1YmU6IHR1YmUsXG4gICAgcmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxuICAgIHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxuICAgIGFyYzogYXJjXG4gIH07XG5cbiAgcmFkaXVzID0gcmFkaXVzIHx8IDEwMDtcbiAgdHViZSA9IHR1YmUgfHwgNDA7XG4gIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgdHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY7XG4gIGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuICB2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgdXZzID0gW10sIG5vcm1hbHMgPSBbXTtcblxuICBmb3IgKCB2YXIgaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuXG4gICAgICB2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG4gICAgICB2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG4gICAgICBjZW50ZXIueCA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICk7XG4gICAgICBjZW50ZXIueSA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICk7XG5cbiAgICAgIHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgICAgdmVydGV4LnggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuICAgICAgdmVydGV4LnkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuICAgICAgdmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcblxuICAgICAgdXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdHVidWxhclNlZ21lbnRzLCBqIC8gcmFkaWFsU2VnbWVudHMgKSApO1xuICAgICAgbm9ybWFscy5wdXNoKCB2ZXJ0ZXguY2xvbmUoKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZvciAoIHZhciBqID0gMTsgaiA8PSByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuICAgIGZvciAoIHZhciBpID0gMTsgaSA8PSB0dWJ1bGFyU2VnbWVudHM7IGkgKysgKSB7XG5cbiAgICAgIHZhciBhID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaSAtIDE7XG4gICAgICB2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XG4gICAgICB2YXIgYyA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaTtcbiAgICAgIHZhciBkID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiBqICsgaTtcblxuICAgICAgdmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQsIFsgbm9ybWFsc1sgYSBdLmNsb25lKCksIG5vcm1hbHNbIGIgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG4gICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cbiAgICAgIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQsIFsgbm9ybWFsc1sgYiBdLmNsb25lKCksIG5vcm1hbHNbIGMgXS5jbG9uZSgpLCBub3JtYWxzWyBkIF0uY2xvbmUoKSBdICk7XG4gICAgICB0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcbiAgICAgIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Ub3J1c0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1RvcnVzS25vdEdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcbiAqL1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcblxuICBUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgdHViZTogdHViZSxcbiAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgdHVidWxhclNlZ21lbnRzOiB0dWJ1bGFyU2VnbWVudHMsXG4gICAgcDogcCxcbiAgICBxOiBxLFxuICAgIGhlaWdodFNjYWxlOiBoZWlnaHRTY2FsZVxuICB9O1xuXG4gIHJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XG4gIHR1YmUgPSB0dWJlIHx8IDQwO1xuICByYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDY0O1xuICB0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgODtcbiAgcCA9IHAgfHwgMjtcbiAgcSA9IHEgfHwgMztcbiAgaGVpZ2h0U2NhbGUgPSBoZWlnaHRTY2FsZSB8fCAxO1xuXG4gIHZhciBncmlkID0gbmV3IEFycmF5KCByYWRpYWxTZWdtZW50cyApO1xuICB2YXIgdGFuZyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciBuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIGJpdGFuID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCByYWRpYWxTZWdtZW50czsgKysgaSApIHtcblxuICAgIGdyaWRbIGkgXSA9IG5ldyBBcnJheSggdHVidWxhclNlZ21lbnRzICk7XG4gICAgdmFyIHUgPSBpIC8gcmFkaWFsU2VnbWVudHMgKiAyICogcCAqIE1hdGguUEk7XG4gICAgdmFyIHAxID0gZ2V0UG9zKCB1LCBxLCBwLCByYWRpdXMsIGhlaWdodFNjYWxlICk7XG4gICAgdmFyIHAyID0gZ2V0UG9zKCB1ICsgMC4wMSwgcSwgcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApO1xuICAgIHRhbmcuc3ViVmVjdG9ycyggcDIsIHAxICk7XG4gICAgbi5hZGRWZWN0b3JzKCBwMiwgcDEgKTtcblxuICAgIGJpdGFuLmNyb3NzVmVjdG9ycyggdGFuZywgbiApO1xuICAgIG4uY3Jvc3NWZWN0b3JzKCBiaXRhbiwgdGFuZyApO1xuICAgIGJpdGFuLm5vcm1hbGl6ZSgpO1xuICAgIG4ubm9ybWFsaXplKCk7XG5cbiAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB0dWJ1bGFyU2VnbWVudHM7ICsrIGogKSB7XG5cbiAgICAgIHZhciB2ID0gaiAvIHR1YnVsYXJTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xuICAgICAgdmFyIGN4ID0gLSB0dWJlICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cbiAgICAgIHZhciBjeSA9IHR1YmUgKiBNYXRoLnNpbiggdiApO1xuXG4gICAgICB2YXIgcG9zID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgICAgIHBvcy54ID0gcDEueCArIGN4ICogbi54ICsgY3kgKiBiaXRhbi54O1xuICAgICAgcG9zLnkgPSBwMS55ICsgY3ggKiBuLnkgKyBjeSAqIGJpdGFuLnk7XG4gICAgICBwb3MueiA9IHAxLnogKyBjeCAqIG4ueiArIGN5ICogYml0YW4uejtcblxuICAgICAgZ3JpZFsgaSBdWyBqIF0gPSB0aGlzLnZlcnRpY2VzLnB1c2goIHBvcyApIC0gMTtcblxuICAgIH1cblxuICB9XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgcmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XG5cbiAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCB0dWJ1bGFyU2VnbWVudHM7ICsrIGogKSB7XG5cbiAgICAgIHZhciBpcCA9ICggaSArIDEgKSAlIHJhZGlhbFNlZ21lbnRzO1xuICAgICAgdmFyIGpwID0gKCBqICsgMSApICUgdHVidWxhclNlZ21lbnRzO1xuXG4gICAgICB2YXIgYSA9IGdyaWRbIGkgXVsgaiBdO1xuICAgICAgdmFyIGIgPSBncmlkWyBpcCBdWyBqIF07XG4gICAgICB2YXIgYyA9IGdyaWRbIGlwIF1bIGpwIF07XG4gICAgICB2YXIgZCA9IGdyaWRbIGkgXVsganAgXTtcblxuICAgICAgdmFyIHV2YSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsIGogLyB0dWJ1bGFyU2VnbWVudHMgKTtcbiAgICAgIHZhciB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gcmFkaWFsU2VnbWVudHMsIGogLyB0dWJ1bGFyU2VnbWVudHMgKTtcbiAgICAgIHZhciB1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xuICAgICAgdmFyIHV2ZCA9IG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gcmFkaWFsU2VnbWVudHMsICggaiArIDEgKSAvIHR1YnVsYXJTZWdtZW50cyApO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSwgdXZiLCB1dmQgXSApO1xuXG4gICAgICB0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYiwgYywgZCApICk7XG4gICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgIH1cbiAgfVxuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxuICBmdW5jdGlvbiBnZXRQb3MoIHUsIGluX3EsIGluX3AsIHJhZGl1cywgaGVpZ2h0U2NhbGUgKSB7XG5cbiAgICB2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xuICAgIHZhciBzdSA9IE1hdGguc2luKCB1ICk7XG4gICAgdmFyIHF1T3ZlclAgPSBpbl9xIC8gaW5fcCAqIHU7XG4gICAgdmFyIGNzID0gTWF0aC5jb3MoIHF1T3ZlclAgKTtcblxuICAgIHZhciB0eCA9IHJhZGl1cyAqICggMiArIGNzICkgKiAwLjUgKiBjdTtcbiAgICB2YXIgdHkgPSByYWRpdXMgKiAoIDIgKyBjcyApICogc3UgKiAwLjU7XG4gICAgdmFyIHR6ID0gaGVpZ2h0U2NhbGUgKiByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xuXG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0eCwgdHksIHR6ICk7XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRvcnVzS25vdEdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UdWJlR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxuICogQGF1dGhvciBtaW5pbmdvbGQgLyBodHRwczovL2dpdGh1Yi5jb20vbWluaW5nb2xkXG4gKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMVxuICpcbiAqIE1vZGlmaWVkIGZyb20gdGhlIFRvcnVzS25vdEdlb21ldHJ5IGJ5IEBvb3Ntb3hpZWNvZGVcbiAqXG4gKiBDcmVhdGVzIGEgdHViZSB3aGljaCBleHRydWRlcyBhbG9uZyBhIDNkIHNwbGluZVxuICpcbiAqIFVzZXMgcGFyYWxsZWwgdHJhbnNwb3J0IGZyYW1lcyBhcyBkZXNjcmliZWQgaW5cbiAqIGh0dHA6Ly93d3cuY3MuaW5kaWFuYS5lZHUvcHViL3RlY2hyZXBvcnRzL1RSNDI1LnBkZlxuICovXG5cblRIUkVFLlR1YmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcGF0aCwgc2VnbWVudHMsIHJhZGl1cywgcmFkaWFsU2VnbWVudHMsIGNsb3NlZCwgdGFwZXIgKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdUdWJlR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBwYXRoOiBwYXRoLFxuICAgIHNlZ21lbnRzOiBzZWdtZW50cyxcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICByYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXG4gICAgY2xvc2VkOiBjbG9zZWRcbiAgfTtcblxuICBzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xuICByYWRpdXMgPSByYWRpdXMgfHwgMTtcbiAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICBjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XG4gIHRhcGVyID0gdGFwZXIgfHwgVEhSRUUuVHViZUdlb21ldHJ5Lk5vVGFwZXI7XG5cbiAgdmFyIGdyaWQgPSBbXTtcblxuICB2YXIgc2NvcGUgPSB0aGlzLFxuXG4gICAgdGFuZ2VudCxcbiAgICBub3JtYWwsXG4gICAgYmlub3JtYWwsXG5cbiAgICBudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXG5cbiAgICB1LCB2LCByLFxuXG4gICAgY3gsIGN5LFxuICAgIHBvcywgcG9zMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXG4gICAgaSwgaixcbiAgICBpcCwganAsXG4gICAgYSwgYiwgYywgZCxcbiAgICB1dmEsIHV2YiwgdXZjLCB1dmQ7XG5cbiAgdmFyIGZyYW1lcyA9IG5ldyBUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICksXG4gICAgdGFuZ2VudHMgPSBmcmFtZXMudGFuZ2VudHMsXG4gICAgbm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzLFxuICAgIGJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XG5cbiAgLy8gcHJveHkgaW50ZXJuYWxzXG4gIHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcbiAgdGhpcy5ub3JtYWxzID0gbm9ybWFscztcbiAgdGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XG5cbiAgZnVuY3Rpb24gdmVydCggeCwgeSwgeiApIHtcblxuICAgIHJldHVybiBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgLSAxO1xuXG4gIH1cblxuICAvLyBjb25zcnVjdCB0aGUgZ3JpZFxuXG4gIGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG4gICAgZ3JpZFsgaSBdID0gW107XG5cbiAgICB1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgcG9zID0gcGF0aC5nZXRQb2ludEF0KCB1ICk7XG5cbiAgICB0YW5nZW50ID0gdGFuZ2VudHNbIGkgXTtcbiAgICBub3JtYWwgPSBub3JtYWxzWyBpIF07XG4gICAgYmlub3JtYWwgPSBiaW5vcm1hbHNbIGkgXTtcblxuICAgIHIgPSByYWRpdXMgKiB0YXBlciggdSApO1xuXG4gICAgZm9yICggaiA9IDA7IGogPCByYWRpYWxTZWdtZW50czsgaiArKyApIHtcblxuICAgICAgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xuXG4gICAgICBjeCA9IC0gciAqIE1hdGguY29zKCB2ICk7IC8vIFRPRE86IEhhY2s6IE5lZ2F0aW5nIGl0IHNvIGl0IGZhY2VzIG91dHNpZGUuXG4gICAgICBjeSA9IHIgKiBNYXRoLnNpbiggdiApO1xuXG4gICAgICBwb3MyLmNvcHkoIHBvcyApO1xuICAgICAgcG9zMi54ICs9IGN4ICogbm9ybWFsLnggKyBjeSAqIGJpbm9ybWFsLng7XG4gICAgICBwb3MyLnkgKz0gY3ggKiBub3JtYWwueSArIGN5ICogYmlub3JtYWwueTtcbiAgICAgIHBvczIueiArPSBjeCAqIG5vcm1hbC56ICsgY3kgKiBiaW5vcm1hbC56O1xuXG4gICAgICBncmlkWyBpIF1bIGogXSA9IHZlcnQoIHBvczIueCwgcG9zMi55LCBwb3MyLnogKTtcblxuICAgIH1cbiAgfVxuXG5cbiAgLy8gY29uc3RydWN0IHRoZSBtZXNoXG5cbiAgZm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcblxuICAgIGZvciAoIGogPSAwOyBqIDwgcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XG5cbiAgICAgIGlwID0gKCBjbG9zZWQgKSA/IChpICsgMSkgJSBzZWdtZW50cyA6IGkgKyAxO1xuICAgICAganAgPSAoaiArIDEpICUgcmFkaWFsU2VnbWVudHM7XG5cbiAgICAgIGEgPSBncmlkWyBpIF1bIGogXTsgICAvLyAqKiogTk9UIE5FQ0VTU0FSSUxZIFBMQU5BUiAhICoqKlxuICAgICAgYiA9IGdyaWRbIGlwIF1bIGogXTtcbiAgICAgIGMgPSBncmlkWyBpcCBdWyBqcCBdO1xuICAgICAgZCA9IGdyaWRbIGkgXVsganAgXTtcblxuICAgICAgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyBzZWdtZW50cywgaiAvIHJhZGlhbFNlZ21lbnRzICk7XG4gICAgICB1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gc2VnbWVudHMsIGogLyByYWRpYWxTZWdtZW50cyApO1xuICAgICAgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaSArIDEgKSAvIHNlZ21lbnRzLCAoIGogKyAxICkgLyByYWRpYWxTZWdtZW50cyApO1xuICAgICAgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyBzZWdtZW50cywgKCBqICsgMSApIC8gcmFkaWFsU2VnbWVudHMgKTtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGQgKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGIsIGMsIGQgKSApO1xuICAgICAgdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmIuY2xvbmUoKSwgdXZjLCB1dmQuY2xvbmUoKSBdICk7XG5cbiAgICB9XG4gIH1cblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuICB0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7XG5cbn07XG5cblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5UdWJlR2VvbWV0cnk7XG5cblRIUkVFLlR1YmVHZW9tZXRyeS5Ob1RhcGVyID0gZnVuY3Rpb24gKCB1ICkge1xuXG4gIHJldHVybiAxO1xuXG59O1xuXG5USFJFRS5UdWJlR2VvbWV0cnkuU2ludXNvaWRhbFRhcGVyID0gZnVuY3Rpb24gKCB1ICkge1xuXG4gIHJldHVybiBNYXRoLnNpbiggTWF0aC5QSSAqIHUgKTtcblxufTtcblxuLy8gRm9yIGNvbXB1dGluZyBvZiBGcmVuZXQgZnJhbWVzLCBleHBvc2luZyB0aGUgdGFuZ2VudHMsIG5vcm1hbHMgYW5kIGJpbm9ybWFscyB0aGUgc3BsaW5lXG5USFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzID0gZnVuY3Rpb24gKCBwYXRoLCBzZWdtZW50cywgY2xvc2VkICkge1xuXG4gIHZhciBub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuXG4gICAgdGFuZ2VudHMgPSBbXSxcbiAgICBub3JtYWxzID0gW10sXG4gICAgYmlub3JtYWxzID0gW10sXG5cbiAgICB2ZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxuICAgIG1hdCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXG5cbiAgICBudW1wb2ludHMgPSBzZWdtZW50cyArIDEsXG4gICAgdGhldGEsXG4gICAgZXBzaWxvbiA9IDAuMDAwMSxcbiAgICBzbWFsbGVzdCxcblxuICAgIHR4LCB0eSwgdHosXG4gICAgaSwgdTtcblxuXG4gIC8vIGV4cG9zZSBpbnRlcm5hbHNcbiAgdGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xuICB0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xuICB0aGlzLmJpbm9ybWFscyA9IGJpbm9ybWFscztcblxuICAvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG4gIGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG4gICAgdSA9IGkgLyAoIG51bXBvaW50cyAtIDEgKTtcblxuICAgIHRhbmdlbnRzWyBpIF0gPSBwYXRoLmdldFRhbmdlbnRBdCggdSApO1xuICAgIHRhbmdlbnRzWyBpIF0ubm9ybWFsaXplKCk7XG5cbiAgfVxuXG4gIGluaXRpYWxOb3JtYWwzKCk7XG5cbiAgLypcbiAgZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDEobGFzdEJpbm9ybWFsKSB7XG4gICAgLy8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xuICAgIG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgYmlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XG4gICAgbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggbGFzdEJpbm9ybWFsLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7XG4gICAgYmlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwyKCkge1xuXG4gICAgLy8gVGhpcyB1c2VzIHRoZSBGcmVuZXQtU2VycmV0IGZvcm11bGEgZm9yIGRlcml2aW5nIGJpbm9ybWFsXG4gICAgdmFyIHQyID0gcGF0aC5nZXRUYW5nZW50QXQoIGVwc2lsb24gKTtcblxuICAgIG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuc3ViVmVjdG9ycyggdDIsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcbiAgICBiaW5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCkuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKTtcblxuICAgIG5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIGJpbm9ybWFsc1sgMCBdLCB0YW5nZW50c1sgMCBdICkubm9ybWFsaXplKCk7IC8vIGxhc3QgYmlub3JtYWwgeCB0YW5nZW50XG4gICAgYmlub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWxzWyAwIF0gKS5ub3JtYWxpemUoKTtcblxuICB9XG4gICovXG5cbiAgZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDMoKSB7XG4gICAgLy8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5pY3VsYXIgdG8gdGhlIGZpcnN0IHRhbmdlbnQgdmVjdG9yLFxuICAgIC8vIGFuZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzbWFsbGVzdCB0YW5nZW50IHh5eiBjb21wb25lbnRcblxuICAgIG5vcm1hbHNbIDAgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgYmlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIHNtYWxsZXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0eCA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnggKTtcbiAgICB0eSA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnkgKTtcbiAgICB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcblxuICAgIGlmICggdHggPD0gc21hbGxlc3QgKSB7XG4gICAgICBzbWFsbGVzdCA9IHR4O1xuICAgICAgbm9ybWFsLnNldCggMSwgMCwgMCApO1xuICAgIH1cblxuICAgIGlmICggdHkgPD0gc21hbGxlc3QgKSB7XG4gICAgICBzbWFsbGVzdCA9IHR5O1xuICAgICAgbm9ybWFsLnNldCggMCwgMSwgMCApO1xuICAgIH1cblxuICAgIGlmICggdHogPD0gc21hbGxlc3QgKSB7XG4gICAgICBub3JtYWwuc2V0KCAwLCAwLCAxICk7XG4gICAgfVxuXG4gICAgdmVjLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsICkubm9ybWFsaXplKCk7XG5cbiAgICBub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcbiAgICBiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xuICB9XG5cblxuICAvLyBjb21wdXRlIHRoZSBzbG93bHktdmFyeWluZyBub3JtYWwgYW5kIGJpbm9ybWFsIHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxuXG4gIGZvciAoIGkgPSAxOyBpIDwgbnVtcG9pbnRzOyBpICsrICkge1xuXG4gICAgbm9ybWFsc1sgaSBdID0gbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xuXG4gICAgYmlub3JtYWxzWyBpIF0gPSBiaW5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcblxuICAgIHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XG5cbiAgICBpZiAoIHZlYy5sZW5ndGgoKSA+IGVwc2lsb24gKSB7XG5cbiAgICAgIHZlYy5ub3JtYWxpemUoKTtcblxuICAgICAgdGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRhbmdlbnRzWyBpIC0gMSBdLmRvdCggdGFuZ2VudHNbIGkgXSApLCAtIDEsIDEgKSApOyAvLyBjbGFtcCBmb3IgZmxvYXRpbmcgcHQgZXJyb3JzXG5cbiAgICAgIG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcblxuICAgIH1cblxuICAgIGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cbiAgfVxuXG5cbiAgLy8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxuXG4gIGlmICggY2xvc2VkICkge1xuXG4gICAgdGhldGEgPSBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIG5vcm1hbHNbIDAgXS5kb3QoIG5vcm1hbHNbIG51bXBvaW50cyAtIDEgXSApLCAtIDEsIDEgKSApO1xuICAgIHRoZXRhIC89ICggbnVtcG9pbnRzIC0gMSApO1xuXG4gICAgaWYgKCB0YW5nZW50c1sgMCBdLmRvdCggdmVjLmNyb3NzVmVjdG9ycyggbm9ybWFsc1sgMCBdLCBub3JtYWxzWyBudW1wb2ludHMgLSAxIF0gKSApID4gMCApIHtcblxuICAgICAgdGhldGEgPSAtIHRoZXRhO1xuXG4gICAgfVxuXG4gICAgZm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkgKysgKSB7XG5cbiAgICAgIC8vIHR3aXN0IGEgbGl0dGxlLi4uXG4gICAgICBub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcbiAgICAgIGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XG5cbiAgICB9XG5cbiAgfVxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvUG9seWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciBjbG9ja3dvcmtnZWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL2Nsb2Nrd29ya2dlZWtcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICB2ZXJ0aWNlczogdmVydGljZXMsXG4gICAgaW5kaWNlczogaW5kaWNlcyxcbiAgICByYWRpdXM6IHJhZGl1cyxcbiAgICBkZXRhaWw6IGRldGFpbFxuICB9O1xuXG4gIHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xuICBkZXRhaWwgPSBkZXRhaWwgfHwgMDtcblxuICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArPSAzICkge1xuXG4gICAgcHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF0sIHZlcnRpY2VzWyBpICsgMSBdLCB2ZXJ0aWNlc1sgaSArIDIgXSApICk7XG5cbiAgfVxuXG4gIHZhciBwID0gdGhpcy52ZXJ0aWNlcztcblxuICB2YXIgZmFjZXMgPSBbXTtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGogPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IDMsIGogKysgKSB7XG5cbiAgICB2YXIgdjEgPSBwWyBpbmRpY2VzWyBpICAgICBdIF07XG4gICAgdmFyIHYyID0gcFsgaW5kaWNlc1sgaSArIDEgXSBdO1xuICAgIHZhciB2MyA9IHBbIGluZGljZXNbIGkgKyAyIF0gXTtcblxuICAgIGZhY2VzWyBqIF0gPSBuZXcgVEhSRUUuRmFjZTMoIHYxLmluZGV4LCB2Mi5pbmRleCwgdjMuaW5kZXgsIFsgdjEuY2xvbmUoKSwgdjIuY2xvbmUoKSwgdjMuY2xvbmUoKSBdICk7XG5cbiAgfVxuXG4gIHZhciBjZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIHN1YmRpdmlkZSggZmFjZXNbIGkgXSwgZGV0YWlsICk7XG5cbiAgfVxuXG5cbiAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBmYWNlIHN0cmFkZGxlcyB0aGUgc2VhbVxuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICB2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF1bIGkgXTtcblxuICAgIHZhciB4MCA9IHV2c1sgMCBdLng7XG4gICAgdmFyIHgxID0gdXZzWyAxIF0ueDtcbiAgICB2YXIgeDIgPSB1dnNbIDIgXS54O1xuXG4gICAgdmFyIG1heCA9IE1hdGgubWF4KCB4MCwgTWF0aC5tYXgoIHgxLCB4MiApICk7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKCB4MCwgTWF0aC5taW4oIHgxLCB4MiApICk7XG5cbiAgICBpZiAoIG1heCA+IDAuOSAmJiBtaW4gPCAwLjEgKSB7IC8vIDAuOSBpcyBzb21ld2hhdCBhcmJpdHJhcnlcblxuICAgICAgaWYgKCB4MCA8IDAuMiApIHV2c1sgMCBdLnggKz0gMTtcbiAgICAgIGlmICggeDEgPCAwLjIgKSB1dnNbIDEgXS54ICs9IDE7XG4gICAgICBpZiAoIHgyIDwgMC4yICkgdXZzWyAyIF0ueCArPSAxO1xuXG4gICAgfVxuXG4gIH1cblxuXG4gIC8vIEFwcGx5IHJhZGl1c1xuXG4gIGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIHRoaXMudmVydGljZXNbIGkgXS5tdWx0aXBseVNjYWxhciggcmFkaXVzICk7XG5cbiAgfVxuXG5cbiAgLy8gTWVyZ2UgdmVydGljZXNcblxuICB0aGlzLm1lcmdlVmVydGljZXMoKTtcblxuICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xuXG4gIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcblxuXG4gIC8vIFByb2plY3QgdmVjdG9yIG9udG8gc3BoZXJlJ3Mgc3VyZmFjZVxuXG4gIGZ1bmN0aW9uIHByZXBhcmUoIHZlY3RvciApIHtcblxuICAgIHZhciB2ZXJ0ZXggPSB2ZWN0b3Iubm9ybWFsaXplKCkuY2xvbmUoKTtcbiAgICB2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcblxuICAgIC8vIFRleHR1cmUgY29vcmRzIGFyZSBlcXVpdmFsZW50IHRvIG1hcCBjb29yZHMsIGNhbGN1bGF0ZSBhbmdsZSBhbmQgY29udmVydCB0byBmcmFjdGlvbiBvZiBhIGNpcmNsZS5cblxuICAgIHZhciB1ID0gYXppbXV0aCggdmVjdG9yICkgLyAyIC8gTWF0aC5QSSArIDAuNTtcbiAgICB2YXIgdiA9IGluY2xpbmF0aW9uKCB2ZWN0b3IgKSAvIE1hdGguUEkgKyAwLjU7XG4gICAgdmVydGV4LnV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICk7XG5cbiAgICByZXR1cm4gdmVydGV4O1xuXG4gIH1cblxuXG4gIC8vIEFwcHJveGltYXRlIGEgY3VydmVkIGZhY2Ugd2l0aCByZWN1cnNpdmVseSBzdWItZGl2aWRlZCB0cmlhbmdsZXMuXG5cbiAgZnVuY3Rpb24gbWFrZSggdjEsIHYyLCB2MyApIHtcblxuICAgIHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSApO1xuICAgIHRoYXQuZmFjZXMucHVzaCggZmFjZSApO1xuXG4gICAgY2VudHJvaWQuY29weSggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xuXG4gICAgdmFyIGF6aSA9IGF6aW11dGgoIGNlbnRyb2lkICk7XG5cbiAgICB0aGF0LmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXG4gICAgICBjb3JyZWN0VVYoIHYxLnV2LCB2MSwgYXppICksXG4gICAgICBjb3JyZWN0VVYoIHYyLnV2LCB2MiwgYXppICksXG4gICAgICBjb3JyZWN0VVYoIHYzLnV2LCB2MywgYXppIClcbiAgICBdICk7XG5cbiAgfVxuXG5cbiAgLy8gQW5hbHl0aWNhbGx5IHN1YmRpdmlkZSBhIGZhY2UgdG8gdGhlIHJlcXVpcmVkIGRldGFpbCBsZXZlbC5cblxuICBmdW5jdGlvbiBzdWJkaXZpZGUoIGZhY2UsIGRldGFpbCApIHtcblxuICAgIHZhciBjb2xzID0gTWF0aC5wb3coMiwgZGV0YWlsKTtcbiAgICB2YXIgYSA9IHByZXBhcmUoIHRoYXQudmVydGljZXNbIGZhY2UuYSBdICk7XG4gICAgdmFyIGIgPSBwcmVwYXJlKCB0aGF0LnZlcnRpY2VzWyBmYWNlLmIgXSApO1xuICAgIHZhciBjID0gcHJlcGFyZSggdGhhdC52ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcbiAgICB2YXIgdiA9IFtdO1xuXG4gICAgLy8gQ29uc3RydWN0IGFsbCBvZiB0aGUgdmVydGljZXMgZm9yIHRoaXMgc3ViZGl2aXNpb24uXG5cbiAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDw9IGNvbHM7IGkgKysgKSB7XG5cbiAgICAgIHZbIGkgXSA9IFtdO1xuXG4gICAgICB2YXIgYWogPSBwcmVwYXJlKCBhLmNsb25lKCkubGVycCggYywgaSAvIGNvbHMgKSApO1xuICAgICAgdmFyIGJqID0gcHJlcGFyZSggYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICkgKTtcbiAgICAgIHZhciByb3dzID0gY29scyAtIGk7XG5cbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8PSByb3dzOyBqICsrKSB7XG5cbiAgICAgICAgaWYgKCBqID09PSAwICYmIGkgPT09IGNvbHMgKSB7XG5cbiAgICAgICAgICB2WyBpIF1bIGogXSA9IGFqO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB2WyBpIF1bIGogXSA9IHByZXBhcmUoIGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICkgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIENvbnN0cnVjdCBhbGwgb2YgdGhlIGZhY2VzLlxuXG4gICAgZm9yICggdmFyIGkgPSAwOyBpIDwgY29scyA7IGkgKysgKSB7XG5cbiAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDIgKiAoY29scyAtIGkpIC0gMTsgaiArKyApIHtcblxuICAgICAgICB2YXIgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XG5cbiAgICAgICAgaWYgKCBqICUgMiA9PT0gMCApIHtcblxuICAgICAgICAgIG1ha2UoXG4gICAgICAgICAgICB2WyBpIF1bIGsgKyAxXSxcbiAgICAgICAgICAgIHZbIGkgKyAxIF1bIGsgXSxcbiAgICAgICAgICAgIHZbIGkgXVsgayBdXG4gICAgICAgICAgKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgbWFrZShcbiAgICAgICAgICAgIHZbIGkgXVsgayArIDEgXSxcbiAgICAgICAgICAgIHZbIGkgKyAxXVsgayArIDFdLFxuICAgICAgICAgICAgdlsgaSArIDEgXVsgayBdXG4gICAgICAgICAgKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cblxuICAvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXG5cbiAgZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xuXG4gICAgcmV0dXJuIE1hdGguYXRhbjIoIHZlY3Rvci56LCAtIHZlY3Rvci54ICk7XG5cbiAgfVxuXG5cbiAgLy8gQW5nbGUgYWJvdmUgdGhlIFhaIHBsYW5lLlxuXG4gIGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XG5cbiAgICByZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcblxuICB9XG5cblxuICAvLyBUZXh0dXJlIGZpeGluZyBoZWxwZXIuIFNwaGVyZXMgaGF2ZSBzb21lIG9kZCBiZWhhdmlvdXJzLlxuXG4gIGZ1bmN0aW9uIGNvcnJlY3RVViggdXYsIHZlY3RvciwgYXppbXV0aCApIHtcblxuICAgIGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcbiAgICBpZiAoICggdmVjdG9yLnggPT09IDAgKSAmJiAoIHZlY3Rvci56ID09PSAwICkgKSB1diA9IG5ldyBUSFJFRS5WZWN0b3IyKCBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjUsIHV2LnkgKTtcbiAgICByZXR1cm4gdXYuY2xvbmUoKTtcblxuICB9XG5cblxufTtcblxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvRG9kZWNhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIEFiZSBQYXpvcyAvIGh0dHBzOi8vaGFtb2lkLmNvbVxuICovXG5cblRIUkVFLkRvZGVjYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfTtcblxuICB2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuICB2YXIgciA9IDEgLyB0O1xuXG4gIHZhciB2ZXJ0aWNlcyA9IFtcblxuICAgIC8vICjCsTEsIMKxMSwgwrExKVxuICAgIC0xLCAtMSwgLTEsICAgIC0xLCAtMSwgIDEsXG4gICAgLTEsICAxLCAtMSwgICAgLTEsICAxLCAgMSxcbiAgICAgMSwgLTEsIC0xLCAgICAgMSwgLTEsICAxLFxuICAgICAxLCAgMSwgLTEsICAgICAxLCAgMSwgIDEsXG5cbiAgICAvLyAoMCwgwrExL8+GLCDCsc+GKVxuICAgICAwLCAtciwgLXQsICAgICAwLCAtciwgIHQsXG4gICAgIDAsICByLCAtdCwgICAgIDAsICByLCAgdCxcblxuICAgIC8vICjCsTEvz4YsIMKxz4YsIDApXG4gICAgLXIsIC10LCAgMCwgICAgLXIsICB0LCAgMCxcbiAgICAgciwgLXQsICAwLCAgICAgciwgIHQsICAwLFxuXG4gICAgLy8gKMKxz4YsIDAsIMKxMS/PhilcbiAgICAtdCwgIDAsIC1yLCAgICAgdCwgIDAsIC1yLFxuICAgIC10LCAgMCwgIHIsICAgICB0LCAgMCwgIHJcbiAgXTtcblxuICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgMywgMTEsICA3LCAgICAgIDMsICA3LCAxNSwgICAgICAzLCAxNSwgMTMsXG4gICAgIDcsIDE5LCAxNywgICAgICA3LCAxNywgIDYsICAgICAgNywgIDYsIDE1LFxuICAgIDE3LCAgNCwgIDgsICAgICAxNywgIDgsIDEwLCAgICAgMTcsIDEwLCAgNixcbiAgICAgOCwgIDAsIDE2LCAgICAgIDgsIDE2LCAgMiwgICAgICA4LCAgMiwgMTAsXG4gICAgIDAsIDEyLCAgMSwgICAgICAwLCAgMSwgMTgsICAgICAgMCwgMTgsIDE2LFxuICAgICA2LCAxMCwgIDIsICAgICAgNiwgIDIsIDEzLCAgICAgIDYsIDEzLCAxNSxcbiAgICAgMiwgMTYsIDE4LCAgICAgIDIsIDE4LCAgMywgICAgICAyLCAgMywgMTMsXG4gICAgMTgsICAxLCAgOSwgICAgIDE4LCAgOSwgMTEsICAgICAxOCwgMTEsICAzLFxuICAgICA0LCAxNCwgMTIsICAgICAgNCwgMTIsICAwLCAgICAgIDQsICAwLCAgOCxcbiAgICAxMSwgIDksICA1LCAgICAgMTEsICA1LCAxOSwgICAgIDExLCAxOSwgIDcsXG4gICAgMTksICA1LCAxNCwgICAgIDE5LCAxNCwgIDQsICAgICAxOSwgIDQsIDE3LFxuICAgICAxLCAxMiwgMTQsICAgICAgMSwgMTQsICA1LCAgICAgIDEsICA1LCAgOVxuICBdO1xuXG4gIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxufTtcblxuVEhSRUUuRG9kZWNhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Eb2RlY2FoZWRyb25HZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvSWNvc2FoZWRyb25HZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcbiAqL1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuICB2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xuXG4gIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAtIDEsICB0LCAgMCwgICAgMSwgIHQsICAwLCAgIC0gMSwgLSB0LCAgMCwgICAgMSwgLSB0LCAgMCxcbiAgICAgMCwgLSAxLCAgdCwgICAgMCwgIDEsICB0LCAgICAwLCAtIDEsIC0gdCwgICAgMCwgIDEsIC0gdCxcbiAgICAgdCwgIDAsIC0gMSwgICAgdCwgIDAsICAxLCAgIC0gdCwgIDAsIC0gMSwgICAtIHQsICAwLCAgMVxuICBdO1xuXG4gIHZhciBpbmRpY2VzID0gW1xuICAgICAwLCAxMSwgIDUsICAgIDAsICA1LCAgMSwgICAgMCwgIDEsICA3LCAgICAwLCAgNywgMTAsICAgIDAsIDEwLCAxMSxcbiAgICAgMSwgIDUsICA5LCAgICA1LCAxMSwgIDQsICAgMTEsIDEwLCAgMiwgICAxMCwgIDcsICA2LCAgICA3LCAgMSwgIDgsXG4gICAgIDMsICA5LCAgNCwgICAgMywgIDQsICAyLCAgICAzLCAgMiwgIDYsICAgIDMsICA2LCAgOCwgICAgMywgIDgsICA5LFxuICAgICA0LCAgOSwgIDUsICAgIDIsICA0LCAxMSwgICAgNiwgIDIsIDEwLCAgICA4LCAgNiwgIDcsICAgIDksICA4LCAgMVxuICBdO1xuXG4gIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICB0aGlzLnR5cGUgPSAnSWNvc2FoZWRyb25HZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIGRldGFpbDogZGV0YWlsXG4gIH07XG59O1xuXG5USFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5JY29zYWhlZHJvbkdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9PY3RhaGVkcm9uR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XG4gKi9cblxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcblxuICB0aGlzLnBhcmFtZXRlcnMgPSB7XG4gICAgcmFkaXVzOiByYWRpdXMsXG4gICAgZGV0YWlsOiBkZXRhaWxcbiAgfTtcblxuICB2YXIgdmVydGljZXMgPSBbXG4gICAgMSwgMCwgMCwgICAtIDEsIDAsIDAsICAgIDAsIDEsIDAsICAgIDAsLSAxLCAwLCAgICAwLCAwLCAxLCAgICAwLCAwLC0gMVxuICBdO1xuXG4gIHZhciBpbmRpY2VzID0gW1xuICAgIDAsIDIsIDQsICAgIDAsIDQsIDMsICAgIDAsIDMsIDUsICAgIDAsIDUsIDIsICAgIDEsIDIsIDUsICAgIDEsIDUsIDMsICAgIDEsIDMsIDQsICAgIDEsIDQsIDJcbiAgXTtcblxuICBUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XG5cbiAgdGhpcy50eXBlID0gJ09jdGFoZWRyb25HZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIGRldGFpbDogZGV0YWlsXG4gIH07XG59O1xuXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvZ2VvbWV0cmllcy9UZXRyYWhlZHJvbkdlb21ldHJ5LmpzXG5cbi8qKlxuICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxuICovXG5cblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkgPSBmdW5jdGlvbiAoIHJhZGl1cywgZGV0YWlsICkge1xuXG4gIHZhciB2ZXJ0aWNlcyA9IFtcbiAgICAgMSwgIDEsICAxLCAgIC0gMSwgLSAxLCAgMSwgICAtIDEsICAxLCAtIDEsICAgIDEsIC0gMSwgLSAxXG4gIF07XG5cbiAgdmFyIGluZGljZXMgPSBbXG4gICAgIDIsICAxLCAgMCwgICAgMCwgIDMsICAyLCAgICAxLCAgMywgIDAsICAgIDIsICAzLCAgMVxuICBdO1xuXG4gIFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcblxuICB0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25HZW9tZXRyeSc7XG5cbiAgdGhpcy5wYXJhbWV0ZXJzID0ge1xuICAgIHJhZGl1czogcmFkaXVzLFxuICAgIGRldGFpbDogZGV0YWlsXG4gIH07XG5cbn07XG5cblRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XG5USFJFRS5UZXRyYWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlRldHJhaGVkcm9uR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9nZW9tZXRyaWVzL1BhcmFtZXRyaWNHZW9tZXRyeS5qc1xuXG4vKipcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XG4gKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XG4gKiBiYXNlZCBvbiB0aGUgYnJpbGxpYW50IGFydGljbGUgYnkgQHByaWRlb3V0IGh0dHA6Ly9wcmlkZW91dC5uZXQvYmxvZy8/cD00NFxuICpcbiAqIG5ldyBUSFJFRS5QYXJhbWV0cmljR2VvbWV0cnkoIHBhcmFtZXRyaWNGdW5jdGlvbiwgdVNlZ21lbnRzLCB5U2VnZW1lbnRzICk7XG4gKlxuICovXG5cblRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSA9IGZ1bmN0aW9uICggZnVuYywgc2xpY2VzLCBzdGFja3MgKSB7XG5cbiAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xuXG4gIHRoaXMudHlwZSA9ICdQYXJhbWV0cmljR2VvbWV0cnknO1xuXG4gIHRoaXMucGFyYW1ldGVycyA9IHtcbiAgICBmdW5jOiBmdW5jLFxuICAgIHNsaWNlczogc2xpY2VzLFxuICAgIHN0YWNrczogc3RhY2tzXG4gIH07XG5cbiAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgdmFyIGZhY2VzID0gdGhpcy5mYWNlcztcbiAgdmFyIHV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdO1xuXG4gIHZhciBpLCBqLCBwO1xuICB2YXIgdSwgdjtcblxuICB2YXIgc2xpY2VDb3VudCA9IHNsaWNlcyArIDE7XG5cbiAgZm9yICggaSA9IDA7IGkgPD0gc3RhY2tzOyBpICsrICkge1xuXG4gICAgdiA9IGkgLyBzdGFja3M7XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8PSBzbGljZXM7IGogKysgKSB7XG5cbiAgICAgIHUgPSBqIC8gc2xpY2VzO1xuXG4gICAgICBwID0gZnVuYyggdSwgdiApO1xuICAgICAgdmVydHMucHVzaCggcCApO1xuXG4gICAgfVxuICB9XG5cbiAgdmFyIGEsIGIsIGMsIGQ7XG4gIHZhciB1dmEsIHV2YiwgdXZjLCB1dmQ7XG5cbiAgZm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkgKysgKSB7XG5cbiAgICBmb3IgKCBqID0gMDsgaiA8IHNsaWNlczsgaiArKyApIHtcblxuICAgICAgYSA9IGkgKiBzbGljZUNvdW50ICsgajtcbiAgICAgIGIgPSBpICogc2xpY2VDb3VudCArIGogKyAxO1xuICAgICAgYyA9IChpICsgMSkgKiBzbGljZUNvdW50ICsgaiArIDE7XG4gICAgICBkID0gKGkgKyAxKSAqIHNsaWNlQ291bnQgKyBqO1xuXG4gICAgICB1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuICAgICAgdXZiID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xuICAgICAgdXZjID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG4gICAgICB1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XG5cbiAgICAgIGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgZCApICk7XG4gICAgICB1dnMucHVzaCggWyB1dmEsIHV2YiwgdXZkIF0gKTtcblxuICAgICAgZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBjLCBkICkgKTtcbiAgICAgIHV2cy5wdXNoKCBbIHV2Yi5jbG9uZSgpLCB1dmMsIHV2ZC5jbG9uZSgpIF0gKTtcblxuICAgIH1cblxuICB9XG5cbiAgLy8gY29uc29sZS5sb2codGhpcyk7XG5cbiAgLy8gbWFnaWMgYnVsbGV0XG4gIC8vIHZhciBkaWZmID0gdGhpcy5tZXJnZVZlcnRpY2VzKCk7XG4gIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xuXG4gIHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XG4gIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcblxufTtcblxuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuUGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2dlb21ldHJpZXMvV2lyZWZyYW1lR2VvbWV0cnkuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcblxuICBUSFJFRS5CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XG5cbiAgdmFyIGVkZ2UgPSBbIDAsIDAgXSwgaGFzaCA9IHt9O1xuICB2YXIgc29ydEZ1bmN0aW9uID0gZnVuY3Rpb24gKCBhLCBiICkgeyByZXR1cm4gYSAtIGIgfTtcblxuICB2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xuXG4gIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xuICAgIHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xuICAgIHZhciBudW1FZGdlcyA9IDA7XG5cbiAgICAvLyBhbGxvY2F0ZSBtYXhpbWFsIHNpemVcbiAgICB2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDYgKiBmYWNlcy5sZW5ndGggKTtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgICAgICBlZGdlWyAwIF0gPSBmYWNlWyBrZXlzWyBqIF0gXTtcbiAgICAgICAgZWRnZVsgMSBdID0gZmFjZVsga2V5c1sgKCBqICsgMSApICUgMyBdIF07XG4gICAgICAgIGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICAgICAgdmFyIGtleSA9IGVkZ2UudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoIGhhc2hbIGtleSBdID09PSB1bmRlZmluZWQgKSB7XG5cbiAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG4gICAgICAgICAgZWRnZXNbIDIgKiBudW1FZGdlcyArIDEgXSA9IGVkZ2VbIDEgXTtcbiAgICAgICAgICBoYXNoWyBrZXkgXSA9IHRydWU7XG4gICAgICAgICAgbnVtRWRnZXMgKys7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgY29vcmRzID0gbmV3IEZsb2F0MzJBcnJheSggbnVtRWRnZXMgKiAyICogMyApO1xuXG4gICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICBmb3IgKCB2YXIgaiA9IDA7IGogPCAyOyBqICsrICkge1xuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0aWNlc1sgZWRnZXMgWyAyICogaSArIGpdIF07XG5cbiAgICAgICAgdmFyIGluZGV4ID0gNiAqIGkgKyAzICogajtcbiAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRleC54O1xuICAgICAgICBjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGV4Lnk7XG4gICAgICAgIGNvb3Jkc1sgaW5kZXggKyAyIF0gPSB2ZXJ0ZXguejtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIGNvb3JkcywgMyApICk7XG5cbiAgfSBlbHNlIGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcblxuICAgIGlmICggZ2VvbWV0cnkuYXR0cmlidXRlcy5pbmRleCAhPT0gdW5kZWZpbmVkICkgeyAvLyBJbmRleGVkIEJ1ZmZlckdlb21ldHJ5XG5cbiAgICAgIHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG4gICAgICB2YXIgaW5kaWNlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMuaW5kZXguYXJyYXk7XG4gICAgICB2YXIgZHJhd2NhbGxzID0gZ2VvbWV0cnkuZHJhd2NhbGxzO1xuICAgICAgdmFyIG51bUVkZ2VzID0gMDtcblxuICAgICAgaWYgKCBkcmF3Y2FsbHMubGVuZ3RoID09PSAwICkge1xuXG4gICAgICAgIGRyYXdjYWxscyA9IFsgeyBjb3VudCA6IGluZGljZXMubGVuZ3RoLCBpbmRleCA6IDAsIHN0YXJ0IDogMCB9IF07XG5cbiAgICAgIH1cblxuICAgICAgLy8gYWxsb2NhdGUgbWF4aW1hbCBzaXplXG4gICAgICB2YXIgZWRnZXMgPSBuZXcgVWludDMyQXJyYXkoIDIgKiBpbmRpY2VzLmxlbmd0aCApO1xuXG4gICAgICBmb3IgKCB2YXIgbyA9IDAsIG9sID0gZHJhd2NhbGxzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xuXG4gICAgICAgIHZhciBzdGFydCA9IGRyYXdjYWxsc1sgbyBdLnN0YXJ0O1xuICAgICAgICB2YXIgY291bnQgPSBkcmF3Y2FsbHNbIG8gXS5jb3VudDtcbiAgICAgICAgdmFyIGluZGV4ID0gZHJhd2NhbGxzWyBvIF0uaW5kZXg7XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcblxuICAgICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cbiAgICAgICAgICAgIGVkZ2VbIDAgXSA9IGluZGV4ICsgaW5kaWNlc1sgaSArIGogXTtcbiAgICAgICAgICAgIGVkZ2VbIDEgXSA9IGluZGV4ICsgaW5kaWNlc1sgaSArICggaiArIDEgKSAlIDMgXTtcbiAgICAgICAgICAgIGVkZ2Uuc29ydCggc29ydEZ1bmN0aW9uICk7XG5cbiAgICAgICAgICAgIHZhciBrZXkgPSBlZGdlLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmICggaGFzaFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgICAgICAgICBlZGdlc1sgMiAqIG51bUVkZ2VzIF0gPSBlZGdlWyAwIF07XG4gICAgICAgICAgICAgIGVkZ2VzWyAyICogbnVtRWRnZXMgKyAxIF0gPSBlZGdlWyAxIF07XG4gICAgICAgICAgICAgIGhhc2hbIGtleSBdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbnVtRWRnZXMgKys7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtRWRnZXM7IGkgPCBsOyBpICsrICkge1xuXG4gICAgICAgIGZvciAoIHZhciBqID0gMDsgaiA8IDI7IGogKysgKSB7XG5cbiAgICAgICAgICB2YXIgaW5kZXggPSA2ICogaSArIDMgKiBqO1xuICAgICAgICAgIHZhciBpbmRleDIgPSBlZGdlc1syICogaSArIGpdO1xuXG4gICAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzLmdldFgoIGluZGV4MiApO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyAxIF0gPSB2ZXJ0aWNlcy5nZXRZKCBpbmRleDIgKTtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXMuZ2V0WiggaW5kZXgyICk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb29yZHMsIDMgKSApO1xuXG4gICAgfSBlbHNlIHsgLy8gbm9uLWluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcblxuICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcbiAgICAgIHZhciBudW1FZGdlcyA9IHZlcnRpY2VzLmxlbmd0aCAvIDM7XG4gICAgICB2YXIgbnVtVHJpcyA9IG51bUVkZ2VzIC8gMztcblxuICAgICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoIG51bUVkZ2VzICogMiAqIDMgKTtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbnVtVHJpczsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaiArKyApIHtcblxuICAgICAgICAgIHZhciBpbmRleCA9IDE4ICogaSArIDYgKiBqO1xuXG4gICAgICAgICAgdmFyIGluZGV4MSA9IDkgKiBpICsgMyAqIGo7XG4gICAgICAgICAgY29vcmRzWyBpbmRleCArIDAgXSA9IHZlcnRpY2VzWyBpbmRleDEgXTtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMSBdID0gdmVydGljZXNbIGluZGV4MSArIDEgXTtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMiBdID0gdmVydGljZXNbIGluZGV4MSArIDIgXTtcblxuICAgICAgICAgIHZhciBpbmRleDIgPSA5ICogaSArIDMgKiAoICggaiArIDEgKSAlIDMgKTtcbiAgICAgICAgICBjb29yZHNbIGluZGV4ICsgMyBdID0gdmVydGljZXNbIGluZGV4MiBdO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyA0IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMSBdO1xuICAgICAgICAgIGNvb3Jkc1sgaW5kZXggKyA1IF0gPSB2ZXJ0aWNlc1sgaW5kZXgyICsgMiBdO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IFRIUkVFLkJ1ZmZlckF0dHJpYnV0ZSggY29vcmRzLCAzICkgKTtcblxuICAgIH1cblxuICB9XG5cbn07XG5cblRIUkVFLldpcmVmcmFtZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xuVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnk7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0F4aXNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIHNyb3VjaGVyYXkgLyBodHRwOi8vc3JvdWNoZXJheS5vcmcvXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XG5cbiAgc2l6ZSA9IHNpemUgfHwgMTtcblxuICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgMCwgMCwgMCwgIHNpemUsIDAsIDAsXG4gICAgMCwgMCwgMCwgIDAsIHNpemUsIDAsXG4gICAgMCwgMCwgMCwgIDAsIDAsIHNpemVcbiAgXSApO1xuXG4gIHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBbXG4gICAgMSwgMCwgMCwgIDEsIDAuNiwgMCxcbiAgICAwLCAxLCAwLCAgMC42LCAxLCAwLFxuICAgIDAsIDAsIDEsICAwLCAwLjYsIDFcbiAgXSApO1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5CdWZmZXJHZW9tZXRyeSgpO1xuICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcbiAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG5USFJFRS5BeGlzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQXhpc0hlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQXJyb3dIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly9naXRodWIuY29tL3p6ODVcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxuICpcbiAqIENyZWF0ZXMgYW4gYXJyb3cgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnNcbiAqXG4gKiBQYXJhbWV0ZXJzOlxuICogIGRpciAtIFZlY3RvcjNcbiAqICBvcmlnaW4gLSBWZWN0b3IzXG4gKiAgbGVuZ3RoIC0gTnVtYmVyXG4gKiAgY29sb3IgLSBjb2xvciBpbiBoZXggdmFsdWVcbiAqICBoZWFkTGVuZ3RoIC0gTnVtYmVyXG4gKiAgaGVhZFdpZHRoIC0gTnVtYmVyXG4gKi9cblxuVEhSRUUuQXJyb3dIZWxwZXIgPSAoIGZ1bmN0aW9uICgpIHtcblxuICB2YXIgbGluZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIGxpbmVHZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApICk7XG5cbiAgdmFyIGNvbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcbiAgY29uZUdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbiggMCwgLSAwLjUsIDAgKSApO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGNvbG9yLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKSB7XG5cbiAgICAvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgICBpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xuICAgIGlmICggbGVuZ3RoID09PSB1bmRlZmluZWQgKSBsZW5ndGggPSAxO1xuICAgIGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcbiAgICBpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcblxuICAgIHRoaXMucG9zaXRpb24uY29weSggb3JpZ2luICk7XG5cbiAgICB0aGlzLmxpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuICAgIHRoaXMubGluZS5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5hZGQoIHRoaXMubGluZSApO1xuXG4gICAgdGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGNvbmVHZW9tZXRyeSwgbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcbiAgICB0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcblxuICAgIHRoaXMuc2V0RGlyZWN0aW9uKCBkaXIgKTtcbiAgICB0aGlzLnNldExlbmd0aCggbGVuZ3RoLCBoZWFkTGVuZ3RoLCBoZWFkV2lkdGggKTtcblxuICB9XG5cbn0oKSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkFycm93SGVscGVyO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gKCBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIGF4aXMgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICB2YXIgcmFkaWFucztcblxuICByZXR1cm4gZnVuY3Rpb24gKCBkaXIgKSB7XG5cbiAgICAvLyBkaXIgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXG5cbiAgICBpZiAoIGRpci55ID4gMC45OTk5OSApIHtcblxuICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldCggMCwgMCwgMCwgMSApO1xuXG4gICAgfSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XG5cbiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXQoIDEsIDAsIDAsIDAgKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGF4aXMuc2V0KCBkaXIueiwgMCwgLSBkaXIueCApLm5vcm1hbGl6ZSgpO1xuXG4gICAgICByYWRpYW5zID0gTWF0aC5hY29zKCBkaXIueSApO1xuXG4gICAgICB0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xuXG4gICAgfVxuXG4gIH07XG5cbn0oKSApO1xuXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGgsIGhlYWRMZW5ndGgsIGhlYWRXaWR0aCApIHtcblxuICBpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XG4gIGlmICggaGVhZFdpZHRoID09PSB1bmRlZmluZWQgKSBoZWFkV2lkdGggPSAwLjIgKiBoZWFkTGVuZ3RoO1xuXG4gIHRoaXMubGluZS5zY2FsZS5zZXQoIDEsIGxlbmd0aCAtIGhlYWRMZW5ndGgsIDEgKTtcbiAgdGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xuXG4gIHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XG4gIHRoaXMuY29uZS5wb3NpdGlvbi55ID0gbGVuZ3RoO1xuICB0aGlzLmNvbmUudXBkYXRlTWF0cml4KCk7XG5cbn07XG5cblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZS5zZXRDb2xvciA9IGZ1bmN0aW9uICggY29sb3IgKSB7XG5cbiAgdGhpcy5saW5lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcbiAgdGhpcy5jb25lLm1hdGVyaWFsLmNvbG9yLnNldCggY29sb3IgKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm94SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5Cb3hIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuQnVmZmVyR2VvbWV0cnkoKTtcbiAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgVEhSRUUuQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA3MiApLCAzICkgKTtcblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmMDAgfSApICk7XG5cbiAgaWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcblxuICAgIHRoaXMudXBkYXRlKCBvYmplY3QgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLkJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuQm94SGVscGVyO1xuXG5USFJFRS5Cb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcblxuICBpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ID09PSBudWxsICkge1xuXG4gICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cbiAgfVxuXG4gIHZhciBtaW4gPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5taW47XG4gIHZhciBtYXggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5tYXg7XG5cbiAgLypcbiAgICA1X19fXzRcbiAgMS9fX18wL3xcbiAgfCA2X198XzdcbiAgMi9fX18zL1xuXG4gIDA6IG1heC54LCBtYXgueSwgbWF4LnpcbiAgMTogbWluLngsIG1heC55LCBtYXguelxuICAyOiBtaW4ueCwgbWluLnksIG1heC56XG4gIDM6IG1heC54LCBtaW4ueSwgbWF4LnpcbiAgNDogbWF4LngsIG1heC55LCBtaW4uelxuICA1OiBtaW4ueCwgbWF4LnksIG1pbi56XG4gIDY6IG1pbi54LCBtaW4ueSwgbWluLnpcbiAgNzogbWF4LngsIG1pbi55LCBtaW4uelxuICAqL1xuXG4gIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcblxuICB2ZXJ0aWNlc1sgIDAgXSA9IG1heC54OyB2ZXJ0aWNlc1sgIDEgXSA9IG1heC55OyB2ZXJ0aWNlc1sgIDIgXSA9IG1heC56O1xuICB2ZXJ0aWNlc1sgIDMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgIDQgXSA9IG1heC55OyB2ZXJ0aWNlc1sgIDUgXSA9IG1heC56O1xuXG4gIHZlcnRpY2VzWyAgNiBdID0gbWluLng7IHZlcnRpY2VzWyAgNyBdID0gbWF4Lnk7IHZlcnRpY2VzWyAgOCBdID0gbWF4Lno7XG4gIHZlcnRpY2VzWyAgOSBdID0gbWluLng7IHZlcnRpY2VzWyAxMCBdID0gbWluLnk7IHZlcnRpY2VzWyAxMSBdID0gbWF4Lno7XG5cbiAgdmVydGljZXNbIDEyIF0gPSBtaW4ueDsgdmVydGljZXNbIDEzIF0gPSBtaW4ueTsgdmVydGljZXNbIDE0IF0gPSBtYXguejtcbiAgdmVydGljZXNbIDE1IF0gPSBtYXgueDsgdmVydGljZXNbIDE2IF0gPSBtaW4ueTsgdmVydGljZXNbIDE3IF0gPSBtYXguejtcblxuICB2ZXJ0aWNlc1sgMTggXSA9IG1heC54OyB2ZXJ0aWNlc1sgMTkgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMjAgXSA9IG1heC56O1xuICB2ZXJ0aWNlc1sgMjEgXSA9IG1heC54OyB2ZXJ0aWNlc1sgMjIgXSA9IG1heC55OyB2ZXJ0aWNlc1sgMjMgXSA9IG1heC56O1xuXG4gIC8vXG5cbiAgdmVydGljZXNbIDI0IF0gPSBtYXgueDsgdmVydGljZXNbIDI1IF0gPSBtYXgueTsgdmVydGljZXNbIDI2IF0gPSBtaW4uejtcbiAgdmVydGljZXNbIDI3IF0gPSBtaW4ueDsgdmVydGljZXNbIDI4IF0gPSBtYXgueTsgdmVydGljZXNbIDI5IF0gPSBtaW4uejtcblxuICB2ZXJ0aWNlc1sgMzAgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMzEgXSA9IG1heC55OyB2ZXJ0aWNlc1sgMzIgXSA9IG1pbi56O1xuICB2ZXJ0aWNlc1sgMzMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgMzQgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgMzUgXSA9IG1pbi56O1xuXG4gIHZlcnRpY2VzWyAzNiBdID0gbWluLng7IHZlcnRpY2VzWyAzNyBdID0gbWluLnk7IHZlcnRpY2VzWyAzOCBdID0gbWluLno7XG4gIHZlcnRpY2VzWyAzOSBdID0gbWF4Lng7IHZlcnRpY2VzWyA0MCBdID0gbWluLnk7IHZlcnRpY2VzWyA0MSBdID0gbWluLno7XG5cbiAgdmVydGljZXNbIDQyIF0gPSBtYXgueDsgdmVydGljZXNbIDQzIF0gPSBtaW4ueTsgdmVydGljZXNbIDQ0IF0gPSBtaW4uejtcbiAgdmVydGljZXNbIDQ1IF0gPSBtYXgueDsgdmVydGljZXNbIDQ2IF0gPSBtYXgueTsgdmVydGljZXNbIDQ3IF0gPSBtaW4uejtcblxuICAvL1xuXG4gIHZlcnRpY2VzWyA0OCBdID0gbWF4Lng7IHZlcnRpY2VzWyA0OSBdID0gbWF4Lnk7IHZlcnRpY2VzWyA1MCBdID0gbWF4Lno7XG4gIHZlcnRpY2VzWyA1MSBdID0gbWF4Lng7IHZlcnRpY2VzWyA1MiBdID0gbWF4Lnk7IHZlcnRpY2VzWyA1MyBdID0gbWluLno7XG5cbiAgdmVydGljZXNbIDU0IF0gPSBtaW4ueDsgdmVydGljZXNbIDU1IF0gPSBtYXgueTsgdmVydGljZXNbIDU2IF0gPSBtYXguejtcbiAgdmVydGljZXNbIDU3IF0gPSBtaW4ueDsgdmVydGljZXNbIDU4IF0gPSBtYXgueTsgdmVydGljZXNbIDU5IF0gPSBtaW4uejtcblxuICB2ZXJ0aWNlc1sgNjAgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNjEgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgNjIgXSA9IG1heC56O1xuICB2ZXJ0aWNlc1sgNjMgXSA9IG1pbi54OyB2ZXJ0aWNlc1sgNjQgXSA9IG1pbi55OyB2ZXJ0aWNlc1sgNjUgXSA9IG1pbi56O1xuXG4gIHZlcnRpY2VzWyA2NiBdID0gbWF4Lng7IHZlcnRpY2VzWyA2NyBdID0gbWluLnk7IHZlcnRpY2VzWyA2OCBdID0gbWF4Lno7XG4gIHZlcnRpY2VzWyA2OSBdID0gbWF4Lng7IHZlcnRpY2VzWyA3MCBdID0gbWluLnk7IHZlcnRpY2VzWyA3MSBdID0gbWluLno7XG5cbiAgdGhpcy5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICB0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG4gIHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQm91bmRpbmdCb3hIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG4vLyBhIGhlbHBlciB0byBzaG93IHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGZvciBhbiBvYmplY3RcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xuXG4gIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ODg4ODg4O1xuXG4gIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gIHRoaXMuYm94ID0gbmV3IFRIUkVFLkJveDMoKTtcblxuICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSggMSwgMSwgMSApLCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCB3aXJlZnJhbWU6IHRydWUgfSApICk7XG5cbn07XG5cblRIUkVFLkJvdW5kaW5nQm94SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Cb3VuZGluZ0JveEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Cb3VuZGluZ0JveEhlbHBlcjtcblxuVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmJveC5zZXRGcm9tT2JqZWN0KCB0aGlzLm9iamVjdCApO1xuXG4gIHRoaXMuYm94LnNpemUoIHRoaXMuc2NhbGUgKTtcblxuICB0aGlzLmJveC5jZW50ZXIoIHRoaXMucG9zaXRpb24gKTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvQ2FtZXJhSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqXG4gKiAgLSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXG4gKiAgLSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXG4gKiAgLSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxuICogICAgaHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxuICovXG5cblRIUkVFLkNhbWVyYUhlbHBlciA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMgfSApO1xuXG4gIHZhciBwb2ludE1hcCA9IHt9O1xuXG4gIC8vIGNvbG9yc1xuXG4gIHZhciBoZXhGcnVzdHVtID0gMHhmZmFhMDA7XG4gIHZhciBoZXhDb25lID0gMHhmZjAwMDA7XG4gIHZhciBoZXhVcCA9IDB4MDBhYWZmO1xuICB2YXIgaGV4VGFyZ2V0ID0gMHhmZmZmZmY7XG4gIHZhciBoZXhDcm9zcyA9IDB4MzMzMzMzO1xuXG4gIC8vIG5lYXJcblxuICBhZGRMaW5lKCBcIm4xXCIsIFwibjJcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcIm4yXCIsIFwibjRcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcIm40XCIsIFwibjNcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcIm4zXCIsIFwibjFcIiwgaGV4RnJ1c3R1bSApO1xuXG4gIC8vIGZhclxuXG4gIGFkZExpbmUoIFwiZjFcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwiZjJcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwiZjRcIiwgXCJmM1wiLCBoZXhGcnVzdHVtICk7XG4gIGFkZExpbmUoIFwiZjNcIiwgXCJmMVwiLCBoZXhGcnVzdHVtICk7XG5cbiAgLy8gc2lkZXNcblxuICBhZGRMaW5lKCBcIm4xXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcIm4yXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcIm4zXCIsIFwiZjNcIiwgaGV4RnJ1c3R1bSApO1xuICBhZGRMaW5lKCBcIm40XCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xuXG4gIC8vIGNvbmVcblxuICBhZGRMaW5lKCBcInBcIiwgXCJuMVwiLCBoZXhDb25lICk7XG4gIGFkZExpbmUoIFwicFwiLCBcIm4yXCIsIGhleENvbmUgKTtcbiAgYWRkTGluZSggXCJwXCIsIFwibjNcIiwgaGV4Q29uZSApO1xuICBhZGRMaW5lKCBcInBcIiwgXCJuNFwiLCBoZXhDb25lICk7XG5cbiAgLy8gdXBcblxuICBhZGRMaW5lKCBcInUxXCIsIFwidTJcIiwgaGV4VXAgKTtcbiAgYWRkTGluZSggXCJ1MlwiLCBcInUzXCIsIGhleFVwICk7XG4gIGFkZExpbmUoIFwidTNcIiwgXCJ1MVwiLCBoZXhVcCApO1xuXG4gIC8vIHRhcmdldFxuXG4gIGFkZExpbmUoIFwiY1wiLCBcInRcIiwgaGV4VGFyZ2V0ICk7XG4gIGFkZExpbmUoIFwicFwiLCBcImNcIiwgaGV4Q3Jvc3MgKTtcblxuICAvLyBjcm9zc1xuXG4gIGFkZExpbmUoIFwiY24xXCIsIFwiY24yXCIsIGhleENyb3NzICk7XG4gIGFkZExpbmUoIFwiY24zXCIsIFwiY240XCIsIGhleENyb3NzICk7XG5cbiAgYWRkTGluZSggXCJjZjFcIiwgXCJjZjJcIiwgaGV4Q3Jvc3MgKTtcbiAgYWRkTGluZSggXCJjZjNcIiwgXCJjZjRcIiwgaGV4Q3Jvc3MgKTtcblxuICBmdW5jdGlvbiBhZGRMaW5lKCBhLCBiLCBoZXggKSB7XG5cbiAgICBhZGRQb2ludCggYSwgaGV4ICk7XG4gICAgYWRkUG9pbnQoIGIsIGhleCApO1xuXG4gIH1cblxuICBmdW5jdGlvbiBhZGRQb2ludCggaWQsIGhleCApIHtcblxuICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCBoZXggKSApO1xuXG4gICAgaWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xuXG4gICAgICBwb2ludE1hcFsgaWQgXSA9IFtdO1xuXG4gICAgfVxuXG4gICAgcG9pbnRNYXBbIGlkIF0ucHVzaCggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoIC0gMSApO1xuXG4gIH1cblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XG5cbiAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gIHRoaXMubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxuICB0aGlzLnBvaW50TWFwID0gcG9pbnRNYXA7XG5cbiAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5DYW1lcmFIZWxwZXI7XG5cblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBnZW9tZXRyeSwgcG9pbnRNYXA7XG5cbiAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciBjYW1lcmEgPSBuZXcgVEhSRUUuQ2FtZXJhKCk7XG5cbiAgdmFyIHNldFBvaW50ID0gZnVuY3Rpb24gKCBwb2ludCwgeCwgeSwgeiApIHtcblxuICAgIHZlY3Rvci5zZXQoIHgsIHksIHogKS51bnByb2plY3QoIGNhbWVyYSApO1xuXG4gICAgdmFyIHBvaW50cyA9IHBvaW50TWFwWyBwb2ludCBdO1xuXG4gICAgaWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcblxuICAgICAgZm9yICggdmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcblxuICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc1sgcG9pbnRzWyBpIF0gXS5jb3B5KCB2ZWN0b3IgKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblxuICAgIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICBwb2ludE1hcCA9IHRoaXMucG9pbnRNYXA7XG5cbiAgICB2YXIgdyA9IDEsIGggPSAxO1xuXG4gICAgLy8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeFxuICAgIC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XG5cbiAgICBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5jb3B5KCB0aGlzLmNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XG5cbiAgICAvLyBjZW50ZXIgLyB0YXJnZXRcblxuICAgIHNldFBvaW50KCBcImNcIiwgMCwgMCwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwidFwiLCAwLCAwLCAgMSApO1xuXG4gICAgLy8gbmVhclxuXG4gICAgc2V0UG9pbnQoIFwibjFcIiwgLSB3LCAtIGgsIC0gMSApO1xuICAgIHNldFBvaW50KCBcIm4yXCIsICAgdywgLSBoLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJuM1wiLCAtIHcsICAgaCwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwibjRcIiwgICB3LCAgIGgsIC0gMSApO1xuXG4gICAgLy8gZmFyXG5cbiAgICBzZXRQb2ludCggXCJmMVwiLCAtIHcsIC0gaCwgMSApO1xuICAgIHNldFBvaW50KCBcImYyXCIsICAgdywgLSBoLCAxICk7XG4gICAgc2V0UG9pbnQoIFwiZjNcIiwgLSB3LCAgIGgsIDEgKTtcbiAgICBzZXRQb2ludCggXCJmNFwiLCAgIHcsICAgaCwgMSApO1xuXG4gICAgLy8gdXBcblxuICAgIHNldFBvaW50KCBcInUxXCIsICAgdyAqIDAuNywgaCAqIDEuMSwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwidTJcIiwgLSB3ICogMC43LCBoICogMS4xLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJ1M1wiLCAgICAgICAgIDAsIGggKiAyLCAgIC0gMSApO1xuXG4gICAgLy8gY3Jvc3NcblxuICAgIHNldFBvaW50KCBcImNmMVwiLCAtIHcsICAgMCwgMSApO1xuICAgIHNldFBvaW50KCBcImNmMlwiLCAgIHcsICAgMCwgMSApO1xuICAgIHNldFBvaW50KCBcImNmM1wiLCAgIDAsIC0gaCwgMSApO1xuICAgIHNldFBvaW50KCBcImNmNFwiLCAgIDAsICAgaCwgMSApO1xuXG4gICAgc2V0UG9pbnQoIFwiY24xXCIsIC0gdywgICAwLCAtIDEgKTtcbiAgICBzZXRQb2ludCggXCJjbjJcIiwgICB3LCAgIDAsIC0gMSApO1xuICAgIHNldFBvaW50KCBcImNuM1wiLCAgIDAsIC0gaCwgLSAxICk7XG4gICAgc2V0UG9pbnQoIFwiY240XCIsICAgMCwgICBoLCAtIDEgKTtcblxuICAgIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgfTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9EaXJlY3Rpb25hbExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiAqL1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc2l6ZSApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgdGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgc2l6ZSA9IHNpemUgfHwgMTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcbiAgZ2VvbWV0cnkudmVydGljZXMucHVzaChcbiAgICBuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKSxcbiAgICBuZXcgVEhSRUUuVmVjdG9yMyggICBzaXplLCAgIHNpemUsIDAgKSxcbiAgICBuZXcgVEhSRUUuVmVjdG9yMyggICBzaXplLCAtIHNpemUsIDAgKSxcbiAgICBuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAtIHNpemUsIDAgKSxcbiAgICBuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAgIHNpemUsIDAgKVxuICApO1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBmb2c6IGZhbHNlIH0gKTtcbiAgbWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gIHRoaXMubGlnaHRQbGFuZSA9IG5ldyBUSFJFRS5MaW5lKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgdGhpcy5hZGQoIHRoaXMubGlnaHRQbGFuZSApO1xuXG4gIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG4gICAgbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgICBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICk7XG5cbiAgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XG4gIG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICB0aGlzLnRhcmdldExpbmUgPSBuZXcgVEhSRUUuTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gIHRoaXMuYWRkKCB0aGlzLnRhcmdldExpbmUgKTtcblxuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuXG4gIHRoaXMubGlnaHRQbGFuZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gIHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG4gIHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gIHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5kaXNwb3NlKCk7XG59O1xuXG5USFJFRS5EaXJlY3Rpb25hbExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcbiAgdmFyIHYzID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgdjEuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgdjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xuICAgIHYzLnN1YlZlY3RvcnMoIHYyLCB2MSApO1xuXG4gICAgdGhpcy5saWdodFBsYW5lLmxvb2tBdCggdjMgKTtcbiAgICB0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCB0aGlzLmxpZ2h0LmludGVuc2l0eSApO1xuXG4gICAgdGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzWyAxIF0uY29weSggdjMgKTtcbiAgICB0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodFBsYW5lLm1hdGVyaWFsLmNvbG9yICk7XG5cbiAgfTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9FZGdlc0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuICogQHBhcmFtIG9iamVjdCBUSFJFRS5NZXNoIHdob3NlIGdlb21ldHJ5IHdpbGwgYmUgdXNlZFxuICogQHBhcmFtIGhleCBsaW5lIGNvbG9yXG4gKiBAcGFyYW0gdGhyZXNob2xkQW5nbGUgdGhlIG1pbmltaW0gYW5nbGUgKGluIGRlZ3JlZXMpLFxuICogYmV0d2VlbiB0aGUgZmFjZSBub3JtYWxzIG9mIGFkamFjZW50IGZhY2VzLFxuICogdGhhdCBpcyByZXF1aXJlZCB0byByZW5kZXIgYW4gZWRnZS4gQSB2YWx1ZSBvZiAxMCBtZWFuc1xuICogYW4gZWRnZSBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBhbmdsZSBpcyBhdCBsZWFzdCAxMCBkZWdyZWVzLlxuICovXG5cblRIUkVFLkVkZ2VzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIGhleCwgdGhyZXNob2xkQW5nbGUgKSB7XG5cbiAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmZmY7XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIG5ldyBUSFJFRS5FZGdlc0dlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnksIHRocmVzaG9sZEFuZ2xlICksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XG5cbiAgdGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG59O1xuXG5USFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5FZGdlc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5FZGdlc0hlbHBlcjtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvRmFjZU5vcm1hbHNIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XG4qL1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICB0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cbiAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XG5cbiAgdmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICB2YXIgZmFjZXMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS5mYWNlcztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgZ2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSApO1xuXG4gIH1cblxuICBUSFJFRS5MaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IsIGxpbmV3aWR0aDogd2lkdGggfSApICk7XG5cbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy5ub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkZhY2VOb3JtYWxzSGVscGVyO1xuXG5USFJFRS5GYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgdmFyIG9iamVjdCA9IHRoaXMub2JqZWN0O1xuICB2YXIgb2JqZWN0VmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XG4gIHZhciBvYmplY3RGYWNlcyA9IG9iamVjdC5nZW9tZXRyeS5mYWNlcztcbiAgdmFyIG9iamVjdFdvcmxkTWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuXG4gIG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xuXG4gIHRoaXMubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggb2JqZWN0V29ybGRNYXRyaXggKTtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGkyID0gMCwgbCA9IG9iamVjdEZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKyssIGkyICs9IDIgKSB7XG5cbiAgICB2YXIgZmFjZSA9IG9iamVjdEZhY2VzWyBpIF07XG5cbiAgICB2ZXJ0aWNlc1sgaTIgXS5jb3B5KCBvYmplY3RWZXJ0aWNlc1sgZmFjZS5hIF0gKVxuICAgICAgLmFkZCggb2JqZWN0VmVydGljZXNbIGZhY2UuYiBdIClcbiAgICAgIC5hZGQoIG9iamVjdFZlcnRpY2VzWyBmYWNlLmMgXSApXG4gICAgICAuZGl2aWRlU2NhbGFyKCAzIClcbiAgICAgIC5hcHBseU1hdHJpeDQoIG9iamVjdFdvcmxkTWF0cml4ICk7XG5cbiAgICB2ZXJ0aWNlc1sgaTIgKyAxIF0uY29weSggZmFjZS5ub3JtYWwgKVxuICAgICAgLmFwcGx5TWF0cml4MyggdGhpcy5ub3JtYWxNYXRyaXggKVxuICAgICAgLm5vcm1hbGl6ZSgpXG4gICAgICAubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApXG4gICAgICAuYWRkKCB2ZXJ0aWNlc1sgaTIgXSApO1xuXG4gIH1cblxuICB0aGlzLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL0dyaWRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cblRIUkVFLkdyaWRIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUsIHN0ZXAgKSB7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLlZlcnRleENvbG9ycyB9ICk7XG5cbiAgdGhpcy5jb2xvcjEgPSBuZXcgVEhSRUUuQ29sb3IoIDB4NDQ0NDQ0ICk7XG4gIHRoaXMuY29sb3IyID0gbmV3IFRIUkVFLkNvbG9yKCAweDg4ODg4OCApO1xuXG4gIGZvciAoIHZhciBpID0gLSBzaXplOyBpIDw9IHNpemU7IGkgKz0gc3RlcCApIHtcblxuICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyggLSBzaXplLCAwLCBpICksIG5ldyBUSFJFRS5WZWN0b3IzKCBzaXplLCAwLCBpICksXG4gICAgICBuZXcgVEhSRUUuVmVjdG9yMyggaSwgMCwgLSBzaXplICksIG5ldyBUSFJFRS5WZWN0b3IzKCBpLCAwLCBzaXplIClcbiAgICApO1xuXG4gICAgdmFyIGNvbG9yID0gaSA9PT0gMCA/IHRoaXMuY29sb3IxIDogdGhpcy5jb2xvcjI7XG5cbiAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggY29sb3IsIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcblxuICB9XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG59O1xuXG5USFJFRS5HcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLkdyaWRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuR3JpZEhlbHBlcjtcblxuVEhSRUUuR3JpZEhlbHBlci5wcm90b3R5cGUuc2V0Q29sb3JzID0gZnVuY3Rpb24oIGNvbG9yQ2VudGVyTGluZSwgY29sb3JHcmlkICkge1xuXG4gIHRoaXMuY29sb3IxLnNldCggY29sb3JDZW50ZXJMaW5lICk7XG4gIHRoaXMuY29sb3IyLnNldCggY29sb3JHcmlkICk7XG5cbiAgdGhpcy5nZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcblxufTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvSGVtaXNwaGVyZUxpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgdGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy5jb2xvcnMgPSBbIG5ldyBUSFJFRS5Db2xvcigpLCBuZXcgVEhSRUUuQ29sb3IoKSBdO1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgNCwgMiApO1xuICBnZW9tZXRyeS5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlUm90YXRpb25YKCAtIE1hdGguUEkgLyAyICkgKTtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gODsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgZ2VvbWV0cnkuZmFjZXNbIGkgXS5jb2xvciA9IHRoaXMuY29sb3JzWyBpIDwgNCA/IDAgOiAxIF07XG5cbiAgfVxuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLkZhY2VDb2xvcnMsIHdpcmVmcmFtZTogdHJ1ZSB9ICk7XG5cbiAgdGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcbiAgdGhpcy5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcblxuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyO1xuXG5USFJFRS5IZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMubGlnaHRTcGhlcmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLmRpc3Bvc2UoKTtcbn07XG5cblRIUkVFLkhlbWlzcGhlcmVMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmNvbG9yc1sgMCBdLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcbiAgICB0aGlzLmNvbG9yc1sgMSBdLmNvcHkoIHRoaXMubGlnaHQuZ3JvdW5kQ29sb3IgKS5tdWx0aXBseVNjYWxhciggdGhpcy5saWdodC5pbnRlbnNpdHkgKTtcblxuICAgIHRoaXMubGlnaHRTcGhlcmUubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcbiAgICB0aGlzLmxpZ2h0U3BoZXJlLmdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gIH1cblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9Qb2ludExpZ2h0SGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKi9cblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XG5cbiAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XG4gIHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xuICBtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgVEhSRUUuTWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcblxuICB0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIC8qXG4gIHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcbiAgdmFyIGRpc3RhbmNlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlLCB3aXJlZnJhbWU6IHRydWUsIG9wYWNpdHk6IDAuMSwgdHJhbnNwYXJlbnQ6IHRydWUgfSApO1xuXG4gIHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcbiAgdGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcblxuICB2YXIgZCA9IGxpZ2h0LmRpc3RhbmNlO1xuXG4gIGlmICggZCA9PT0gMC4wICkge1xuXG4gICAgdGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuICB9IGVsc2Uge1xuXG4gICAgdGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xuXG4gIH1cblxuICB0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XG4gICovXG5cbn07XG5cblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuUG9pbnRMaWdodEhlbHBlcjtcblxuVEhSRUUuUG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcbiAgdGhpcy5tYXRlcmlhbC5kaXNwb3NlKCk7XG59O1xuXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdGhpcy5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgLypcbiAgdmFyIGQgPSB0aGlzLmxpZ2h0LmRpc3RhbmNlO1xuXG4gIGlmICggZCA9PT0gMC4wICkge1xuXG4gICAgdGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcblxuICB9IGVsc2Uge1xuXG4gICAgdGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMubGlnaHREaXN0YW5jZS5zY2FsZS5zZXQoIGQsIGQsIGQgKTtcblxuICB9XG4gICovXG5cbn07XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9oZWxwZXJzL1NrZWxldG9uSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBTZWFuIEdyaWZmaW4gLyBodHRwOi8vdHdpdHRlci5jb20vc2dyaWZcbiAqIEBhdXRob3IgTWljaGFlbCBHdWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXG4gKi9cblxuVEhSRUUuU2tlbGV0b25IZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICB0aGlzLmJvbmVzID0gdGhpcy5nZXRCb25lTGlzdCggb2JqZWN0ICk7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5ib25lcy5sZW5ndGg7IGkgKysgKSB7XG5cbiAgICB2YXIgYm9uZSA9IHRoaXMuYm9uZXNbIGkgXTtcblxuICAgIGlmICggYm9uZS5wYXJlbnQgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xuXG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMygpICk7XG4gICAgICBnZW9tZXRyeS5jb2xvcnMucHVzaCggbmV3IFRIUkVFLkNvbG9yKCAwLCAwLCAxICkgKTtcbiAgICAgIGdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIDAsIDEsIDAgKSApO1xuXG4gICAgfVxuXG4gIH1cblxuICBnZW9tZXRyeS5keW5hbWljID0gdHJ1ZTtcblxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMsIGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMucm9vdCA9IG9iamVjdDtcblxuICB0aGlzLm1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuXG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lU2VnbWVudHMucHJvdG90eXBlICk7XG5USFJFRS5Ta2VsZXRvbkhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Ta2VsZXRvbkhlbHBlcjtcblxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLmdldEJvbmVMaXN0ID0gZnVuY3Rpb24oIG9iamVjdCApIHtcblxuICB2YXIgYm9uZUxpc3QgPSBbXTtcblxuICBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cbiAgICBib25lTGlzdC5wdXNoKCBvYmplY3QgKTtcblxuICB9XG5cbiAgZm9yICggdmFyIGkgPSAwOyBpIDwgb2JqZWN0LmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcblxuICAgIGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCB0aGlzLmdldEJvbmVMaXN0KCBvYmplY3QuY2hpbGRyZW5bIGkgXSApICk7XG5cbiAgfVxuXG4gIHJldHVybiBib25lTGlzdDtcblxufTtcblxuVEhSRUUuU2tlbGV0b25IZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuXG4gIHZhciBtYXRyaXhXb3JsZEludiA9IG5ldyBUSFJFRS5NYXRyaXg0KCkuZ2V0SW52ZXJzZSggdGhpcy5yb290Lm1hdHJpeFdvcmxkICk7XG5cbiAgdmFyIGJvbmVNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuXG4gIHZhciBqID0gMDtcblxuICBmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmJvbmVzLmxlbmd0aDsgaSArKyApIHtcblxuICAgIHZhciBib25lID0gdGhpcy5ib25lc1sgaSBdO1xuXG4gICAgaWYgKCBib25lLnBhcmVudCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgKSB7XG5cbiAgICAgIGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUubWF0cml4V29ybGQgKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzWyBqIF0uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBib25lTWF0cml4ICk7XG5cbiAgICAgIGJvbmVNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggbWF0cml4V29ybGRJbnYsIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XG4gICAgICBnZW9tZXRyeS52ZXJ0aWNlc1sgaiArIDEgXS5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcblxuICAgICAgaiArPSAyO1xuXG4gICAgfVxuXG4gIH1cblxuICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xuXG59O1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9TcG90TGlnaHRIZWxwZXIuanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCApIHtcblxuICBUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XG5cbiAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICB0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG5cbiAgdGhpcy5tYXRyaXggPSBsaWdodC5tYXRyaXhXb3JsZDtcbiAgdGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XG5cbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN5bGluZGVyR2VvbWV0cnkoIDAsIDEsIDEsIDgsIDEsIHRydWUgKTtcblxuICBnZW9tZXRyeS5hcHBseU1hdHJpeCggbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24oIDAsIC0gMC41LCAwICkgKTtcbiAgZ2VvbWV0cnkuYXBwbHlNYXRyaXgoIG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVJvdGF0aW9uWCggLSBNYXRoLlBJIC8gMiApICk7XG5cbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XG5cbiAgdGhpcy5jb25lID0gbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuICB0aGlzLmFkZCggdGhpcy5jb25lICk7XG5cbiAgdGhpcy51cGRhdGUoKTtcblxufTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlNwb3RMaWdodEhlbHBlcjtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICB0aGlzLmNvbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xufTtcblxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgdmFyIHZlY3RvciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gIHZhciB2ZWN0b3IyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDAwO1xuICAgIHZhciBjb25lV2lkdGggPSBjb25lTGVuZ3RoICogTWF0aC50YW4oIHRoaXMubGlnaHQuYW5nbGUgKTtcblxuICAgIHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XG5cbiAgICB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICk7XG4gICAgdmVjdG9yMi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XG5cbiAgICB0aGlzLmNvbmUubG9va0F0KCB2ZWN0b3IyLnN1YiggdmVjdG9yICkgKTtcblxuICAgIHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIHRoaXMubGlnaHQuaW50ZW5zaXR5ICk7XG5cbiAgfTtcblxufSgpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhOb3JtYWxzSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxuKi9cblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlciA9IGZ1bmN0aW9uICggb2JqZWN0LCBzaXplLCBoZXgsIGxpbmV3aWR0aCApIHtcblxuICB0aGlzLm9iamVjdCA9IG9iamVjdDtcblxuICB0aGlzLnNpemUgPSAoIHNpemUgIT09IHVuZGVmaW5lZCApID8gc2l6ZSA6IDE7XG5cbiAgdmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZjAwMDA7XG5cbiAgdmFyIHdpZHRoID0gKCBsaW5ld2lkdGggIT09IHVuZGVmaW5lZCApID8gbGluZXdpZHRoIDogMTtcblxuICB2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcblxuICB2YXIgZmFjZXMgPSBvYmplY3QuZ2VvbWV0cnkuZmFjZXM7XG5cbiAgZm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgIGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCksIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcblxuICAgIH1cblxuICB9XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xuXG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHRoaXMubm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcblxuICB0aGlzLnVwZGF0ZSgpO1xuXG59O1xuXG5USFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLlZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlcjtcblxuVEhSRUUuVmVydGV4Tm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXG4gICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIHRoaXMubm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICB2YXIgdmVydHMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIHZhciBmYWNlcyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXG4gICAgdmFyIHdvcmxkTWF0cml4ID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cbiAgICB2YXIgaWR4ID0gMDtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcblxuICAgICAgICB2YXIgdmVydGV4SWQgPSBmYWNlWyBrZXlzWyBqIF0gXTtcbiAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRzWyB2ZXJ0ZXhJZCBdO1xuXG4gICAgICAgIHZhciBub3JtYWwgPSBmYWNlLnZlcnRleE5vcm1hbHNbIGogXTtcblxuICAgICAgICB2ZXJ0aWNlc1sgaWR4IF0uY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCB3b3JsZE1hdHJpeCApO1xuXG4gICAgICAgIHYxLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4MyggdGhpcy5ub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggdGhpcy5zaXplICk7XG5cbiAgICAgICAgdjEuYWRkKCB2ZXJ0aWNlc1sgaWR4IF0gKTtcbiAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgICB2ZXJ0aWNlc1sgaWR4IF0uY29weSggdjEgKTtcbiAgICAgICAgaWR4ID0gaWR4ICsgMTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5nZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgfVxuXG59KCkpO1xuXG4vLyBGaWxlOnNyYy9leHRyYXMvaGVscGVycy9WZXJ0ZXhUYW5nZW50c0hlbHBlci5qc1xuXG4vKipcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcbiovXG5cblRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyID0gZnVuY3Rpb24gKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xuXG4gIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuXG4gIHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcblxuICB2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweDAwMDBmZjtcblxuICB2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xuXG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuXG4gIHZhciBmYWNlcyA9IG9iamVjdC5nZW9tZXRyeS5mYWNlcztcblxuICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG4gICAgdmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xuXG4gICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4VGFuZ2VudHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcbiAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcblxuICAgIH1cblxuICB9XG5cbiAgVEhSRUUuTGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBsaW5ld2lkdGg6IHdpZHRoIH0gKSApO1xuXG4gIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xuXG4gIHRoaXMudXBkYXRlKCk7XG5cbn07XG5cblRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLlZlcnRleFRhbmdlbnRzSGVscGVyO1xuXG5USFJFRS5WZXJ0ZXhUYW5nZW50c0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoIG9iamVjdCApIHtcblxuICB2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuXG4gIHJldHVybiBmdW5jdGlvbiggb2JqZWN0ICkge1xuXG4gICAgdmFyIGtleXMgPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xuXG4gICAgdGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcblxuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkudmVydGljZXM7XG5cbiAgICB2YXIgdmVydHMgPSB0aGlzLm9iamVjdC5nZW9tZXRyeS52ZXJ0aWNlcztcblxuICAgIHZhciBmYWNlcyA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5LmZhY2VzO1xuXG4gICAgdmFyIHdvcmxkTWF0cml4ID0gdGhpcy5vYmplY3QubWF0cml4V29ybGQ7XG5cbiAgICB2YXIgaWR4ID0gMDtcblxuICAgIGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cbiAgICAgIHZhciBmYWNlID0gZmFjZXNbIGkgXTtcblxuICAgICAgZm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4VGFuZ2VudHMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XG5cbiAgICAgICAgdmFyIHZlcnRleElkID0gZmFjZVsga2V5c1sgaiBdIF07XG4gICAgICAgIHZhciB2ZXJ0ZXggPSB2ZXJ0c1sgdmVydGV4SWQgXTtcblxuICAgICAgICB2YXIgdGFuZ2VudCA9IGZhY2UudmVydGV4VGFuZ2VudHNbIGogXTtcblxuICAgICAgICB2ZXJ0aWNlc1sgaWR4IF0uY29weSggdmVydGV4ICkuYXBwbHlNYXRyaXg0KCB3b3JsZE1hdHJpeCApO1xuXG4gICAgICAgIHYxLmNvcHkoIHRhbmdlbnQgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIHdvcmxkTWF0cml4ICkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApO1xuXG4gICAgICAgIHYxLmFkZCggdmVydGljZXNbIGlkeCBdICk7XG4gICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgICAgdmVydGljZXNbIGlkeCBdLmNvcHkoIHYxICk7XG4gICAgICAgIGlkeCA9IGlkeCArIDE7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzO1xuXG4gIH1cblxufSgpKTtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL2hlbHBlcnMvV2lyZWZyYW1lSGVscGVyLmpzXG5cbi8qKlxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cbiAqL1xuXG5USFJFRS5XaXJlZnJhbWVIZWxwZXIgPSBmdW5jdGlvbiAoIG9iamVjdCwgaGV4ICkge1xuXG4gIHZhciBjb2xvciA9ICggaGV4ICE9PSB1bmRlZmluZWQgKSA/IGhleCA6IDB4ZmZmZmZmO1xuXG4gIFRIUkVFLkxpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBuZXcgVEhSRUUuV2lyZWZyYW1lR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xuXG4gIHRoaXMubWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xuICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcblxufTtcblxuVEhSRUUuV2lyZWZyYW1lSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcblRIUkVFLldpcmVmcmFtZUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5XaXJlZnJhbWVIZWxwZXI7XG5cbi8vIEZpbGU6c3JjL2V4dHJhcy9vYmplY3RzL0ltbWVkaWF0ZVJlbmRlck9iamVjdC5qc1xuXG4vKipcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXG4gKi9cblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG4gIFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcblxuICB0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyQ2FsbGJhY2sgKSB7fTtcblxufTtcblxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdDtcblxuLy8gRmlsZTpzcmMvZXh0cmFzL29iamVjdHMvTW9ycGhCbGVuZE1lc2guanNcblxuLyoqXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xuICovXG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoID0gZnVuY3Rpb24oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcblxuICBUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xuXG4gIHRoaXMuYW5pbWF0aW9uc01hcCA9IHt9O1xuICB0aGlzLmFuaW1hdGlvbnNMaXN0ID0gW107XG5cbiAgLy8gcHJlcGFyZSBkZWZhdWx0IGFuaW1hdGlvblxuICAvLyAoYWxsIGZyYW1lcyBwbGF5ZWQgdG9nZXRoZXIgaW4gMSBzZWNvbmQpXG5cbiAgdmFyIG51bUZyYW1lcyA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDtcblxuICB2YXIgbmFtZSA9IFwiX19kZWZhdWx0XCI7XG5cbiAgdmFyIHN0YXJ0RnJhbWUgPSAwO1xuICB2YXIgZW5kRnJhbWUgPSBudW1GcmFtZXMgLSAxO1xuXG4gIHZhciBmcHMgPSBudW1GcmFtZXMgLyAxO1xuXG4gIHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgZnBzICk7XG4gIHRoaXMuc2V0QW5pbWF0aW9uV2VpZ2h0KCBuYW1lLCAxICk7XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1lc2gucHJvdG90eXBlICk7XG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5Nb3JwaEJsZW5kTWVzaDtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNyZWF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSwgc3RhcnQsIGVuZCwgZnBzICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB7XG5cbiAgICBzdGFydEZyYW1lOiBzdGFydCxcbiAgICBlbmRGcmFtZTogZW5kLFxuXG4gICAgbGVuZ3RoOiBlbmQgLSBzdGFydCArIDEsXG5cbiAgICBmcHM6IGZwcyxcbiAgICBkdXJhdGlvbjogKCBlbmQgLSBzdGFydCApIC8gZnBzLFxuXG4gICAgbGFzdEZyYW1lOiAwLFxuICAgIGN1cnJlbnRGcmFtZTogMCxcblxuICAgIGFjdGl2ZTogZmFsc2UsXG5cbiAgICB0aW1lOiAwLFxuICAgIGRpcmVjdGlvbjogMSxcbiAgICB3ZWlnaHQ6IDEsXG5cbiAgICBkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxuICAgIG1pcnJvcmVkTG9vcDogZmFsc2VcblxuICB9O1xuXG4gIHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdID0gYW5pbWF0aW9uO1xuICB0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goIGFuaW1hdGlvbiApO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuYXV0b0NyZWF0ZUFuaW1hdGlvbnMgPSBmdW5jdGlvbiAoIGZwcyApIHtcblxuICB2YXIgcGF0dGVybiA9IC8oW2Etel0rKV8/KFxcZCspLztcblxuICB2YXIgZmlyc3RBbmltYXRpb24sIGZyYW1lUmFuZ2VzID0ge307XG5cbiAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblxuICBmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgdmFyIG1vcnBoID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF07XG4gICAgdmFyIGNodW5rcyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcblxuICAgIGlmICggY2h1bmtzICYmIGNodW5rcy5sZW5ndGggPiAxICkge1xuXG4gICAgICB2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xuXG4gICAgICBpZiAoICEgZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtIEluZmluaXR5IH07XG5cbiAgICAgIHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG5cbiAgICAgIGlmICggaSA8IHJhbmdlLnN0YXJ0ICkgcmFuZ2Uuc3RhcnQgPSBpO1xuICAgICAgaWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcblxuICAgICAgaWYgKCAhIGZpcnN0QW5pbWF0aW9uICkgZmlyc3RBbmltYXRpb24gPSBuYW1lO1xuXG4gICAgfVxuXG4gIH1cblxuICBmb3IgKCB2YXIgbmFtZSBpbiBmcmFtZVJhbmdlcyApIHtcblxuICAgIHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XG4gICAgdGhpcy5jcmVhdGVBbmltYXRpb24oIG5hbWUsIHJhbmdlLnN0YXJ0LCByYW5nZS5lbmQsIGZwcyApO1xuXG4gIH1cblxuICB0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25Gb3J3YXJkID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi5kaXJlY3Rpb24gPSAxO1xuICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EaXJlY3Rpb25CYWNrd2FyZCA9IGZ1bmN0aW9uICggbmFtZSApIHtcblxuICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICBhbmltYXRpb24uZGlyZWN0aW9uID0gLSAxO1xuICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkZQUyA9IGZ1bmN0aW9uICggbmFtZSwgZnBzICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi5mcHMgPSBmcHM7XG4gICAgYW5pbWF0aW9uLmR1cmF0aW9uID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZnBzO1xuXG4gIH1cblxufTtcblxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkR1cmF0aW9uID0gZnVuY3Rpb24gKCBuYW1lLCBkdXJhdGlvbiApIHtcblxuICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICBhbmltYXRpb24uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICBhbmltYXRpb24uZnBzID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZHVyYXRpb247XG5cbiAgfVxuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24gKCBuYW1lLCB3ZWlnaHQgKSB7XG5cbiAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xuXG4gIGlmICggYW5pbWF0aW9uICkge1xuXG4gICAgYW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi50aW1lID0gdGltZTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciB0aW1lID0gMDtcblxuICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XG5cbiAgaWYgKCBhbmltYXRpb24gKSB7XG5cbiAgICB0aW1lID0gYW5pbWF0aW9uLnRpbWU7XG5cbiAgfVxuXG4gIHJldHVybiB0aW1lO1xuXG59O1xuXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuZ2V0QW5pbWF0aW9uRHVyYXRpb24gPSBmdW5jdGlvbiAoIG5hbWUgKSB7XG5cbiAgdmFyIGR1cmF0aW9uID0gLSAxO1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGR1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gIH1cblxuICByZXR1cm4gZHVyYXRpb247XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi50aW1lID0gMDtcbiAgICBhbmltYXRpb24uYWN0aXZlID0gdHJ1ZTtcblxuICB9IGVsc2Uge1xuXG4gICAgY29uc29sZS53YXJuKCBcIlRIUkVFLk1vcnBoQmxlbmRNZXNoOiBhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZCBpbiAucGxheUFuaW1hdGlvbigpXCIgKTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zdG9wQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xuXG4gIHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcblxuICBpZiAoIGFuaW1hdGlvbiApIHtcblxuICAgIGFuaW1hdGlvbi5hY3RpdmUgPSBmYWxzZTtcblxuICB9XG5cbn07XG5cblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoIGRlbHRhICkge1xuXG4gIGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmFuaW1hdGlvbnNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG4gICAgdmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc0xpc3RbIGkgXTtcblxuICAgIGlmICggISBhbmltYXRpb24uYWN0aXZlICkgY29udGludWU7XG5cbiAgICB2YXIgZnJhbWVUaW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uIC8gYW5pbWF0aW9uLmxlbmd0aDtcblxuICAgIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kaXJlY3Rpb24gKiBkZWx0YTtcblxuICAgIGlmICggYW5pbWF0aW9uLm1pcnJvcmVkTG9vcCApIHtcblxuICAgICAgaWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiB8fCBhbmltYXRpb24udGltZSA8IDAgKSB7XG5cbiAgICAgICAgYW5pbWF0aW9uLmRpcmVjdGlvbiAqPSAtIDE7XG5cbiAgICAgICAgaWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcblxuICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gYW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgICAgICAgIGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIHtcblxuICAgICAgICAgIGFuaW1hdGlvbi50aW1lID0gMDtcbiAgICAgICAgICBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xuXG4gICAgICBpZiAoIGFuaW1hdGlvbi50aW1lIDwgMCApIGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kdXJhdGlvbjtcblxuICAgIH1cblxuICAgIHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydEZyYW1lICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggYW5pbWF0aW9uLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgYW5pbWF0aW9uLmxlbmd0aCAtIDEgKTtcbiAgICB2YXIgd2VpZ2h0ID0gYW5pbWF0aW9uLndlaWdodDtcblxuICAgIGlmICgga2V5ZnJhbWUgIT09IGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgKSB7XG5cbiAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAwO1xuICAgICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IDEgKiB3ZWlnaHQ7XG5cbiAgICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBrZXlmcmFtZSBdID0gMDtcblxuICAgICAgYW5pbWF0aW9uLmxhc3RGcmFtZSA9IGFuaW1hdGlvbi5jdXJyZW50RnJhbWU7XG4gICAgICBhbmltYXRpb24uY3VycmVudEZyYW1lID0ga2V5ZnJhbWU7XG5cbiAgICB9XG5cbiAgICB2YXIgbWl4ID0gKCBhbmltYXRpb24udGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xuXG4gICAgaWYgKCBhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzICkgbWl4ID0gMSAtIG1peDtcblxuICAgIHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24uY3VycmVudEZyYW1lIF0gPSBtaXggKiB3ZWlnaHQ7XG4gICAgdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5sYXN0RnJhbWUgXSA9ICggMSAtIG1peCApICogd2VpZ2h0O1xuXG4gIH1cblxufTtcblxuIiwiIC8qIGdsb2JhbHMgZGVmaW5lICovXG4gKGZ1bmN0aW9uKGRlZmluZSl7J3VzZSBzdHJpY3QnO2RlZmluZShmdW5jdGlvbihyZXF1aXJlLGV4cG9ydHMsbW9kdWxlKXtcblxuZnVuY3Rpb24gZm92VG9ORENTY2FsZU9mZnNldCggZm92ICkge1xuXG4gICAgdmFyIHB4c2NhbGUgPSAyLjAgLyAoZm92LmxlZnRUYW4gKyBmb3YucmlnaHRUYW4pO1xuICAgIHZhciBweG9mZnNldCA9IChmb3YubGVmdFRhbiAtIGZvdi5yaWdodFRhbikgKiBweHNjYWxlICogMC41O1xuICAgIHZhciBweXNjYWxlID0gMi4wIC8gKGZvdi51cFRhbiArIGZvdi5kb3duVGFuKTtcbiAgICB2YXIgcHlvZmZzZXQgPSAoZm92LnVwVGFuIC0gZm92LmRvd25UYW4pICogcHlzY2FsZSAqIDAuNTtcbiAgICByZXR1cm4geyBzY2FsZTogWyBweHNjYWxlLCBweXNjYWxlIF0sIG9mZnNldDogWyBweG9mZnNldCwgcHlvZmZzZXQgXSB9O1xuXG4gIH1cblxuICBmdW5jdGlvbiBmb3ZQb3J0VG9Qcm9qZWN0aW9uKCBmb3YsIHJpZ2h0SGFuZGVkLCB6TmVhciwgekZhciApIHtcblxuICAgIHJpZ2h0SGFuZGVkID0gcmlnaHRIYW5kZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiByaWdodEhhbmRlZDtcbiAgICB6TmVhciA9IHpOZWFyID09PSB1bmRlZmluZWQgPyAwLjAxIDogek5lYXI7XG4gICAgekZhciA9IHpGYXIgPT09IHVuZGVmaW5lZCA/IDEwMDAwLjAgOiB6RmFyO1xuXG4gICAgdmFyIGhhbmRlZG5lc3NTY2FsZSA9IHJpZ2h0SGFuZGVkID8gLTEuMCA6IDEuMDtcblxuICAgIC8vIHN0YXJ0IHdpdGggYW4gaWRlbnRpdHkgbWF0cml4XG4gICAgdmFyIG1vYmogPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHZhciBtID0gbW9iai5lbGVtZW50cztcblxuICAgIC8vIGFuZCB3aXRoIHNjYWxlL29mZnNldCBpbmZvIGZvciBub3JtYWxpemVkIGRldmljZSBjb29yZHNcbiAgICB2YXIgc2NhbGVBbmRPZmZzZXQgPSBmb3ZUb05EQ1NjYWxlT2Zmc2V0KGZvdik7XG5cbiAgICAvLyBYIHJlc3VsdCwgbWFwIGNsaXAgZWRnZXMgdG8gWy13LCt3XVxuICAgIG1bMCAqIDQgKyAwXSA9IHNjYWxlQW5kT2Zmc2V0LnNjYWxlWzBdO1xuICAgIG1bMCAqIDQgKyAxXSA9IDAuMDtcbiAgICBtWzAgKiA0ICsgMl0gPSBzY2FsZUFuZE9mZnNldC5vZmZzZXRbMF0gKiBoYW5kZWRuZXNzU2NhbGU7XG4gICAgbVswICogNCArIDNdID0gMC4wO1xuXG4gICAgLy8gWSByZXN1bHQsIG1hcCBjbGlwIGVkZ2VzIHRvIFstdywrd11cbiAgICAvLyBZIG9mZnNldCBpcyBuZWdhdGVkIGJlY2F1c2UgdGhpcyBwcm9qIG1hdHJpeCB0cmFuc2Zvcm1zIGZyb20gd29ybGQgY29vcmRzIHdpdGggWT11cCxcbiAgICAvLyBidXQgdGhlIE5EQyBzY2FsaW5nIGhhcyBZPWRvd24gKHRoYW5rcyBEM0Q/KVxuICAgIG1bMSAqIDQgKyAwXSA9IDAuMDtcbiAgICBtWzEgKiA0ICsgMV0gPSBzY2FsZUFuZE9mZnNldC5zY2FsZVsxXTtcbiAgICBtWzEgKiA0ICsgMl0gPSAtc2NhbGVBbmRPZmZzZXQub2Zmc2V0WzFdICogaGFuZGVkbmVzc1NjYWxlO1xuICAgIG1bMSAqIDQgKyAzXSA9IDAuMDtcblxuICAgIC8vIFogcmVzdWx0ICh1cCB0byB0aGUgYXBwKVxuICAgIG1bMiAqIDQgKyAwXSA9IDAuMDtcbiAgICBtWzIgKiA0ICsgMV0gPSAwLjA7XG4gICAgbVsyICogNCArIDJdID0gekZhciAvICh6TmVhciAtIHpGYXIpICogLWhhbmRlZG5lc3NTY2FsZTtcbiAgICBtWzIgKiA0ICsgM10gPSAoekZhciAqIHpOZWFyKSAvICh6TmVhciAtIHpGYXIpO1xuXG4gICAgLy8gVyByZXN1bHQgKD0gWiBpbilcbiAgICBtWzMgKiA0ICsgMF0gPSAwLjA7XG4gICAgbVszICogNCArIDFdID0gMC4wO1xuICAgIG1bMyAqIDQgKyAyXSA9IGhhbmRlZG5lc3NTY2FsZTtcbiAgICBtWzMgKiA0ICsgM10gPSAwLjA7XG5cbiAgICBtb2JqLnRyYW5zcG9zZSgpO1xuXG4gICAgcmV0dXJuIG1vYmo7XG4gIH1cblxuICBmdW5jdGlvbiBmb3ZUb1Byb2plY3Rpb24oIGZvdiwgcmlnaHRIYW5kZWQsIHpOZWFyLCB6RmFyICkge1xuXG4gICAgdmFyIERFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLjA7XG5cbiAgICB2YXIgZm92UG9ydCA9IHtcbiAgICAgIHVwVGFuOiBNYXRoLnRhbiggZm92LnVwRGVncmVlcyAqIERFRzJSQUQgKSxcbiAgICAgIGRvd25UYW46IE1hdGgudGFuKCBmb3YuZG93bkRlZ3JlZXMgKiBERUcyUkFEICksXG4gICAgICBsZWZ0VGFuOiBNYXRoLnRhbiggZm92LmxlZnREZWdyZWVzICogREVHMlJBRCApLFxuICAgICAgcmlnaHRUYW46IE1hdGgudGFuKCBmb3YucmlnaHREZWdyZWVzICogREVHMlJBRCApXG4gICAgfTtcblxuICAgIHJldHVybiBmb3ZQb3J0VG9Qcm9qZWN0aW9uKCBmb3ZQb3J0LCByaWdodEhhbmRlZCwgek5lYXIsIHpGYXIgKTtcblxuICB9XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZm92VG9Qcm9qZWN0aW9uOiBmb3ZUb1Byb2plY3Rpb25cbiAgfTtcblxuICB9KTt9KSh0eXBlb2YgZGVmaW5lPT0nZnVuY3Rpb24nJiZkZWZpbmUuYW1kP2RlZmluZVxuOihmdW5jdGlvbihuLHcpeyd1c2Ugc3RyaWN0JztyZXR1cm4gdHlwZW9mIG1vZHVsZT09J29iamVjdCc/ZnVuY3Rpb24oYyl7XG5jKHJlcXVpcmUsZXhwb3J0cyxtb2R1bGUpO306ZnVuY3Rpb24oYyl7dmFyIG09e2V4cG9ydHM6e319O2MoZnVuY3Rpb24obil7XG5yZXR1cm4gd1tuXTt9LG0uZXhwb3J0cyxtKTt3W25dPW0uZXhwb3J0czt9O30pKCdWUlBlcnNwZWN0aXZlJyx0aGlzKSk7XG4iLCIgLyogZ2xvYmFscyBkZWZpbmUgKi9cbiAoZnVuY3Rpb24oZGVmaW5lKXsndXNlIHN0cmljdCc7ZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUsZXhwb3J0cyxtb2R1bGUpe1xuXG4gICAgdmFyIHZyRGV2aWNlcyA9IHt9O1xuICAgIHZhciB2aWV3cG9ydDtcbiAgICB2YXIgc2NlbmUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2NlbmUnKTtcbiAgICB2YXIgd29ybGQ7XG4gICAgdmFyIGNhbWVyYTtcbiAgICB2YXIgZnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgIHZhciBwcm9qZWN0aW9uVHJhbnNmb3JtO1xuICAgIHZhciBmb3Y7XG4gICAgdmFyIGZ1bGxzY3JlZW5CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciB6ID0gMDtcbiAgICB2YXIgcm90WCA9IDA7XG4gICAgdmFyIHJvdFkgPSAwO1xuICAgIHZhciByb3RaID0gMDtcbiAgICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgIHZhciByb3RhdGlvbjtcbiAgICB2YXIgcm90YXRpb25FdWxlciA9IFRIUkVFLkV1bGVyKDAsIDAsIDAsIFwiWVhaXCIpO1xuICAgIHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWVJRDtcblxuICAgIHNldHVwVlJEZXZpY2VzKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ3JlYXRlcyB2aWV3cG9ydCwgY2FtZXJhIGFuZCB3b3JsZCBlbGVtZW50c1xuICAgICAgc2V0dXBTY2VuZSgpO1xuICAgICAgLy8gSW5pdGlhdGVzIHRoZSBjYW1lcmEgcGVyc3BlY3RpdmUgbWF0cml4XG4gICAgICBzZXR1cFBlcnNwZWN0aXZlKCk7XG4gICAgICAvLyBJdCBpbnNlcnRzIGEgYnV0dG9uIG9uIHRoZSB0b3AgbGVmdCBjb3JuZXJcbiAgICAgIC8vIHRvIHJlcXVlc3QgZnVsbHNjcmVlblxuICAgICAgc2V0dXBGdWxsc2NyZWVuQnV0dG9uKCk7XG4gICAgICAvLyBGb3IgbW91c2UgbG9vayBtb2RlIHdoZW4gdGhlcmUncyBubyBITUQgYXZhaWFsYWJsZVxuICAgICAgc2V0dXBJbnB1dEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgIHNldHVwRnVsbHNjcmVlbkhhbmRsZXJzKCk7XG4gICAgICAvLyBGdW5jdGlvbiB0aGF0IHVwZGF0ZXMgdGhlIGNhbWVyYSBvcmllbnRhdGlvbiBmcm9tIEhNRCBpbmZvcm1hdGlvblxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lSUQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZUNhbWVyYSk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBzZXR1cFZSRGV2aWNlcyhkb25lKSB7XG4gICAgICBpZiAobmF2aWdhdG9yLmdldFZSRGV2aWNlcyAmJiBuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzKCkudGhlbikge1xuICAgICAgICBuYXZpZ2F0b3IuZ2V0VlJEZXZpY2VzKCkudGhlbihnb3RWUkRldmljZXMpO1xuICAgICAgfSBlbHNlIHsgZG9uZSgpOyB9XG4gICAgICBmdW5jdGlvbiBnb3RWUkRldmljZXMoZGV2aWNlcykge1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGV2aWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGRldmljZXNbaV0gaW5zdGFuY2VvZiBITURWUkRldmljZSkge1xuICAgICAgICAgICAgICB2ckRldmljZXMuaGVhZHNldCA9IGRldmljZXNbaV07XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRldmljZXNbaV0gaW5zdGFuY2VvZiBQb3NpdGlvblNlbnNvclZSRGV2aWNlKSB7XG4gICAgICAgICAgICAgIHZyRGV2aWNlcy5wb3NpdGlvbiA9IGRldmljZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnJEZXZpY2VzLmhlYWRzZXQgJiYgdnJEZXZpY2VzLnBvc2l0aW9uKSB7IGJyZWFrOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvbmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXR1cEZ1bGxzY3JlZW5CdXR0b24oKSB7XG4gICAgICBmdWxsc2NyZWVuQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICBmdWxsc2NyZWVuQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2Z1bGxzY3JlZW4tYnV0dG9uJyk7XG4gICAgICBmdWxsc2NyZWVuQnV0dG9uLmlubmVySFRNTCA9ICdGdWxsc2NyZWVuJztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnVsbHNjcmVlbkJ1dHRvbik7XG4gICAgICB2YXIgcmVxdWVzdEZ1bGxTY3JlZW4gPSBzY2VuZS5tb3pSZXF1ZXN0RnVsbFNjcmVlbiB8fCBzY2VuZS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbjtcbiAgICAgIGZ1bGxzY3JlZW5CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVxdWVzdEZ1bGxTY3JlZW4uY2FsbChzY2VuZSwgeyB2ckRpc3BsYXk6IHZyRGV2aWNlcy5oZWFkc2V0IH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0dXBQZXJzcGVjdGl2ZSgpIHtcbiAgICAgIGZvdiA9IHZyRGV2aWNlcy5oZWFkc2V0PyB2ckRldmljZXMuaGVhZHNldC5nZXRFeWVQYXJhbWV0ZXJzKCdsZWZ0JykucmVjb21tZW5kZWRGaWVsZE9mVmlldyA6IHsgdXBEZWdyZWVzOiA0NSwgcmlnaHREZWdyZWVzOiA0NSwgZG93bkRlZ3JlZXM6IDQ1LCBsZWZ0RGVncmVlczogNDUgfTtcbiAgICAgIC8vdmFyIHBlcnNwZWN0aXZlID0gVlJQZXJzcGVjdGl2ZS5mb3ZUb1Byb2plY3Rpb24oIGZvdiwgdHJ1ZSwgMSwgMTAwMDAgKTtcbiAgICAgIHZhciBwZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlTWF0cml4KFRIUkVFLk1hdGguZGVnVG9SYWQoZm92LnVwRGVncmVlcyksIHZpZXdwb3J0Lm9mZnNldFdpZHRoIC8gdmlld3BvcnQub2Zmc2V0SGVpZ2h0LCAxLCAxMDAwMCk7XG4gICAgICBwZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlLmNsb25lKCkuc2NhbGUobmV3IFRIUkVFLlZlY3RvcjModmlld3BvcnQub2Zmc2V0V2lkdGgsIHZpZXdwb3J0Lm9mZnNldEhlaWdodCwgMSkpO1xuICAgICAgcHJvamVjdGlvblRyYW5zZm9ybSA9IGdldENTU01hdHJpeChwZXJzcGVjdGl2ZSk7XG4gICAgICB2aWV3cG9ydC5zdHlsZS50cmFuc2Zvcm0gPSBwcm9qZWN0aW9uVHJhbnNmb3JtO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwU2NlbmUoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciB2ckVscyA9IHNjZW5lLmNoaWxkcmVuO1xuICAgICAgdmFyIHZyRWxzTGVuZ3RoID0gdnJFbHMubGVuZ3RoO1xuICAgICAgdmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHZpZXdwb3J0LmNsYXNzTGlzdC5hZGQoJ3ZpZXdwb3J0Jyk7XG4gICAgICBjYW1lcmEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNhbWVyYS5jbGFzc0xpc3QuYWRkKCd2cicpO1xuICAgICAgY2FtZXJhLmNsYXNzTGlzdC5hZGQoJ2NhbWVyYScpO1xuICAgICAgd29ybGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHdvcmxkLmNsYXNzTGlzdC5hZGQoJ3ZyJyk7XG4gICAgICB3b3JsZC5jbGFzc0xpc3QuYWRkKCd3b3JsZCcpO1xuXG4gICAgICAvLyBTZXR1cCBIaWVyYXJjaHlcbiAgICAgIC8vIHNjZW5lXG4gICAgICAvLyAgIHZpZXdwb3J0XG4gICAgICAvLyAgICAgIGNhbWVyYVxuICAgICAgLy8gICAgICAgIHdvcmxkXG4gICAgICAvLyAgICAgICAgICB1c2VyLWVsZW1lbnRzXG4gICAgICBmb3IoaSA9IDA7IGkgPCB2ckVsc0xlbmd0aDsgKytpKSB7XG4gICAgICAgIHdvcmxkLmFwcGVuZENoaWxkKHZyRWxzWzBdKTtcbiAgICAgIH1cbiAgICAgIHNjZW5lLmFwcGVuZENoaWxkKHZpZXdwb3J0KTtcbiAgICAgIHZpZXdwb3J0LmFwcGVuZENoaWxkKGNhbWVyYSk7XG4gICAgICBjYW1lcmEuYXBwZW5kQ2hpbGQod29ybGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNhbWVyYSgpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm07XG4gICAgICBpZiAoZnVsbHNjcmVlbikge1xuICAgICAgICB0cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoLTUwJSwgLTUwJSwgMHB4KSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm0gPSBwcm9qZWN0aW9uVHJhbnNmb3JtO1xuICAgICAgfVxuICAgICAgcG9sbEhlYWRPcmllbnRhdGlvbigpO1xuICAgICAgdmlld3BvcnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGVDYW1lcmEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvbGxIZWFkT3JpZW50YXRpb24oKSB7XG4gICAgICB2YXIgb3JpZW50YXRpb247XG4gICAgICB2YXIgcXVhdGVybmlvbjtcbiAgICAgIHZhciBwb3NpdGlvblxuICAgICAgdmFyIHN0YXRlO1xuICAgICAgaWYgKHZyRGV2aWNlcy5wb3NpdGlvbikge1xuICAgICAgICBzdGF0ZSA9IHZyRGV2aWNlcy5wb3NpdGlvbi5nZXRTdGF0ZSgpXG4gICAgICAgIG9yaWVudGF0aW9uID0gc3RhdGUub3JpZW50YXRpb247XG4gICAgICAgIHBvc2l0aW9uID0gc3RhdGUucG9zaXRpb247XG4gICAgICAgIGlmIChvcmllbnRhdGlvbikge1xuICAgICAgICAgIHF1YXRlcm5pb24gPSBuZXcgVEhSRUUuUXVhdGVybmlvbihvcmllbnRhdGlvbi54LCAtb3JpZW50YXRpb24ueSwgb3JpZW50YXRpb24ueiwgb3JpZW50YXRpb24udyk7XG4gICAgICAgICAgcm90YXRpb24gPSBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHF1YXRlcm5pb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgIHRyYW5zbGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5tYWtlVHJhbnNsYXRpb24ocG9zaXRpb24ueCAsIHBvc2l0aW9uLnkgLCBwb3NpdGlvbi56KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlRWxlbWVudChjYW1lcmEsIHtcbiAgICAgICAgcm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICB0cmFuc2xhdGlvbjogdHJhbnNsYXRpb25cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHVwRnVsbHNjcmVlbkhhbmRsZXJzKCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIndlYmtpdGZ1bGxzY3JlZW5jaGFuZ2VcIiwgb25mdWxsc2NyZWVuY2hhbmdlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3pmdWxsc2NyZWVuY2hhbmdlXCIsICAgIG9uZnVsbHNjcmVlbmNoYW5nZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZnVsbHNjcmVlbmNoYW5nZVwiLCAgICAgICBvbmZ1bGxzY3JlZW5jaGFuZ2UpO1xuXG4gICAgICBmdW5jdGlvbiBvbmZ1bGxzY3JlZW5jaGFuZ2UoKSB7XG4gICAgICAgIGlmICggIWRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50ICYmICFkb2N1bWVudC53ZWJraXRGdWxsU2NyZWVuRWxlbWVudCApIHtcbiAgICAgICAgICB2aWV3cG9ydC5jbGFzc0xpc3QucmVtb3ZlKCdmdWxsc2NyZWVuJyk7XG4gICAgICAgICAgZnVsbHNjcmVlbiA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmdWxsc2NyZWVuID0gdHJ1ZTtcbiAgICAgICAgdmlld3BvcnQuY2xhc3NMaXN0LmFkZCgnZnVsbHNjcmVlbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlcnNwZWN0aXZlTWF0cml4KGZvdiwgYXNwZWN0LCBuZWFyeiwgZmFyeikge1xuICAgICAgdmFyIG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICB2YXIgcmFuZ2UgPSBNYXRoLnRhbihmb3YgKiAwLjUpICogbmVhcno7XG5cbiAgICAgIG1hdHJpeC5lbGVtZW50c1swXSA9ICgyICogbmVhcnopIC8gKChyYW5nZSAqIGFzcGVjdCkgLSAoLXJhbmdlICogYXNwZWN0KSk7XG4gICAgICBtYXRyaXguZWxlbWVudHNbMV0gPSAwO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWzJdID0gMDtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1szXSA9IDA7XG4gICAgICBtYXRyaXguZWxlbWVudHNbNF0gPSAwO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWzVdID0gKDIgKiBuZWFyeikgLyAoMiAqIHJhbmdlKTtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1s2XSA9IDA7XG4gICAgICBtYXRyaXguZWxlbWVudHNbN10gPSAwO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWzhdID0gMDtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1s5XSA9IDA7XG4gICAgICBtYXRyaXguZWxlbWVudHNbMTBdID0gLShmYXJ6ICsgbmVhcnopIC8gKGZhcnogLSBuZWFyeik7XG4gICAgICBtYXRyaXguZWxlbWVudHNbMTFdID0gLTE7XG4gICAgICBtYXRyaXguZWxlbWVudHNbMTJdID0gMDtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1sxM10gPSAwO1xuICAgICAgbWF0cml4LmVsZW1lbnRzWzE0XSA9IC0oMiAqIGZhcnogKiBuZWFyeikgLyAoZmFyeiAtIG5lYXJ6KTtcbiAgICAgIG1hdHJpeC5lbGVtZW50c1sxNV0gPSAwO1xuICAgICAgcmV0dXJuIG1hdHJpeC50cmFuc3Bvc2UoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZ2V0Q1NTTWF0cml4KG1hdHJpeCkge1xuICAgICAgdmFyIGVsZW1lbnRzID0gbWF0cml4LmVsZW1lbnRzO1xuXG4gICAgICByZXR1cm4gJ21hdHJpeDNkKCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgMCBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgMSBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgMiBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgMyBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgNCBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgNSBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgNiBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgNyBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgOCBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgOSBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgMTAgXSApICsgJywnICtcbiAgICAgICAgZXBzaWxvbiggZWxlbWVudHNbIDExIF0gKSArICcsJyArXG4gICAgICAgIGVwc2lsb24oIGVsZW1lbnRzWyAxMiBdICkgKyAnLCcgK1xuICAgICAgICBlcHNpbG9uKCBlbGVtZW50c1sgMTMgXSApICsgJywnICtcbiAgICAgICAgZXBzaWxvbiggZWxlbWVudHNbIDE0IF0gKSArICcsJyArXG4gICAgICAgIGVwc2lsb24oIGVsZW1lbnRzWyAxNSBdICkgK1xuICAgICAgJyknO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBlcHNpbG9uKCB2YWx1ZSApIHtcbiAgICAgIHJldHVybiBNYXRoLmFicyggdmFsdWUgKSA8IDAuMDAwMDAxID8gMCA6IHZhbHVlO1xuICAgIH07XG5cbiAgICB2YXIgcm90YXRpb25FbmFibGVkO1xuICAgIHZhciBsYXN0TW91c2VYO1xuICAgIHZhciBsYXN0TW91c2VZO1xuICAgIHZhciBQSV8yID0gTWF0aC5QSSAvIDI7XG4gICAgdmFyIGNhbWVyYVJvdGF0aW9uO1xuICAgIHZhciBjYW1lcmFUcmFuc2xhdGlvbjtcblxuICAgIGZ1bmN0aW9uIHNldHVwSW5wdXRFdmVudEhhbmRsZXJzKCkge1xuICAgICAgc2NlbmUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgcm90YXRpb25FbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgbGFzdE1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxhc3RNb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgIHNjZW5lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByb3RhdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH0sIHRydWUpO1xuXG4gICAgICBzY2VuZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBpZiAoIXJvdGF0aW9uRW5hYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVsdGFYID0gKGV2ZW50LmNsaWVudFggLSBsYXN0TW91c2VYKSAqIDAuMjtcbiAgICAgICAgdmFyIGRlbHRhWSA9IChldmVudC5jbGllbnRZIC0gbGFzdE1vdXNlWSkgKiAwLjI7XG4gICAgICAgIHJvdFggKz0gZGVsdGFYO1xuICAgICAgICByb3RZIC09IGRlbHRhWTtcbiAgICAgICAgLy8gQ2xhbXAgdG8gWy1QSSAvIDIsIFBJIC8gMl1cbiAgICAgICAgcm90WSA9IE1hdGgubWF4KCAtOTAsIE1hdGgubWluKCA5MCwgcm90WSApICk7XG5cbiAgICAgICAgbGFzdE1vdXNlWCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgIGxhc3RNb3VzZVkgPSBldmVudC5jbGllbnRZO1xuICAgICAgICB0cmFuc2xhdGlvbiA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVRyYW5zbGF0aW9uKHggLCB5ICwgeik7XG4gICAgICAgIHJvdGF0aW9uRXVsZXIgPSBuZXcgVEhSRUUuRXVsZXIoXG4gICAgICAgICAgVEhSRUUuTWF0aC5kZWdUb1JhZChyb3RZKSxcbiAgICAgICAgICBUSFJFRS5NYXRoLmRlZ1RvUmFkKHJvdFgpLFxuICAgICAgICAgIFRIUkVFLk1hdGguZGVnVG9SYWQocm90WiksXG4gICAgICAgICAgXCJYWVpcIiApO1xuICAgICAgICByb3RhdGlvbiA9IG5ldyBUSFJFRS5NYXRyaXg0KCkubWFrZVJvdGF0aW9uRnJvbUV1bGVyKHJvdGF0aW9uRXVsZXIpO1xuXG4gICAgICB9LCB0cnVlKTtcblxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGlmICggKCBlLmtleWNvZGUgfHwgZS53aGljaCApID09IDMyKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICB9LCBmYWxzZSk7XG5cbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCwgZGF0YSkge1xuICAgICAgdmFyIHRyYW5zbGF0aW9uID0gZGF0YS50cmFuc2xhdGlvbi5jbG9uZSgpIHx8IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICB2YXIgcm90YXRpb24gPSBkYXRhLnJvdGF0aW9uIHx8IG5ldyBUSFJFRS5NYXRyaXg0KCk7XG4gICAgICBvYmplY3Quc3R5bGUudHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUzZCgtNTAlLCAtNTAlLCAwcHgpIFwiICsgZ2V0Q1NTTWF0cml4KHRyYW5zbGF0aW9uLm11bHRpcGx5KHJvdGF0aW9uKSk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgemVyb1NlbnNvcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByb3RYID0gMDtcbiAgICAgICAgcm90WSA9IDA7XG4gICAgICAgIHJvdGF0aW9uID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcbiAgICAgICAgdHJhbnNsYXRpb24gPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xuICAgICAgICBpZiAodnJEZXZpY2VzLnBvc2l0aW9uKSB7IHZyRGV2aWNlcy5wb3NpdGlvbi5yZXNldFNlbnNvcigpOyB9XG4gICAgICB9XG4gICAgfTtcblxufSk7fSkodHlwZW9mIGRlZmluZT09J2Z1bmN0aW9uJyYmZGVmaW5lLmFtZD9kZWZpbmVcbjooZnVuY3Rpb24obix3KXsndXNlIHN0cmljdCc7cmV0dXJuIHR5cGVvZiBtb2R1bGU9PSdvYmplY3QnP2Z1bmN0aW9uKGMpe1xuYyhyZXF1aXJlLGV4cG9ydHMsbW9kdWxlKTt9OmZ1bmN0aW9uKGMpe3ZhciBtPXtleHBvcnRzOnt9fTtjKGZ1bmN0aW9uKG4pe1xucmV0dXJuIHdbbl07fSxtLmV4cG9ydHMsbSk7d1tuXT1tLmV4cG9ydHM7fTt9KSgnVlJDU1MnLHRoaXMpKTtcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==